After reading Hidden Features of C# I wondered, What are some of the hidden features of Java?Double Brace Initialization took me by surprise a few months ago when I first discovered it, never heard of it before.ThreadLocals are typically not so widely known as a way to store per-thread state.Since JDK 1.5 Java has had extremely well implemented and robust concurrency tools beyond just locks, they live in java.util.concurrent and a specifically interesting example is the java.util.concurrent.atomic subpackage that contains thread-safe primitives that implement the compare-and-swap operation and can map to actual native hardware-supported versions of these operations.Joint union in type parameter variance:For example, if you wanted to take a parameter that\'s both Comparable and a Collection:This contrived method returns true if the two given collections are equal or if either one of them contains the given element, otherwise false. The point to notice is that you can invoke methods of both Comparable and Collection on the arguments b1 and b2.I was surprised by instance initializers the other day.  I was deleting some code-folded methods and ended up creating multiple instance initializers :Executing the main method will display: I guess these would be useful if you had multiple constructors and needed common codeThey also provide syntactic sugar for initializing your classes:JDK 1.6_07+ contains an app called VisualVM (bin/jvisualvm.exe) that is a nice GUI on top of many of the tools.  It seems more comprehensive than JConsole.Classpath wild cards since Java 6.Instead ofSee http://java.sun.com/javase/6/docs/technotes/tools/windows/classpath.htmlFor most people I interview for Java developer positions labeled blocks are very surprising. Here is an example:Who said goto in java is just a keyword? :)How about covariant return types which have been in place since JDK 1.5?  It is pretty poorly publicised, as it is an unsexy addition, but as I understand it, is absolutely necessary for generics to work.  Essentially, the compiler now allows a subclass to narrow the return type of an overridden method to be a subclass of the original method\'s return type.  So this is allowed:You can call the subclass\'s values method and obtain a sorted thread safe Set of Strings without having to down cast to the ConcurrentSkipListSet.Haven\'t seen anyone mention instanceof being implemented in such a way that checking for null is not necessary.Instead of:just use:Transfer of control in a finally block throws away any exception.  The following code does not throw RuntimeException -- it is lost.From http://jamesjava.blogspot.com/2006/03/dont-return-in-finally-clause.htmlAllowing methods and constructors in enums surprised me. For example:You can even have a "constant specific class body" which allows a specific enum value to override methods.More documentation here.The type params for generic methods can be specified explicitly like so:You can use enums to implement an interface.EDIT: Years later....I use this feature herehttps://github.com/peter-lawrey/Java-Thread-Affinity/blob/master/src/main/java/vanilla/java/affinity/AffinityStrategies.javaBy using an interface, developers can define their own strategies. Using an enum means I can define a collection (of five) built in ones.As of Java 1.5, Java now has a much cleaner syntax for writing functions of variable arity. So, instead of just passing an array, now you can do the followingbars is automatically converted to array of the specified type. Not a huge win, but a win nonetheless.My favorite: dump all thread stack traces to standard out.windows: CTRL-Break in your java cmd/console windowunix:  kill -3 PIDA couple of people have posted about instance initializers, here\'s a good use for it:Is a quick way to initialize maps if you\'re just doing something quick and simple.Or using it to  create a   quick swing frame prototype:Of course it can be abused:Dynamic proxies (added in 1.3) allow you to define a new type at runtime that conforms to an interface.  It\'s come in handy a surprising number of times.final initialization can be postponed.It makes sure that even with a complex flow of logic return values are always set.  It\'s too easy to miss a case and return null by accident.  It doesn\'t make returning null impossible, just obvious that it\'s on purpose:I think another "overlooked" feature of java is the JVM itself. It is probably the best VM available. And it supports lots of interesting and useful languages (Jython, JRuby, Scala, Groovy). All those languages can easily and seamlessly cooperate.If you design a new language (like in the scala-case) you immediately have all the existing libraries available and your language is therefore "useful" from the very beginning.All those languages make use of the HotSpot optimizations. The VM is very well monitor and debuggable. You can define an anonymous subclass and directly call a method on it even if it implements no interfaces.The asList method in java.util.Arrays allows a nice combination of varargs, generic methods and autoboxing:Using this keyword for accessing fields/methods of containing class from an inner class. In below, rather contrived example, we want to use sortAscending field of container class from the anonymous inner class. Using ContainerClass.this.sortAscending instead of this.sortAscending does the trick.Not really a feature, but an amusing trick I discovered recently in some Web page:is a valid Java program (although it generates a warning).\nIf you don\'t see why, see Gregory\'s answer! ;-) Well, syntax highlighting here also gives a hint!This is not exactly "hidden features" and not very useful, but can be extremely interesting in some cases:\nClass sun.misc.Unsafe - will allow you to implement direct memory management in Java (you can even write self-modifying Java code with this if you try a lot):When working in Swing I like the hidden Ctrl - Shift - F1 feature.It dumps the component tree of the current window.\n(Assuming you have not bound that keystroke to something else.)Every class file starts with the hex value 0xCAFEBABE to identify it as valid JVM bytecode.(Explanation)My vote goes to java.util.concurrent with its concurrent collections and flexible executors allowing among others thread pools, scheduled tasks and coordinated tasks. The DelayQueue is my personal favorite, where elements are made available after a specified delay.java.util.Timer and TimerTask may safely be put to rest.Also, not exactly hidden but in a different package from the other classes related to date and time. java.util.concurrent.TimeUnit is useful when converting between nanoseconds, microseconds, milliseconds and seconds.It reads a lot better than the usual someValue * 1000 or someValue / 1000.Language-level assert keyword.Not really part of the Java language, but the javap disassembler which comes with Sun\'s JDK is not widely known or used.The addition of the for-each loop construct in 1.5.  I <3 it.And can be used in nested instances:The for-each construct is also applicable to arrays, where it hides the index variable rather than the iterator. The following method returns the sum of the values in an int array: Link to the Sun documentationi personally discovered java.lang.Void very late -- improves code readability in conjunction with generics, e.g. Callable<Void>