I\'ve been reading through a lot of the rookie Java questions on finalize() and find it kind of bewildering that no one has really made it plain that finalize() is an unreliable way to clean up resources.  I saw someone comment that they use it to clean up Connections, which is really scary since the only way to come as close to a guarantee that a Connection is closed is to implement try (catch) finally.  I was not schooled in CS, but I have been programming in Java professionally for close to a decade now and I have never seen anyone implement finalize() in a production system ever.  This still doesn\'t mean that it doesn\'t have its uses, or that people I\'ve worked with have been doing it right.So my question is, what use cases are there for implementing finalize() that cannot be handled more reliably via another process or syntax within the language?  Please provided specific scenarios or your experience, simply repeating a Java text book, or finalize\'s intended use is not enough, and is not the intent of this question.You could use it as a backstop for an object holding an external resource (socket, file, etc).  Implement a close() method and document that it needs to be called.Implement finalize() to do the close() processing if you detect it hasn\'t been done.  Maybe with something dumped to stderr to point out that you\'re cleaning up after a buggy caller.It provides extra safety in an exceptional/buggy situation.  Not every caller is going to do the correct try {} finally {} stuff every time.  Unfortunate, but true in most environments.I agree that it\'s rarely needed.  And as commenters point out, it comes with GC overhead.  Only use if you need that "belt and suspenders" safety in a long-running app.finalize() is a hint to the JVM that it might be nice to execute your code at an unspecified time. This is good when you want code to mysteriously fail to run.Doing anything significant in finalizers (basically anything except logging) is also good in three situations:If you think you need finalize(), sometimes what you really want is a phantom reference (which in the example given could hold a hard reference to a connection used by its referand, and close it after the phantom reference has been queued). This also has the property that it may mysteriously never run, but at least it can\'t call methods on or resurrect finalized objects. So it\'s just right for situations where you don\'t absolutely need to close that connection cleanly, but you\'d quite like to, and the clients of your class can\'t or won\'t call close themselves (which is actually fair enough - what\'s the point of having a garbage collector at all if you design interfaces that require a specific action be taken prior to collection? That just puts us back in the days of malloc/free.)Other times you need the resource you think you\'re managing to be more robust. For example, why do you need to close that connection? It must ultimately be based on some kind of I/O provided by the system (socket, file, whatever), so why can\'t you rely on the system to close it for you when the lowest level of resource is gced? If the server at the other end absolutely requires you to close the connection cleanly rather than just dropping the socket, then what\'s going to happen when someone trips over the power cable of the machine your code is running on, or the intervening network goes out?Disclaimer: I\'ve worked on a JVM implementation in the past. I hate finalizers.A simple rule: never use finalizers. The fact alone that an object has a finalizer (regardless what code it executes) is enough to cause considerable overhead for garbage collection.From an article by Brian Goetz:Objects with finalizers (those that\n  have a non-trivial finalize() method)\n  have significant overhead compared to\n  objects without finalizers, and should\n  be used sparingly. Finalizeable\n  objects are both slower to allocate\n  and slower to collect. At allocation\n  time, the JVM must register any\n  finalizeable objects with the garbage\n  collector, and (at least in the\n  HotSpot JVM implementation)\n  finalizeable objects must follow a\n  slower allocation path than most other\n  objects. Similarly, finalizeable\n  objects are slower to collect, too. It\n  takes at least two garbage collection\n  cycles (in the best case) before a\n  finalizeable object can be reclaimed,\n  and the garbage collector has to do\n  extra work to invoke the finalizer.\n  The result is more time spent\n  allocating and collecting objects and\n  more pressure on the garbage\n  collector, because the memory used by\n  unreachable finalizeable objects is\n  retained longer. Combine that with the\n  fact that finalizers are not\n  guaranteed to run in any predictable\n  timeframe, or even at all, and you can\n  see that there are relatively few\n  situations for which finalization is\n  the right tool to use.The only time I\'ve used finalize in production code was to implement a check that a given object\'s resources had been cleaned up, and if not, then log a very vocal message. It didn\'t actually try and do it itself, it just shouted a lot if it wasn\'t done properly. Turned out to be quite useful.I\'ve been doing Java professionally since 1998, and I\'ve never implemented finalize().  Not once.I\'m not sure what you can make of this, but...So I guess the Sun found some cases where (they think) it should be used. I used finalize once to understand what objects were being freed.  You can play some neat games with statics, reference counting and such--but it was only for analysis.The accepted answer is good, I just wanted to add that there is now a way to have the functionality of finalize without actually using it at all.Look at the "Reference" classes.  Weak reference, etc.You can use them to keep a reference to all your objects, but this reference ALONE will not stop GC.  The neat thing about this is you can have it call a method when it will be deleted, and this method can be guaranteed to be called.Another thing to watch out for.  Any time you see anything like this anywhere in code (not just in finalize, but that\'s where you are most likely to see it):It is a sign that somebody didn\'t know what they were doing. "Cleaning up" like this is virtually never needed.  When the class is GC\'d, this is done automatically.If you find code like that in a finalize it\'s guaranteed that the person who wrote it was confused.  If it\'s elsewhere, it could be that the code is a valid patch to a bad model (a class stays around for a long time and for some reason things it referenced had to be manually freed before the object is GC\'d).  Generally it\'s because someone forgot to remove a listener or something and can\'t figure out why their object isn\'t being GC\'d so they just delete things it refers to and shrug their shoulders and walk away.It should never be used to clean things up "Quicker". ====================================result:This is finalizeMyObject still alive!=====================================So you may make an unreachable instance reachable in finalize method.finalize can be useful to catch resource leaks.  If the resource should be closed but is not write the fact that it wasn\'t closed to a log file and close it.  That way you remove the resource leak and give yourself a way to know that it has happened so you can fix it.I have been programming in Java since 1.0 alpha 3 (1995) and I have yet to override finalize for anything...You shouldn\'t depend on finalize() to clean up your resources for you.  finalize() won\'t run until the class is garbage collected, if then.  It\'s much better to explicitly free resources when you\'re done using them.To highlight a point in the above answers: finalizers will be executed on the lone GC thread. I have heard of a major Sun demo where the developers added a small sleep to some finalizers and intentionally brought an otherwise fancy 3D demo to its knees.Best to avoid, with possible exception of test-env diagnostics.Eckel\'s Thinking in Java has a good section on this.When writing code that will be used by other developers that requires some sort of "cleanup" method to be called to free up resources.  Sometimes those other developers forget to call your cleanup (or close, or destroy, or whatever) method.  To avoid possible resource leaks you can check in the finalize method to ensure that the method was called and if it wasn\'t you can call it yourself.  Many database drivers do this in their Statement and Connection implementations to provide a little safety against developers who forget to call close on them.Hmmm, I once used it to clean up objects that weren\'t being returned to an existing pool. They were passed around a lot, so it was impossible to tell when they could safely be returned to the pool. The problem was that it introduced a huge penalty during garbage collection that was far greater than any savings from pooling the objects. It was in production for about a month before I ripped out the whole pool, made everything dynamic and was done with it.Edit: Okay, it really doesn\'t work. I implemented it and thought if it fails sometimes that\'s ok for me but it did not even call the finalize method a single time.I am not a professional programmer but in my program I have a case that I think to be an example of a good case of using finalize(), that is a cache that writes its content to disk before it is destroyed. Because it is not necessary that it is executed every time on destruction, it does only speed up my program, I hope that it i didn\'t do it wrong.It can be handy to remove things that have been added to a global/static place (out of need), and need to be removed when the object is removed. For instance:Be careful what you do in a finalize().  Especially if you are using it for things like calling close() to ensure that resources are cleaned up.  We ran into several situations where we had JNI libraries linked in to the running java code, and in any circumstances where we used finalize() to invoke JNI methods, we would get very bad java heap corruption.  The corruption was not caused by the underlying JNI code itself, all of the memory traces were fine in the native libraries.  It was just the fact that we were calling JNI methods from the finalize() at all.This was with a JDK 1.5 which is still in widespread use.We wouldn\'t find out that something went wrong until much later, but in the end the culprit was always the finalize() method making use of JNI calls.The accepted answer lists that closing a resource during finalize can be done.However this answer shows that at least in java8 with the JIT compiler, you run into unexpected issues where sometimes the finalizer is called even before you finish reading from a stream maintained by your object.So even in that situation calling finalize would not be recommended.Personally, I almost never use finalize() except in one rare circumstance: I made a custom generic-type collection, and I wrote a custom finalize() method that does the following:(CompleteObject is an interface I made that lets you specify that you\'ve implemented rarely-implemented Object methods like #finalize(), #hashCode(), and #clone())So, using a sister #setDestructivelyFinalizes(boolean) method, the program using my collection can (help) guarantee that destroying a reference to this collection also destroys references to its contents and disposes any windows that might keep the JVM alive unintentionally. I considered also stopping any threads, but that opened a whole new can of worms.The resources (File, Socket, Stream etc.) need to be closed once we are done with their usage. They generally have close() method which we generally call in finally section of try-catch statements. Sometimes finalize() can also be used by few developers but IMO that is not a suitable way as there is no guarantee that finalize will be called always.In Java 7 we have got try-with-resources statement which can be used like:In the above example try-with-resource will automatically close the resource BufferedReader by invoking close() method. If we want we can also implement Closeable in our own classes and use it in similar way. IMO it seems more neat and simple to understand.iirc - you can use finalize method as a means of implementing a pooling mechanism for expensive resources - so they don\'t get GC\'s too.