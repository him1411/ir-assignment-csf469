How are Docker images and containers different?When using docker, we start with a base image. We boot it up, create changes and those changes are saved in layers forming another image. So eventually I have an image for my Postgres and an image for my web app, changes to which keep on being persisted.So the question is: what is a container?An instance of an image is called a container. You have an image, which is a set of layers as you describe. If you start this image, you have a running container of this image. You can have many running containers of the same image.You can see all your images with docker images whereas you can see your running containers with docker ps (and you can see all containers with docker ps -a).So a running image is a container.From my article on Automating Docker Deployments:In Dockerland, there are images and there are containers. The two are closely related, but distinct. For me, grasping this dichotomy has clarified Docker immensely.An image is an inert, immutable, file that\'s essentially a snapshot of a container. Images are created with the build command, and they\'ll produce a container when started with run. Images are stored in a Docker registry such as registry.hub.docker.com. Because they can become quite large, images are designed to be composed of layers of other images, allowing a miminal amount of data to be sent when transferring images over the network.Local images can be listed by running docker images:Some things to note:More info on images is available from the Docker docs and glossary.To use a programming metaphor, if an image is a class, then a container is an instance of a class\xe2\x80\x94a runtime object. Containers are hopefully why you\'re using Docker; they\'re lightweight and portable encapsulations of an environment in which to run applications.View local running containers with docker ps:Here I\'m running a dockerized version of the docker registry, so that I have a private place to store my images. Again, some things to note:One of my early frustrations with Docker was the seemingly constant buildup of untagged images and stopped containers. On a handful of occassions this buildup resulted in maxed out hard drives slowing down my laptop or halting my automated build pipeline. Talk about "containers everywhere"!We can remove all untagged images by combining docker rmi with the recent dangling=true query:docker images -q --filter "dangling=true" | xargs docker rmiDocker won\'t be able to remove images that are behind existing containers, so you may have to remove stopped containers with docker rm first:These are known pain points with Docker, and may be addressed in future releases. However, with a clear understanding of images and containers, these situations can be avoided with a couple of practices:While it\'s simplest to think of a container as a running image, this isn\'t quite accurate.An image is really a template that can be turned into a container. To turn an image into a container, the Docker engine takes the image, adds a read-write filesystem on top and initialises various settings including network ports, container name, ID and resource limits. A running container has a currently executing process, but a container can also be stopped (or exited in Docker\'s terminology). An exited container is not the same as an image, as it can be restarted and will retain its settings and any filesystem changes. Maybe explaining the whole workflow can help.Everything starts with the Dockerfile. The Dockerfile is the source code of the Image.Once the Dockerfile is created, you build it to create the image of the container. The image is just the "compiled version" of the "source code" which is the Dockerfile.Once you have the image of the container, you should redistribute it using the registry. The registry is like a git repository -- you can push and pull images.Next, you can use the image to run containers. A running container is very similar, in many aspects, to a virtual machine (but without the hypervisor).This post explains many basic things about docker containers (it is talking about Docker and Puppet, but there are many concepts that can be used in any context)The core concept of docker is to make it easy to create "machines" which in this case can be considered containers. The container aids in reusability, allowing you to create and drop containers with ease.Images depict the state of a container at every point in time. So the basic workflow is:A container is just an executable binary that is to be run by the host OS under a set of restrictions that are preset using an application (e.g., docker) that knows how to tell the OS which restrictions to apply. The typical restrictions are process-isolation related, security related (like using SELinux protection) and system-resource related (memory, disk, cpu, networking). Until recently only kernels in Unix-based systems supported the ability to run executables under strict restrictions. That\'s why most container talk today involves mostly Linux or other Unix distributions. Docker is one of those applications that knows how to tell the OS (Linux mostly) what restrictions to run an executable under. The executable is contained in the Docker image, which is just a tarfile. That executable is usually a stripped-down version of a Linux distribution (Ubuntu, centos, Debian etc) preconfigured to run one or more applications within. Though most people use a Linux base as the executable, it can be any other binary application as long as the host OS can run it. (see creating a simple base image using scratch). Whether the binary in the docker image is an OS or simply an application, to the OS host it is just another process, a contained process ruled by preset OS boundaries. Other applications that, like Docker, can tell the host OS which boundaries to apply to a process while it is running include LXC, libvirt, and systemd. Docker used to use these applications to indirectly interact with the Linux OS, but now Docker interacts directly with Linux using its own library called "libcontainer". So containers are just processes running in a restricted mode, similar to what chroot used to do. IMO what sets Docker apart from any other container technology is its repository (Docker Hub) and their management tools which makes working with containers extremely easy. See \nhttps://en.m.wikipedia.org/wiki/Docker_(Linux_container_engine)Dockerfile > (Build) > Image > (Run) > Container.Dockerfile: contains a set of docker instructions that provisions your operating system the way you like, and installs/configure all your software\'s.Image: compiled Dockerfile. Saves you time from rebuilding the Dockerfile every time you need to run a container. And it\'s a way to hide your provision code.Container: the virtual operating system itself, you can ssh into it and run any commands you wish, as if it\'s a real environment. You can run 1000+ containers from the same Image.A Docker image packs up the application and environment required by the application to run, and a container is a running instance of the image. Images are the packing part of docker, analogous to "source code" or a "program". Containers are the execution part of docker, analogous to a "process".In the question, only the "program" part is referred to and that\'s the image.  The "running" part of docker is the container. When a container is run and changes are made, it\'s as if the process makes a change in it\'s own source code and saves it as the new image.I couldn\'t understand the concept of Image and Layer inspite of reading all the questions here and then eventually stumbled upon this excellent documentation from docker (duh!).The example there is really the key to understand the whole concept. It is a lengthy post, so I am summarising the key points that need to be really grasped to get clarity.Image: A Docker image is built up from a series of read only\nlayersLayer: Each layer represents an instruction in the image\xe2\x80\x99s Dockerfile. Example: The below Dockerfile contains four commands, each of which creates a layer. FROM ubuntu:15.04COPY . /appRUN make /appCMD python /app/app.pyImportantly, Each layer is only a set of differences from the layer before it.Hence, the The major difference between a container and an image is\n  the top writable layer. All writes to the container that add new or\n  modify existing data are stored in this writable layer. When the\n  container is deleted, the writable layer is also deleted. The\n  underlying image remains unchanged.Understanding Images and Containers from a Size on Disk PerspectiveTo view the approximate size of a running container, you can use the docker ps -s command. You get size and virtual size as two of the outputsSize:  the amount of data (on disk) that is used for the writable layer of each containerVirtual Size:  the amount of data used for the read-only image data used by the container. Multiple containers may share some or all read-only image data. Hence these are not additive. i.e. you can\'t add all the virtual sizes to calculate how much size on disk is used by the ImageAnother important concept is the Copy on Write Strategy\n If a file or directory exists in a lower layer within the image, and another layer (including the writable layer) needs read access to it, it just uses the existing file. The first time another layer needs to modify the file (when building the image or running the container), the file is copied into that layer and modified.Hope that helps someone else like me.Here is the end-to-end workflow showing the various commands and their associated inputs and outputs. That should clarify the relationship between an image and a container.To list the images you could run, execute:To list the containers you could execute commands on:As in the programming aspect,Image is a source code.When source code is compiled and build, it is called as application.Simillar to that "when instance is created for the image", it is called as "Container"Dockerfile is like your bash script that produce a tarball (Docker image).Docker containers is like extracted version of the tarball.  You can have as many copies as you like in different folders (the containers)Simply say, if an Image is a Class, then a Container is an instance of a Class - a runtime object.