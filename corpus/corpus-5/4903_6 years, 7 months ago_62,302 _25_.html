So, the title should speak for itself.To create re-usable components in ASP.NET MVC, we have 3 options (could be others i haven\'t mentioned):Partial View:Custom Editor Template:Custom Display Template:In terms of the actual View/HTML, all three implementations are identical:So, my question is - when/how do you decide which one of the three to use?What i\'m really looking for is a list of questions to ask yourself before creating one, for which the answers can be used to decide on which template to use.Here\'s the 2 things i have found better with EditorFor/DisplayFor:They respect model hierarchies when rendering HTML helpers (e.g if you have a "Bar" object on your "Foo" model, the HTML elements for "Bar" will be rendered with "Foo.Bar.ElementName", whilst a partial will have "ElementName").More robust, e.g if you had a List<T> of something in your ViewModel, you could use @Html.DisplayFor(model => model.CollectionOfFoo), and MVC is smart enough to see it\'s a collection and render out the single display for each item (as opposed to a Partial, which would require an explicit for loop).I\'ve also heard DisplayFor renders a "read-only" template, but i don\'t understand that - couldn\'t i throw a form on there?Can someone tell me some other reasons? Is there a list/article somewhere comparing the three?EditorFor vs DisplayFor is simple. The semantics of the methods is to generate edit/insert and display/read only views (respectively). Use DisplayFor when displaying data (i.e. when you generate divs and spans that contain the model values). Use EditorFor when editing/inserting data (i.e. when you generate input tags inside a form). The above methods are model-centric. This means that they will take the model metadata into account (for example you could annotate your model class with [UIHintAttribute] or [DisplayAttribute] and this would influence which template gets chosen to generate the UI for the model. They are also usually used for data models (i.e. models that represent rows in a database, etc)On the other hand Partial is view-centric in that you are mostly concerned with choosing the correct partial view. The view doesn\'t necessarily need a model to function correctly. It can just have a common set of markup that gets reused throughout the site. Of course often times you want to affect the behavior of this partial in which case you might want to pass in an appropriate view model.You did not ask about @Html.Action which also deserves a mention here. You could think of it as a more powerful version of Partial in that it executes a controller child action and then renders a view (which is usually a partial view). This is important because the child action can execute additional business logic that does not belong in a partial view. For example it could represent a shopping cart component. The reason to use it is to avoid performing the shopping cart-related work in every controller in your application.Ultimately the choice depends on what is it that you are modelling in your application. Also remember that you can mix and match. For example you could have a partial view that calls the EditorFor helper. It really depends on what your application is and how to factor it to encourage maximum code reuse while avoiding repetition.Just to give my 2c worth, our project is using a partial view with several jQuery tabs, and each tab rendering its fields with its own partial view. This worked fine until we added a feature whereby some of the tabs shared some common fields. Our first approach to this was to create another partial view with these common fields, but this got very clunky when using EditorFor and DropDownListFor to render fields and drop downs. In order to get the ids and names unique we had to render the fields with a prefix depending on the parent partial view that was rendering it:This got pretty ugly so we decided to use Editor Templates instead, which worked out much cleaner. We added a new View Model with the common fields, added a matching Editor Template, and rendered the fields using the Editor Template from different parent views. The Editor Template correctly renders the ids and names. So in short, a compelling reason for us to use Editor Templates was the need to render some common fields in multiple tabs. Partial views aren\'t designed for this but Editor Templates handle the scenario perfectly. You certainly could customize DisplayFor to display an editable form.  But the convention is for DisplayFor to be readonly and EditorFor to be for editing.  Sticking with the convention will ensure that no matter what you pass into DisplayFor, it will do the same type of thing.Another difference that hasn\'t been mentioned so far is that a partialview doesn\'t add model prefixes while a template does\nHere is the issueUse _partial view approach if:Reasons to use Template: