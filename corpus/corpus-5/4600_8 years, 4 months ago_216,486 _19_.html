I have been investigating transactions and it appears that they take care of themselves in EF as long as I pass false to SaveChanges() and then call AcceptAllChanges() if there are no errors:What if something goes bad? don\'t I have to rollback or, as soon as my method goes out of scope, is the transaction ended?What happens to any indentiy columns that were assigned half way through the transaction? I presume if somebody else added a record after mine before mine went bad then this means there will be a missing Identity value.Is there any reason to use the standard TransactionScope class in my code?With the Entity Framework most of the time SaveChanges() is sufficient. This creates a transaction, or enlists in any ambient transaction, and does all the necessary work in that transaction.Sometimes though the SaveChanges(false) + AcceptAllChanges() pairing is useful.The most useful place for this is in situations where you want to do a distributed transaction across two different Contexts.I.e. something like this (bad):If  context1.SaveChanges() succeeds but context2.SaveChanges() fails the whole distributed transaction is aborted. But unfortunately the Entity Framework has already discarded the changes on context1, so you can\'t replay or effectively log the failure.But if you change your code to look like this:While the call to SaveChanges(false) sends the necessary commands to the database, the context itself is not changed, so you can do it again if necessary, or you can interrogate the ObjectStateManager if you want.This means if the transaction actually throws an exception you can compensate, by either re-trying or logging state of each contexts ObjectStateManager somewhere.See my blog post for more.If you are using EF6 (Entity Framework 6+), this has changed for database calls to SQL.\nSee: http://msdn.microsoft.com/en-us/data/dn456843.aspxuse context.Database.BeginTransaction.Because some database can throw an exception at dbContextTransaction.Commit() so better this:Usually (99.9% of the time) the exceptions are thrown before or during the sql statements execution. The AcceptAllChanges runs after, to make sure all statements have been completed succesfully. DbContext SaveChanges calls the method automaticaly (at least in EF6) so you do not need to call it directly. The only place this is useful is when you have split the application in multiple contexts and you want to save at least 2 of them within a transaction. If the last save fails you might want to retry the previous saves.I advice to use transactions at all times unless you are absolutely certain that your app is not going to grow or add more functionality. 