I have a class with two constructors, one that takes no arguments and one that takes one argument.Creating objects using the constructor that takes one argument works as expected. However, if I create objects using the constructor that takes no arguments, I get an error.For instance, if I compile this code (using g++ 4.0.1)...... I get the following error:Why is this, and how do I make it work?change toYou get the error because compiler thinks ofas of function declaration with name \'foo2\' and the return type \'Foo\'.But in that case If we change to Foo foo2 , the compiler might show the error   " call of overloaded \xe2\x80\x98Foo()\xe2\x80\x99 is ambiguous".Just for the record..It is actually not a solution to your code, but I had the same error message when incorrectly accessing the method of a class instance pointed to by myPointerToClass, e.g.wherewould obviously be correct.Adding to the knowledge base, I got the same error for Even though the IDE gave me the correct members for class_iter. Obviously, the problem is that "anything"::iterator doesn\'t have a member called num so I need to dereference it. Which doesn\'t work like this:...apparently. I eventually solved it with this:I hope this helps someone who runs across this question the way I did.I was having a similar error, it seems that the compiler misunderstand the call to the constructor without arguments. I made it work by removing the parenthesis from the variable declaration, in your code something like this:Parenthesis is not required to instantiate a class object when you don\'t intend to use a parameterised constructor.Just use  Foo foo2;It will work.I ran into a case where I got that error message and hadand was basically trying to pass in a temporary Bar object to the Foo constructor. Turns out the compiler was translating this tothat is, a function declaration whose name is foo that returns a Foo that takes in an argument -- a function pointer returning a Bar with 0 arguments. When passing in temporaries like this, better to use Bar{} instead of Bar() to eliminate ambiguity.