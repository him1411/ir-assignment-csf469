Is it possible for C++ code to conform to both the C++03 standard and the C++11 standard, but do different things depending on under which standard it is being compiled?The answer is a definite yes. On the plus side there is:On the negative side, several examples are listed in the appendix C of the standard. Even though there are many more negative ones than positive, each one of them is much less likely to occur.String literalsandType conversions of 0In C++11, only literals are integer null pointer constants:Rounded results after integer division and moduloIn C++03 the compiler was allowed to either round towards 0 or towards negative infinity. In C++11 it is mandatory to round towards 0Whitespaces between nested template closing braces >> vs > >Inside an specialization or instantiation the >> might instead be interpreted as an right-shift in C++03. This is more likely to break existing code though: (from http://gustedt.wordpress.com/2013/12/15/a-disimprovement-observed-from-the-outside-right-angle-brackets/)Operator new may now throw other exceptions than std::bad_allocUser-declared destructors have an implicit exception specification\nexample from What breaking changes are introduced in C++11?size() of containers is now required to run in O(1)std::ios_base::failure does not derive from std::exception anymoreCode that expects it to derive directly from std::exception might behave differently.I point you to this article and the follow-up, which has a nice example of how >> can change meaning from C++03 to C++11 while still compiling in both.The key part is the line in main, which is an expression. Congratulations, two different results for the same expression. Granted, the C++03 one did come up with a warning form Clang when I tested it.Yes, there are number of changes that will cause the same code to result in different behavior between C++03 and C++11. The sequencing rules differences make for some interesting changes including some previously undefined behavior becoming well defined.1. multiple mutations of the same variable within an initializer listOne very interesting corner case would multiple mutations of the same variable within an initializer list, for example:In both C++03 and C++11 this is well defined but the order of evaluation in C++03 is unspecified but in C++11 they are evaluated in the order in which they appear. So if we compile using clang in C++03 mode it provide the following warning (see it live):but does not provide a warning in C++11 (see it live).2. New sequencing rules make i = ++ i + 1; well defined in C++11 The new sequencing rules adopted after C++03 means that:is no longer undefined behavior in C++11, this is covered in defect report 637. Sequencing rules and example disagree 3. New sequencing rules also make ++++i ; well defined in C++11 The new sequencing rules adopted after C++03 means that:is no longer undefined behavior in C++11.4. Slightly More Sensible Signed Left-ShiftsLater drafts of C++11 include N3485 which I link below fixed the undefined behavior of shifting a 1 bit into or past the sign bit. This is also covered in defect report 1457. Howard Hinnant commented on the significance of this change in the thread on Is left-shifting (<<) a negative integer undefined behavior in C++11?. 5. constexpr functions can be treated as compile time constant expressions in C++11C++11 introduced constexpr functions which:The constexpr specifier declares that it is possible to evaluate the value of the function or variable at compile time. Such variables and functions can then be used where only compile time constant expressions are allowed. while C++03 does not have the constexpr feature we don\'t have to explicitly use the constexpr keyword since the standard library provides many functions in C++11 as constexpr. For example std::numeric_limits::min. Which can lead to different behavior, for example:Using clang in C++03 this will cause x to be a variable length array, which is an extension and will generate the following warning:while in C++11 std::numeric_limits<unsigned int>::min()+2 is a compile time constant expression and does not require the VLA extension.6. In C++11 noexcept exception specifications are implicitly generated for your destructors Since in C++11 user defined destructor has implicit noexcept(true) specification as explained in noexcept destructors it means that the following program:In C++11 will call std::terminate but will run successfully in C++03.7. In C++03, template arguments could not have internal linkageThis is covered nicely in Why std::sort doesn\'t accept Compare classes declared within a function. So the following code should not work in C++03:but currently clang allows this code in C++03 mode with a warning unless you use -pedantic-errors flag, which is kind of icky, see it live.8. >> is not longer ill-formed when closing multiple templatesUsing >> to close multiple templates is no longer ill-formed but can lead to code with different results in C++03 and C+11. The example below is taken from Right angle brackets and backwards compatibility:and the result in C++03 is:and in C++11:9. C++11 changes some of std::vector constructorsSlightly modified code from this answer shows that using the following constructor from std::vector:produces different results in C++03 and C++11:10. Narrowing conversions in aggregate initializersIn C++11 a narrowing conversion in aggregate initializers is ill-formed and it looks like gcc allows this in both C++11 and C++03 although it provide a warning by default in C++11:This is covered in the draft C++11 standard section 8.5.4 List-initialization paragraph 3:List-initialization of an object or reference of type T is defined as follows:and contains the following bullet (emphasis mine):Otherwise, if T is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen through overload resolution (13.3, 13.3.1.7). If a narrowing conversion (see below) is required to convert any of the arguments, the program is ill-formedThis and many more instance are covered in the draft C++ standard section annex C.2 C++ and ISO C++ 2003. It also includes:New kinds of string literals [...] Specifically, macros named R, u8, u8R, u, uR, U, UR, or LR will not be expanded when adjacent to a string literal but will be interpreted as part of the string literal. For exampleUser-defined literal string support [...]Previously, #1 would have consisted of two separate preprocessing tokens and the macro _x would have been expanded. In this International Standard, #1 consists of a single preprocessing tokens, so the macro\nis not expanded.Specify rounding for results of integer / and % [...] 2003 code that uses integer division rounds the result toward 0 or toward negative infinity, whereas this \nInternational Standard always rounds the result toward 0.Complexity of size() member functions now constant [...] Some container implementations that conform to C++ 2003 may not conform to the specified size() requirements in this International Standard. Adjusting containers such as std::list to the stricter requirements may require incompatible changes.Change base class of std::ios_base::failure [...] std::ios_base::failure is no longer derived directly from std::exception, but is now derived from std::system_error, which in turn is derived from std::runtime_error. Valid C++ 2003 code that assumes that std::ios_base::failure is derived directly from std::exception may execute differently in this International Standard.One potentially dangerous backward-incompatible change is in constructors of sequence containers such as std::vector, specifically in the overload specifying initial size. Where in C++03, they copied a default-constructed element, in C++11 they default-construct each one.Consider this example (using boost::shared_ptr so that it\'s valid C++03):C++03 Live exampleC++11 Live exampleThe reason is that C++03 specified one overload for both "specify size and prototype element" and "specify size only," like this (allocator arguments omitted for brevity):This will always copy prototype into the container size times. When called with just one argument, it will therefore create size copies of a default-constructed element.In C++11, this constructor signature was removed and replaced with these two overloads:The second one works as before, creating size copies of the prototype element. However, the first one (which now handles calls with only the size argument specified) default-constructs each element individually.My guess for the reason of this change is that the C++03 overload wouldn\'t be usable with a move-only element type. But it\'s a breaking change none the less, and one seldom documented at that.The result of a failed read from an std::istream has changed.  CppReference summarizes it nicely:If extraction fails (e.g. if a letter was entered where a digit is expected), value is left unmodified and failbit is set. (until C++11)If extraction fails, zero is written to value and failbit is set. If extraction results in the value too large or too small to fit in value, std::numeric_limits<T>::max() or std::numeric_limits<T>::min() is written and failbit flag is set. (since C++11)This is primarily an issue if you are used to the new semantics and then have to write using C++03.  The following is not particularly good practice but well-defined in C++11:However, in C++03, the above code uses an uninitialized variable and thus has undefined behaviour.This thread What differences, if any, between C++03 and C++0x can be detected at run-time has examples (copied from that thread) to determine language differences, for example by exploiting C++11 reference collapsing:and c++11 allowing local types as template parameters:Here\'s another example:Prints:See the result on Coliru