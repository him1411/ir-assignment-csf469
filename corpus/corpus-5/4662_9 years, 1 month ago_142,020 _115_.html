I have been reading through the C++ FAQ and was curious about the friend declaration. I personally have never used it, however I am interested in exploring the language. What is a good example of using friend?Reading the FAQ a bit longer I like the idea of the << >> operator overloading and adding as a friend of those classes. However I am not sure how this doesn\'t break encapsulation. When can these exceptions stay within the strictness that is OOP?Firstly (IMO) don\'t listen to people who say friend is not useful. It IS useful. In many situations you will have objects with data or functionality that are not intended to be publicly available. This is particularly true of large codebases with many authors who may only be superficially familiar with different areas. There ARE alternatives to the friend specifier, but often they are cumbersome (cpp-level concrete classes/masked typedefs) or not foolproof (comments or function name conventions).Onto the answer; The friend specifier allows the designated class access to protected data or functionality within the class making the friend statement. For example in the below code anyone may ask a child for their name, but only the mother and the child may change the name. You can take this simple example further by considering a more complex class such as a Window. Quite likely a Window will have many function/data elements that should not be publicly accessible, but ARE needed by a related class such as a WindowManager.At work we use friends for testing code, extensively. It means we can provide proper encapsulation and information hiding for the main application code. But also we can have separate test code that uses friends to inspect internal state and data for testing.Suffice to say I wouldn\'t use the friend keyword as an essential component of your design.The friend keyword has a number of good uses. Here are the two uses immediately visible to me:Friend definition allows to define a function in class-scope, but the function will not be defined as a member function, but as a free function of the enclosing namespace, and won\'t be visible normally except for argument dependent lookup. That makes it especially useful for operator overloading:Sometimes, you find the need that a policy needs access to the derived class:You will find a non-contrived example for that in this answer. Another code using that is in this answer. The CRTP base casts its this pointer, to be able to access data-fields of the derived class using data-member-pointers.  @roo: Encapsulation is not broken here because the class itself dictates who can access its private members. Encapsulation would only be broken if this could be caused from outside the class, e.g. if your operator << would proclaim \xe2\x80\x9cI\'m a friend of class foo.\xe2\x80\x9dfriend replaces use of public, not use of private!Actually, the C++ FAQ answers this already.The canonical example is to overload operator<<.  Another common use is to allow a helper or admin class access to your internals.Here are a couple of guidelines I heard about C++ friends.  The last one is particularly memorable.edit: Reading the faq a bit longer I like the idea of the << >> operator overloading and adding as a friend of those classes, however I am not sure how this doesn\'t break encapsulationHow would it break encapsulation?You break encapsulation when you allow unrestricted access to a data member. Consider the following classes:c1 is obviously not encapsulated. Anyone can read and modify x in it. We have no way to enforce any kind of access control.c2 is obviously encapsulated. There is no public access to x. All you can do is call the foo function, which performs some meaningful operation on the class.c3? Is that less encapsulated? Does it allow unrestricted access to x? Does it allow unknown functions access?No. It allows precisely one function to access the private members of the class. Just like c2 did. And just like c2, the one function which has access is not "some random, unknown function", but "the function listed in the class definition". Just like c2, we can see, just by looking at the class definitions, a complete list of who has access.So how exactly is this less encapsulated? The same amount of code has access to the private members of the class. And everyone who has access is listed in the class definition.friend does not  break encapsulation. It makes some Java people programmers feel uncomfortable, because when they say "OOP", they actually mean "Java". When they say "Encapsulation", they don\'t mean "private members must be protected from arbitrary accesses", but "a Java class where the only functions able to access private members, are class members", even though this is complete nonsense for several reasons.First, as already shown, it is too restricting. There\'s no reason why friend methods shouldn\'t be allowed to do the same.Second, it is not restrictive enough. Consider a fourth class:This, according to aforesaid Java mentality, is perfectly encapsulated.\nAnd yet, it allows absolutely anyone to read and modify x. How does that even make sense? (hint: It doesn\'t)Bottom line:\nEncapsulation is about being able to control which functions can access private members. It is not about precisely where the definitions of these functions are located.Another common version of Andrew\'s example, the dreaded code-coupletInstead of worrying if both lines are always done together and in consistent order you could make the methods private and have a friend function to enforce consistency:In other words you can keep the public interfaces smaller and enforce invariants that cut across classes and objects in friend functions.You control the access rights for members and functions using Private/Protected/Public right?\nso assuming the idea of each and every one of those 3 levels is clear, then it should be clear that we are missing something... The declaration of a member/function as protected for example is pretty generic. You are saying that this function is out of reach for everyone (except for an inherited child of course). But what about exceptions? every security system lets you have some type of \'white list" right?So friend lets you have the flexibility of having rock solid object isolation, but allows for a "loophole" to be created for things that you feel are justified.I guess people say it is not needed because there is always a design that will do without it. I think it is similar to the discussion of global variables: You should never use them, There is always a way to do without them... but in reality, you see cases where that ends up being the (almost) most elegant way... I think this is the same case with friends.It doesn\'t really do any good, other than let you access a member variable without using a setting functionwell that is not exactly the way to look at it.\nThe idea is to control WHO can access what, having or not a setting function has little to do with it. I found handy place to use friend access: Unittest of private functions.Friend comes handy when you are building a container and you want to implement an iterator for that class.  The short answer would be: use friend when it actually improves encapsulation.  Improving readability and usability (operators << and >> are the canonical example) is also a good reason.As for examples of improving encapsulation, classes specifically designed to work with the internals of other classes (test classes come to mind) are good candidates.The creator of C++ says that isn\'t broking any encapsulation principle, and I will quote him:Does "friend" violate encapsulation?\n  No. It does not. "Friend" is an explicit mechanism for granting access, just like membership. You cannot (in a standard conforming program) grant yourself access to a class without modifying its source.Is more than clear...We had an interesting issue come up at a company I previously worked at where we used friend to decent affect.  I worked in our framework department we created a basic engine level system over our custom OS.  Internally we had a class structure:All of these classes were part of the framework and maintained by our team.  The games produced by the company were built on top of this framework deriving from one of Games children.  The issue was that Game had interfaces to various things that SinglePlayer and TwoPlayer needed access to but that we did not want expose outside of the framework classes.  The solution was to make those interfaces private and allow TwoPlayer and SinglePlayer access to them via friendship.  Truthfully this whole issue could have been resolved by a better implementation of our system but we were locked into what we had.  Another use: friend (+ virtual inheritance) can be used to avoid deriving from a class (aka: "make a class underivable") => 1, 2From 2:To do TDD many times I\'ve used \'friend\' keyword in C++.Can a friend know everything about me?Updated: I found this valuable answer about "friend" keyword from Bjarne Stroustrup site."Friend" is an explicit mechanism for granting access, just like membership.I\'m only using the friend-keyword to unittest protected functions. Some will say that you shouldn\'t test protected functionality. I, however, find this very useful tool when adding new functionality. However, I don\'t use the keyword in directly in the class declarations, instead I use a nifty template-hack to achive this:This enables me to do the following:Works on GCC and MSVC atleast.You have to be very careful about when/where you use the friend keyword, and, like you, I have used it very rarely. Below are some notes on using friend and the alternatives.Let\'s say you want to compare two objects to see if they\'re equal. You could either:The problem with the first option, is that that could be a LOT of accessors, which is (slightly) slower than direct variable access, harder to read, and cumbersome. The problem with the second approach is that you completely break encapsulation.What would be nice, is if we could define an external function which could still get access to the private members of a class. We can do this with the friend keyword:The method equal(Beer, Beer) now has direct access to a and b\'s private members (which may be char *brand, float percentAlcohol, etc. This is a rather contrived example, you would sooner apply friend to an overloaded == operator, but we\'ll get to that.A few things to note:I only really use friends when it\'s much harder to do it the other way. As another example, many vector maths functions are often created as friends due to the interoperability of Mat2x2, Mat3x3, Mat4x4, Vec2, Vec3, Vec4, etc. And it\'s just so much easier to be friends, rather than have to use accessors everywhere. As pointed out, friend is often useful when applied to the << (really handy for debugging), >> and maybe the == operator, but can also be used for something like this:As I say, I don\'t use friend very often at all, but every now and then it\'s just what you need. Hope this helps!The tree example is a pretty good example : \nHaving an object implemented in a few different class without\nhaving an inheritance relationship.Maybe you could also need it to have a constructor protected and force\npeople to use your "friend" factory.... Ok, Well frankly you can live without it.One specific instance where I use friend is when creating Singleton classes.  The friend keyword lets me create an accessor function, which is more concise than always having a "GetInstance()" method on the class.With regards to operator<< and  operator>> there is no good reason to make these operators friends.  It is true that they should not be member functions, but they don\'t need to be friends, either.The best thing to do is create public print(ostream&) and read(istream&) functions.  Then, write the operator<< and operator>> in terms of those functions.  This gives the added benefit of allowing you to make those functions virtual, which provides virtual serialization.Friend functions and classes provide direct access to private and protected members of class to avoid breaking encapsulation in the general case. Most usage is with ostream: we would like to be able to type:However, this may require access to the private data of Point, so we define the overloaded operatorThere are obvious encapsulation implications, however. First, now the friend class or function has full access to ALL members of the class, even ones that do not pertain to its needs. Second, the implementations of the class and the friend are now enmeshed to the point where an internal change in the class can break the friend.If you view the friend as an extension of the class, then this is not an issue, logically speaking. But, in that case, why was it necessary to spearate out the friend in the first place.To achieve the same thing that \'friends\' purport to achieve, but without breaking encapsulation, one can do this:Encapsulation is not broken, class B has no access to the internal implementation in A, yet the result is the same as if we had declared B a friend of A.\nThe compiler will optimize away the function calls, so this will result in the same instructions as direct access.I think using \'friend\' is simply a shortcut with arguable benefit, but definite cost.In C++ "friend" keyword is useful in Operator overloading and Making Bridge.\n1.) Friend keyword in operator overloading :Example for operator overloading is: Let say we have a class "Point" that has two float variable"x"(for x-coordinate) and "y"(for y-coordinate). Now we have to overload "<<"(extraction operator) such that if we call "cout << pointobj" then it will print x and y coordinate (where pointobj is an object of class Point). To do this we have two option:Beacause we have implemented overloading in Point class. So to call this function without an object we have to add"friend" keyword because we can call a friend function without an object.\nNow function declaration will be As:\n     "friend ostream &operator<<(ostream &cout, Point &pointobj);"\n\n2.) Friend keyword in making bridge :\nSuppose we have to make a function in which we have to access private member of two or more classes ( generally termed as "bridge" ) .\nHow to do this:\nTo access private member of a class it should be member of that class. Now to access private member of other class every class should declare that function as a friend function. For example :\nSuppose there are two class A and B. A function "funcBridge()" want to access private member of both classes. Then both class should declare "funcBridge()" as:\n   friend return_type funcBridge(A &a_obj, B & b_obj);I think this would help to understand friend keyword.When implementing tree algorithms for class, the framework code the prof gave us had the tree class as a friend of the node class.It doesn\'t really do any good, other than let you access a member variable without using a setting function.To do TDD many times I\'ve used \'friend\' keyword in C++.Can a friend know everything about me?No, its only a one way friendship :`(You may use friendship when different classes (not inheriting one from the other) are using private or protected members of the other class.Typical use cases of friend functions are operations that are\n  conducted between two different classes accessing private or protected\n  members of both.from http://www.cplusplus.com/doc/tutorial/inheritance/ .You can see this example where non-member method accesses the private members of a class. This method has to be declared in this very class as a friend of the class.Probably I missed something from the answers above but another important concept in encapsulation is hiding of implementation. Reducing access to private data members (the implementation details of a class) allows much easier modification of the code later. If a friend directly accesses the private data, any changes to the implementation data fields (private data), break the code accessing that data. Using access methods mostly eliminates this. Fairly important I would think.This may not be an actual use case situation but may help to illustrate the use of friend between classes.The ClubHouseThe Members Class\'sAmenitiesIf you look at the relationship of these classes here; the ClubHouse holds a variety of different types of memberships and membership access. The Members are all derived from a super or base class since they all share an ID and an enumerated type that are common and outside classes can access their IDs and Types through access functions that are found in the base class. However through this kind of hierarchy of the Members and its Derived classes and their relationship with the ClubHouse class the only one of the derived class\'s that has "special privileges" is the VIPMember class. The base class and the other 2 derived classes can not access the ClubHouse\'s  joinVIPEvent() method, yet the VIP Member class has that privilege as if it has complete access to that event. So with the VIPMember and the ClubHouse it is a two way street of access where the other Member Classes are limited.As the reference for friend declaration says:The friend declaration appears in a class body and grants a function or another class access to private and protected members of the class where the friend declaration appears.So just as a reminder, there are technical errors in some of the answers which say that friend can only visit protected members.You could adhere to the strictest and purest OOP principles and ensure that no data members for any class even have accessors so that all objects must be the only ones that can know about their data with the only way to act on them is through indirect messages, i.e., methods.But even C# has an internal visibility keyword and Java has its default package level accessibility for some things. C++ comes actually closer to the OOP ideal by minimizinbg the compromise of visibility into a class by specifying exactly which other class and only other classes could see into it. I don\'t really use C++ but if C# had friends I would that instead of the assembly-global internal modifier, which I actually use a lot. It doesn\'t really break incapsulation, because the unit of deployment in .NET is an assembly.But then there\'s the InternalsVisibleToAttribute(otherAssembly) which acts like a cross-assembly friend mechanism. Microsoft uses this for visual designer assemblies.Friends are also useful for callbacks. You could implement callbacks as static methodswhere callback calls localCallback internally, and the clientData has your instance in it. In my opinion, or...What this allows is for the friend to be a defined purely in the cpp as a c-style function, and not clutter up the class.Similarly, a pattern I\'ve seen very often is to put all the really private members of a class into another class, which is declared in the header, defined in the cpp, and friended. This allows the coder to hide a lot of the complexity and internal working of the class from the user of the header.In the header:In the cpp,It becomes easier to hide things that the downstream needn\'t see this way.