How do you add an observer in Swift to the default notification center?  I\'m trying to port this line of code that sends a notification when the battery level changes.It\'s the same as the Objective-C API, but uses Swift\'s syntax.Or in Swift 3:If your observer does not inherit from an Objective-C object, you must prefix your method with @objc in order to use it as a selector.See NSNotificationCenter Class Reference, Interacting with Objective-C APIsSend(Post) Notification:Receive(Get) Notification:Method handler for received Notification:Remove Notification:Send(Post) NotificationReceive(Get) NotificationMethod handler for received NotificationFor historic Xcode versions...Send(Post) NotificationReceive(Get) NotificationRemove NotificationMethod handler for received NotificationAnnotate either the class or the target method with @objcSwift 3.0 has replaced many "stringly-typed" APIs with struct "wrapper types", as is the case with NotificationCenter. Notifications are now identified by a struct Notfication.Name rather than by String. See the Migrating to Swift 3 guide.Previous usage:New Swift 3.0 usage:All of the system notification types are now defined as static constants on Notification.Name; i.e. .UIDeviceBatteryLevelDidChange, .UIApplicationDidFinishLaunching, .UITextFieldTextDidChange, etc.You can extend Notification.Name with your own custom notifications in order to stay consistent with the system notifications:A nice way of doing this is to use the addObserver(forName:object:queue:using:) method rather than the addObserver(_:selector:name:object:) method that is often used from Objective-C code. The advantage of the first variant is that you don\'t have to use the @objc attribute on your method:and you can even just use a closure instead of a method if you want:You can use the returned value to stop listening for the notification later:There used to be another advantage in using this method, which was that it doesn\'t require you to use selector strings which couldn\'t be statically checked by the compiler and so were fragile to breaking if the method is renamed, but Swift 2.2 and later include #selector expressions that fix that problem.Pass Data using NSNotificationCenterYou can also pass data using NotificationCentre in swift 3.0 and NSNotificationCenter in swift 2.0.Swift 2.0 VersionPass info using userInfo which is a optional Dictionary of type [NSObject : AnyObject]?Swift 3.0 VersionThe userInfo now takes [AnyHashable:Any]? as an argument, which we provide as a dictionary literal in SwiftSource pass data using NotificationCentre(swift 3.0) and NSNotificationCenter(swift 2.0) I\'m able to do one of the following to successfully use a selector - without annotating anything with @objc:ORMy xcrun version shows Swift 1.2, and this works on Xcode 6.4 and Xcode 7 beta 2 (which I thought would be using Swift 2.0):In swift 2.2 - XCode 7.3, we use #selector for NSNotificationCenterWe should remove notification also.Ex.In swift 3, Xcode 8.2:- checking battery state level