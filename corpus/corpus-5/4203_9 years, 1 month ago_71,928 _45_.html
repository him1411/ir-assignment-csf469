In Ruby 1.8, there are subtle differences between proc/lambda on the one hand, and Proc.new on the other. Another important but subtle difference between procs created with lambda and procs created with Proc.new is how they handle the return statement:Here\'s lambda-created proc\'s return in action. It behaves in a way that you probably expect:Now here\'s a Proc.new-created proc\'s return doing the same thing. You\'re about to see one of those cases where Ruby breaks the much-vaunted Principle of Least Surprise:Thanks to this surprising behavior (as well as less typing), I tend to favor using lambda over Proc.new when making procs.To provide further clarification:Joey says that the return behavior of Proc.new is surprising. However when you consider that Proc.new behaves like a block this is not surprising as that is exactly how blocks behave. lambas on the other hand behave more like methods.This actually explains why Procs are flexible when it comes to arity (number of arguments) whereas lambdas are not. Blocks don\'t require all their arguments to be provided but methods do (unless a default is provided). While providing lambda argument default is not an option in Ruby 1.8, it is now supported in Ruby 1.9 with the alternative lambda syntax (as noted by webmat):And Michiel de Mare (the OP) is incorrect about the Procs and lambda behaving the same with arity in Ruby 1.9. I have verified that they still maintain the behavior from 1.8 as specified above.break statements don\'t actually make much sense in either Procs or lambdas. In Procs, the break would return you from Proc.new which has already been completed. And it doesn\'t make any sense to break from a lambda since it\'s essentially a method, and you would never break from the top level of a method.next, redo, and raise behave the same in both Procs and lambdas. Whereas retry is not allowed in either and will raise an exception.And finally, the proc method should never be used as it is inconsistent and has unexpected behavior. In Ruby 1.8 it actually returns a lambda! In Ruby 1.9 this has been fixed and it returns a Proc. If you want to create a Proc, stick with Proc.new.For more information, I highly recommend O\'Reilly\'s The Ruby Programming Language which is my source for most of this information.I found this page which shows what the difference between Proc.new and lambda are.  According to the page, the only difference is that a lambda is strict about the number of arguments it accepts, whereas Proc.new converts missing arguments to nil.  Here is an example IRB session illustrating the difference:The page also recommends using lambda unless you specifically want the error tolerant behavior.  I agree with this sentiment.  Using a lambda seems a tad more concise, and with such an insignificant difference, it seems the better choice in the average situation.As for Ruby 1.9, sorry, I haven\'t looked into 1.9 yet, but I don\'t imagine they would change it all that much (don\'t take my word for it though, it seems you have heard of some changes, so I am probably wrong there).Proc is older, but the semantics of return are highly counterintuitive to me (at least when I was learning the language) because:Lambda is functionally safer and easier to reason about - I always use it instead of proc.I can\'t say much about the subtle differences. However, I can point out that Ruby 1.9 now allows optional parameters for lambdas and blocks.Here\'s the new syntax for the stabby lambdas under 1.9:Ruby 1.8 didn\'t have that syntax. Neither did the conventional way of declaring blocks/lambdas support optional args:Ruby 1.9, however, supports optional arguments even with the old syntax:If you wanna build Ruby1.9 for Leopard or Linux, check out this article (shameless self promotion).Short answer: What matters is what return does: lambda returns out of itself, and proc returns out of itself AND the function that called it. What is less clear is why you want to use each. lambda is what we expect things should do in a functional programming sense. It is basically an anonymous method with the current scope automatically bound. Of the two, lambda is the one you should probably be using.Proc, on the other hand, is really useful for implementing the language itself. For example you can implement "if" statements or "for" loops with them. Any return found in the proc will return out of the method that called it, not the just the "if" statement. This is how languages work, how "if" statements work, so my guess is Ruby uses this under the covers and they just exposed it because it seemed powerful.You would only really need this if you are creating new language constructs like loops, if-else constructs, etc.A good way to see it is that lambdas are executed in their own scope (as if it was a method call), while Procs may be viewed as executed inline with the calling method, at least that\'s a good way of deciding wich one to use in each case.I didn\'t notice any comments on the third method in the queston, "proc" which is deprecated, but handled differently in 1.8 and 1.9.Here\'s a fairly verbose example that makes it easy to see the differences between the three similar calls:Closures in Ruby is a good overview for how blocks, lambda and proc work in Ruby, with Ruby. Understanding Ruby Blocks, Procs and Lambdas by Robert Sosinski clearly explains these programming concepts and reinforces the explanations with example code. Method objects are related and covered as well.lambda works as expected, like in other languages.The wired Proc.new is surprising and confusing.The return statement in proc created by Proc.new will not only return control just from itself, but also from the method enclosing it.You can argue that Proc.new inserts code into the enclosing method, just like block.\nBut Proc.new creates an object, while block are part of an object.And there is another difference between lambda and Proc.new, which is their handling of (wrong) arguments.\nlambda complains about it, while Proc.new ignores extra arguments or considers the absence of arguments as nil.BTW, proc in Ruby 1.8 creates a lambda, while in Ruby 1.9+ behaves like Proc.new, which is really confusing.To elaborate on Accordion Guy\'s response:Notice that Proc.new creates a proc out by being passed a block.  I believe that lambda {...} is parsed as a sort of literal, rather than a method call which passes a block.  returning from inside a block attached to a method call will return from the method, not the block, and the Proc.new case is an example of this at play.(This is 1.8.  I don\'t know how this translates to 1.9.)I am a bit late on this, but there is one great but little known thing about Proc.new not mentioned in comments at all. As by documentation:Proc::new may be called without a block only within a method with an attached block, in which case that block is converted to the Proc object.That said, Proc.new lets to chain yielding methods:The difference in behaviour with return is IMHO the most important difference between the 2. I also prefer lambda because it\'s less typing than Proc.new :-)