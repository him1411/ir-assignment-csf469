Suppose we have two stacks and no other temporary variable.Is to possible to "construct" a queue data structure using only the two stacks?Keep 2 stacks, let\'s call them inbox and outbox.Enqueue:Dequeue:If outbox is empty, refill it by popping each element from inbox and pushing it onto outboxPop and return the top element from outboxUsing this method, each element will be in each stack exactly once - meaning each element will be pushed twice and popped twice, giving amortized constant time operations.Here\'s an implementation in Java:To understand how to construct a queue using two stacks, you should understand how to reverse a stack crystal clear. Remember how stack works, it is very similar to the dish stack on your kitchen. The last washed dish will be on the top of the clean stack, which is called as Last In First Out (LIFO) in computer science.Lets imagine our stack like a bottle as below;If we push integers 1,2,3 respectively, then 3 will be on the top of the stack. Because 1 will be pushed first, then 2 will be put on the top of 1. Lastly, 3 will be put on the top of the stack and latest state of our stack represented as a bottle will be as below;Now we have our stack represented as a bottle is populated with values 3,2,1. And we want to reverse the stack so that the top element of the stack will be 1 and bottom element of the stack will be 3. What we can do ? We can take the bottle and hold it upside down so that all the values should reverse in order ?Yes we can do that, but that\'s a bottle. To do the same process, we need to have a second stack that which is going to store the first stack elements in reverse order. Let\'s put our populated stack to the left and our new empty stack to the right. To reverse the order of the elements, we are going to pop each element from left stack, and push them to the right stack. You can see what happens as we do so on the image below;So we know how to reverse a stack.On previous part, I\'ve explained how can we reverse the order of stack elements. This was important, because if we push and pop elements to the stack, the output will be exactly in reverse order of a queue. Thinking on an example, let\'s push the array of integers {1, 2, 3, 4, 5} to a stack. If we pop the elements and print them until the stack is empty, we will get the array in the reverse order of pushing order, which will be {5, 4, 3, 2, 1} Remember that for the same input, if we dequeue the queue until the queue is empty, the output will be {1, 2, 3, 4, 5}. So it is obvious that for the same input order of elements, output of the queue is exactly reverse of the output of a stack. As we know how to reverse a stack using an extra stack, we can construct a queue using two stacks.Our queue model will consist of two stacks. One stack will be used for enqueue operation (stack #1 on the left, will be called as Input Stack), another stack will be used for the dequeue operation (stack #2 on the right, will be called as Output Stack). Check out the image below;Our pseudo-code is as below;Let\'s enqueue the integers {1, 2, 3} respectively. Integers will be pushed on the Input Stack (Stack #1) which is located on the left;Then what will happen if we execute a dequeue operation? Whenever a dequeue operation is executed, queue is going to check if the Output Stack is empty or not(see the pseudo-code above) If the Output Stack is empty, then the Input Stack is going to be extracted on the output so the elements of Input Stack will be reversed. Before returning a value, the state of the queue will be as below;Check out the order of elements in the Output Stack (Stack #2). It\'s obvious that we can pop the elements from the Output Stack so that the output will be same as if we dequeued from a queue. Thus, if we execute two dequeue operations, first we will get {1, 2} respectively. Then element 3 will be the only element of the Output Stack, and the Input Stack will be empty. If we enqueue the elements 4 and 5, then the state of the queue will be as follows;Now the Output Stack is not empty, and if we execute a dequeue operation, only 3 will be popped out from the Output Stack. Then the state will be seen as below;Again, if we execute two more dequeue operations, on the first dequeue operation, queue will check if the Output Stack is empty, which is true. Then pop out the elements of the Input Stack and push them to the Output Stack unti the Input Stack is empty, then the state of the Queue will be as below;Easy to see, the output of the two dequeue operations will be {4, 5}Here is an implementation in Java. I\'m not going to use the existing implementation of Stack so the example here is going to reinvent the wheel;You can even simulate a queue using only one stack. The second (temporary) stack can be simulated by the call stack of recursive calls to the insert method. The principle stays the same when inserting a new element into the queue: A Queue class using only one Stack, would be as follows:Brian\'s answer is the classically correct one.  In fact, this is one of the best ways to implement persistent functional queues with amortized constant time.  This is so because in functional programming we have a very nice persistent stack (linked list).  By using two lists in the way Brian describes, it is possible to implement a fast queue without requiring an obscene amount of copying.As a minor aside, it is possible to prove that you can do anything with two stacks.  This is because a two-stack operation completely fulfills the definition of a universal Turing machine.  However, as Forth demonstrates, it isn\'t always easy.  :-)The time complexities would be worse, though.  A good queue implementation does everything in constant time.EditNot sure why my answer has been downvoted here.  If we program, we care about time complexity, and using two standard stacks to make a queue is inefficient.  It\'s a very valid and relevant point.  If someone else feels the need to downvote this more, I would be interested to know why.A little more detail: on why using two stacks is worse than just a queue: if you use two stacks, and someone calls dequeue while the outbox is empty, you need linear time to get to the bottom of the inbox (as you can see in Dave\'s code).You can implement a queue as a singly-linked list (each element points to the next-inserted element), keeping an extra pointer to the last-inserted element for pushes (or making it a cyclic list).  Implementing queue and dequeue on this data structure is very easy to do in constant time.  That\'s worst-case constant time, not amortized.  And, as the comments seem to ask for this clarification, worst-case constant time is strictly better than amortized constant time.Let queue to be implemented be q and stacks used to implement q be stack1 and stack2. q can be implemented in two ways:Method 1 (By making enQueue operation costly)This method makes sure that newly entered element is always at the top of stack 1, so that deQueue operation just pops from stack1. To put the element at top of stack1, stack2 is used.Method 2 (By making deQueue operation costly)In this method, in en-queue operation, the new element is entered at the top of stack1. In de-queue operation, if stack2 is empty then all the elements are moved to stack2 and finally top of stack2 is returned.Method 2 is definitely better than method 1. Method 1 moves all the elements twice in enQueue operation, while method 2 (in deQueue operation) moves the elements once and moves elements only if stack2 empty.Two stacks in the queue are defined as stack1 and stack2.Enqueue:\nThe euqueued elements are always pushed into stack1Dequeue:\nThe top of stack2 can be popped out since it is the first element inserted into queue when stack2 is not empty. When stack2 is empty, we pop all elements from stack1 and push them into stack2 one by one. The first element in a queue is pushed into the bottom of stack1. It can be popped out directly after popping and pushing operations since it is on the top of stack2.The following is same C++ sample code:This solution is borrowed from my blog. More detailed analysis with step-by-step operation simulations is available in my blog webpage.You\'ll have to pop everything off the first stack to get the bottom element. Then put them all back onto the second stack for every "dequeue" operation.for c# developer here is the complete program :For every enqueue operation, we add to the top of the stack1. For every dequeue, we empty the content\'s of stack1 into stack2, and remove the element at top of the stack.Time complexity is O(n) for dequeue, as we have to copy the stack1 to stack2. time complexity of enqueue is the same as a regular stackI\'ll answer this question in Go because Go does not have a rich a lot of collections in its standard library.Since a stack is really easy to implement I thought I\'d try and use two stacks to accomplish a double ended queue. To better understand how I arrived at my answer I\'ve split the implementation in two parts, the first part is hopefully easier to understand but it\'s incomplete.It\'s basically two stacks where we allow the bottom of the stacks to be manipulated by each other. I\'ve also used the STL naming conventions, where the traditional push, pop, peek operations of a stack have a front/back prefix whether they refer to the front or back of the queue.The issue with the above code is that it doesn\'t use memory very efficiently. Actually, it grows endlessly until you run out of space. That\'s really bad. The fix for this is to simply reuse the bottom of the stack space whenever possible. We have to introduce an offset to track this since a slice in Go cannot grow in the front once shrunk.It\'s a lot of small functions but of the 6 functions 3 of them are just mirrors of the other.A solution in c#Queue implementation using two java.util.Stack objects: