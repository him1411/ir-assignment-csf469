I\'ve just had to write a string reverse function in C# 2.0 (i.e. LINQ not available) and came up with this:Personally I\'m not crazy about the function and am convinced that there\'s a better way to do it. Is there?I think the above works not tested, although the stringbuilder class may also have a reverse function I haven\'t checked that though.Here a solution that properly reverses the string "Les Mise\\u0301rables" as "selbare\\u0301siM seL". This should render just like selbar\xc3\xa9siM seL, not selbar\xcc\x81esiM seL (note the position of the accent), as would the result of most implementations based on code units (Array.Reverse, etc) or even code points (reversing with special care for surrogate pairs).(And live running example here: https://ideone.com/DqAeMJ)It simply uses the .NET API for grapheme cluster iteration, which has been there since ever, but a bit "hidden" from view, it seems. This is turning out to be a surprisingly tricky question. I would recommend using Array.Reverse for most cases as it is coded natively and it is very simple to maintain and understand. It seems to outperform StringBuilder in all the cases I tested.  There is a second approach that can be faster for certain string lengths which uses Xor. Note If you want to support the full Unicode UTF16 charset read this. And use the implementation there instead. It can be further optimized by using one of the above algorithms and running through the string to clean it up after the chars are reversed.Here is a performance comparison between the StringBuilder, Array.Reverse and Xor method. Here are the results: It seems that Xor can be faster for short strings. If the string contains Unicode data (strictly speaking, non-BMP characters) the other methods that have been posted will corrupt it, because you cannot swap the order of high and low surrogate code units when reversing the string. (More information about this can be found on my blog.)The following code sample will correctly reverse a string that contains non-BMP characters, e.g., "\\U00010380\\U00010381" (Ugaritic Letter Alpa, Ugaritic Letter Beta).From above 3.5 FrameworkOk, in the interest of "don\'t repeat yourself," I offer the following solution:My understanding is that this implementation, available by default in VB.NET, properly handles Unicode characters.Greg Beech posted an unsafe option that is indeed as fast as it gets (it\'s an in-place reversal); but, as he indicated in his answer, it\'s a completely disastrous idea.That said, I\'m surprised there is so much of a consensus that Array.Reverse is the fastest method. There\'s still an unsafe approach that returns a reversed copy of a string (no in-place reversal shenanigans) significantly faster than the Array.Reverse method for small strings:Here are some benchmark results.You can see that the performance gain shrinks and then disappears against the Array.Reverse method as the strings get larger. For small- to medium-sized strings, though, it\'s tough to beat this method.If you want to play a really dangerous game, then this is by far the fastest way there is (around four times faster than the Array.Reverse method). It\'s an in-place reverse using pointers.Note that I really do not recommend this for any use, ever (have a look here for some reasons why you should not use this method), but it\'s just interesting to see that it can be done, and that strings aren\'t really immutable once you turn on unsafe code.Firstly you don\'t need to call ToCharArray as a string can already be indexed as a char array, so this will save you an allocation.The next optimisation is to use a StringBuilder to prevent unnecessary allocations (as strings are immutable, concatenating them makes a copy of the string each time). To further optimise this we pre-set the length of the StringBuilder so it won\'t need to expand its buffer.Edit: Performance DataI tested this function and the function using Array.Reverse with the following simple program, where Reverse1 is one function and Reverse2 is the other:It turns out that for short strings the Array.Reverse method is around twice as quick as the one above, and for longer strings the difference is even more pronounced. So given that the Array.Reverse method is both simpler and faster I\'d recommend you use that rather than this one. I leave this one up here just to show that it isn\'t the way you should do it (much to my surprise!)The easy and nice answer is using the Extension Method:and here\'s the output: Try using Array.ReverseOf course you can extend string class with Reverse methodHave a look at the wikipedia entry here. They implement the String.Reverse extension method. This allows you to write code like this:They also use the ToCharArray/Reverse combination that other answers to this question suggest. The source code looks like this:Don\'t bother with a function, just do it in place.  Note: The second line will throw an argument exception in the Immediate window of some VS versions.Had to submit a recursive example:Sorry for long post, but this might be interestingResults:Stack-based solution.Or How about:OutputFor size: 10For size: 100For size: 1000For size: 10000I\'ve made a C# port from Microsoft.VisualBasic.Strings. I\'m not sure why they keep such useful functions (from VB) outside the System.String in Framework, but still under Microsoft.VisualBasic. Same scenario for financial functions (e.g. Microsoft.VisualBasic.Financial.Pmt())."Better way" depends on what is more important to you in your situation, performance, elegance, maintainability etc.Anyway, here\'s an approach using Array.Reverse:If you have a string that only contains ASCII characters, you can use this method.As simple as this:See the output.If it ever came up in an interview and you were told you can\'t use Array.Reverse, i think this might be one of the fastest.  It does not create new strings and iterates only over half of the array (i.e O(n/2) iterations)Faster than above methodFirst of all what you have to understand is that str+= will resize your string memory to make space for 1 extra char. This is fine, but if you have, say, a book with 1000 pages that you want to reverse, this will take very long to execute.The solution that some people might suggest is using StringBuilder. What string builder does when you perform a += is that it allocates much larger chunks of memory to hold the new character so that it does not need to do a reallocation every time you add a char. If you really want a fast and minimal solution I\'d suggest the following:In this solution there is one initial memory allocation when the char[] is initialized and one allocation when the string constructor builds the string from the char array. On my system I ran a test for you that reverses a string of 2 750 000 characters. Here are the results for 10 executions:StringBuilder: 190K - 200K ticksChar Array: 130K - 160K ticksI also ran a test for normal String += but I abandoned it after 10 minutes with no output.However, I also noticed that for smaller strings the StringBuilder is faster, so you will have to decide on the implementation based on the input.CheersSorry for posting on this old thread. I am practicing some code for an interview.This was what I came up with for C#. My first version before refactoring was horrible.In Contrast to the Array.Reverse method below, it appears faster with 12 characters or less in the string. After 13 characters, the Array.Reverse starts to get faster, and it eventually dominates pretty heavily on speed. I just wanted to point out approximately where the speed starts to change.At 100 characters in the string, it is faster than my version x 4. However, if I knew that the strings would always be less than 13 characters, I would use the one I made. Testing was done with Stopwatch and 5000000 iterations. Also, I\'m not sure if my version handles Surrogates or combined character situations with Unicode encoding.