According to the docs, "Without middleware, Redux store only supports synchronous data flow". I don\'t understand why this is the case. Why can\'t the container component call the async API, and then dispatch the actions? For example, imagine a simple UI: a field and a button. When user pushes the button, the field gets populated with data from a remote server.When the exported component is rendered, I can click the button and the input is updated correctly. Note the update function in the connect call. It dispatches an action that tells the App that it is updating, and then performs an async call. After the call finishes, the provided value is dispatched as a payload of another action.What is wrong with this approach? Why would I want to use Redux Thunk or Redux Promise, as the documentation suggests?EDIT: I searched the Redux repo for clues, and found that Action Creators were required to be pure functions in the past. For example, here\'s a user trying to provide a better explanation for async data flow:The action creator itself is still a pure function, but the thunk function it returns doesn\'t need to be, and it can do our async callsAction creators are no longer required to be pure. So, thunk/promise middleware was definitely required in the past, but it seems that this is no longer the case?What is wrong with this approach? Why would I want to use Redux Thunk or Redux Promise, as the documentation suggests?There is nothing wrong with this approach. It\xe2\x80\x99s just inconvenient in a large application because you\xe2\x80\x99ll have different components performing the same actions, you might want to debounce some actions, or keep some local state like auto-incrementing IDs close to action creators, etc. So it is just easier from the maintenance point of view to extract action creators into separate functions.You can read my answer to \xe2\x80\x9cHow to dispatch a Redux action with a timeout\xe2\x80\x9d for a more detailed walkthrough.Middleware like Redux Thunk or Redux Promise just gives you \xe2\x80\x9csyntax sugar\xe2\x80\x9d for dispatching thunks or promises, but you don\xe2\x80\x99t have to use it.So, without any middleware, your action creator might look likeBut with Thunk Middleware you can write it like this:So there is no huge difference. One thing I like about the latter approach is that the component doesn\xe2\x80\x99t care that the action creator is async. It just calls dispatch normally, it can also use mapDispatchToProps to bind such action creator with a short syntax, etc. The components don\xe2\x80\x99t know how action creators are implemented, and you can switch between different async approaches (Redux Thunk, Redux Promise, Redux Saga) without changing the components. On the other hand, with the former, explicit approach, your components know exactly that a specific call is async, and needs dispatch to be passed by some convention (for example, as a sync parameter).Also think about how this code will change. Say we want to have a second data loading function, and to combine them in a single action creator.With the first approach we need to be mindful of what kind of action creator we are calling:With Redux Thunk action creators can dispatch the result of other action creators and not even think whether those are synchronous or asynchronous:With this approach, if you later want your action creators to look into current Redux state, you can just use the second getState argument passed to the thunks without modifying the calling code at all:If you need to change it to be synchronous, you can also do this without changing any calling code:So the benefit of using middleware like Redux Thunk or Redux Promise is that components aren\xe2\x80\x99t aware of how action creators are implemented, and whether they care about Redux state, whether they are synchronous or asynchronous, and whether or not they call other action creators. The downside is a little bit of indirection, but we believe it\xe2\x80\x99s worth it in real applications.Finally, Redux Thunk and friends is just one possible approach to asynchronous requests in Redux apps. Another interesting approach is Redux Saga which lets you define long-running daemons (\xe2\x80\x9csagas\xe2\x80\x9d) that take actions as they come, and transform or perform requests before outputting actions. This moves the logic from action creators into sagas. You might want to check it out, and later pick what suits you the most.I searched the Redux repo for clues, and found that Action Creators were required to be pure functions in the past. This is incorrect. The docs said this, but the docs were wrong.\nAction creators were never required to be pure functions.\nWe fixed the docs to reflect that.Dan Abramov\'s answer is right about redux-thunk but I will talk a bit more about redux-saga that is quite similar but more powerful.When you have a thunk in yours hands, like an IO monad or a promise, you can\'t easily know what it will do once you execute. The only way to test a thunk is to execute it, and mock the dispatcher (or the whole outside world if it interacts with more stuff...).If you are using mocks, then you are not doing functional programming. Seen through the lens of side-effects, mocks are a flag that your code is impure, and in the functional programmer\'s eye, proof that something is wrong. Instead of downloading a library to help us check the iceberg is intact, we should be sailing around it.\n  A hardcore TDD/Java guy once asked me how you do mocking in Clojure. The answer is, we usually don\'t. We usually see it as a sign we need to refactor our code.SourceThe sagas (as they got implemented in redux-saga) are declarative and like the Free monad or React components, they are much easier to test without any mock.See also this article:in modern FP, we shouldn\xe2\x80\x99t write programs \xe2\x80\x94 we should write descriptions of programs, which we can then introspect, transform, and interpret at will.(Actually, Redux-saga is like a hybrid: the flow is imperative but the effects are declarative)There is a lot of confusion in the frontend world on how some backend concepts like CQRS / EventSourcing and Flux / Redux may be related, mostly because in Flux we use the term "action" which can sometimes represent both imperative code (LOAD_USER) and events (USER_LOADED). I believe that like event-sourcing, you should only dispatch events.Imagine an app with a link to a user profile. The idiomatic way to handle this with both middlewares would be:This saga translates to:every time a username gets clicked, fetch the user profile and then dispatch an event with the loaded profile. As you can see, there are some advantages of redux-saga.The usage of takeLatest permits to express that you are only interested to get the data of the last username clicked (handle concurrency problems in case the user click very fast on a lot of usernames). This kind of stuff is hard with thunks. You could have used takeEvery if you don\'t want this behavior.You keep action creators pure. Note it\'s still useful to keep actionCreators (in sagas put and components dispatch), as it might help you to add action validation (assertions/flow/typescript) in the future.Your code becomes much more testable as the effects are declarativeYou don\'t need anymore to trigger rpc-like calls like actions.loadUser(). Your UI just needs to dispatch what HAS HAPPENED. We only fire events (always in the past tense!) and not actions anymore. This means that you can create decoupled "ducks" or Bounded Contexts and that the saga can act as the coupling point between these modular components.This means that your views are more easy to manage because they don\'t need anymore to contain that translation layer between what has happened and what should happen as an effect For example imagine an infinite scroll view. CONTAINER_SCROLLED can lead to NEXT_PAGE_LOADED, but is it really the responsibility of the scrollable container to decide whether or not we should load another page? Then he has to be aware of more complicated stuff like whether or not the last page was loaded successfully or if there is already a page that tries to load, or if there is no more items left to load? I don\'t think so: for maximum reusability the scrollable container should just describe that it has been scrolled. The loading of a page is a "business effect" of that scrollSome might argue that generators can inherently hide state outside of redux store with local variables, but if you start to orchestrate complex things inside thunks by starting timers etc you would have the same problem anyway. And there\'s a select effect that now permits to get some state from your Redux store.Sagas can be time-traveled and also enables complex flow logging and dev-tools that are currently being worked on. Here is some simple async flow logging that is already implemented:Sagas are not only replacing redux thunks. They come from backend / distributed systems / event-sourcing.It is a very common misconception that sagas are just here to replace your redux thunks with better testability. Actually this is just an implementation detail of redux-saga. Using declarative effects is better than thunks for testability, but the saga pattern can be implemented on top of imperative or declarative code.In the first place, the saga  is a piece of software that permits to coordinate long running transactions (eventual consistency), and transactions across different bounded contexts (domain driven design jargon).To simplify this for frontend world, imagine there is widget1 and widget2. When some button on widget1 is clicked, then it should have an effect on widget2. Instead of coupling the 2 widgets together (ie widget1 dispatch an action that targets widget2), widget1 only dispatch that its button was clicked. Then the saga listen for this button click and then update widget2 by dispaching a new event that widget2 is aware of.This adds a level of indirection that is unnecessary for simple apps, but make it more easy to scale complex applications. You can now publish widget1 and widget2 to different npm repositories so that they never have to know about each others, without having them to share a global registry of actions. The 2 widgets are now bounded contexts that can live separately. They do not need each others to be consistent and can be reused in other apps as well. The saga is the coupling point between the two widgets that coordinate them in a meaningful way for your business.Some nice articles on how to structure your Redux app, on which you can use Redux-saga for decoupling reasons:I want my components to be able to trigger the display of in-app notifications. But I don\'t want my components to be highly coupled to the notification system that has its own business rules (max 3 notifications displayed at the same time,  notification queueing, 4 seconds display-time etc...).I don\'t want my JSX components to decide when a notification will show/hide. I just give it the ability to request a notification, and leave the complex rules inside the saga. This kind of stuff is quite hard to implement with thunks or promises.I\'ve described here how this can be done with sagaThe term saga comes from the backend world. I initially introduced Yassine (the author of Redux-saga) to that term in a long discussion.Initially, that term was introduced with a paper, the saga pattern was supposed to be used to handle eventual consistency in distributed transactions, but its usage has been extended to a broader definition by backend developers so that it now also covers the "process manager" pattern (somehow the original saga pattern is a specialized form of process manager).Today, the term "saga" is confusing as it can describe 2 different things. As it is used in redux-saga, it does not describe a way to handle distributed transactions but rather a way to coordinate actions in your app. redux-saga could also have been called redux-process-manager. See also:If you don\'t like the idea of using generators but you are interested by the saga pattern and its decoupling properties, you can also achieve the same with redux-observable which uses the fancy name epic for the exact same pattern.The short answer: seems like a totally reasonable approach to the asynchrony problem to me. With a couple caveats.I had a very similar line of thought when working on a new project we just started at my job. I was a big fan of vanilla Redux\'s elegant system for updating the store and rerendering components in a way that stays out of the guts of a React component tree. It seemed weird to me to hook into that elegant dispatch mechanism to handle asynchrony.I ended up going with a really similar approach to what you have there in a library I factored out of our project, which we called react-redux-controller.I ended up not going with the exact approach you have above for a couple reasons:Take together, you have to rig up some system to allow dispatch and the store to be injected into your dispatching functions, along with the parameters of the event. I know of three reasonable approaches to this dependency injection:UpdateIt occurs to me that part of this conundrum is a limitation of react-redux. The first argument to connect gets a state snapshot, but not dispatch. The second argument gets dispatch but not the state. Neither argument gets a thunk that closes over the current state, for being able to see updated state at the time of a continuation/callback.To answer the question that is asked in the beginning:Why can\'t the container component call the async API, and then dispatch the actions?Keep in mind that those docs are for Redux, not Redux plus React. Redux stores hooked up to React components can do exactly what you say, but a Plain Jane Redux store with no middleware doesn\'t accept arguments to dispatch except plain ol\' objects.Without middleware you could of course still doBut it\'s a similar case where the asynchrony is wrapped around Redux rather than handled by Redux. So, middleware allows for asynchrony by modifying what can be passed directly to dispatch.That said, the spirit of your suggestion is, I think, valid. There are certainly other ways you could handle asynchrony in a Redux + React application.One benefit of using middleware is that you can continue to use action creators as normal without worrying about exactly how they\'re hooked up. For example, using redux-thunk, the code you wrote would look a lot likewhich doesn\'t look all that different from the original \xe2\x80\x94 it\'s just shuffled a bit \xe2\x80\x94 and connect doesn\'t know that updateThing is (or needs to be) asynchronous.If you also wanted to support promises, observables, sagas, or crazy custom and highly declarative action creators, then Redux can do it just by changing what you pass to dispatch (aka, what you return from action creators). No mucking with the React components (or connect calls) necessary.Abramov\'s goal - and everyone\'s ideally - is simply to encapsulate complexity and async in the place where it\'s most appropriate. Where\'s the best place to do that in the standard Redux dataflow? How about: