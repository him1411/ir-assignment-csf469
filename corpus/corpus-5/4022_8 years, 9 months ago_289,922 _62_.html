Is there any good example to give the difference between a struct and a union?\nBasically I know that struct uses all the memory of its member and union uses the largest members memory space. Is there any other OS level difference? With a union, you\'re only supposed to use one of the elements, because they\'re all stored at the same spot. This makes it useful when you want to store something that could be one of several types. A struct, on the other hand, has a separate memory location for each of its elements and they all can be used at once.To give a concrete example of their use, I was working on a Scheme interpreter a little while ago and I was essentially overlaying the Scheme data types onto the C data types. This involved storing in a struct an enum indicating the type of value and a union to store that value.edit: If you\'re wondering what setting x.b to \'c\' changes the value of x.a to, technically speaking it\'s undefined. On most modern machines a char is 1 byte and an int is 4 bytes, so giving x.b the value \'c\' also gives the first byte of x.a that same value:printsWhy are the two values the same? Because the last 3 bytes of the int 3 are all zero, so it\'s also read as 99. If we put in a larger number for x.a, you\'ll see that this is not always the case:printsTo get a closer look at the actual memory values, let\'s set and print out the values in hex:printsYou can clearly see where the 0x22 overwrote the 0xEF.BUTIn C, the order of bytes in an int are not defined. This program overwrote the 0xEF with 0x22 on my Mac, but there are other platforms where it would overwrite the 0xDE instead because the order of the bytes that make up the int were reversed. Therefore, when writing a program, you should never rely on the behavior of overwriting specific data in a union because it\'s not portable.For more reading on the ordering of bytes, check out endianness.Here\'s the short answer: a struct is a record structure: each element in the struct allocates new space.  So, a struct likeallocates at least (sizeof(int)+sizeof(long)+sizeof(double)+sizeof(long double)) bytes in memory for each instance.  ("At least" because architecture alignment constraints may force the compiler to pad the struct.)On the other hand,allocates one chunk of memory and gives it four aliases.  So sizeof(union foobarbazquux_u) \xe2\x89\xa5 max((sizeof(int),sizeof(long),sizeof(double),sizeof(long double)), again with the possibility of some addition for alignments.As you already state in your question, the main difference between union and struct is that union members overlay the memory of each other so that the sizeof of a union is the one , while struct members are laid out one after each other (with optional padding in between). Also an union is large enough to contain all its members, and have an alignment that fits all its members. So let\'s say int can only be stored at 2 byte addresses and is 2 bytes wide, and long can only be stored at 4 byte addresses and is 4 bytes long. The following unioncould have a sizeof of 4, and an alignment requirement of 4. Both an union and a struct can have padding at the end, but not at their beginning. Writing to a struct changes only the value of the member written to. Writing to a member of an union will render the value of all other members invalid. You cannot access them if you haven\'t written to them before, otherwise the behavior is undefined. GCC provides as an extension that you can actually read from members of an union, even though you haven\'t written to them most recently. For an Operation System, it doesn\'t have to matter whether a user program writes to an union or to a structure. This actually is only an issue of the compiler. Another important property of union and struct is, they allow that a pointer to them can point to types of any of its members. So the following is valid:some_test_pointer can point to int* or bool*. If you cast an address of type test to int*, it will point to its first member, a, actually. The same is true for an union too. Thus, because an union will always have the right alignment, you can use an union to make pointing to some type valid:That union will actually be able to point to an int, and a double:is actually valid, as stated by the C99 standard:An object shall have its stored value accessed only by an lvalue expression that has one of the following types:  The compiler won\'t optimize out the v->a = 10; as it could affect the value of *some_int_pointer (and the function will return 10 instead of 5).Is there any good example to give the difference between a \'struct\' and a \'union\'?An imaginary communications protocolIn this imaginary protocol, it has been sepecified that, based on the "message type", the following location in the header will either be a request number, or a four character code, but not both.  In short, unions allow for the same storage location to represent more than one data type, where it is guaranteed that you will only want to store one of the types of data at any one time.Unions are largely a low-level detail based in C\'s heritage as a system programming language, where "overlapping" storage locations are sometimes used in this way.  You can sometimes use unions to save memory where you have a data structure where only one of several types will be saved at one time. In general, the OS doesn\'t care or know about structs and unions -- they are both simply blocks of memory to it.  A struct is a block of memory that stores several data objects, where those objects don\'t overlap.  A union is a block of memory that stores several data objects, but has only storage for the largest of these, and thus can only store one of the data objects at any one time.A union is useful in a couple scenarios.\nunion can be a tool for very low level manipulation like writing device drivers for a kernel.An example of that is dissecting a float number by using union of a struct with bitfields and a float. I save a number in the float, and later I can access particular parts of the float through that struct. The example shows how union is used to have different angles to look at  data.Take a look at single precision description on wikipedia. I used the example and the magic number 0.15625 from there.union can also be used to implement an algebraic data type that has multiple alternatives. I found an example of that in the "Real World Haskell" book by  O\'Sullivan, Stewart, and Goerzen.\nCheck it out in the The discriminated union section.Cheers!Yes, the main difference between struct and union is same as you stated.\nStruct uses all the memory of its member and union uses the largest members memory space.But all the difference lies by the usage need of the memory.\nBest usage of the union can be seen in the processes of unix where we make use of signals.\nlike a process can act upon only one signal at a time.\nSo the general declaration will be:In this case, process make use of only the highest memory of all signals.\nbut if you use struct in this case, memory usage will be sum of all signals. \nMakes a lot of difference.To summarize, Union should be selected if you know that you access any one of the member at a time.Non technically speaking means :Assumption: chair = memory block , people = variableStructure : If there are 3 people they can sit in chair of their size correspondingly .  Union : If there are 3 people only one chair will be there to sit , all need to use the same chair when they want to sit .Technically speaking means :The below mentioned program gives a deep dive into structure and union together .Total  MAIN_STRUCT size =sizeof(UINT64) for bufferaddr + sizeof(UNIT32) for union + 32 bit for padding(depends on processor architecture) = 128 bits . \nFor structure all the members get the memory block contiguously .Union gets one memory block of  the max size member(Here its 32 bit) .\nInside union one more structure lies(INNER_STRUCT) its members get a memory block of total size  32 bits(16+8+8) . In union either INNER_STRUCT(32 bit) member or data(32 bit) can be accessed ."union" and "struct" are constructs of the C language. Talking of an "OS level" difference between them is inappropriate, since it\'s the compiler that produces different code if you use one or another keyword.A structure allocates the total size of all elements in it.A union only allocates as much memory as its largest member requires.You have it, that\'s all.\nBut so, basically, what\'s the point of unions?You can put in the same location content of different types. You have to know the type of what you have stored in the union (so often you put it in a struct with a type tag...).Why is this important? Not really for space gains. Yes, you can gain some bits or do some padding, but that\'s not the main point anymore.It\'s for type safety, it enables you to do some kind of \'dynamic typing\': the compiler knows that your content may have different meanings and the precise meaning of how your interpret it is up to you at run-time. If you have a pointer that can point to different types, you MUST use a union, otherwise you code may be incorrect due to aliasing problems (the compiler says to itself "oh, only this pointer can point to this type, so I can optimize out those accesses...", and bad things can happen).The uses of union\nUnions are used frequently when specialized type conversations are needed.\nTo get an idea of the usefulness of union. The c/c   standard library defines no function specifically designed to write short integers to a file. Using fwrite() incurs encurs excessive overhead for simple operation. However using a union you can easily create a function which writes binary of a short integer to a file one byte at a time. I assume that short integers are 2 byte longTHE EXAMPLE:although putw() i called with short integer, it was possble to use putc() and fwrite(). But i wanted to show an example to dominstrate how a union can be usedstructure is collection of different data type where different type of data can reside in it\nand every one get its own block of memory we usually used union when we sure that only one of the variable will be used at once and you want fully utilization of present memory because it get only one block of memory which is equal to the biggest type.total memory it get =>5 bytetotal memory it get =4 byteUnions come handy while writing a byte ordering function which is given below. It\'s not possible with structs.