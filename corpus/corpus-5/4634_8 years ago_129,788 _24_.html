Is the client supposed to behave differently? How?Status 301 means that the resource (page) is moved permanently to a new location. The client/browser should not attempt to request the original location but use the new location from now on.Status 302 means that the resource is temporarily located somewhere else, and the client/browser should continue requesting the original url.When a search engine spider finds 301 status code in the response header of a webpage, it understands that this webpage no longer exists, it searches for location header in response pick the new URL and replace the indexed URL with the new one and also transfer pagerank.So search engine refreshes all indexed URL that no longer exist (301 found) with the new URL, this will retain your old webpage traffic, pagerank and divert it to the new one (you will not lose you traffic of old webpage).Browser: if a browser finds 301 status code then it caches the mapping of the old URL with the new URL, the client/browser will not attempt to request the original location but use the new location from now on unless the cache is cleared.When a search engine spider finds 302 status for a webpage, it will only redirect temporarily to the new location and crawl both of the pages. The old webpage URL still exists in the search engine database and it always attempts to request the old location and crawl it. The client/browser will still attempt to request the original location.Read more about how to implement it in asp.net c# and what is the impact on search engines -\nhttp://www.dotnetbull.com/2013/08/301-permanent-vs-302-temporary-status-code-aspnet-csharp-Implementation.htmlMostly 301 vs 302 is important for indexing in search engines, as their crawlers take this into account and transfer PageRank when using 301.See Peter Lee\'s answer for more details.301 is that the requested resource has been assigned a new permanent URI and any\n   future references to this resource SHOULD be done using one of the\n   returned URIs. \n302 is that the requested resource resides temporarily under a different URI.\n   Since the redirection may be altered on occasion, the client SHOULD\n   continue to use the Request-URI for future requests. This response is\n   only cachable if indicated by a Cache-Control or Expires header\n   field.301 redirects are cached indefinitely (at least by some browsers).This means, if you set up a 301, visit that page, you not only get redirected, but that redirection gets cached.When you visit that page again, your Browser* doesn\'t even bother to request that URL, it just goes to the cached redirection target.The only way to undo a 301 for a visitor with that redirection in Cache, is re-redirecting back to the original URL**. In that case, the Browser will notice the loop, and finally really request the entered URL.Obviously, that\'s not an option if you decided to 301 to facebook or any other resource you\'re not fully under control.Unfortunately, many Hosting Providers offer a feature in their Admin Interface simply called "Redirection", which does a 301 redirect. If you\'re using this to temporarily redirect your domain to facebook as a coming soon page, you\'re basically screwed.*at least Chrome and Firefox, according to How long do browsers cache HTTP 301s?. Just tried it with Chrome 45.\nEdit: Safari 7.0.6 on Mac also caches, a browser restart didn\'t help (Link says that on Safari 5 on Windows it does help.)**I tried javascript window.location = \'\', because it would be the solution which could be applied in most cases - it doesn\'t work. It results in an undetected infinite Loop. However, php header(\'Location: new.url\') does break the loopBottom Line: only use 301s if you\'re absolutely sure you\'re never going to use that URL again. Usually never on the root dir (example.com/)The main issue with 301 is browser will cache the redirection even if you disabled the redirection from the server level.Its always better to use 302 if you are enabling the redirection for a short maintenance window.