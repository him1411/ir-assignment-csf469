How can I recursively count files in a Linux directory?I found this:But when I run this it returns the following error.find: paths must precede expression: \xc2\xa6This should work:Explanation:Notes: Explanation of why your example does not work:In the command you showed, you do not use the "Pipe" (|) to kind-of connect two commands, but the broken bar (\xc2\xa6) which the shell does not recognize as a command or something similar. That\'s why you get that error message.For the current directory:If you want a breakdown of how many files are in each dir under your current dir:That can go all on one line, of course.  The parenthesis clarify whose output wc -l is supposed to be watching (find $i -type f in this case).You can useafter installing the tree package with(on a Debian / Mint / Ubuntu Linux machine).The command shows not only the count of the files, but also the count of the directories, separately. The option -L can be used to specify the maximum display level (which, by default, is the maximum depth of the directory tree).Hidden files can be included too by supplying the -a option .On my computer, rsync is a little bit faster than find | wc -l in the accepted answer. For example you can count the files in /Users/joe/ like this:The second line has the number of files, 150,481 in the above example. As a bonus you get the total size as well (in bytes).Remarks:Combining several of the answers here together, the most useful solution seems to be:It can handle odd things like file names that include spaces parenthesis and even new lines. It also sorts the output by the number of files.You can increase the number after -maxdepth to get sub directories counted too. Keep in mind that this can potentially take a long time, particularly if you have a highly nested directory structure in combination with a high -maxdepth number.If you want to know how many files and sub-directories exist from the present working directory you can use this one-linerThis will work in GNU flavour, and just omit the -e from the echo command for BSD linux (e.g. OSX).If you want to avoid error cases, don\'t allow wc -l to see files with newlines (which it will count as 2+ files)e.g. Consider a case where we have a single file with a single EOL character in itSince at least gnu wc does not appear to have an option to read/count a null terminated list (except from a file), the easiest solution would just be to not pass it filenames, but a static output each time a file is found, e.g. in the same directory as aboveOr if your find supports itTo determine how many files there are in the current directory, put in ls -1 | wc -l. This uses wc to do a count of the number of lines (-l) in the output of ls -1. It doesn\'t count dotfiles. Please note that ls -l (that\'s an "L" rather than a "1" as in the previous examples) which I used in previous versions of this HOWTO will actually give you a file count one greater than the actual count. Thanks to Kam Nejad for this point.If you want to count only files and NOT include symbolic links (just an example of what else you could do), you could use ls -l | grep -v ^l | wc -l (that\'s an "L" not a "1" this time, we want a "long" listing here). grep checks for any line beginning with "l" (indicating a link), and discards that line (-v).Relative speed: "ls -1 /usr/bin/ | wc -l" takes about 1.03 seconds on an unloaded 486SX25 (/usr/bin/ on this machine has 355 files). "ls -l /usr/bin/ | grep -v ^l | wc -l" takes about 1.19 seconds.Source: http://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/x700.htmlYou could try :I would like to give a different approach with filtering for format. Example counts all available grub kernel modules: ls -l /boot/grub/*.mod | wc -lls -l | grep -e -x -e -dr | wc -l 1.long list \n2.filter files and dirs\n3.count the filtered line noThere are many correct answers here. Here\'s another!where . is the folder to look in and 10 is the number of characters by which to group the directory.I have written ffcnt to speed up recursive file counting under specific circumstances: rotational disks and filesystems that support extent mapping.It can be an order of magnitude faster than ls or find based approaches, but YMMV.With bash:Create an array of entries with ( ) and get the count with #.Ok that doesn\'t recursively count files but I wanted to show the simple option first. A common use case might be for creating rollover backups of a file. This will create logfile.1, logfile.2, logfile.3 etc.To get the count of files recursively we can still use find in the same way.