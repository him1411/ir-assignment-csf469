What exactly is the the difference between array_map, array_walk and array_filter. What I could see from documentation is that you could pass a callback function to perform an action on the supplied array. But I don\'t seem to find any particular difference between them.Do they perform the same thing?\nCan they be used interchangeably?I would appreciate your help with illustrative example if they are different at all.Example:Result:The idea of mapping an function to array of data comes from functional programming. You shouldn\'t think about array_map as a foreach loop that calls a function on each element of the array (even though that\'s how it\'s implemented). It should be thought of as applying the function to each element in the array independently.In theory such things as function mapping can be done in parallel since the function being applied to the data should ONLY affect the data and NOT the global state. This is because an array_map could choose any order in which to apply the function to the items in (even though in PHP it doesn\'t).array_walk on the other hand it the exact opposite approach to handling arrays of data. Instead of handling each item separately, it uses a state (&$userdata) and can edit the item in place (much like a foreach loop). Since each time an item has the $funcname applied to it, it could change the global state of the program and therefor requires a single correct way of processing the items.Back in PHP land, array_map and array_walk are almost identical except array_walk gives you more control over the iteration of data and is normally used to "change" the data in-place vs returning a new "changed" array.array_filter is really an application of array_walk (or array_reduce) and it more-or-less just provided for convenience.From the documentation,bool array_walk ( array &$array , callback $funcname [, mixed $userdata ] ) <-return boolarray_walk takes an array and a function F and modifies it by replacing every element x with F(x).  array array_map ( callback $callback ,\n  array $arr1 [, array $... ] )<-return arrayarray_map does the exact same thing except that instead of modifying in-place it will return a new array with the transformed elements. array array_filter ( array $input [,\n  callback $callback ] )<-return array array_filter with function F, instead of transforming the elements, will remove any elements for which F(x) is not trueThe other answers demonstrate the difference between array_walk (in-place modification) and array_map (return modified copy) quite well. However, they don\'t really mention array_reduce, which is an illuminating way to understand array_map and array_filter.The array_reduce function takes an array, a two-argument function and an \'accumulator\', like this:The array\'s elements are combined with the accumulator one at a time, using the given function. The result of the above call is the same as doing this:If you prefer to think in terms of loops, it\'s like doing the following (I\'ve actually used this as a fallback when array_reduce wasn\'t available):This looping version makes it clear why I\'ve called the third argument an \'accumulator\': we can use it to accumulate results through each iteration.So what does this have to do with array_map and array_filter? It turns out that they\'re both a particular kind of array_reduce. We can implement them like this:Ignore the fact that array_map and array_filter take their arguments in a different order; that\'s just another quirk of PHP. The important point is that the right-hand-side is identical except for the functions I\'ve called $MAP and $FILTER. So, what do they look like?As you can see, both functions take in the $accumulator and return it again. There are two differences in these functions:Note that this is far from useless trivia; we can use it to make our algorithms more efficient!We can often see code like these two examples:Using array_map and array_filter instead of loops makes these examples look quite nice. However, it can be very inefficient if $inputs is large, since the first call (map or filter) will traverse $inputs and build an intermediate array. This intermediate array is passed straight into the second call, which will traverse the whole thing again, then the intermediate array will need to be garbage collected.We can get rid of this intermediate array by exploiting the fact that array_map and array_filter are both examples of array_reduce. By combining them, we only have to traverse $inputs once in each example:NOTE: My implementations of array_map and array_filter above won\'t behave exactly like PHP\'s, since my array_map can only handle one array at a time and my array_filter won\'t use "empty" as its default $function. Also, neither will preserve keys.It\'s not difficult to make them behave like PHP\'s, but I felt that these complications would make the core idea harder to spot.The following revision seeks to more clearly delineate PHP\'s array_filer(), array_map(), and array_walk(), all of which originate from functional programming:  array_filter() filters out data, producing as a result a new array holding only the desired items of the former array, as follows:live code hereAll numeric values are filtered out of $array, leaving $filtered with only types of fruit.array_map() also creates a new array but unlike array_filter() the resulting  array contains every element of the input $filtered but with altered values, owing to applying a callback to each element, as follows:  live code hereThe code in this case applies a callback using the built-in strtoupper() but a user-defined function is another viable option, too.  The callback applies to every item of $filtered and thereby engenders $nu whose elements contain uppercase values.In the next snippet, array walk() traverses $nu and makes changes to each element vis a vis the reference operator \'&\'. The changes occur without creating an additional array. Every element\'s value changes in place into a more informative string specifying its key, category and value.See demoNote: the callback function with respect to array_walk() takes two parameters which will automatically acquire an element\'s value and its key and in that order, too when invoked by array_walk(). (See more here).