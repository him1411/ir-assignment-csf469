The glorified global variable - becomes a gloried global class. Some say breaking Object Oriented Design.Give me scenarios, other than the good old logger where it makes sense to use the singleton.On my quest for the truth I discovered that there are actually very few "acceptable" reasons to use a Singleton.One reason that tends to come up over and over again on the internets is that of a "logging" class (which you mentioned). In this case, a Singleton can be used instead of a single instance of a class because a logging class usually needs to be used over and over again ad nauseam by every class in a project. If every class uses this logging class, dependency injection becomes cumbersome.Logging is a specific example of an "acceptable" Singleton because it doesn\'t affect the execution of your code. Disable logging, code execution remains the same. Enable it, same same. Misko puts it in the following way in Root Cause of Singletons, "The information here flows one way: From your application into the logger. Even though loggers are global state, since no information flows from loggers into your application, loggers are acceptable."I\'m sure there are other valid reasons as well. Alex Miller, in "Patterns I Hate", talks of service locators and client side UI\'s also being possibly "acceptable" choices.Read more at Singleton I love you, but you\'re bringing me down.A Singleton candidate must satisfy three requirements:If your proposed Singleton has only one or two of these requirements, a redesign is almost always the correct option. For example, a printer spooler is unlikely to be called from more than one place (the Print menu), so you can use mutexes to solve the concurrent access problem.A simple logger is the most obvious example of a possibly-valid Singleton, but this can change with more complex logging schemes.Reading configuration files that should only be read at startup time and encapsulating them in a Singleton.You use a singleton when you need to manage a shared resource. For instance a printer  spooler. Your application should only have a single instance of the spooler in order to avoid conflicting request for the same resource.Or a database connection or a file manager etc.Read only singletons storing some global state (user language, help filepath, application path) are reasonable. Be carefull of using singletons to control business logic - single almost always ends up being multiple Managing a connection (or a pool of connections) to a database.I would use it also to retrieve and store informations on external configuration files.One of the ways you use a singleton is to cover an instance where there must be a single "broker" controlling access to a resource.  Singletons are good in loggers because they broker access to, say, a file, which can only be written to exclusively.  For something like logging, they provide a way of abstracting away the writes to something like a log file -- you could wrap a caching mechanism to your singleton, etc...Also think of a situation where you have an application with many windows/threads/etc, but which needs a single point of communication.  I once used one to control jobs that I wanted my application to launch.  The singleton was responsible for serializing the jobs and displaying their status to any other part of the program which was interested.  In this sort of scenario, you can look at a singleton as being sort of like a "server" class running inside your application... HTHA singleton should be used when managing access to a resource which  is shared by the entire application, and it would be destructive to potentially have multiple instances of the same class.  Making sure that access to shared resources thread safe is one very good example of where this kind of pattern can be vital.When using Singletons, you should make sure that you\'re not accidentally concealing dependencies.  Ideally, the singletons (like most static variables in an application) be set up during the execution of your initialization code for the application (static void Main() for C# executables, static void main() for java executables) and then passed in to all other classes that are instantiated which require it.  This helps you maintain testability.A practical example of a singleton can be found in Test::Builder, the class which backs just about every modern Perl testing module.  The Test::Builder singleton stores and brokers the state and history of the test process (historical test results, counts the number of tests run) as well as things like where the test output is going.  These are all necessary to coordinate multiple testing modules, written by different authors, to work together in a single test script.The history of Test::Builder\'s singleton is educational.  Calling new() always gives you the same object.  First, all the data was stored as class variables with nothing in the object itself.  This worked until I wanted to test Test::Builder with itself.  Then I needed two Test::Builder objects, one setup as a dummy, to capture and test its behavior and output, and one to be the real test object.  At that point Test::Builder was refactored into a real object.  The singleton object was stored as class data, and new() would always return it.  create() was added to make a fresh object and enable testing.Currently, users are wanting to change some behaviors of Test::Builder in their own module, but leave others alone, while the test history remains in common across all testing modules.  What\'s happening now is the monolithic Test::Builder object is being broken down into smaller pieces (history, output, format...) with a Test::Builder instance collecting them together.  Now Test::Builder no longer has to be a singleton.  Its components, like history, can be.  This pushes the inflexible necessity of a singleton down a level.  It gives more flexibility to the user to mix-and-match pieces.  The smaller singleton objects can now just store data, with their containing objects deciding how to use it.  It even allows a non-Test::Builder class to play along by using the Test::Builder history and output singletons.Seems to be there\'s a push and pull between coordination of data and flexibility of behavior which can be mitigated by putting the singleton around just shared data with the smallest amount of behavior as possible to ensure data integrity.As everyone has said, a shared resource - specifically something that cannot handle concurrent access.One specific example that I have seen, is a Lucene Search Index Writer.When you load a configuration Properties object, either from the database or a file, it helps to have it as a singleton; there\'s no reason to keep re-reading static data that won\'t change while the server is running.I think singleton use can be thought of the same as the many-to-one relationship in databases. If you have many different parts of your code that need to work with a single instance of an object, that is where it makes sense to use singletons.Shared resources. Especially in php. a database class, a template class, a global variable depot class. all has to be shared by all modules/classes that are being used throughout the code. Its a true object usage -> the template class contains the page template that is being built, and it gets shaped, added, changed by modules that are adding to page output. it has to be kept as a single instance so that this can happen. same goes for database. with a shared db singleton, all modules\' classes can get access to queries, get them without having to rerun them. a global variable depot singleton provides you a global, reliable and easily usable variable depot, tidying up your code a great lot. imagine having all config values in an array in a singleton like $gb->config[\'hostname\']. or, having all language values in an array like $gb->lang[\'ENTER_USER\']. in the end of running the code for the page, you get, say, a now mature $template singleton, a $gb singleton that has the lang array for replacing into it, all output loaded and ready. you just replace them into the keys that are now present in mature template object\'s page value, and then serve it out to user. the great advantage of this is, you can do ANY postprocessing you like on anything. you can pipe all language values to google translate, or another translate service and get them back, and replace them into their places, translated, for example. or, you can replace in page structures, or, content strings, as you want. It can be very pragmatic to configure specific infrastructure concerns as singletons or global variables. My favourite example of this is Dependency Injection frameworks that make use of singletons to act as a connection point to the framework.In this case you are taking a dependency on the infrastructure to simplify using the library and avoid unneeded complexity.You can use Singleton when implementing the State pattern (in the manner shown in the GoF book). This is because the concrete State classes have no state of their own, and perform their actions in terms of a context class.You can also make Abstract Factory a singleton.I use it for an object encapsulating command-line parameters when dealing with pluggable modules.  The main program doesn\'t know what the command-line parameters are for modules that get loaded (and doesn\'t always even know what modules are being loaded).  e.g., main loads A, which doesn\'t need any parameters itself (so why it should take an extra pointer / reference / whatever, I\'m not sure - looks like pollution), then loads modules X, Y, and Z.  Two of these, say X and Z, need (or accept) parameters, so they call back to the command-line singleton to tell it what parameters to accept, and the at runtime they call back to find out if the user actually has specified any of them.In many ways, a singleton for handling CGI parameters would work similarly if you\'re only using one process per query (other mod_* methods don\'t do this, so it\'d be bad there - thus the argument that says you shouldn\'t use singletons in the mod_cgi world in case you port to the mod_perl or whatever world).An example with code, perhaps.Here, the ConcreteRegistry is a singleton in a poker game that allows the behaviours all the way up the package tree access the few, core interfaces of the game (i.e., the facades for the model, view, controller, environment, etc.):http://www.edmundkirwan.com/servlet/fractal/cs1/frac-cs40.htmlEd.1 - A comment on the first answer:I don\'t agree with a static Logger class. this can be practical for an implementation, but it cannot be replaceable for unit testing. A static class cannot be replaced by a test double. If you don\'t unit test, you won\'t don\'t see the problem here.2 - I try not to create a singleton by hand. I just create a simple object with constructors that allow me to inject collaborators into the object. If I needed a singleton, I\'d use a dependency inyection framework (Spring.NET, Unity for .NET, Spring for Java), or some other.