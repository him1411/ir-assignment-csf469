What does the expression "Turing Complete" mean? Can you give a simple explanation, without going into too many theoretical details?Here\'s the briefest explanation:A Turing Complete system means a system in which a program can be written that will find an answer (although with no guarantees regarding runtime or memory).So, if somebody says "my new thing is Turing Complete" that means in principle (although often not in practice) it could be used to solve any computation problem.Sometime\'s it\'s a joke... a guy wrote a Turing Machine simulator in vi, so it\'s possible to say that vi is the only computational engine ever needed in the world.From wikipedia:Turing completeness, named after Alan\n  Turing, is significant in that every\n  plausible design for a computing\n  device so far advanced can be emulated\n  by a universal Turing machine \xe2\x80\x94 an\n  observation that has become known as\n  the Church-Turing thesis. Thus, a\n  machine that can act as a universal\n  Turing machine can, in principle,\n  perform any calculation that any other\n  programmable computer is capable of.\n  However, this has nothing to do with\n  the effort required to write a program\n  for the machine, the time it may take\n  for the machine to perform the\n  calculation, or any abilities the\n  machine may possess that are unrelated\n  to computation.While truly Turing-complete machines\n  are very likely physically impossible,\n  as they require unlimited storage,\n  Turing completeness is often loosely\n  attributed to physical machines or\n  programming languages that would be\n  universal if they had unlimited\n  storage. All modern computers are\n  Turing-complete in this sense.I don\'t know how you can be more non-technical than that except by saying "turing complete means \'able to answer computable problem given enough time and space\'".Here is the simplest explanationAlan Turing created a machine that can take a program and run that program and show some result. But then he had to create different machines for different programs. So he created "Universal Turing Machine" that can take ANY program and run it. Programming languages are similar to those machines (although virtual). They take programs and run them. Now, a programing language is called "Turing complete", if that it can run any program(irrespective of the language) that a Turing machine can run given enough time and memory. For example: Let\'s say there is a program that takes 10 numbers and adds them. Turing machine can easily run this program. But now imagine for some reason your programming language can\'t do the same addition then it\'s Turing machine incomplete. On the other hand, if it can run any program like the universal turing machine can run, then it\'s Turing complete.Most modern programming languages like Java, JavaScript, Perl etc are all turing complete because they all implement all the features required to run programs like addition, multiplication, if-else condition, return statements, ways to store/retrieve/erase data and so on.Update: You can learn more on my blog post: "JavaScript Is Turing Complete"\xe2\x80\x8a\xe2\x80\x94\xe2\x80\x8aExplainedIts often used to define "real" programming languages, where you can express any computation. Examining some languages that can\'t express all computations can help:wikipedia on non-turing-complete languagesFundamentally, Turing-completeness is one concise requirement, unbounded recursion.Not even bounded by memory.I thought of this independently, but here is some discussion of the assertion. My definition of LSP provides more context.The other answers here don\'t directly define the fundamental essence of Turing-completeness.Turing Complete means that it is at least as powerful as a Turing Machine. This means anything that can be computed by a Turing Machine can be computed by a Turing Complete system.No one has yet found a system more powerful than a Turing Machine. So, for the time being, saying a system is Turing Complete is the same as saying the system is as powerful as any known computing system (see Church-Turing Thesis).In the simplest terms, a Turing-complete system can solve any possible computational problem.One of the key requirements is the scratchpad size be unbounded and that is possible to rewind to access prior writes to the scratchpad.Thus in practice no system is Turing-complete.Rather some systems approximate Turing-completeness by modeling unbounded memory and performing any possible computation that can fit within the system\'s memory.I think the importance of the concept "Turing Complete" is in the the ability to identify a computing machine (not necessarily a mechanical/electrical "computer") that can have its processes be deconstructed into "simple" instructions, composed of simpler and simpler instructions, that a Universal machine could interpret and then execute.I highly recommend The Annotated Turing@Mark i think what you are explaining is a mix between the description of the Universal Turing Machine and Turing Complete.Something that is Turing Complete, in a practical sense, would be a machine/process/computation able to be written and represented as a program, to be executed by a Universal Machine (a desktop computer).  Though it doesn\'t take consideration for time or storage, as mentioned by others.As Waylon Flinn said:Turing Complete means that it is at least as powerful as a Turing Machine.I believe this is incorrect, a system is Turing complete if it\'s exactly as powerful as the Turing Machine, i.e. every computation done by the machine can be done by the system, but also every computation done by the system can be done by the Turing machine.In practical language terms familiar to most programmers, the usual way to detect Turing completeness is if the language allows or allows the simulation of nested unbounded while statements (as opposed to Pascal-style for statements, with fixed upper bounds).Can a relational database input latitudes and longitudes of places and roads, and compute the shortest path between them - no.  This is one problem that shows SQL is not Turing complete.But C++ can do it, and can do any problem.  Thus it is.