Is it possible to have an event that fires when the value of a certain variable changes?\nThanks!Yes, object.watch (it\'s non-standard though). Here\'s my implementation that works in every current major browser.No.But, if it\'s really that important, you have 2 options (first is tested, second isn\'t):First, use setters and getters, like so:then you can do something like:then set the listener like:Second, I actually forgot, I\'ll submit while I think about it :)EDIT: Oh, I remember :) You could put a watch on the value:Given myobj above, with \'a\' on it:Sorry to bring up an old thread, but here is a little manual for those who (like me!) don\'t see how Eli Grey\'s example works:Hope this can help someoneYes, this is now completely possible!I know this is an old thread but now this effect is possible using accessors (getters and setters): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_settersYou can define an object like this, in which aInternal represents the field a:Then you can register a listener using the following:So whenever anything changes the value of x.a, the listener function will be fired. Running the following line will bring the alert popup:See an example here: https://jsfiddle.net/5o1wf1bn/1/You can also user an array of listeners instead of a single listener slot, but I wanted to give you the simplest possible example.Using Prototype: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/definePropertyAs Luke Schafer\'s answer (note: this refers to his original post; but the whole point here remains valid after the edit), I would also suggest a pair of Get/Set methods to access your value.However I would suggest some modifications (and that\'s why I\'m posting...).A problem with that code is that the field a of the object myobj is directly accessible, so it\'s possible to access it / change its value without triggering the listeners:So, to guarantee that the listeners are actually called, we would have to prohibit that direct access to the field a. How to do so? Use a closure!Now you can use the same method to create and add the listeners as Luke proposed, but you can rest assured that there\'s no possible way to read from or write to a going unnoticed!Still on Luke\'s track, I propose now a simple way to add encapsulated fields and the respective getters/setters to objects by the means of a simple function call.Note that this will only work properly with value types. For this to work with reference types, some kind of deep copy would have to be implemented (see this one, for instance).This works the same as before: we create a local variable on a function, and then we create a closure.How to use it? Simple:AngularJS (I know this is not JQuery, but that might help. [Pure JS is good in theory only]):where "data" is name of your variable in the scope.There is a link to doc.If you\'re using jQuery {UI} (which everyone should be using :-) ), you can use .change() with a hidden <input/> element.For those tuning in a couple years later:A solution for most browsers (and IE6+) is available that uses the onpropertychange event and the newer spec defineProperty.  The slight catch is that you\'ll need to make your variable a dom object.Full details:http://johndyer.name/native-browser-get-set-properties-in-javascript/Not directly: you need a pair getter/setter with an "addListener/removeListener" interface of some sort... or an NPAPI plugin (but that\'s another story altogether).The functionality you\'re looking for can be achieved through the use of the "defineProperty()" method--which is only available to modern browsers:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/definePropertyI\'ve written a jQuery extension that has some similar functionality if you need more cross browser support:https://github.com/jarederaj/jQueueA small jQuery extension that handles queuing callbacks to the\n  existence of a variable, object, or key. You can assign any number of\n  callbacks to any number of data points that might be affected by\n  processes running in the background. jQueue listens and waits for\n  these data you specify to come into existence and then fires off the\n  correct callback with its arguments.ororA rather simple and simplistic solution is to just use a function call to set the value of the global variable, and never set its value directly.  This way you have total control:There is no way to enforce this, it just requires programming discipline... though you can use grep (or something similar) to check that nowhere does your code directly set the value of globalVar.Or you could encapsulate it in an object and user getter and setter methods... just a thought.Yet again, I am fashionably late to this party. I know this is not pure JavaScript or jQuery; however, I\'ve have been toying with a project in knockout.js, and have found the subscribe() method works great for firing an event (or notifying) when the value of something changes. Here is a simple example:Granted, subscribe() works on knockout\'s "observables" not on regular variables. Here is a link to the knockout documentation page covering observables and subscriptions, for anyone interested: http://knockoutjs.com/documentation/observables.html