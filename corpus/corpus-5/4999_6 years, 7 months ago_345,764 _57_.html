If I have a function which accepts more than one string parameter, the first parameter seems to get all the data assigned to it, and remaining parameters are passed in as empty.A quick test script:The output generated is The correct output should be:This seems to be consistent between v1 and v2 on multiple machines, so obviously, I\'m doing something wrong. Can anyone point out exactly what?Parameters in calls to functions in PowerShell (all versions) are space-separated, not comma separated. Also, the parentheses are entirely unneccessary and will cause a parse error in powershell 2.0 (or later) if Set-StrictMode is active. Parenthesised arguments are used in .NET methods only.The correct answer has already been provided but this issue seems prevalent enough to warrant some additional details for those wanting to understand the subtleties. I would have added this just as a comment but I wanted to include an illustration--I tore this off my quick reference chart on PowerShell functions. This assumes function f\'s signature is f($a, $b, $c):Thus, one can call a function with space-separated positional parameters or order-independent named parameters. The other pitfalls reveal that you need to be cognizant of commas, parentheses, and white space.For further reading see my article Down the Rabbit Hole: A Study in PowerShell Pipelines, Functions, and Parameters just published on Simple-Talk.com. The article contains a link to the quick reference/wall chart as well.You call PowerShell functions without the parenthesis and without using the comma as a separator. Try using:In PowerShell the comma (,) is an array operator, e.g.It sets $a to an array with three values.If you\'re a C# / Java / C++ / Ruby / Python / Pick-A-Language-From-This-Century developer and you want to call your function with commas, because that\'s what you\'ve always done, then you need something like this:Now call:and you\'ll seeIf you try:you get: If you try:you get:Now you could find some immediate usefulness of the parenthesis - a space will not become a separator for the next parameter - instead you have an eval function.Some good answers here, but I wanted to point out a couple other things.  Function parameters are actually a place where Powershell shines.  For example, you can have either named or positional parameters in advanced functions like so:Then you could either call it by specifying the parameter name, or you could just use positional parameters, since you explicitly defined them.  So either of these would work:The first example works even though Name is provided second, because we explicitly used the parameter name.  The second example works based on position though, so Name would need to be first. When possible, I always try to define positions so both options are available.Powershell also has the ability to define parameter sets.  It uses this in place of method overloading, and again is quite useful:Now the function will either take a name, or an id, but not both.  You can use them positionally, or by name.  Since they are a different type, Powershell will figure it out.  So all of these would workYou can also assign additional parameters to the various parameter sets. (That was a pretty basic example obviously)  Inside of the function, you can determine which parameter set was used with the $PsCmdlet.ParameterSetName property. For example:Then, on a related side note, there is also parameter validation in Powershell.  This is one of my favorite Powershell features, and it makes the code inside your functions very clean. There are numerous validations you can use.  A couple examples are In the first example, ValidatePattern accepts a regular expression that assures the supplied parameter matches what you\'re expecting.  If it doesn\'t, an intuitive exception is thrown, telling you exactly what is wrong.  So in that example, \'Something\' would work fine, but \'Summer\' wouldn\'t pass validation.  ValidateRange ensures that the parameter value is in between the range you expect for an integer.  So 10 or 99 would work, but 101 would throw an exception. Another useful one is ValidateSet, which allows you to explicitly define an array of acceptable values.  If something else is entered, an exception will be thrown.  There are others as well, but probably the most useful one is ValidateScript.  This takes a script block that must evaluate to $true, so the sky is the limit.  For example:In this example, we are assured not only that $Path exists, but that it is a file, (as opposed to a directory) and has a .csv extension. ($_ refers to the parameter, when inside your scriptblock.) You can also pass in much larger, multi-line script blocks if that level is required, or use multiple scriptblocks like I did here.  It\'s extremely useful, and makes for nice clean functions and intuitive exceptions. I don\'t know what you\'re doing with the function, but have a look at using the \'param\' keyword. It\'s quite a bit more powerful for passing parameters into a function, and makes it more user friendly. Below is a link to an overly complex article from Microsoft about it. It isn\'t as complicated as the article makes it sound. \nParam UsageAlso, here is an example from a thread on this site:Check it out.I states the following earlier:The common problem is using the singular form $arg, which is incorrect.\nIt should always be plural as $args.The problem is not that.\nIn fact, $arg can be anything else. The problem was the use of the comma and the parantheses.\nI run the following code that worked and the output follows:Code:Test "ABC" "DEF" Output:$var1 value: ABC\n$var2 value: DEFYou can pass parameters in function like this also.If you don\'t know (or care) how many arguments you will be passing to the function, you could also use a very simple approach like;Code:That would print out all arguments. For example:OutputI find this particularly useful when creating functions that use external commands that could have many different (and optional) parameters, but relies on said command to provide feedback on syntax errors etc.Here is a another real-world example (creating a function to the tracert command, which I hate having to remember the truncated name);Code:This is proper params declaration\nhttps://technet.microsoft.com/en-us/library/dd347600.aspxAnd it indeed worksBecause this is a frequent viewed question I want to mention that a PowerShell function should use approved verbs (Verb-Noun as the function name). Also you can specify things like whether the parameter is mandatory and the position of the parameter:To pass the parameter to the function you can either use the position:Or you specify the parameter name:You don\'t use parentheses like you do when you call a function within C#.I would recommend to always pass the parameter names when using more then one parameter, since this is more readable.