I want to initialize a struct element, split in declaration and initialization. This is what I have:Is this the way to declare and initialize a local variable of MY_TYPE in accordance with C programming language standards (C89, C90, C99, C11, etc.)? Or is there anything better or at least working?Update I ended up having a static initialization element where I set every subelement according to my needs.In (ANSI) C99, you can use a designated initializer to initialize a structure: Edit: Other members are initialized as zero: "Omitted field members are implicitly initialized the same as objects that have static storage duration." (https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html)You can do it with a compound literal. According to that page, it works in C99 (which also counts as ANSI C).The designations in the initializers are optional; you could also write:I see you\'ve already received an answer about ANSI C 99, so I\'ll throw a bone about ANSI C 89.\nANSI C 89 allows you to initialize a struct this way:An important thing to remember, at the moment you initialize even one object/ variable in the struct, all of its other variables will be initialized to default value.If you don\'t initialize the values in your struct, all variables will contain "garbage values".Good luck!a = (MYTYPE){ true, 15, 0.123 };would do fine in C99You\'ve almost got it...Quick search on \'struct initialize c\' shows me thisas Ron Nuni said:An important thing to remember: at the moment you initialize even one object/variable in the struct, all of its other variables will be initialized to default value.If you don\'t initialize the values in your struct (i.e. if you just declare that variable), all variable.members will contain "garbage values", only if the declaration is local!If the declaration is global or static (like in this case), all uninitialized variable.members will be initialized automatically to:C programming language standard ISO/IEC 9899:1999 (commonly known as C99) allows one to use a designated initializer to initialize members of a structure or union as follows:It is defined in paragraph 7, section 6.7.8 Initialization of ISO/IEC 9899:1999 standard as:If a designator has the form\n  . identifier\n  then the current object (defined below) shall have structure or union type and the identifier shall be the name of a member of that type.Note that paragraph 9 of the same section states that:Except where explicitly stated otherwise, for the purposes of this subclause unnamed members of objects of structure and union type do not participate in initialization. Unnamed members of structure objects have indeterminate value even after initialization.In GNU GCC implementation however omitted members are initialized as zero or zero-like type-appropriate value. As stated in section 6.27 Designated Initializers of GNU GCC documentation:Omitted field members are implicitly initialized the same as objects that have static storage duration.Microsoft Visual C++ compiler should support designated initializers since version 2013 according to official blog post C++ Conformance Roadmap. Paragraph Initializing unions and structs of Initializers  article at MSDN Visual Studio documentation suggests that unnamed members initialized to zero-like appropriate values similarly to GNU GCC.New ISO/IEC 9899:2011 standard (commonly known as C11) which had superseded ISO/IEC 9899:1999 retains designated initializers under section 6.7.9 Initialization. It also retains paragraph 9 unchanged.If MS has not updated to C99, MY_TYPE a = { true,15,0.123 };I found another way to initialize structs.The struct:Initialization:As per GCC\xe2\x80\x99s documentation, this syntax is obsolete since GCC 2.5.I didn\'t like any of these answers so I made my own.  I don\'t know if this is ANSI C or not, it\'s just GCC 4.2.1 in it\'s default mode.  I never can remember the bracketing so I start with a subset of my data and do battle with compiler error messages until it shuts up.  Readability is my first priority.The data may start life as a tab-delimited file that you search-replace to massage into something else.  Yes, this is Debian stuff.  So one outside pair of {} (indicating the array), then another pair for each struct inside.  With commas between.  Putting things in a header isn\'t strictly necessary, but I\'ve got about 50 items in my struct so I want them in a separate file, both to keep the mess out of my code and so it\'s easier to replace.Structure in C can be declared and initialized like this: