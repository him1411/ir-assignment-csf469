I need to read [100]byte to transfer a bunch of string data.Because not all the string is precisely 100 long, the remaining part of the byte array are padded with 0s. If I tansfer [100]byte to string by: string(byteArray[:]), the tailing 0s are displayed as ^@^@s.In C the string will terminate upon 0, so I wonder what\'s the best way of smartly transfer byte array to string.methods that read data into byte slices return the number of bytes read.  You should save that number and then use it to create your string.  n being the number of bytes read, your code would look like this:If for some reason you don\'t have n, you could use the bytes package to find it, assuming your input doesn\'t have a null character in it.Or as icza pointed out, you can use the code below:What about?Simplistic solution:I\'m not sure how performant this is though.For example,Output:The following code is looking for \'\\0\', and under the assumptions of the question the array can be considered sorted since all non-\'\\0\' precede all \'\\0\'. This assumption won\'t hold if the array can contain \'\\0\' within the data.Find the location of the first zero-byte using a binary search, then slice.You can find the zero-byte like this:It may be faster just to naively scan the byte array looking for the zero-byte, especially if most of your strings are short.Use slices instead of arrays for reading. e.g. io.Reader accepts a slice, not an array.Use slicing instead of zero padding.Example:Why not this?I when with a recursive solution.