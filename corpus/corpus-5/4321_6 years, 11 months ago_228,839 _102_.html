In PHP, you can do...That is, there is a function that lets you get a range of numbers or characters by passing the upper and lower bounds.Is there anything built-in to JavaScript natively for this? If not, how would I implement it?lodash.js _.range() functionOr without a library: ES6 version and character iteration(ES6 credit to nils petersohn and other commenters)For numbers you can use ES6 Array.from(), which works in everything these days except IE:which creates an array from 0 to 19 inclusive. This can be further shortened to one of these forms:Lower and upper bounds can be specified too, for example: An article describing this in more detail: http://www.2ality.com/2014/05/es6-array-methods.htmlHere\'s my 2 cents:It works for characters and numbers, going forwards or backwards with an optional step.jsFiddle.If augmenting native types is your thing, then assign it to Array.range.simple range function:Handy function to do the trick, run the code snippet belowhere is how to use itrange (Start, End, Step=1, Offset=0);hope you find it useful.And here is how it works.Basically I\'m first calculating the length of the resulting array and create a zero filled array to that length, then fill it with the needed valuesThe standard Javascript doesn\'t have a built-in function to generate ranges.  Several javascript frameworks add support for such features, including Prototype.js.If you\'d like to double-check, the definitive resource is the ECMA-262 Standard.Using Harmony spread operator and arrow functions:Example:Did some research on some various Range Functions.\nCheckout the jsperf comparison of the different ways to do these functions. Certainly not a perfect or exhaustive list, but should help :)The Winner is...Technically its not the fastest on firefox, but crazy speed difference (imho) on chrome makes up for it.Also interesting observation is how much faster chrome is with these array functions than firefox. Chrome is at least 4 or 5 times faster.An interesting challenge would be to write the shortest function to do this.  Recursion to the rescue!Tends to be slow on large ranges, but luckily quantum computers are just around the corner.An added bonus is that it\'s obfuscatory.  Because we all know how important it is to hide our code from prying eyes.To truly and utterly obfuscate the function, do this:I would code something like this:It behaves similarly to Python range:A rather minimalistic implementation that heavily employs ES6 can be created as follows, drawing particular attention to the Array.from() static method:OK, in JavaScript we don\'t have range() function like PHP, so we need to create the function which is quite easy, I write couple of one-liner functions for you and separate them for Numbers and Alphabets:for Numbers:and call it like:for Alphabets:and call it like:Though this is not from PHP, but an imitation of range from Python.My new favorite form (ES2015)You can use lodash or Undescore.js range:Alternatively, if you only need a consecutive range of integers you can do something like:In ES6 range can be implemented with generators:This implementation saves memory when iterating large sequences, because it doesn\'t have to materialize all values into an array:Using Harmony generators, supported by all browsers except IE11:takeExample 1.take only takes as much as it can gettake(10, range( {from: 100, step: 5, to: 120} ) ) returns [100, 105, 110, 115, 120]Example 2.to not neccesarytake(10, range( {from: 100, step: 5} ) )returns[100, 105, 110, 115, 120, 125, 130, 135, 140, 145]takeAllExample 3.from not neccesarytakeAll( range( {to: 5} ) )returns[0, 1, 2, 3, 4, 5]Example 4.takeAll( range( {to: 500, step: 100} ) )returns[0, 100, 200, 300, 400, 500]Example 5.takeAll( range( {from: \'z\', to: \'a\'} ) )returns ["z", "y", "x", "w", "v", "u", "t", "s", "r", "q", "p", "o", "n", "m", "l", "k", "j", "i", "h", "g", "f", "e", "d", "c", "b", "a"]you can use lodash function _.range(10) https://lodash.com/docs#rangeAs far as generating a numeric array for a given range, I use this:  Obviously, it won\'t work for alphabetical arrays.d3 also has a built-in range function.  See https://github.com/mbostock/d3/wiki/Arrays#d3_range:Generates an array containing an arithmetic progression, similar to the Python built-in range. This method is often used to iterate over a sequence of numeric or integer values, such as the indexes into an array. Unlike the Python version, the arguments are not required to be integers, though the results are more predictable if they are due to floating point precision. If step is omitted, it defaults to 1. Example:Another version using ES6 generators ( see great Paolo Moretti answer with ES6 generators ):Or, if we only need iterable, then:I was surprised to come across this thread and see nothing like my solution (maybe I missed an answer), so here it is.\nI use a simple range function in ES6 syntax :But it works only when counting forward (ie. begin < end), so we can modify it slightly when needed like so : Here\'s a nice short way to do it in ES6 with numbers only (don\'t know its speed compares):For a range of single characters, you can slightly modify it:Complete ES6 implementation using range([start, ]stop[, step]) signature:If you want automatic negative stepping, addOr more minimalistically:If you have huge ranges look at Paolo Moretti\'s generator approachI found a JS range function equivalent to the one in PHP, and works amazingly great here. Works forward & backward, and works with integers, floats and alphabets!And here is the minified version:For a more ruby-like approach with good backward compatibility:range([begin], end = 0) where begin and end are numbersExamples:Here is my solution that mimics Python. At the bottom you can find some examples how to use it. It works with numbers, just like Python\'s range:Examples:Coded to 2010 specs (ya, it is 2016 with ES6 generators). Here\'s my take, with options to emulate the Python\'s range() function. Example: