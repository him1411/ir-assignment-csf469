The git clone help page has this to say about --mirror:Set up a mirror of the remote repository. This implies --bare.But doesn\'t go into detail about how the --mirror clone is different from a --bare clone.The difference is that when using --mirror, all refs are copied as-is. This means everything: remote-tracking branches, notes, refs/originals/* (backups from filter-branch). The cloned repo has it all. It\'s also set up so that a remote update will re-fetch everything from the origin (overwriting the copied refs). The idea is really to mirror the repository, to have a total copy, so that you could for example host your central repo in multiple places, or back it up. Think of just straight-up copying the repo, except in a much more elegant git way.The new documentation pretty much says all this:--mirrorSet up a mirror of the source repository.  This implies --bare. Compared to --bare, --mirror not only maps local branches of the source to local branches of the target, it maps all refs (including remote branches, notes etc.) and sets up a refspec configuration such that all these refs are overwritten by a git remote update in the target repository.My original answer also noted the differences between a bare clone and a normal (non-bare) clone - the non-bare clone sets up remote tracking branches, only creating a local branch for HEAD, while the bare clone copies the branches directly.Suppose origin has a few branches (master (HEAD), next, pu, and maint), some tags (v1, v2, v3), some remote branches (devA/master, devB/master), and some other refs (refs/foo/bar, refs/foo/baz, which might be notes, stashes, other devs\' namespaces, who knows). git clone origin-url (non-bare): you will get all of the tags copied, a local branch master (HEAD) tracking a remote branch origin/master, and remote branches origin/next, origin/pu, and origin/maint. The tracking branches are set up so that if you do something like git fetch origin, they\'ll be fetched as you expect. Any remote branches (in the cloned remote) and other refs are completely ignored.git clone --bare origin-url: you will get all of the tags copied, local branches master (HEAD), next, pu, and maint, no remote tracking branches. That is, all branches are copied as is, and it\'s set up completely independent, with no expectation of fetching again. Any remote branches (in the cloned remote) and other refs are completely ignored.git clone --mirror origin-url: every last one of those refs will be copied as-is. You\'ll get all the tags, local branches master (HEAD), next, pu, and maint, remote branches devA/master and devB/master, other refs refs/foo/bar and refs/foo/baz. Everything is exactly as it was in the cloned remote. Remote tracking is set up so that if you run git remote update all refs will be overwritten from origin, as if you\'d just deleted the mirror and recloned it. As the docs originally said, it\'s a mirror. It\'s supposed to be a functionally identical copy, interchangeable with the original.is a short-hand for(Copied directly from here)How the current man-page puts it:Compared to --bare, --mirror not only maps local branches of the source to local branches of the target, it maps all refs (including remote branches, notes etc.) and sets up a refspec configuration such that all these refs are overwritten by a git remote update in the target repository.My tests with git-2.0.0 today indicate that the --mirror option does not copy hooks, the config file, the description file, the info/exclude file, and at least in my test case a few refs (which I don\'t understand.) I would not call it a "functionally identical copy, interchangeable with the original."A clone copies the refs from the remote and stuffs them into a subdirectory named \'these are the refs that the remote has\'.A mirror copies the refs from the remote and puts them into its own top level - it replaces its own refs with those of the remote.This means that when someone pulls from your mirror and stuffs the mirror\'s refs into thier subdirectory, they will get the same refs as were on the original. The result of fetching from an up-to-date mirror is the same as fetching directly from the initial repo.A nuanced explanation from the GitHub documentation on Duplicating a Repository:As with a bare clone, a mirrored clone includes all remote branches and tags, but all local references will be overwritten each time you fetch, so it will always be the same as the original repository.I add a picture, show configdifference between mirror and bare.\n\nThe left is bare, right is mirror. You can be clear, mirror\'s config file have fetch key, which means you can update it,by git remote update or git fetch --all