In C#, int and Int32 are the same thing, but I\'ve read a number of times that int is preferred over Int32 with no reason given. Is there a reason, and should I care?ECMA-334:2006 C# Language Specification (p18):Each of the predefined types is shorthand for a system-provided type. For example, the keyword int refers to the struct System.Int32. As a matter of style, use of the keyword is favoured over use of the complete system type name.The two are indeed synonymous; int will be a little more familiar looking, Int32 makes the 32-bitness more explicit to those reading your code. I would be inclined to use int where I just need \'an integer\', Int32 where the size is important (cryptographic code, structures) so future maintainers will know it\'s safe to enlarge an int if appropriate, but should take care changing Int32s in the same way.The resulting code will be identical: the difference is purely one of readability or code appearance.They both declare 32 bit integers, and as other posters stated, which one you use is mostly a matter of syntactic style.  However they don\'t always behave the same way.  For instance, the C# compiler won\'t allow this:but it will allow this:Go figure.I always use the system types - e.g., Int32 instead of int. I adopted this practice after reading Applied .NET Framework Programming - author Jeffrey Richter makes a good case for using the full type names.  Here are the two points that stuck with me:Type names can vary between .NET languages. For example, in C#, long maps to System.Int64 while in C++ with managed extensions, long maps to Int32. Since languages can be mixed-and-matched while using .NET, you can be sure that using the explicit class name will always be clearer, no matter the reader\'s preferred language.Many framework methods have type names as part of their method names:BinaryReader br = new BinaryReader( /* ... */ );float val = br.ReadSingle();     // OK, but it looks a little odd...Single val = br.ReadSingle();    // OK, and is easier to readint is a C# keyword and is unambiguous.  Most of the time it doesn\'t matter but two things that go against Int32:As already stated, int = Int32.  To be safe, be sure to always use int.MinValue/int.MaxValue when implementing anything that cares about the data type boundaries.  Suppose .NET decided that int would now be Int64, your code would be less dependent on the bounds.There is no difference between int and Int32, but as int is a language keyword many people prefer it stylistically (just as with string vs String).Byte size for types is not too interesting when you only have to deal with a single language (and for code which you don\'t have to remind yourself about math overflows). The part that becomes interesting is when you bridge between one language to another, C# to COM object, etc., or you\'re doing some bit-shifting or masking and you need to remind yourself (and your code-review co-wokers) of the size of the data.In practice, I usually use Int32 just to remind myself what size they are because I do write managed C++ (to bridge to C# for example) as well as unmanaged/native C++.Long as you probably know, in C# is 64-bits, but in native C++, it ends up as 32-bits, or char is unicode/16-bits while in C++ it is 8-bits. But how do we know this? The answer is, because we\'ve looked it up in the manual and it said so.With time and experiences, you will start to be more type-conscientious when you do write codes to bridge between C# and other languages (some readers here are thinking "why would you?"), but IMHO I believe it is a better practice because I cannot remember what I\'ve coded last week (or I don\'t have to specify in my API document that "this parameter is 32-bits integer").In F# (although I\'ve never used it), they define int, int32, and nativeint. The same question should rise, "which one do I use?". As others has mentioned, in most cases, it should not matter (should be transparent). But I for one would choose int32 and uint32 just to remove the ambiguities.I guess it would just depend on what applications you are coding, who\'s using it, what coding practices you and your team follows, etc. to justify when to use Int32.In my experience it\'s been a convention thing.  I\'m not aware of any technical reason to use int over Int32, but it\'s:I\'m especially fond of that last one.  :)I know that the best practice is to use int, and all MSDN code uses int. However, there\'s not a reason beyond standardisation and consistency as far as I know.Though they are (mostly) identical (see below for the one [bug] difference), you definitely should care and you should use Int32.The name for a 16-bit integer is Int16. For a 64 bit integer it\'s Int64, and for a 32-bit integer the intuitive choice is: int or Int32?The question of the size of a variable of type Int16, Int32, or Int64 is self-referencing, but the question of the size of a variable of type int is a perfectly valid question and questions, no matter how trivial, are distracting, lead to confusion, waste time, hinder discussion, etc. (the fact this question exists proves the point).Using Int32 promotes that the developer is conscious of their choice of type. How big is an int again? Oh yeah, 32. The likelihood that the size of the type will actually be considered is greater when the size is included in the name. Using Int32 also promotes knowledge of the other choices. When people aren\'t forced to at least recognize there are alternatives it become far too easy for int to become "THE integer type".The class within the framework intended to interact with 32-bit integers is named Int32. Once again, which is: more intuitive, less confusing, lacks an (unnecessary) translation (not a translation in the system, but in the mind of the developer), etc.  int lMax = Int32.MaxValue or Int32 lMax = Int32.MaxValue?int isn\'t a keyword in all .NET languages.Although there are arguments why it\'s not likely to ever change, int may not always be an Int32.The drawbacks are two extra characters to type and [bug].This won\'t compileBut this will:You shouldn\'t care. You should use int most of the time. It will help the porting of your program to a wider architecture in the future (currently int is an alias to System.Int32 but that could change). Only when the bit width of the variable matters (for instance: to control the layout in memory of a struct) you should use int32 and others (with the associated "using System;").int is the C# language\'s shortcut for System.Int32Whilst this does mean that Microsoft could change this mapping, a post on FogCreek\'s discussions stated [source]"On the 64 bit issue -- Microsoft is indeed working on a 64-bit version of the .NET Framework but I\'m pretty sure int will NOT map to 64 bit on that system. Reasons:1. The C# ECMA standard specifically says that int is 32 bit and long is 64 bit.2. Microsoft introduced additional properties & methods in Framework version 1.1 that return long values instead of int values, such as Array.GetLongLength in addition to Array.GetLength.So I think it\'s safe to say that all built-in C# types will keep their current mapping."int is the same as System.Int32 and when compiled it will turn into the same thing in CIL.  We use int by convention in C# since C# wants to look like C and C++ (and Java) and that is what we use there...BTW, I do end up using System.Int32 when declaring imports of various Windows API functions. I am not sure if this is a defined convention or not, but it reminds me that I am going to an external DLL...Once upon a time, the int datatype was pegged to the register size of the machine targeted by the compiler. So, for example, a compiler for a 16-bit system would use a 16-bit integer.However, we thankfully don\'t see much 16-bit any more, and when 64-bit started to get popular people were more concerned with making it compatible with older software and 32-bit had been around so long that for most compilers an int is just assumed to be 32 bits.I always use the aliased types (int, string, etc.) when defining a variable and use the real name when accessing a static method:It just seems ugly to see something like int.TryParse(). There\'s no other reason I do this other than style.It makes no difference in practice and in time you will adopt your own convention.  I tend to use the keyword when assigning a type, and the class version when using static methods and such:int total = Int32.Parse("1009");int and Int32 is the same. int is an alias for Int32.You should not care.  If size is a concern I would use byte, short, int, then long.  The only reason you would use an int larger than int32 is if you need a number higher than 2147483647 or lower than -2147483648.Other than that I wouldn\'t care, there are plenty of other items to be concerned with.I\'d recommend using Microsoft\'s StyleCop.It is like FxCop, but for style-related issues. The default configuration matches Microsoft\'s internal style guides, but it can be customised for your project.It can take a bit to get used to, but it definitely makes your code nicer.You can include it in your build process to automatically check for violations.int is an alias for System.Int32, as defined in this table:\nBuilt-In Types Table (C# Reference)I use int in the event that Microsoft changes the default implementation for an integer to some new fangled version (let\'s call it Int32b). Microsoft can then change the int alias to Int32b, and I don\'t have to change any of my code to take advantage of their new (and hopefully improved) integer implementation.The same goes for any of the type keywords.You should not care in most programming languages, unless you need to write very specific mathematical functions, or code optimized for one specific architecture... Just make sure the size of the type is enough for you (use something bigger than an Int if you know you\'ll need more than 32-bits for example)It doesn\'t matter. int is the language keyword and Int32 its actual system type.See also my answer here to a related question.Use of Int or Int32 are the same Int is just sugar to simplify the code for the reader.Use the Nullable variant Int? or Int32? when you work with databases on fields containing null. That will save you from a lot of runtime issues.Some compilers have different sizes for int on different platforms (not C# specific)Some coding standards (MISRA C) requires that all types used are size specified (i.e. Int32 and not int).It is also good to specify prefixes for different type variables (e.g. b for 8 bit byte, w for 16 bit word, and l for 32 bit long word => Int32 lMyVariable)You should care because it makes your code more portable and more maintainable.Portable may not be applicable to C# if you are always going to use C# and the C# specification will never change in this regard.Maintainable ihmo will always be applicable, because the person maintaining your code may not be aware of this particular C# specification, and miss a bug were the int occasionaly becomes more than 2147483647.In a simple for-loop that counts for example the months of the year, you won\'t care, but when you use the variable in a context where it could possibly owerflow, you should care.You should also care if you are going to do bit-wise operations on it.Using the Int32 type requires a namespace reference to System, or fully qualifying (System.Int32).  I tend toward int, because it doesn\'t require a namespace import, therefore reducing the chance of namespace collision in some cases. When compiled to IL, there is no difference between the two.According to the Immediate Window in Visual Studio 2012 Int32 is int, Int64 is long. Here is the output:Also consider Int16. If you need to store an Integer in memory in your application and you are concerned about the amount of memory used, then you could go with Int16 since it uses less memeory and has a smaller min/max range than Int32 (which is what int is.)A while back I was working on a project with Microsoft when we had a visit from someone on the Microsoft .NET CLR product team. This person coded examples and when he defined his variables he used \xe2\x80\x9cInt32\xe2\x80\x9d vs. \xe2\x80\x9cint\xe2\x80\x9d and \xe2\x80\x9cString\xe2\x80\x9d vs. \xe2\x80\x9cstring\xe2\x80\x9d.I had remembered seeing this style in other example code from Microsoft.  So, I did some research and found that everyone says that there is no difference between the \xe2\x80\x9cInt32\xe2\x80\x9d and \xe2\x80\x9cint\xe2\x80\x9d except for syntax coloring. In fact, I found a lot of material suggesting you use \xe2\x80\x9cInt32\xe2\x80\x9d to make your code more readable. So, I adopted the style.The other day I did find a difference! The compiler doesn\xe2\x80\x99t allow you to type enum using the \xe2\x80\x9cInt32\xe2\x80\x9d, but it does when you use \xe2\x80\x9cint\xe2\x80\x9d. Don\xe2\x80\x99t ask me why because I don\xe2\x80\x99t know yet.Example:This works.Taken from: Int32 notation vs. int