I\'m trying to use sed to clean up lines of URLs to extract just the domain..So from:I want:http://www.suepearson.co.uk/(either with or without the trainling slash, it doesn\'t matter)I have tried:and (escaping the non greedy quantifier)but I can not seem to get the non greedy quantifier to work, so it always ends up matching the whole string.Neither basic nor extended Posix/GNU regex recognizes the non-greedy quantifier; you need a later regex.  Fortunately, Perl regex for this context is pretty easy to get:Try [^/]* instead of .*?:With sed, I usually implement non-greedy search by searching for anything except the separator until the separator :Output:this is:If you want to include backslash after the domain as well, then add one more backslash in the group to remember:output:sed does not support "non greedy" operator.You have to use "[]" operator to exclude "/" from match.P.S. there is no need to backslash "/".This thread is really old but I assume people still needs it.\nLets say you want to kill everything till the very first occurrence of HELLO. You cannot say [^HELLO]...So a nice solution involves two steps, assuming that you can spare a unique character that you are not expecting in the input, say ` (a backtick).In this case we can:HTH!This can be done using cut:another way, not using regex, is to use fields/delimiter method egAnd all other regex flavors!Finding first occurrence of an expression:POSIX ERE (using -r option)Regex:Sed:Example (finding first sequence of digits) Live demo:How does it work?This regex benefits from an alternation |. At each position engine will look for the first side of alternation (our target) and if it is not matched second side of alternation which has a dot . matches the next immediate character. Since global flag is set, engine tries to continue matching character by character up to the end of input string or our target. As soon as the first and only capturing group  of left side of alternation is matched (EXPRESSION) rest of line is consumed immediately as well .*. We now hold our value in the first capturing group.POSIX BRERegex:Sed:Example (finding first sequence of digits):This one is like ERE version but with no alternation involved. That\'s all. At each single position engine tries to match a digit.If it is found, other following digits are consumed and captured and the rest of line is matched immediately otherwise since * means\nmore or zero it skips over second capturing group \\(\\([0-9]\\{1,\\}\\).*\\)* and arrives at a dot . to match a single character and this process continues.Finding first occurrence of a delimited expression:This approach will match the very first occurrence of a string that is delimited. We can call it a block of string. Input string:-EDE: end-SDE: startOutput:First regex \\(end\\).* matches and captures first end delimiter end and substitues all match with recent captured characters which\nis the end delimiter. At this stage our output is: foobar start block #1 end.Then the result is passed to second regex \\(\\(start.*\\)*.\\)* that is same as POSIX BRE version above. It matches a single character\nif start delimiter start is not matched otherwise it matches and captures the start delimiter and matches the rest of characters.Using approach #2 (delimited expression) you should select two appropriate expressions:EDE: [^:/]\\/SDE: http:Usage: Output:sed certainly has its place but this not not one of them !As Dee has pointed out:  Just use cut. It is far simpler and much more safe in this case. Here\'s an example where we extract various components from the URL using Bash syntax:gives you:As you can see this is a lot more flexible approach.(all credit to Dee)sed -E interprets regular expressions as extended (modern) regular expressionsUpdate: -E on MacOS X, -r in GNU sed.There is still hope to solve this using pure (GNU) sed. Despite this is not a generic solution in some cases you can use "loops" to eliminate all the unnecessary parts of the string like this:The only problem here is it will also cut the last separator character (\'/\'), but if you really need it you can still simply put it back after the "loop" finished, just append this additional command at the end of the previous command line:Because you specifically stated you\'re trying to use sed (instead of perl, cut, etc.), try grouping. This circumvents the non-greedy identifier potentially not being recognized. The first group is the protocol (i.e. \'http://\', \'https://\', \'tcp://\', etc). The second group is the domain: If you\'re not familiar with grouping, start here.I realize this is an old entry, but someone may find it useful.\nAs the full domain name may not exceed a total length of 253 characters replace .* with .\\{1, 255\\}don bother, i got it on another forum :)sed \'s|\\(http:\\/\\/www\\.[a-z.0-9]*\\/\\).*|\\1| works tooAnother sed version:It matches / followed by an alphanumeric character (so not another forward slash) as well as the rest of characters till the end of the line. Afterwards it replaces it with nothing (ie. deletes it.)Here is something you can do with a two step approach and awk:Output:\n  http://www.suepearson.co.ukHope that helps!