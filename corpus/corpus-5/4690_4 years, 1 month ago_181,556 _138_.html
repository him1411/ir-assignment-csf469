In iOS 7 the UIStatusBar has been designed in a way that it merges with the view like this:\n(GUI designed by Tina Tav\xc4\x8dar)It is cool, but it will somewhat mess up your view when you have something at the top part of your view, and it becomes overlapped with the status bar.Is there a simple solution (such as setting a property in info.plist) that can change the way it works [not overlapping] back to how it is in iOS6? I know a more straightforward solution is to have self.view.center.x + 20 points for every single view controller, but changing them will screw other dimensions up (having a different self.view.center.x can cause problem to custom segues, etc.) and suddenly it turns into a tedious job that is best to be avoided. I\'ll really be glad if someone can provide me an one-liner solution for this.P.S. I know I can hide the status bar by doing things like havingIn didFinishLaunchingWithOptions method, but that\'s a workaround, a shortcut avoiding the problem, so I don\'t consider that a real solution.This is cross-posted from a blog post I wrote, but here is the full rundown on status bars, navigation bars, and container view controllers on iOS 7:There is no way to preserve the iOS 6 style status bar layout. The status bar will always overlap your application on iOS 7Do not confuse status bar appearance with status bar layout. The appearance (light or default) does not affect how the status bar is laid out (frame/height/overlap). It is important to note as well that the system status bar no longer has any background color. When the API refers to UIStatusBarStyleLightContent, they mean white text on a clear background. UIStatusBarStyleDefault is black text on a clear background.Status bar appearance is controlled along one of two mutually-exclusive basis paths: you can either set them programmatically in the traditional manner, or UIKit will update the appearance for you based on some new properties of UIViewController. The latter option is on by default. Check your app\xe2\x80\x99s plist value for \xe2\x80\x9cViewController-Based Status Bar Appearance\xe2\x80\x9d to see which one you\xe2\x80\x99re using. If you set this value to YES, every top-level view controller in your app (other than a standard UIKit container view controller) needs to override preferredStatusBarStyle, returning either the default or the light style. If you edit the plist value to NO, then you can manage the status bar appearance using the familiar UIApplication methods.UINavigationController will alter the height of its UINavigationBar to either 44 points or 64 points, depending on a rather strange and undocumented set of constraints. If the UINavigationController detects that the top of its view\xe2\x80\x99s frame is visually contiguous with its UIWindow\xe2\x80\x99s top, then it draws its navigation bar with a height of 64 points. If its view\xe2\x80\x99s top is not contiguous with the UIWindow\xe2\x80\x99s top (even if off by only one point), then it draws its navigation bar in the \xe2\x80\x9ctraditional\xe2\x80\x9d way with a height of 44 points. This logic is performed by UINavigationController even if it is several children down inside the view controller hierarchy of your application. There is no way to prevent this behavior.If you supply a custom navigation bar background image that is only 44 points (88 pixels) tall, and the UINavigationController\xe2\x80\x99s view\xe2\x80\x99s bounds matches the UIWindow\xe2\x80\x99s bounds (as discussed in #4), the UINavigationController will draw your image in the frame (0,20,320,44), leaving 20 points of opaque black space above your custom image. This may confuse you into thinking you are a clever developer who bypassed rule #1, but you are mistaken. The navigation bar is still 64 points tall. Embedding a UINavigationController in a slide-to-reveal style view hierarchy makes this abundantly clear.Beware of the confusingly-named edgesForExtendedLayout property of UIViewController. Adjusting edgesForExtendedLayout does nothing in most cases. The only way UIKit uses this property is if you add a view controller to a UINavigationController, then the UINavigationController uses edgesForExtendedLayout to determine whether or not its child view controller should be visible underneath the navigation bar / status bar area. Setting edgesForExtendedLayout on the UINavigationController itself does nothing to alter whether or not the UINavigationController has a 44 or 64 point high navigation bar area. See #4 for that logic. Similar layout logic applies to the bottom of your view when using a toolbar or UITabBarController.If all you are trying to do is prevent your custom child view controller from underlapping the navigation bar when inside a UINavigationController, then set edgesForExtendedLayout to UIRectEdgeNone (or at least a mask that excludes UIRectEdgeTop). Set this value as early as possible in the life cycle of your view controller.UINavigationController and UITabBarController will also try to pad the contentInsets of table views and collection views in its subview hierarchy. It does this in a manner similar to the status bar logic from #4. There is a programmatic way of preventing this, by setting automaticallyAdjustsScrollViewInsets to NO for your table views and collection views (it defaults to YES). This posed some serious problems for Whisper and Riposte, since we use contentInset adjustments to control the layout of table views in response to toolbar and keyboard movements.To reiterate: there is no way to return to iOS 6 style status bar layout logic. In order to approximate this, you have to move all the view controllers of your app into a container view that is offset by 20 points from the top of the screen, leaving an intentionally black view behind the status bar to simulate the old appearance. This is the method we ended up using in Riposte and Whisper.Apple is pushing very hard to ensure that you don\xe2\x80\x99t try to do #9. They want us to redesign all our apps to underlap the status bar. There are many cogent arguments, however, for both user experience and technical reasons, why this is not always a good idea. You should do what is best for your users and not simply follow the whimsy of the platform.Updates on 19th Sep 2013: fixed scaling bugs by adding\n  self.window.bounds = CGRectMake(0, 20, self.window.frame.size.width, self.window.frame.size.height);  corrected typos in the NSNotificationCenter statement Updates on 12th Sep 2013:corrected UIViewControllerBasedStatusBarAppearance to NOadded a solution for apps with screen rotationadded an approach to change the background color of the status bar.There is, apparently, no way to revert the iOS7 status bar back to how it works in iOS6. However, we can always write some codes and turn the status bar into iOS6-like, and this is the shortest way I can come up with:Set UIViewControllerBasedStatusBarAppearance to NO in info.plist (To opt out of having view controllers adjust the status bar style so that we can set the status bar style by using the UIApplicationstatusBarStyle method.)In AppDelegate\'s application:didFinishLaunchingWithOptions, callin order to:Check if it\'s iOS 7.Set status bar\'s content to be white, as opposed to UIStatusBarStyleDefault.Avoid subviews whose frames extend beyond the visible bounds from showing up (for views animating into the main view from top).Create the illusion that the status bar takes up space like how it is in iOS 6 by shifting and resizing the app\'s window frame.use NSNotificationCenter to detect orientation changes by addingin if (NSFoundationVersionNumber > NSFoundationVersionNumber_iOS_6_1) and create a new method in AppDelegate:So that when orientation changes, it will trigger a switch statement to detect app\'s screen orientation (Portrait, Upside Down, Landscape Left, or Landscape Right) and change the app\'s window frame respectively to create the iOS 6 status bar illusion.Addin AppDelegate.h to make background a property in your class and prevent ARC from deallocating it. (You don\'t have to do it if you are not using ARC.)After that you just need to create the UIWindow in if (NSFoundationVersionNumber > NSFoundationVersionNumber_iOS_6_1):Don\'t forget to @synthesize background; after @implementation AppDelegate!UPDATE(NEW SOLUTION) This update is the best solution of iOS 7 navigation bar problem.You can set navigation bar color example: FakeNavBar.backgroundColor = [UIColor redColor];Note : If you use default Navigation Controller please use old solution.AppDelegate.mOLD SOLUTION - IF you use previous code please ignore following Code and Image This is old version of iOS 7 navigation bar solution.I solved the problem with the following code. This is for adding a status bar.\ndidFinishLaunchingWithOptionsAnd for Interface Builder this is for when you open with iOS 6; it is starting at 0 pixels.SOLUTION :Set it in your viewcontroller or in rootviewcontroller by overriding the method :Here another approach for projects that make extensive use of the Storyboard:GOAL:Goal of this approach is to recreate the same status bar style in iOS7 as there was in iOS6 (see question title "iOS 7 Status Bar Back to iOS 6 style?").SUMMARY:To achieve this we use the Storyboard as much as possible by shifting UI elements that are overlapped by the status bar (under iOS 7) downwards, whilst using deltas to revert the downwards layout change for iOS 6.1 or earlier. The resulting extra space in iOS 7 is then occupied by a UIView with the backgroundColor set to a color of our choosing. The latter can be created in code or using the Storyboard (see ALTERNATIVES below)ASSUMPTIONS:To get the desired result when following the steps below, it is assumed that View controller-based status bar appearance is set to NO and that your Status bar style is either set to "Transparent black style (alpha of 0.5)" or "Opaque black style". Both settings can be found/or added under "Info" in your project settings.STEPS:Add a subview to the UIWindow to serve as your status bar background. To achieve this, add the following to your AppDelegate\'s application: didFinishLaunchingWithOptions: after makeKeyAndVisibleSince you programmatically added a background for iOS 7 ONLY, you will have to adjust the layout of your UI elements that are overlapped by the status bar accordingly whilst preserving their layout for iOS6. To achieve this, do the following:ALTERNATIVES:To add even less code in storyboard-heavy projects and to have the statusbar background autorotate, instead of programmatically adding a background for your statusbar, you could add a colored view to each view controller that sits at the very top of said viewcontroller\'s main view. You would then change the height delta of this new view to the same negative amount as your view\'s height (to make it disappear under iOS 6).The downside of this alternative (although maybe negligible considering the autorotate compatibility) is the fact that this extra view is not immediately visible if you are viewing your Storyboard for iOS 6. You would only know that it\'s there if you had a look at the "Document Outline" of the Storyboard.If you don\'t want your view controllers to be overlapped by the status bar (and navigation bars), uncheck the "Extend Edges Under Top Bars" box in Interface Builder in Xcode 5.Apple released Technical Q&A QA1797: Preventing the Status Bar from Covering Your Views. It works fine for the iOS 6 and iOS 7 versions.I have viewed many many many many and many tutorials to fix this darn problem. But none of them works! Here is my solution, and it works for me:The logic is simple. I shift all children views on the self.view with 20 pixels.\nThat\'s all. Then, the screenshot will display just like as iOS 6 did. I hate the iOS7 status bar! ~"~A small alternative to Archy Holt\'s answer, a bit more simple:a. Set b. In AppDelegate\'s application:didFinishLaunchingWithOptions:, call:And add the method:You can also consider subclassing UIWindow to handle UIApplicationDidChangeStatusBarOrientationNotification itself. I used this in all my view controllers, it\'s simple.\nAdd this lines in all your viewDidLoad methods:Try this simple method....Step 1:To change in single viewControllerStep 2: To change in whole applicationStep 3: Also add this in each viewWillAppear to adjust statusbar height for iOS7There is an option in the Interface Builder which calls the iOS 6/7 Delta property which aim to solve the offset problem.Take a look at it in Stack Overflow question Interface Builder: What are the UIView\'s Layout iOS 6/7 Deltas for?.I have achieved status bar like iOS 6 in iOS 7.Set UIViewControllerBasedStatusBarAppearance to NO in info.plistPase this code in - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions method It may push down all your views by 20 pixels.To over come that use following code in -(void)viewDidAppear:(BOOL)animated methodYou have to set windowHeight Userdefaults value after window allocation in didFinishLauncing Method like If you\'re using Interface builder, try this:In your xib file:1) Select the main view, set the background color to black (or whatever color you want the status bar to be2) Make sure the background is a self contained subview positioned as a top level child of the controller\'s view.\nMove your background to become a direct child of the controller\'s view. Check the autosizing panel to be sure that you\'ve locked all frame edges, activated both flexibility axes, and if this is a UIImageView, set the content mode to Scale to fill.   Programmatically this translates to contentMode set to UIViewContentModeScaleToFill and has its auto resizing mask set to (UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight).3) Now move everything that is locked to the top - down by 20 pts and set a iOS 6/7 delta Y to -20.\nAll top level children that are locked to the top frame in the autosizing panel need to be moved down by 20pts and have their iOS 6/7 delta Y set to -20. (Cmd select all of those, and click down arrow 20 times - is there a better way anyone?)4) Adjust the iOS 6/7 delta height of all of the above items that had a flexible height.\nAny of the items that were locked to the frame top and bottom and had flexible height enabled in the autosizing panel must also have their iOS 6/7 delta height set to 20.  That includes the background view mentioned above.  This may seem anti-intuitive, but due to the order in which these are applied, it is necessary.  The frame height is set first (based on device), then the deltas are applied, and finally the autosizing masks are applied based upon the offset positions of all of the child frames - think it through for a bit, it will make sense.5) Finally, items that were locked to the bottom frame but not the top frame need no deltas at all. That will give you the identical status bar in iOS7 and iOS6.On the other hand, if you want iOS7 styling while maintaining iOS6 compatibility, then set the delta Y / delta height values to 0 for the background view.To see more iOS7 migration info read the full post: http://uncompiled.blogspot.com/2013/09/legacy-compatible-offsets-in-ios7.htmlMy solution was to add a UIView with height of 20 points on top of the window when on iOS 7.\nThen I created a method in my AppDelegate class to show/hide the "solid" status bar background. In application:didFinishLaunchingWithOptions::Then I created a method to fade in/out the black status bar background:All I have to do now is call is [appDelegate showSolidStatusBar:YES] when needed.This may be a overwhelming problem if you use Auto layout because you can not directly manipulate frames anymore. There is a simple solution without too much work.I ended up writing an utility method in an Utility Class and called it from all the view controllers\'s viewDidLayoutSubviews Method.Override your viewDidLayoutSubviews method in the view controller, where you want status bar. It will get you through the burden of Autolayout.The easiest way to do so is installing an older SDK to your newest Xcode.How to install older SDK to the newest Xcode?U can get the iOS 6.1 SDK from http://www.4shared.com/zip/NlPgsxz6/iPhoneOS61sdk.html or downloading an older Xcode and geting the SDK from its contentsUnzip and paste this folder to /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKsRestart the xcode.Hope it helps you. It worked for me =)As using presentViewController:animated:completion: messed-up the window.rootViewController.view, I had to find a different approach to this issue. I finally got it to work with modals and rotations by subclassing the UIView of my rootViewController..h.mYou now have a strong workaround for iOS7 animations.I am late for this Answer, but i just want to share what i did, which is basically\nthe easiest solutionFirst of all-> Go to your info.plist File and add Status Bar Style->Transparent Black Style(Alpha of 0.5)Now ,here it Goes:-Add this code in your AppDelegate.mMy very simple solution (assuming you have only vertical orientation supported) is to redefine application window bounds for iOS versions below 7, in App delegate didFinishLaunchingWithOptions method:You can hide the status bar all together. So your app will be full-screen. I think that\'s the best you will get.UIStatusBarStyleNone or set in the target settings.Steps For Hide the status bar in iOS 7:1.Go to your application info.plist file.2.And Set, View controller-based status bar appearance  :  Boolean NO Hope i solved the status bar issue.....In order to continue working with setStatusBarHidden: I use this category:I found here is the best alternatives and solution for this navigation bar issue in iOS7!!http://www.appcoda.com/customize-navigation-status-bar-ios-7/I hope it will clear our all queries and worries. This might be too late to share, but I have something to contribute which might help someone, I was trying to sub-class the UINavigationBar and wanted to make it look like ios 6 with black status bar and status bar text in white.Here is what I found working for thatIt made my status bar background black, status bar text white and navigation bar\'s color white.iOS 9.3, XCode 7.3.1