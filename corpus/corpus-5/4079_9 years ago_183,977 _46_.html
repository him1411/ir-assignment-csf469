There seem to be many ways to define singletons in Python. Is there a consensus opinion on StackÂ Overflow?I don\'t really see the need, as a module with functions (and not a class) would serve well as a singleton. All its variables would be bound to the module, which could not be instantiated repeatedly anyway. If you do wish to use a class, there is no way of creating private classes or private constructors in Python, so you can\'t protect against multiple instantiations, other than just via convention in use of your API. I would still just put methods in a module, and consider the module as the singleton.Here\'s my own implementation of singletons. All you have to do is decorate the class; to get the singleton, you then have to use the Instance method. Here\'s an example:And here\'s the code:You can override the __new__ method like this: A slightly different approach to implement the singleton in Python is the borg pattern by Alex Martelli (Google employee and Python genius).So instead of forcing all instances to have the same identity, they share state.The module approach works well. If I absolutely need a singleton I prefer the Metaclass approach.See this implementation from PEP318, implementing the singleton pattern with a decorator:As the accepted answer says, the most idiomatic way is to just use a module.With that in mind, here\'s a proof of concept:See the Python data model for more details on __new__.Example:Notes:You have to use new-style classes (derive from object) for this.The singleton is initialized when it is defined, rather than the first time it\'s used.This is just a toy example. I\'ve never actually used this in production code, and don\'t plan to.The one time I wrote a singleton in Python I used a class where all the member functions had the classmethod decorator.I\'m very unsure about this, but my project uses \'convention singletons\' (not enforced singletons9, that is, if I have a class called DataController, I define this in the same module:It is not elegant, since it\'s a full six lines. But all my singletons use this pattern, and it\'s at least very explicit (which is pythonic).Creating a singleton decorator (aka an annotation) is an elegant way if you want to decorate (annotate) classes going forward. Then you just put @singleton before your class definition. The Python documentation does cover this:I would probably rewrite it to look more like this:It should be relatively clean to extend this:There are also some interesting articles on the Google Testing blog, discussing why singleton are/may be bad and are an anti-pattern:Here is an example from Peter Norvig\'s Python IAQ How do I do the Singleton Pattern in Python? (You should use search feature of your browser to find this question, there is no direct link, sorry)Also Bruce Eckel has another example in his book Thinking in Python (again there is no direct link to the code)I think that forcing a class or an instance to be a singleton is overkill. Personally, I like to define a normal instantiable class, a semi-private reference, and a simple factory function.Or if there is no issue with instantiating when the module is first imported:That way you can write tests against fresh instances without side effects, and there is no need for sprinkling the module with global statements, and if needed you can derive variants in the future.The Singleton Pattern implemented with Python courtesy of ActiveState.It looks like the trick is to put the class that\'s supposed to only have one instance inside of another class.My simple solution which is based on the default value of function parameters.Being relatively new to Python I\'m not sure what the most common idiom is, but the simplest thing I can think of is just using a module instead of a class. What would have been instance methods on your class become just functions in the module and any data just becomes variables in the module instead of members of the class. I suspect this is the pythonic approach to solving the type of problem that people use singletons for.If you really want a singleton class, there\'s a reasonable implementation described on the first hit on Google for "Python singleton", specifically:That seems to do the trick.OK, singleton could be good or evil, I know. This is my implementation, and I simply extend a classic approach to introduce a cache inside and produce many instances of a different type or, many instances of same type, but with different arguments.I called it Singleton_group, because it groups similar instances together and prevent that an object of the same class, with same arguments, could be created:Every object carries the singleton cache... This could be evil, but it works great for some :)Singleton\'s half brotherI completely agree with staale and I leave here a sample of creating a singleton half brother:a will report now as being of the same class as singleton even if it does not look like it. So singletons using complicated classes end up depending on we don\'t mess much with them.Being so, we can have the same effect and use simpler things like a variable or a module. Still, if we want use classes for clarity and because in Python a class is an object, so we already have the object (not and instance, but it will do just like).There we have a nice assertion error if we try to create an instance, and we can store on derivations static members and make changes to them at runtime (I love Python). This object is as good as other about half brothers (you still can create them if you wish), however it will tend to run faster due to simplicity.In cases where you don\'t want the metaclass-based solution above, and you don\'t like the simple function decorator-based approach (e.g. because in that case static methods on the singleton class won\'t work), this compromise works: