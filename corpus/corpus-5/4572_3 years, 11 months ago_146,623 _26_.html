I\'m studying the content of this preinst file that the script executes before that package is unpacked from its Debian archive (.deb) file.The script has the following code:My first query is about the line:I think that the rest of the script is pretty simple: It checks whether the Debian/Ubuntu package manager is executing an install operation. If it is, it checks whether my application has just been installed on the system. If it has, the script prints the message "MyApplicarionName is just installed" and ends (return 1 mean that ends with an \xe2\x80\x9cerror\xe2\x80\x9d, doesn\xe2\x80\x99t it?).If the user is asking the Debian/Ubuntu package system to install my package, the script also deletes two directories.Is this right or am I missing something?From help set :But it\'s not very reliable and considered as a bad practice, better use :to run do_something function when errors will occurs.See http://mywiki.wooledge.org/BashFAQ/105set -e stops the execution of a script if a command or pipeline has an error - which is the opposite of the default shell behaviour, which is to ignore errors in scripts. Type help set in a terminal to see the documentation for this built-in command.As per bash - The Set Builtin manual, if -e/errexit is set, shell exits immediately if a pipeline consist of a single simple command, a list or a compound command returns a non-zero status.By default, the exit status of a pipeline is the exit status of the last command in the pipeline, unless the pipefail option is enabled (it\'s disabled by default).If so, the pipeline\xe2\x80\x99s return status of the last (rightmost) command to exit with a non-zero status, or zero if all commands exit successfully.If you\'d like to execute something on exit, try defining trap, for example:where onexit is your function to do something on exit, like below which is printing the simple stack trace:There is similar option -E/errtrace which would trap on ERR instead, e.g.:Zero status example:Non-zero status example:Negating status examples:Test with pipefail being disabled:Test with pipefail being enabled:I found this question while Googling, trying to figure out what the exit status was for a script that was aborted due to a set -e. The answer didn\'t appear obvious to me; hence this answer. Basically, set -e aborts the execution of a command (e.g. a shell script) and returns the exit status code of the command that failed (e.g. the inner script, not the outer script).For example, suppose I have the a shell script outer-test.sh:The code for inner-test.sh is:When I run outer-script.sh from the command line my outer script terminates with the exit code of the inner script: