In C#, the result of Math.Round(2.5) is 2.It is supposed to be 3, isn\'t it? Why is it 2 instead in C#?Firstly, this wouldn\'t be a C# bug anyway - it would be a .NET bug. C# is the language - it doesn\'t decide how Math.Round is implemented.And secondly, no - if you read the docs, you\'ll see that the default rounding is "round to even" (banker\'s rounding):Return ValueType: System.DoubleThe integer nearest a. If the\n  fractional component of a is halfway\n  between two integers, one of which is\n  even and the other odd, then the even\n  number is returned. Note that this\n  method returns a Double instead of an\n  integral type.RemarksThe behavior of this method follows IEEE Standard 754,\n  section 4. This kind of rounding is\n  sometimes called rounding to nearest,\n  or banker\'s rounding. It minimizes\n  rounding errors that result from\n  consistently rounding a midpoint value\n  in a single direction.You can specify how Math.Round should round mid-points using an overload which takes a MidpointRounding value. There\'s one overload with a MidpointRounding corresponding to each of the overloads which doesn\'t have one:Whether this default was well chosen or not is a different matter. (MidpointRounding was only introduced in .NET 2.0. Before then I\'m not sure there was any easy way of implementing the desired behaviour without doing it yourself.) In particular, history has shown that it\'s not the expected behaviour - and in most cases that\'s a cardinal sin in API design. I can see why Banker\'s Rounding is useful... but it\'s still a surprise to many.You may be interested to take a look at the nearest Java equivalent enum (RoundingMode) which offers even more options. (It doesn\'t just deal with midpoints.)That\'s called rounding to even (or banker\'s rounding), which is a valid rounding strategy for minimizing accrued errors in sums (MidpointRounding.ToEven). The theory is that, if you always round a 0.5 number in the same direction, the errors will accrue faster (round-to-even is supposed to minimize that) (a).Follow these links for the MSDN descriptions of:The following diagram and table may help:Note that Round is a lot more powerful than it seems, simply because it can round to a specific number of decimal places. All the others round to zero decimals always. For example:With the other functions, you have to use multiply/divide trickery to achieve the same effect:(a) Of course, that theory depends on the fact that your data has an fairly even spread of values across the even halves (0.5, 2.5, 4.5, ...) and odd halves (1.5, 3.5, ...).If all the "half-values" are evens (for example), the errors will accumulate just as fast as if you always rounded up.From MSDN, Math.Round(double a) returns:The integer nearest a. If the\n  fractional component of a is halfway\n  between two integers, one of which is\n  even and the other odd, then the even\n  number is returned.... and so 2.5, being halfway between 2 and 3, is rounded down to the even number (2).  this is called Banker\'s Rounding (or round-to-even), and is a commonly-used rounding standard.Same MSDN article:The behavior of this method follows\n  IEEE Standard 754, section 4. This\n  kind of rounding is sometimes called\n  rounding to nearest, or banker\'s\n  rounding. It minimizes rounding errors\n  that result from consistently rounding\n  a midpoint value in a single\n  direction.You can specify a different rounding behavior by calling the overloads of Math.Round that take a MidpointRounding mode.You should check MSDN for Math.Round:The behavior of this method follows IEEE Standard 754, section 4. This kind of rounding is sometimes called rounding to nearest, or banker\'s rounding.You can specify the behavior of Math.Round using an overload:Consider the task of rounding a number that contains a fraction to, say, a whole number. The process of rounding in this circumstance is to determine which whole number best represents the number you are rounding.In common, or \'arithmetic\' rounding, it is clear that 2.1, 2.2, 2.3 and 2.4 round to 2.0; and 2.6, 2.7, 2.8 and 2.9 to 3.0.That leaves 2.5, which is no nearer to 2.0 than it is to 3.0. It is up to you to choose between 2.0 and 3.0, either would be equally valid. For minus numbers, -2.1, -2.2, -2.3 and -2.4, would become -2.0; and -2.6, 2.7, 2.8 and 2.9 would become -3.0 under arithmetic rounding.For -2.5 a choice is needed between -2.0 and -3.0. Other forms of rounding\'Rounding up\' takes any number with decimal places and makes it the next \'whole\' number. Thus not only do 2.5 and 2.6 round to 3.0, but so do 2.1 and 2.2.Rounding up moves both positive and negative numbers away from zero. Eg. 2.5 to 3.0 and -2.5 to -3.0.\'Rounding down\' truncates numbers by chopping off unwanted digits. This has the effect of moving numbers towards zero. Eg. 2.5 to 2.0 and -2.5 to -2.0In "banker\'s rounding" - in its most common form - the .5 to be rounded is rounded either up or down so that the result of the rounding is always an even number. Thus 2.5 rounds to 2.0, 3.5 to 4.0, 4.5 to 4.0, 5.5 to 6.0, and so on.\'Alternate rounding\' alternates the process for any .5 between rounding down and rounding up.\'Random rounding\' rounds a .5 up or down on an entirely random basis.Symmetry and asymmetryA rounding function is said to be \'symmetric\' if it either rounds all numbers away from zero or rounds all numbers towards zero.A function is \'asymmetric\' if rounds positive numbers towards zero and negative numbers away from zero.. Eg. 2.5 to 2.0; and -2.5 to -3.0.Also asymmetric is a function that rounds positive numbers away from zero and negative numbers towards zero. Eg. 2.5 to 3.0; and -2.5 to -2.0.Most of time people think of symmetric rounding, where -2.5 will be rounded towards -3.0 and 3.5 will be rounded towards 4.0. (in C# Round(AwayFromZero))The default MidpointRounding.ToEven, or Bankers\' rounding (2.5 become 2, 4.5 becomes 4 and so on) has stung me before with writing reports for accounting, so I\'ll write a few words of what I found out, previously and from looking into it for this post. From wikipediaThe origin of the term bankers\'\n  rounding remains more obscure. If this\n  rounding method was ever a standard in\n  banking, the evidence has proved\n  extremely difficult to find. To the\n  contrary, section 2 of the European\n  Commission report The Introduction of\n  the Euro and the Rounding of Currency\n  Amounts suggests that there had\n  previously been no standard approach\n  to rounding in banking; and it\n  specifies that "half-way" amounts\n  should be rounded up.It seems a very strange way of rounding particularly for banking, unless of course banks use to receive lots of deposits of even amounts. Deposit \xc2\xa32.4m, but we\'ll call it \xc2\xa32m sir. The IEEE Standard 754 dates back to 1985 and gives both ways of rounding, but with banker\'s as the recommended by the standard. This wikipedia article has a long list of how languages implement rounding (correct me if any of the below are wrong) and most don\'t use Bankers\' but the rounding you\'re taught at school:From MSDN:By default, Math.Round uses\n  MidpointRounding.ToEven. Most people\n  are not familiar with "rounding to\n  even" as the alternative, "rounding\n  away from zero" is more commonly\n  taught in school. .NET defaults to\n  "Rounding to even" as it is\n  statistically superior because it\n  doesn\'t share the tendency of\n  "rounding away from zero" to round up\n  slightly more often than it rounds\n  down (assuming the numbers being\n  rounded tend to be positive.)http://msdn.microsoft.com/en-us/library/system.math.round.aspxSince Silverlight doesn\'t support the MidpointRounding option you have to write your own. Something like:For the examples including how to use this as an extension see the post: .NET and Silverlight RoundingI had this problem where my SQL server rounds up 0.5 to 1 while my C# application didn\'t. So you would see two different results.Here\'s an implementation with int/long. This is how Java rounds.It\'s probably the most efficient method you could think of as well.If you want to keep it a double and use decimal precision , then it\'s really just a matter of using exponents of 10 based on how many decimal places.You can input a negative decimal for decimal points and it\'s word fine as well.This post has the answer you are looking for:http://weblogs.asp.net/sfurman/archive/2003/03/07/3537.aspxBasically this is what it says:Return ValueThe number nearest value with precision equal to digits. If value is halfway between two numbers, one of which is even and the other odd, then the even number is returned. If the precision of value is less than digits, then value is returned unchanged.The behavior of this method follows IEEE Standard 754, section 4. This kind of rounding is sometimes called rounding to nearest, or banker\'s rounding. If digits is zero, this kind of rounding is sometimes called rounding toward zero.Silverlight doesn\'t support the MidpointRounding option. \nHere\'s an extension method for Silverlight that adds the MidpointRounding enum:Source: http://anderly.com/2009/08/08/silverlight-midpoint-rounding-solution/using a custom roundingHere\'s the way i had to work it around :Trying with 1.905 with 2 decimals will give 1.91 as expected but Math.Round(1.905,2,MidpointRounding.AwayFromZero) gives 1.90! Math.Round method is absolutely inconsistent and unusable for most of the basics problems programmers may encounter. I have to check if  (int) 1.905 * decimalPowerOfTen = Math.Round(number * decimalPowerOfTen, 2) cause i don not want to round up what should be round down.This is ugly as all hell, but always produces correct arithmetic rounding.