What is the equivalent of Python dictionaries but in Bash (should work across OS X and Linux).Bash 4 natively supports this feature.  Make sure your script\'s hashbang is #!/usr/bin/env bash or #!/bin/bash or anything else that references bash and not sh.  Make sure you\'re executing your script, and not doing something silly like sh script which would cause your bash hashbang to be ignored.  This is basic stuff, but so many keep failing at it, hence the re-iteration.You declare an associative array by doing:You can fill it up with elements using the normal array assignment operator:Or merge them:Then use them just like normal arrays.  "${animals[@]}" expands the values, "${!animals[@]}" (notice the !) expands the keys.  Don\'t forget to quote them:Before bash 4, you don\'t have associative arrays.  Do not use eval to emulate them.  You must avoid eval like the plague, because it is the plague of shell scripting.  The most important reason is that you don\'t want to treat your data as executable code (there are many other reasons too).First and foremost: Just consider upgrading to bash 4.  Seriously.  The future is now, stop living in the past and suffering from it by forcing stupid broken and ugly hacks on your code and every poor soul stuck maintaining it.If you have some silly excuse why you "can\'t upgrade", declare is a far safer option.  It does not evaluate data as bash code like eval does, and as such it does not allow arbitrary code injection quite so easily.Let\'s prepare the answer by introducing the concepts:First, indirection (seriously; never use this unless you\'re mentally ill or have some other bad excuse for writing hacks).Secondly, declare:Bring them together:Let\'s use it:Note: declare cannot be put in a function.  Any use of declare inside a bash function turns the variable it creates local to the scope of that function, meaning we can\'t access or modify global arrays with it. (In bash 4 you can use declare -g to declare global variables - but in bash 4, you should be using associative arrays in the first place, not this hack.)Upgrade to bash 4 and use declare -A.  If you can\'t, consider switching entirely to awk before doing ugly hacks as described above.  And definitely stay the heck away from eval hackery.There\'s parameter substitution, though it may be un-PC as well ...like indirection.The BASH 4 way is better of course, but if you need a hack ...only a hack will do.\nYou could search the array/hash with similar techniques.This is what I was looking for here:This did not work for me with bash 4.1.5:You can further modify the hput()/hget() interface so that you have named hashes as follows:and thenThis lets you define other maps that don\'t conflict (e.g., \'rcapitals\' which does country lookup by capital city). But, either way, I think you\'ll find that this is all pretty terrible, performance-wise.If you really want fast hash lookup, there\'s a terrible, terrible hack that actually works really well. It is this: write your key/values out to a temporary file, one-per line, then use \'grep "^$key"\' to get them out, using pipes with cut or awk or sed or whatever to retrieve the values.Like I said, it sounds terrible, and it sounds like it ought to be slow and do all sorts of unnecessary IO, but in practice it is very fast (disk cache is awesome, ain\'t it?), even for very large hash tables. You have to enforce key uniqueness yourself, etc. Even if you only have a few hundred entries, the output file/grep combo is going to be quite a bit faster - in my experience several times faster. It also eats less memory.Here\'s one way to do it:Consider a solution using the bash builtin read as illustrated within the code snippet from a ufw firewall script that follows. This approach has the advantage of using as many delimited field sets (not just 2) as are desired.  We have used the | delimiter because port range specifiers may require a colon, ie 6001:6010.I really liked Al P\'s answer but wanted uniqueness enforced cheaply so I took it one step further - use a directory. There are some obvious limitations (directory file limits, invalid file names) but it should work for most cases.It also performs a tad bit better in my tests.Just thought I\'d pitch in. Cheers!Edit: Adding hdestroy()I agree with @lhunath and others that the associative array are the way to go with Bash 4. If you are stuck to Bash 3 (OSX, old distros that you cannot update) you can use also expr, which should be everywhere, a string and regular expressions. I like it especially when the dictionary is not too big.Write your map as a string (note the separator \',\' also at beginning and end)Use a regex to extract the valuesSplit the string to list the itemsNow you can use it:The file system is a tree structure that can be used as a hash map.\nYour hash table will be a temporary directory, your keys will be filenames, and your values will be file contents. The advantage is that it can handle huge hashmaps, and doesn\'t require a specific shell.hashtable=$(mkdir -d)\necho $value > $hashtable/$key\n$value=$(cat $hashtable/$key)\nOf course, its slow, but not that slow.\nI tested it on my machine, with an SSD, and it does around 3000 element read/write per second.Two things, you can use memory instead of /tmp in any kernel 2.6 by using /dev/shm (Redhat) other distros may vary. Also hget can be reimplemented using read as follows:In addition by assuming that all keys are unique, the return short circuits the read loop and prevents having to read through all entries. If your implementation can have duplicate keys, then simply leave out the return. This saves the expense of reading and forking both grep and awk. Using /dev/shm for both implementations yielded the following using time hget on a 3 entry hash searching for the last entry :Grep/Awk:Read/echo:on multiple invocations I never saw less then a 50% improvement. \nThis can all be attributed to fork over head, due to the use of /dev/shm. Bash 3 solution:In reading some of the answers I put together a quick little function I would like to contribute back that might help others.Prior to bash 4 there is no good way to use associative arrays in bash. Your best bet is to use an interpreted language that actually has support for such things, like awk. On the other hand, bash 4 does support them.As for less good ways in bash 3, here is a reference than might help: http://mywiki.wooledge.org/BashFAQ/006A coworker just mentioned this thread.  I\'ve independently implemented hash tables within bash, and it\'s not dependent on version 4.  From a blog post of mine in March 2010 (before some of the answers here...) entitled Hash tables in bash:Sure, it makes an external call for cksum and is therefore somewhat slowed, but the implementation is very clean and usable.  It\'s not bidirectional, and the built-in way is a lot better, but neither should really be used anyway.  Bash is for quick one-offs, and such things should quite rarely involve complexity that might require hashes, except perhaps in your .bashrc and friends.To get a little more performance remember that grep has a stop function, to stop when it finds the nth match in this case n would be 1.grep --max_count=1 ... or\ngrep -m 1 ...I also used the bash4 way but I find and annoying bug.I needed to update dynamically the associative array content so i used this way:I find out that with bash 4.3.11 appending to an existing key in the dict resulted in appending the value if already present. So for example after some repetion the content of the value was "checkKOcheckKOallCheckOK" and this was not good.No problem with bash 4.3.39 where appenging an existent key means to substisture the actuale value if already present.I solved this just cleaning/declaring the statusCheck associative array before the cicle:I create HashMaps in bash 3 using dynamic variables. I explained how that works in my answer to: Associative arrays in Shell scriptsAlso you can take a look in shell_map, which is a HashMap implementation made in bash 3.