I am writing a program that must accept input from the user.This works as expected if the user enters sensible data. But if they make a mistake, then it crashes:Instead of crashing, I would like it to try getting the input again. Like this:How can I accomplish this? What if I also wanted to reject values like -1, which is a valid int, but nonsensical in this context?The simplest way to accomplish this would be to put the input method in a while loop. Use continue when you get bad input, and break out of the loop when you\'re satisfied.Use try and catch to detect when the user enters data that can\'t be parsed.If you want to reject values that Python can successfully parse, you can add your own validation logic.Both of the above techniques can be combined into one loop.If you need to ask your user for a lot of different values, it might be useful to put this code in a function, so you don\'t have to retype it every time.You can extend this idea to make a very generic input function:With usage such as:This method works but is generally considered poor style:It might look attractive initially because it\'s shorter than the while True method, but it violates the Don\'t Repeat Yourself principle of software development. This increases the likelihood of bugs in your system. What if you want to backport to 2.7 by changing input to raw_input, but accidentally change only the first input above? It\'s a SyntaxError just waiting to happen.If you\'ve just learned about recursion, you might be tempted to use it in get_non_negative_int so you can dispose of the while loop.This appears to work fine most of the time, but if the user enters invalid data enough times, the script will terminate with a RuntimeError: maximum recursion depth exceeded. You may think "no fool would make 1000 mistakes in a row", but you\'re underestimating the ingenuity of fools!Why would you do a while True and then break out of this loop while you can also just put your requirements in the while statement since all you want is to stop once you have the age?This would result in the following:this will work since age will never have a value that will not make sense and the code follows the logic of your "business process"Though the accepted answer is amazing. I would also like to share a quick hack for this problem. (This takes care of the negative age problem as well.) P.S. This code is for python 2.x and can be exported to 3.x by changing the \nraw_input and print functions.So, I was messing around with something similar to this recently, and I came up with the following solution, which uses a way of getting input that rejects junk, before it\'s even checked in any logical way.read_single_keypress() courtesy https://stackoverflow.com/a/6599441/4532996You can find the complete module here.Example:Note that the nature of this implementation is it closes stdin as soon as something that isn\'t a digit is read. I didn\'t hit enter after a, but I needed to after the numbers.You could merge this with the thismany() function in the same module to only allow, say, three digits.To edit your code and fix the error:While a try/except block will work, a much faster and cleaner way to accomplish this task would be to use str.isdigit().You can write more general logic to allow user to enter only specific number of times, as the same use-case arises in many real-world applications.Try this one:- 