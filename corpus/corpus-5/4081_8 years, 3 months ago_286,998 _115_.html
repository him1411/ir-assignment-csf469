I\'m in a computer systems course and have been struggling, in part, with Two\'s Complement. I want to understand it but everything I\'ve read hasn\'t brought the picture together for me. I\'ve read the wikipedia article and various other articles, including my text book.Hence, I wanted to start this community wiki post to define what Two\'s Complement is, how to use it and how it can affect numbers during operations like casts (from signed to unsigned and vice versa), bit-wise operations and bit-shift operations.What I\'m hoping for is a clear and concise definition that is easily understood by a programmer.Two\'s complement is a clever way of storing integers so that common math problems are very simple to implement.To understand, you have to think of the numbers in binary.It basically says,Let\'s try it with a mini-byte of 4 bits (we\'ll call it a nibble - 1/2 a byte).That\'s as far as we can go in positives. 23-1 = 7.For negatives:Note that you get one extra value for negatives (1000 = -8) that you don\'t for positives. This is because 0000 is used for zero. This can be consider as Number Line of computers.Distinguishing between positive and negative numbersDoing this, the first bit gets the role of the "sign" bit, as it can be used to distinguish between positive and negative decimal values. If the most significant bit is 1, then the binary can be said to be negative, where as if the most significant bit (the leftmost) is 0, you can say discern the decimal value is positive.I wonder if it could be explained any better than the Wikipedia article.The basic problem that you are trying to solve with two\'s complement representation is the problem of storing negative integers.First consider an unsigned integer stored in 4 bits. You can have the followingThese are unsigned because there is no indication of whether they are negative or positive.To store negative numbers you can try a number of things. First, you can use sign magnitude notation which assigns the first bit as a sign bit to represent +/- and the remaining bits to represent the magnitude. So using 4 bits again and assuming that 1 means - and 0 means + then you have So, you see the problem there? We have positive and negative 0. The bigger problem is adding and subtracting binary numbers. The circuits to add and subtract using sign magnitude will be very complex.What is ?Another system is excess notation. You can store negative numbers, you get rid of the two zeros problem but addition and subtraction remains difficult.So along comes two\'s complement. Now you can store positive and negative integers and perform arithmetic with relative ease. There are a number of methods to convert a number into two\'s complement. Here\'s one.Convert the number to binary (ignore the sign for now)\ne.g. 5 is 0101 and -5 is 0101If the number is a positive number then you are done.\ne.g. 5 is 0101 in binary using twos complement notation.If the number is negative then3.1 find the complement (invert 0\'s and 1\'s)\n e.g. -5 is 0101 so finding the complement is 10103.2 Add 1 to the complement 1010 + 1 = 1011.\n     Therefore, -5 in two\'s complement is 1011.So, what if you wanted to do 2 + (-3) in binary? 2 + (-3) is -1.\nWhat would you have to do if you were using sign magnitude to add these numbers? 0010 + 1101 = ?Using two\'s complement consider how easy it would be.Converting 1111 to decimal:The number starts with 1, so it\'s negative, so we find the complement of 1111, which is 0000.Add 1 to 0000, and we obtain 0001.Convert 0001 to decimal, which is 1.Apply the sign = -1.Tada!Like most explanations I\'ve seen, the ones above are clear about how to work with 2\'s complement, but don\'t really explain what they are mathematically.  I\'ll try to do that, for integers at least, and I\'ll cover some background that\'s probably familiar first.Recall how it works for decimal:   2345 is a way of writing   2 × 103 + 3 × 102 + 4 × 101 + 5 × 100.In the same way, binary is a way of writing numbers using just 0 and 1 following the same general idea, but replacing those 10s above with 2s.  Then in binary,  1111is a way of writing  1 × 23 + 1 × 22 + 1 × 21 + 1 × 20and if you work it out, that turns out to equal 15 (base 10).  That\'s because it is  8+4+2+1 = 15.This is all well and good for positive numbers.  It even works for negative numbers if you\'re willing to just stick a minus sign in front of them, as humans do with decimal numbers.  That can even be done in computers, sort of, but I haven\'t seen such a computer since the early 1970\'s.  I\'ll leave the reasons for a different discussion.For computers it turns out to be more efficient to use a complement representation for negative numbers.  And here\'s something that is often overlooked.  Complement notations involve some kind of reversal of the digits of the number, even the implied zeroes that come before a normal positive number.  That\'s awkward, because the question arises: all of them?  That could be an infinite number of digits to be considered.Fortunately, computers don\'t represent infinities.  Numbers are constrained to a particular length (or width, if you prefer).  So let\'s return to positive binary numbers, but with a particular size.  I\'ll use 8 digits ("bits") for these examples.  So our binary number would really be  00001111or  0 × 27 + 0 × 26 + 0 × 25 + 0 × 24 + 1 × 23 + 1 × 22 + 1 × 21 + 1 × 20To form the 2\'s complement negative, we first complement all the (binary) digits to form   11110000and add 1 to form   11110001but how are we to understand that to mean -15?The answer is that we change the meaning of the high-order bit.  This bit will be a 1 for all negative numbers.  The change will be to change the sign of its contribution to the value of the number it appears in. So now our 11110001 is understood to represent  -1 × 27 + 1 × 26 + 1 × 25 + 1 × 24 + 0 × 23 + 0 × 22 + 0 × 21 + 1 × 20Notice that "-" in front of that expression?  It means that the sign bit carries the weight -27, that is -128 (base 10).  All the other positions retain the same weight they had in unsigned binary numbers.Working out our -15, it is  -128 + 64 + 32 + 16 + 1  Try it on your calculator.  it\'s -15.Of the three main ways that I\'ve seen negative numbers represented in computers, 2\'s complement wins hands down for convenience in general use.  It has an oddity, though.  Since it\'s binary, there have to be an even number of possible bit combinations.  Each positive number can be paired with its negative, but there\'s only one zero.  Negating a zero gets you zero.  So there\'s one more combination, the number with 1 in the sign bit and 0 everywhere else.  The corresponding positive number would not fit in the number of bits being used.What\'s even more odd about this number is that if you try to form its positive by complementing and adding one, you get the same negative number back.  It seems natural that zero would do this, but this is unexpected and not at all the behavior we\'re used to because computers aside, we generally think of an unlimited supply of digits, not this fixed-length arithmetic.This is like the tip of an iceberg of oddities.  There\'s more lying in wait below the surface, but that\'s enough for this discussion.  You could probably find more if you research "overflow" for fixed-point arithmetic.  If you really want to get into it, you might also research "modular arithmetic".2\'s complement is very useful for finding the value of a binary, however I thought of a much more concise way of solving such a problem(never seen anyone else publish it):take a binary, for example: 1101 which is [assuming that space "1" is the sign] equal to -3. using 2\'s complement we would do this...flip 1101 to 0010...add 0001 + 0010 ===> gives us 0011. 0011 in positive binary = 3. therefore 1101 = -3! What I realized:instead of all the flipping and adding, you can just do the basic method for solving for a positive binary(lets say 0101) is (23 * 0) + (22 * 1) + (21 * 0) + (20 * 1) = 5. Do exactly the same concept with a negative!(with a small twist)take 1101, for example:for the first number instead of 23 * 1 = 8 , do -(23 * 1) = -8.then continue as usual, doing -8 + (22 * 1) + (21 * 0) + (20 * 1) = -3Imagine that you have a finite number of bits/trits/digits/whatever. You define 0 as all digits being 0, and count upwards naturally:Eventually you will overflow.We have two digits and can represent all numbers from 0 to 100. All those numbers are positive! Suppose we want to represent negative numbers too?What we really have is a cycle. The number before 2 is 1. The number before 1 is 0. The number before 0 is... 99.So, for simplicity, let\'s say that any number over 50 is negative. "0" through "49" represent 0 through 49. "99" is -1, "98" is -2, ... "50" is -50.This representation is ten\'s complement. Computers typically use two\'s complement, which is the same except using bits instead of digits.The nice thing about ten\'s complement is that addition just works. You do not need to do anything special to add positive and negative numbers!Two complement is found out by adding one to 1\'st complement of the given number.\nLets say we have to find out twos complement of 10101 then find its ones complement, that is, 01010 add 1 to this result, that is, 01010+1=01011, which is the final answer.Lets get the answer 10 \xe2\x80\x93  12 in binary form using 8 bits:\nWhat we will really do is 10 + (-12)We need to get the compliment part of 12 to subtract it from 10. \n12 in binary is 00001100.\n10 in binary is 00001010.To get the compliment part of 12 we just reverse all the bits then add 1.\n12 in binary reversed is 11110011. This is also the Inverse code (one\'s complement).\nNow we need to add one, which is now 11110100.So 11110100 is the compliment of 12! Easy when you think of it this way.Now you can solve the above question of 10 - 12 in binary form.Looking at the two\'s complement system from a math point of view it really makes sense. In ten\'s complement, the idea is to essentially \'isolate\' the difference.Example: 63 - 24 = xWe add the complement of 24 which is really just (100 - 24). So really, all we are doing is adding 100 on both sides of the equation.Now the equation is: 100 + 63 - 24 = x + 100, that is why we remove the 100 (or 10 or 1000 or whatever).Due to the inconvenient situation of having to subtract one number from a long chain of zeroes, we use a \'diminished radix complement\' system, in the decimal system, nine\'s complement.When we are presented with a number subtracted from a big chain of nines, we just need to reverse the numbers.Example: 99999 - 03275 = 96724That is the reason, after nine\'s complement, we add 1. As you probably know from childhood math, 9 becomes 10 by \'stealing\' 1. So basically it\'s just ten\'s complement that takes 1 from the difference.In Binary, two\'s complement is equatable to ten\'s complement, while one\'s complement to nine\'s complement. The primary difference is that instead of trying to isolate the difference with powers of ten (adding 10, 100, etc. into the equation) we are trying to isolate the difference with powers of two.It is for this reason that we invert the bits. Just like how our minuend is a chain of nines in decimal, our minuend is a chain of ones in binary.Example: 111111 - 101001 = 010110Because chains of ones are 1 below a nice power of two, they \'steal\' 1 from the difference like nine\'s do in decimal.When we are using negative binary number\'s, we are really just saying:0000 - 0101 = x1111 - 0101 = 10101111 + 0000 - 0101 = x + 1111In order to \'isolate\' x, we need to add 1 because 1111 is one away from 10000 and we remove the leading 1 because we just added it to the original difference.1111 + 1 + 0000 - 0101 = x + 1111 + 110000 + 0000 - 0101 = x + 10000Just remove 10000 from both sides to get x, it\'s basic algebra.It is a clever means of encoding negative integers in such a way that approximately half of the combination of bits of a data type are reserved for negative integers, and the addition of most of the negative integers with their corresponding positive integers results in a carry overflow that leaves the result to be binary zero.So, in 2\'s complement if one is 0x0001 then -1 is 0x1111, because that will result in a combined sum of 0x0000 (with an overflow of 1).2\xe2\x80\x99s Complements: When we add an extra one with the 1\xe2\x80\x99s complements of a number we will get the 2\xe2\x80\x99s complements. For example: 100101 it\xe2\x80\x99s 1\xe2\x80\x99s complement is 011010 and 2\xe2\x80\x99s complement is 011010+1 = 011011 (By adding one with 1\'s complement) For more information \nthis article explain it graphically.Many of the answers so far nicely explain why two\'s complement is used to represent negative number, but do not tell us what two\'s complement number is, particularly not why a \'1\' is added, and in fact often added in a wrong way.The confusion comes from a poor understanding of the definition of a complement number. A complement is the missing part that would make something complete. The radix complement of an n digit number x in radix b is, by definition, b^n-x. \nIn binary 4 is represent by 100, which has 3 digits (n=3) and a radix of 2 (b=2). So its radix complement is b^n-x = 2^3-4=8-4=4 (or 100 in binary). However, in binary obtaining a radix\'s complement is not as easy as getting its diminished radix complement, which is defined as (b^n-1)-y, just 1 less than that of radix complement. To get a diminished radix complement, you simply flip all the digits.100 -> 011 (diminished (one\'s) radix complement)to obtain the radix (two\'s) complement, we simply add 1, as the definition defined.011 +1 ->100 (two\'s complement).Now with this new understanding, let\'s take a look of the example given by \nVincent Ramdhanie (see above second response)/*  start of VincentConverting 1111 to decimal:The number starts with 1, so it\'s negative, so we find the complement of 1111, which is 0000.\nAdd 1 to 0000, and we obtain 0001.\nConvert 0001 to decimal, which is 1.\nApply the sign = -1.\nTada!end of Vincent */Should be understood asThe number starts with 1, so it\'s negative. So we know it is a two\'s complement of some value x.  To find the x represented by its two\'s complement, we first need find its 1\'s complement.two\'s complement of x: 1111\none\'s complement of x: 1111-1 ->1110;\nx = 0001,  (flip all digits)apply the sign -, and the answer =-x =-1. I liked lavinio\'s answer, but shifting bits adds some complexity. Often there\'s a choice of moving bits while respecting the sign bit or while not respecting the sign bit. This is the choice between treating the numbers as signed (-8 to 7 for a nibble, -128 to 127 for bytes) or full-range unsigned numbers (0 to 15 for nibbles, 0 to 255 for bytes).REFERENCE: https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.htmlI invert all the bits and add 1.  Programmatically:You can also use an online calculator to calculate the two\'s complement binary representation of a decimal number: http://www.convertforfree.com/twos-complement-calculator/The simplest answer:1111 + 1 = (1)0000. So 1111 must be -1. Then -1 + 1 = 0.It\'s perfect to understand these all for me.