When is it better to use a List(Of T) vs a LinkedList(Of T)?Please read the comments to this answer. People claim I did not do\n  proper tests. I agree this should not be an accepted answer. As I was\n  learning I did some tests and felt like sharing them.I found interesting results:Even if you only access data essentially it is much slower!! I say never use a linkedList.Here is another comparison performing a lot of inserts (we plan on inserting an item at the middle of the list)So only if you plan on inserting several items and you also somewhere have the reference of where you plan to insert the item then use a linked list. Just because you have to insert a lot of items it does not make it faster because searching the location where you will like to insert it takes time.In most cases, List<T> is more useful. LinkedList<T> will have less cost when adding/removing items in the middle of the list, whereas List<T> can only cheaply add/remove at the end of the list.LinkedList<T> is only at it\'s most efficient if you are accessing sequential data (either forwards or backwards) - random access is relatively expensive since it must walk the chain each time (hence why it doesn\'t have an indexer). However, because a List<T> is essentially just an array (with a wrapper) random access is fine.List<T> also offers a lot of support methods - Find, ToArray, etc; however, these are also available for LinkedList<T> with .NET 3.5/C# 3.0 via extension methods - so that is less of a factor.Thinking of a linked list as a list can be a bit misleading.  It\'s more like a chain.  In fact, in .NET, LinkedList<T> does not even implement IList<T>.  There is no real concept of index in a linked list, even though it may seem there is.  Certainly none of the methods provided on the class accept indexes.Linked lists may be singly linked, or doubly linked.  This refers to whether each element in the chain has a link only to the next one (singly linked) or to both the prior/next elements (doubly linked).  LinkedList<T> is doubly linked.Internally, List<T> is backed by an array.  This provides a very compact representation in memory.  Conversely, LinkedList<T> involves additional memory to store the bidirectional links between successive elements.  So the memory footprint of a LinkedList<T> will generally be larger than for List<T> (with the caveat that List<T> can have unused internal array elements to improve performance during append operations.)They have different performance characteristics too:As you can see, they\'re mostly equivalent.  In practice, the API of LinkedList<T> is more cumbersome to use, and details of its internal needs spill out into your code.However, if you need to do many insertions/removals from within a list, it offers constant time.  List<T> offers linear time, as extra items in the list must be shuffled around after the insertion/removal.Linked lists provide very fast insertion or deletion of a list member.  Each member in a linked list contains a pointer to the next member in the list so to insert a member at position i:The disadvantage to a linked list is that random access is not possible.  Accessing a member requires traversing the list until the desired member is found.The difference between List and LinkedList lies in their underlying implementation. List is array based collection (ArrayList). LinkedList is node-pointer based collection (LinkedListNode). On the API level usage, both of them are pretty much the same since both implement same set of interfaces such as ICollection, IEnumerable, etc.The key difference comes when performance matter. For example, if you are implementing the list that has heavy "INSERT" operation, LinkedList outperforms List. Since LinkedList can do it in O(1) time, but List may need to expand the size of underlying array. For more information/detail you might want to read up on the algorithmic difference between LinkedList and array data structures. http://en.wikipedia.org/wiki/Linked_list and ArrayHope this help,The primary advantage of linked lists over arrays is that the links provide us with the capability to rearrange the items efficiently.\nSedgewick, p. 91A common circumstance to use LinkedList is like this:Suppose you want to remove many certain strings from a list of strings with a large size, say 100,000. The strings to remove can be looked up in HashSet dic, and the list of strings is believed to contain between 30,000 to 60,000 such strings to remove. Then what\'s the best type of List for storing the 100,000 Strings? The answer is LinkedList. If the they are stored in an ArrayList, then iterating over it and removing matched Strings whould take up\nto billions of operations, while it takes just around 100,000 operations by using an iterator and the remove() method.My previous answer was not enough accurate.\nAs truly it was horrible :D\nBut now I can post much more useful and correct answer.I did some additional tests. You can find it\'s source by the following link and reCheck it on your environment by your own: https://github.com/ukushu/DataStructuresTestsAndOther.gitShort results:Array need to use:List need to use:LinkedList need to use:More details:\nInteresting to know:Linked List internally is not a List in .NET. LinkedList<T>. It\'s even does not implement IList<T>. And that\'s why there are absent indexes and methods related to indexes.LinkedList<T> is node-pointer based collection. In .NET it\'s in doubly linked implementation. This means that prior/next elements have link to current element. And data is fragmented -- different list objects can be located in different places of RAM. Also there will be more memory used for LinkedList<T> than for List<T> or Array.List<T> in .Net is Java\'s alternative of ArraList<T>. This means that this is array wrapper. So it\'s allocated in menory as one contiguous block of data. If allocated data size exceeds 85000 bytes, it will be allocated iside of the Large Object Heap. Depending on the size, this can lead to heap fragmentation, a mild form of memory leak. But in the same time if size < 85000 bytes -- this provides a very compact and fast-access representation in memory. Single contiguous block is preferred for random access performance and memory consumption but for collections that need to change size regularly a structure such as an Array generally need to be copied to a new location whereas a linked list only needs to manage the memory for the newly inserted/deleted nodes. When you need built-in indexed access, sorting (and after this binary searching), and "ToArray()" method, you should use List.This is adapted from Tono Nam\'s accepted answer correcting a few wrong measurements in it.The test: And the code:You can see the results are in accordance with theoretical performance others have documented here. Quite clear - LinkedList<T> gains big time in case of insertions. I haven\'t tested for removal from the middle of list, but the result should be the same. Of course List<T> has other areas where it performs way better like O(1) random access.Use LinkedList<> whenFor everything else, it is better to use List<>.So many average answers here...Some linked list implementations use underlying blocks of pre allocated nodes. If they don\'t do this than constant time / linear time is less relevant as memory performance will be poor and cache performance even worse. Use linked lists when 1) You want thread safety. You can build better thread safe algos. Locking costs will dominate a concurrent style list.2) If you have a large queue like structures and want to remove or add anywhere but the end all the time . >100K lists exists but are not that common. I asked a similar question related to performance of the LinkedList collection, and discovered Steven Cleary\'s C# implement of Deque was a solution.  Unlike the Queue collection, Deque allows moving items on/off front and back.  It is similar to linked list, but with improved performance.