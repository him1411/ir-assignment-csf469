According to the paper written by Martin Fowler, inversion of control is the principle where the control flow of a program is inverted: instead of the programmer controlling the flow of a program, the external sources (framework, services, other components) take control of it. It\'s like we plug something into something else. He mentioned an example about EJB 2.0:For example the Session Bean interface\n  defines ejbRemove, ejbPassivate\n  (stored to secondary storage), and\n  ejbActivate (restored from passive\n  state). You don\'t get to control when\n  these methods are called, just what\n  they do. The container calls us, we\n  don\'t call it.This leads to the difference between framework and library:Inversion of Control is a key part of\n  what makes a framework different to a\n  library. A library is essentially a\n  set of functions that you can call,\n  these days usually organized into\n  classes. Each call does some work and\n  returns control to the client.I think, the point of view that DI is IOC, means the dependency of an object is inverted: instead it controls its own dependencies, life cycle... something else does it for you. But, as you told me about DI by hands, DI is not necessarily IOC. We can still have DI and no IOC.However, in this paper (from the pococapsule, another IOC Framework for C/C++), it suggests that because of IOC and DI, the IOC containers and DI frameworks are far more superior to J2EE, since J2EE mixes the framework code into the components, thus not making it Plain Old Java/C++ Object (POJO/POCO).Inversion of Control Containers other than the Dependency Injection pattern: http://www.pocomatic.com/docs/whitepapers/ioc-vs-di/Additional reading to understand what\'s the problem with old Component-Based Development Framework, which leads to the second paper above: Why and what of Inversion of Control: http://www.pocomatic.com/docs/whitepapers/ioc/My Question: What\'s exactly is IOC and DI? I am confused. Based on pococapsule, IOC is something more significant than just invert the control of objects or between programmers and frameworks.IoC is a generic term meaning rather than having the application, call the methods in a framework, the framework calls implementations provided by the application.DI is a form of IoC, where implementations are passed into an object through constructors/setters/service lookups, which the object will \'depend\' on in order to behave correctly.IoC without using DI, for example would be the Template pattern because the implementation can only be changed through sub-classing.DI Frameworks are designed to make use of DI and can define interfaces (or Annotations in Java) to make it easy to pass in the implementations.IoC Containers are DI frameworks that can work outside of the programming language.  In some you can configure which implementations to use in metadata files (e.g. XML) which are less invasive.  With some you can do IoC that would normally be impossible like inject an implementation at pointcuts.See also this Martin Fowler\'s article.In short, IoC is a much broader term that includes, but is not limited to, DIThe term Inversion of Control (IoC) originally meant any sort of programming style where an overall\nframework or run-time controlled the program flowBefore DI had a name, people started to refer to frameworks that manage Dependencies as Inversion\nof Control Containers, and soon, the meaning of IoC gradually drifted towards that particular meaning: Inversion of Control over Dependencies.Inversion of Control (IoC) means that objects do not create other objects on which they rely to do their work. Instead, they get the objects that they need from an outside source (for example, an xml configuration file).Dependency Injection (DI) means that this is done without the object intervention, usually by a framework component that passes constructor parameters and set properties.DI is a subset of IoCHere are some other techniques to achieve IoC.IOC (Inversion Of Controller):   Giving control to the container to get an instance of the object is called Inversion of Control., means instead of you are creating an object using the new operator, let the container do that for you.DI (Dependency Injection):  Way of injecting properties to an object is called Dependency injection.Spring will support only Constructor Injection and Setter/Getter Injection.But the spring documentation says they are same.http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-introductionIn the first line "IoC is also known as dependency injection (DI)".IoC - Inversion of control is generic term, independent of language, it is actually not create the objects but describe in which fashion object is being created.DI - Dependency Injection is concrete term, in which we provide dependencies of the object at run time by using different injection techniques viz. Setter Injection, Constructor Injection or by Interface Injection.Inversion of control is a design paradigm with the goal of giving more control to the targeted components of your application, the ones getting the work done.\nDependency injection is a pattern used to create instances of objects that other objects rely on without knowing at compile time which class will be used to provide that functionality.There are several basic techniques to implement inversion of control. These are:IOC indicates that an external classes managing the classes of an application,and external classes means a container manages the dependency between class of application.\nbasic concept of IOC is that programmer don\'t need to create your objects but describe how they should be created.The main tasks performed by IoC container are:\nto instantiate the application class. to configure the object. to assemble the dependencies between the objects.DI is the process of providing the dependencies of an object at run time by using setter injection or constructor injection.IOC(Inversion Of Controller) :   Giving control to the container to get instance of object is called Inversion of Control., means instead of you are creating object using new operator, let the container do that for you.DI(Dependency Injection):  Passing the required parameters(properties) from XML to an object(in POJO CLASS) is called Dependency injection.Since all the answers emphasize on theory I would like to demonstrate with an example first approach:Suppose we are building an application which contains a feature to send SMS confirmation messages once the order has been shipped.\nWe will have two classes, one is responsible for sending the SMS (SMSService), and another responsible for capturing user inputs (UIHandler), our code will look as below:Above  implementation is not wrong but there are few issues:\n-) Suppose On development environment, you want to save SMSs sent to a text file instead of using SMS gateway, to achieve this; we will end up changing the concrete implementation of (SMSService) with another implementation, we are losing flexibility and forced to rewrite the code in this case.\n-) We\xe2\x80\x99ll end up mixing responsibilities of classes, our (UIHandler) should never know about the concrete implementation of (SMSService), this should be done outside the classes using \xe2\x80\x9cInterfaces\xe2\x80\x9d. When this is implemented, it will give us the ability to change the behavior of the system by swapping the (SMSService) used with another mock service which implements the same interface, this service will save SMSs to a text file instead of sending to mobileNumber.To fix the above issues we use Interfaces which will be implemented by our (SMSService) and the new (MockSMSService), basically the new Interface (ISMSService) will expose the same behaviors of both services as the code below:Then we will change our (SMSService) implementation to implement the (ISMSService) interface:Now we will be able to create new mock up service (MockSMSService) with totally different implementation using the same interface:At this point, we can change the code in (UIHandler) to use the concrete implementation of the service (MockSMSService) easily as below:We have achieved a lot of flexibility and implemented separation of concerns in our code, but still we need to do a change on the code base to switch between the two SMS Services. So we need to implement Dependency Injection.To achieve this, we need to implement a change to our (UIHandler) class constructor to pass the dependency through it, by doing this, the code which uses the (UIHandler) can determine which concrete implementation of (ISMSService) to use:Now the UI form which will talk with class (UIHandler) is responsible to pass which implementation of interface (ISMSService) to consume. This means we have inverted the control, the (UIHandler) is no longer responsible to decide which implementation to use, the calling code does. We have implemented the Inversion of Control principle which DI is one type of it.The UI form code will be as below:DI and IOC are design patterns that mainly focusing on providing loose coupling between components, or simply a way in which we decouple the conventional dependency relationships between object so that the objects are not tight to each other.With following examples, I am trying to explain both these concepts.Previously we are writing code like thisWith Dependency injection, the dependency injector will take care of the instantiation of objectsThe above process of giving the control to some other (for example the container) for the instantiation and injection can be termed as Inversion of Control and the process in which the IOC container inject the dependency for us can be termed as dependency injection.IOC is the principle where the control flow of a program is inverted: instead of the programmer controlling the flow of a program, program controls the flow by reducing the overhead to the programmer.and the process used by the program to inject dependency  is termed as DIThe two concepts work together providing us with a way to write much more flexible, reusable, and encapsulated code, which make them as important concepts in designing object-oriented solutions.Let\'s begin with D of SOLID and look at DI and IoC from Scott Millett\'s book "Professional ASP.NET Design Patterns":Dependency Inversion Principle (DIP)The DIP is all about isolating your classes from concrete\n  implementations and having them depend on abstract classes or\n  interfaces. It promotes the mantra of coding to an interface rather\n  than an implementation, which increases flexibility within a system by\n  ensuring you are not tightly coupled to one implementation.Dependency Injection (DI) and Inversion of Control (IoC)Closely linked to the DIP are the DI principle and the IoC principle. DI is the act of supplying a low level or dependent class via a\n  constructor, method, or property. Used in conjunction with DI, these\n  dependent classes can be inverted to interfaces or abstract classes\n  that will lead to loosely coupled systems that are highly testable and\n  easy to change. In IoC, a system\xe2\x80\x99s flow of control is inverted\n  compared to procedural programming. An example of this is an IoC\n  container, whose purpose is to inject services into client code\n  without having the client code specifying the concrete implementation.\n  The control in this instance that is being inverted is the act of the\n  client obtaining the service.Millett,C (2010). Professional ASP.NET Design Patterns. Wiley Publishing. 7-8.//ICO , DI ,10 years back , this was they way:Now with Spring 3,4 or latest its like belowOverall the control is inverted from old concept of coupled code to the frameworks like Spring which makes the object available. So that\'s IOC as far as I know and Dependency injection as you know when we inject the dependent object into another object using Constructor or setters . Inject basically means passing it as an argument. In spring we have XML & annotation based configuration where we define bean object and pass the dependent object with Constructor or setter injection style.