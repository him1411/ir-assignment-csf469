Background: Over the next month, I\'ll be giving three talks about or at least including LINQ in the context of C#. I\'d like to know which topics are worth giving a fair amount of attention to, based on what people may find hard to understand, or what they may have a mistaken impression of. I won\'t be specifically talking about LINQ to SQL or the Entity Framework except as examples of how queries can be executed remotely using expression trees (and usually IQueryable).So, what have you found hard about LINQ? What have you seen in terms of misunderstandings? Examples might be any of the following, but please don\'t limit yourself!Delayed executionI know the deferred execution concept should be beaten into me by now, but this example really helped me get a practical grasp of it:The above code returns the following:That there is more than just LINQ to SQL and the features are more than just a SQL parser embedded in the language.Big O notation. LINQ makes it incredibly easy to write O(n^4) algorithms without realizing it, if you don\'t know what you\'re doing.I think the fact that a Lambda expression can resolve to both an expression tree and an anonymous delegate, so you can pass the same declarative lambda expression to both IEnumerable<T> extension methods and IQueryable<T> extension methods.Took me way too long to realize that many LINQ extension methods such as Single(), SingleOrDefault() etc have overloads that take lambdas.You can do :and don\'t need to say this - which some bad tutorial got me in the habit of doingIn LINQ to SQL I constantly see people not understanding the DataContext, how it can be used and how it should be used. Too many people don\'t see the DataContext for what it is, a Unit of Work object, not a persistant object.I\'ve seen plenty of times where people are trying to singleton a DataContext/ session it/ etc rather than making a new time for each operation.And then there\'s disposing of the DataContext before the IQueryable has been evaluated but that\'s more of a prople with people not understanding IQueryable than the DataContext.The other concept I see a lot of confusion with is Query Syntax vs Expression Syntax. I will use which ever is the easiest at that point, often sticking with Expression Syntax. A lot of people still don\'t realise that they will produce the same thing in the end, Query is compiled into Expression after all.I think the misunderstood part of LINQ is that it is a language extension, not a database extension or construct.LINQ is so much more than LINQ to SQL.Now that most of us have used LINQ on collections, we will NEVER go back!LINQ is the single most significant feature to .NET since Generics in 2.0, and Anonymous Types in 3.0.And now that we have Lambda\'s, I can\'t wait for parallel programming!I for one would sure like to know if I need to know what expression trees are, and why.I\'m fairly new to LINQ. Here\'s the things I stumbled over in my first attemptSomething that I didn\'t originally realise was that the LINQ syntax doesn\'t require IEnumerable<T> or IQueryable<T> to work, LINQ is just about pattern matching.alt text http://bartdesmet.info/images_wlw/QIsIQueryabletheRightChoiceforMe_13478/image_thumb_3.pngHere is the answer (no, I didn\'t write that blog, Bart De Smet did, and he\'s one of the best bloggers on LINQ I\'ve found).I still have trouble with the "let" command (which I\'ve never found a use for) and SelectMany (which I\'ve used, but I\'m not sure I\'ve done it right)Understanding when the abstraction among Linq providers leaks. Some things work on objects but not SQL (e.g., .TakeWhile). Some methods can get translated into SQL (ToUpper) while others can\'t. Some techniques are more efficient in objects where others are more effective in SQL (different join methods).Couple of things.OK, due to demand, I\'ve written up some of the Expression stuff. I\'m not 100% happy with how blogger and LiveWriter have conspired to format it, but it\'ll do for now...Anyway, here goes... I\'d love any feedback, especially if there are areas where people want more information.Here it is, like it or hate it...Some of the error messages, especially from LINQ to SQL can be pretty confusing. grinI\'ve been bitten by the deferred execution a couple of times like everyone else. I think the most confusing thing for me has been the SQL Server Query Provider and what you can and can\'t do with it.I\'m still amazed by the fact you can\'t do a Sum() on a decimal/money column that\'s sometimes empty. Using DefaultIfEmpty() just won\'t work. :(I think a great thing to cover in LINQ is how you can get yourself in trouble performance-wise. For instance, using LINQ\'s count as a loop condition is really, really not smart.That IQueryable accept both, Expression<Func<T1, T2, T3, ...>> and Func<T1, T2, T3, ...>, without giving a hint about performance degradation in 2nd case.Here is code example, that demonstrates what I mean:I don\'t know if it qualifies as misunderstood - but for me, simply unknown.I was pleased to learn about DataLoadOptions and how I can control which tables are joined when I make a particular query.See here for more info: MSDN: DataLoadOptionsI would say the most misunderstood (or should that be non-understood?) aspect of LINQ is IQueryable and custom LINQ providers.I have been using LINQ for a while now and am completely comfortable in the IEnumerable world, and can solve most problems with LINQ.But when I started to look at and read about IQueryable, and Expressions and custom linq providers it made my head spin. Take a look at how LINQ to SQL works if you want to see some pretty complex logic.I look forward to understanding that aspect of LINQ...As most people said, i think the most misunderstood part is assuming LINQ is a just a replacement for T-SQL. \nMy manager who considers himself as a TSQL guru would not let us use LINQ in our project and even hates MS for releasing such a thing!!!What does var represent when a query is executed?Is it iQueryable, iSingleResult, iMultipleResult, or does it change based on the the implementation. There\'s some speculation about using (what appears to be) dynamic-typing vs the standard static-typing in C#.How easy it is to nest a loop is something I don\'t think everyone understands.For example:group by still makes my head spin.Any confusion about deferred execution should be able to be resolved by stepping through some simple LINQ-based code and playing around in the watch window.The fact that you can\'t chain IQueryable because they are method calls (while still nothing else but SQL translateable!) and that it is almost impossible to work around it is mindboggling and creates a huge violation of DRY. I need my IQueryable\'s for ad-hoc in which I don\'t have compiled queries (I only have compiled queries for the heavy scenarios), but in compiled queries I can\'t use them and instead need to write regular query syntax again. Now I\'m doing the same subqueries in 2 places, need to remember to update both if something changes, and so forth. A nightmare.I think the #1 misconception about LINQ to SQL is that you STILL HAVE TO KNOW SQL in order to make effective use of it.Another misunderstood thing about Linq to Sql is that you still have to lower your database security to the point of absurdity in order to make it work.A third point is that using Linq to Sql along with Dynamic classes (meaning the class definition is created at runtime) causes a tremendous amount of just-in-time compiling.  Which can absolutely kill performance.Lazy Loading.As mentioned, lazy loading and deferred executionHow LINQ to Objects and LINQ to XML (IEnumerable) are different from LINQ to SQL(IQueryable)HOW to build a Data Access Layer, Business Layer, and Presentation Layer with LINQ in all layers....and a good example.As most people said, i think the most misunderstood part is assuming LINQ is a just a replacement for T-SQL. My manager who considers himself as a TSQL guru would not let us use LINQ in our project and even hates MS for releasing such a thing!!!Transactions (without using TransactionScope)