Playing around with Swift, coming from a Java background, why would you want to choose a Struct instead of a Class?  Seems like they are the same thing, with a Struct offering less functionality.  Why choose it then?According to the very popular WWDC 2015 talk Protocol Oriented Programming in Swift (video, transcript), Swift provides a number of features that make structs better than classes in many circumstances.Structs are preferable if they are relatively small and copiable because copying is way safer than having multiple reference to the same instance as happens with classes. This is especially important when passing around a variable to many classes and/or in a multithreaded environment. If you can always send a copy of your variable to other places, you never have to worry about that other place changing the value of your variable underneath you.With Structs there is much less need to worry about memory leaks or multiple threads racing to access/modify a single instance of a variable. (For the more technically minded, the exception to that is when capturing a struct inside a closure because then it is actually capturing a reference to the instance unless you explicity mark it to be copied).Classes can also become bloated because a class can only inherit from a single superclass. That encourages us to created huge superclasses that encompass many different abilities that are only loosely related. Using protocols, especially with protocol extensions where you can provide implementations to protocols, allows you to eliminate the need for classes to achieve this sort of behavior.The talk lays out these scenarios where classes are preferred:It implies that structs should be the default and classes should be a fallback.On the other hand, The Swift Programming Language documentation is somewhat contradictory:Structure instances are always passed by value, and class\n  instances are always passed by reference. This means that they are\n  suited to different kinds of tasks. As you consider the data\n  constructs and functionality that you need for a project, decide\n  whether each data construct should be defined as a class or as a\n  structure.As a general guideline, consider creating a structure when one or more\n  of these conditions apply:Examples of good candidates for structures include:In all other cases, define a class, and create instances of that class\n  to be managed and passed by reference. In practice, this means that\n  most custom data constructs should be classes, not structures.Here it is claiming that we should default to using classes and use structures only in specific circumstances. Ultimately, you need to understand the real world implication of value types vs. reference types and then you can make an informed decision about when to use structs or classes. Also keep in mind that these concepts are always evolving and The Swift Programming Language documentation was written before the Protocol Oriented Programming talk was given.Since struct instances are allocated on stack, and class instances are allocated on heap, structs can sometimes be drastically faster, but it really depends on how many values you\'re storing and the size / structure of them.However, you should always measure it yourself and decide based on your unique use case.Consider the following example, which demonstrates 2 strategies of wrapping Int data type (e.g. as part of a mathematics library)and measure the performance usingwhere measure is defined asUPDATE (7 May 2016):As of Swift 2.2.1, XCode 7.3, running Release build on iPhone 6S, iOS 9.3.1, averaged over 5 runs, Swift Compiler setting is -O -whole-module-optimizationThat\'s 37,000,000 times faster.Note #1: the difference is much less dramatic without whole module optimization. I\'d be glad if someone can point out what the flag actually does.Note #2: as someone mentioned that in real-world scenarios, there will be likely more than 1 field in a struct, I have added tests for structs/classes with 10 fields instead of 1. Surprisingly, results don\'t vary much.The code can be found at https://github.com/knguyen2708/StructVsClassPerformanceOLD RESULTS (1 June 2014):As of Swift 1.2, XCode 6.3.2, running Release build on iPhone 5S, iOS 8.3, averaged over 5 runsThat\'s 900 times faster.OLD RESULTS (from unknown time)In release build (on my Macbook), the first test takes 1.10082 sec, while the second one takes 0.02324 sec. That\'s 50 times faster! (results are roughly the same in debug build).I created gist for this with simple examples.\nhttps://github.com/objc-swift/swift-classes-vs-structures structures can\'t inherit in swift. If you wantGo for an class.Swift structures pass by value and class instances pass by reference.Struct constant and variablesExample (Used at WWDC 2014)Defines a struct called Point.Now if I try to change the x. Its a valid expression.But if I defined a point as constant.In this case entire point is immutable constant. If I used a class Point instead this is a valid expression. Because in a class immutable constant is the reference to the class itself not its instance variables (Unless those variables defined as constants)Here are some other reasons to consider:structs get an automatic initializer that you don\'t have to maintain in code at all.To get this in a class,  you would have to add the initializer, and maintain the intializer... Basic collection types like Array are structs. The more you use them in your own code, the more you will get used to passing by value as opposed to reference. For instance:Apparently immutability vs. mutability is a huge topic, but a lot of smart folks think immutability -- structs in this case -- is preferable. Mutable vs immutable objectsSome advantages:Assuming that we know Struct is a value type and Class is a reference typehttps://www.mikeash.com/pyblog/friday-qa-2015-07-17-when-to-use-swift-structs-and-classes.html :... Let\'s look at some extreme, obvious examples first. Integers are\n  obviously copyable. They should be value types. Network sockets can\'t\n  be sensibly copied. They should be reference types. Points, as in x, y\n  pairs, are copyable. They should be value types. A controller that\n  represents a disk can\'t be sensibly copied. That should be a reference\n  type.Some types can be copied but it may not be something you want to\n  happen all the time. This suggests that they should be reference\n  types. For example, a button on the screen can conceptually be copied.\n  The copy will not be quite identical to the original. A click on the\n  copy will not activate the original. The copy will not occupy the same\n  location on the screen. If you pass the button around or put it into a\n  new variable you\'ll probably want to refer to the original button, and\n  you\'d only want to make a copy when it\'s explicitly requested. That\n  means that your button type should be a reference type.View and window controllers are a similar example. They might be\n  copyable, conceivably, but it\'s almost never what you\'d want to do.\n  They should be reference types.What about model types? You might have a User type representing a user\n  on your system, or a Crime type representing an action taken by a\n  User. These are pretty copyable, so they should probably be value\n  types. However, you probably want updates to a User\'s Crime made in\n  one place in your program to be visible to other parts of the program.\n  This suggests that your Users should be managed by some sort of user\n  controller which would be a reference type.Collections are an interesting case. These include things like arrays\n  and dictionaries, as well as strings. Are they copyable? Obviously. Is\n  copying something you want to happen easily and often? That\'s less\n  clear.Most languages say "no" to this and make their collections reference\n  types. This is true in Objective-C and Java and Python and JavaScript\n  and almost every other language I can think of. (One major exception\n  is C++ with STL collection types, but C++ is the raving lunatic of the\n  language world which does everything strangely.)Swift said "yes," which means that types like Array and Dictionary and\n  String are structs rather than classes. They get copied on assignment,\n  and on passing them as parameters. This is an entirely sensible choice\n  as long as the copy is cheap, which Swift tries very hard to\n  accomplish.\n  ...In addition don\'t use class when you have to override each and every instance of a function ie them not having any shared functionality.So instead of having several subclasses of a class. Use several structs that conform to a protocol.With classes you get inheritance and are passed by reference, structs do not have inheritance and are passed by value.There are great WWDC sessions on Swift, this specific question is answered in close detail in one of them. Make sure you watch those, as it will get you up to speed much more quickly then the Language guide or the iBook.Structure is much more faster than Class. Also, if you need inheritance then you must use Class. Most important point is that Class is reference type whereas Structure is value type. for example,now lets create instance of both.now lets pass these instance to two functions which modify the id, description, destination etc..}also,now if we print the flightA\'s id and description, we getHere, we can see the id and description of FlightA is changed because the parameter passed to the modify method actually points to the memory address of flightA object(reference type).now if we print the id and description of FLightB instance we get, Here we can see that the FlightB instance is not changed because in modifyFlight2 method, actual instance of Flight2 is passes rather than reference ( value type).I wouldn\'t say that structs offer less functionality.Sure, self is immutable except in a mutating function, but that\'s about it.Inheritance works fine as long as you stick to the good old idea that every class should be either abstract or final.Implement abstract classes as protocols and final classes as structs.The nice thing about structs is that you can make your fields mutable without creating shared mutable state because copy on write takes care of that :)That\'s why the properties / fields in the following example are all mutable, which I would not do in Java or C# or swift classes.Example inheritance structure with a bit of dirty and straightforward usage at the bottom in the function named "example":Many Cocoa APIs require NSObject subclasses, which forces you into using class. But other than that, you can use the following cases from Apple\xe2\x80\x99s Swift blog to decide whether to use a struct / enum value type or a class reference type.https://developer.apple.com/swift/blog/?id=10Answering the question from the perspective of value types vs reference types, from this Apple blog post it would appear very simple:Use a value type [e.g. struct, enum] when:Use a reference type [e.g. class] when:As mentioned in that article, a class with no writeable properties will behave identically with a struct, with (I will add) one caveat: structs are best for thread-safe models -- an increasingly imminent requirement in modern app architecture.