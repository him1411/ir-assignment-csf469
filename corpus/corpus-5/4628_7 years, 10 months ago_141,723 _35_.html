Python has an ordered dictionary. What about an ordered set?There is an ordered set recipe for this which is referred to from the Python 2 Documentation. This runs on Py2.6 or later and 3.0 or later without any modifications. The interface is almost exactly the same as a normal set, except that initialisation should be done with a list.This is a MutableSet, so the signature for .union doesn\'t match that of set, but since it includes __or__ something similar can easily be added:The keys of a dictionary are unique. Thus, if one disregards the values in an ordered dictionary (e.g. by assigning them None), then one has essentially an ordered set.As of Python 3.1 there is collections.OrderedDict. The following is an example implementation of an OrderedSet. (Note that only few methods need to be defined or overridden: collections.OrderedDict and collections.MutableSet do the heavy lifting.)While others have pointed out that there is no built-in implementation of an insertion-order preserving set in Python (yet), I am feeling that this question is missing an answer which states what there is to be found on PyPI.To the best of my knowledge there currently is:Both implementations are based on the recipe posted by Raymond Hettinger to ActiveState which is also mentioned in other answers here. I have checked out both and identified the following Both implementations have O(1) for add(item) and __contains__(item) (item in my_set).Unfortunately neither implementation has method-based set operations like set1.union(set2) -> You have to use the operator-based form like set1 | set2 instead. See the Python documentation on Set Objects for a full list of set operation methods and their operator-based equivalents.I first went with ordered-set until I used remove(item) for the first time which crashed my script with a NotImplementedError. As I have never used lookup by index so far, I meanwhile switched to oset. If you know about other implementations on PyPI, let me know in the comments.If you\'re using the ordered set to maintain a sorted order, consider using a sorted set implementation from PyPI. The sortedcontainers module provides a SortedSet for just this purpose. Some benefits: pure-Python, fast-as-C implementations, 100% unit test coverage, hours of stress testing.Installing from PyPI is easy with pip:Note that if you can\'t pip install, simply pull down the sortedlist.py and sortedset.py files from the open-source repository.Once installed you can simply:The sortedcontainers module also maintains a performance comparison with several alternative implementations.For the comment that asked about Python\'s bag data type, there\'s alternatively a SortedList data type which can be used to efficiently implement a bag.I can do you one better than an OrderedSet: boltons has a pure-Python, 2/3-compatible IndexedSet type that is not only an ordered set, but also supports indexing (as with lists).Simply pip install boltons (or copy setutils.py into your codebase), import the IndexedSet and:Everything is unique and retained in order. Full disclosure: I wrote the IndexedSet, but that also means you can bug me if there are any issues. :)A little late to the game, but I\'ve written a class setlist as part of collections-extended that fully implements both Sequence and SetGitHub: https://github.com/mlenzen/collections-extendedDocumentation: http://collections-extended.lenzm.net/en/latest/PyPI: https://pypi.python.org/pypi/collections-extendedIn case you\'re already using pandas in your code, its Index object behaves pretty like an ordered set, as shown in this article.The ParallelRegression package provides a setList( ) ordered set class that is more method-complete than the options based on the ActiveState recipe.  It supports all methods available for lists and most if not all methods available for sets.For many purposes simply calling sorted will suffice.  For exampleIf you are going to use this repeatedly, there will be overhead incurred by calling the sorted function so you might want to save the resulting list, as long as you\'re done changing the set.  If you need to maintain unique elements and sorted, I agree with the suggestion of using OrderedDict from collections with an arbitrary value such as None.There are four kinds of ordering one might want, I believe:I believe collections.OrderedDict gets you #4.  Or you could remove a key and re-add it, for #3.For #1, you probably should check into a red-black tree or treap:Red-Black trees have low variability in operation times (so might be better for interactive applications), but aren\'t as fast as treaps on average (which might be better for batch processing - treaps don\'t reorganize themselves often making them fast on average, but when they do reorganize it might take a relatively long while).Both of these are established data structures with implementations in many languages.You can use reduce() to get a list of unique values in one line: