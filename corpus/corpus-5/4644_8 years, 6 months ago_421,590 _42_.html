How do I get a PriorityQueue to sort on what I want it to sort on?Also, is there a difference between the offer and add methods?Use the constructor overload which takes a Comparator<? super E> comparator and pass in a comparator which compares in the appropriate way for your sort order. If you give an example of how you want to sort, we can provide some sample code to implement the comparator if you\'re not sure. (It\'s pretty straightforward though.)As has been said elsewhere: offer and add are just different interface method implementations. In the JDK source I\'ve got, add calls offer. Although add and offer have potentially different behaviour in general due to the ability for offer to indicate that the value can\'t be added due to size limitations, this difference is irrelevant in PriorityQueue which is unbounded.Here\'s an example of a priority queue sorting by string length:Here is the output: shortmediumvery long indeedJust pass appropriate Comparator to the constructor:The only difference between offer and add is the interface they belong to. offer belongs to Queue<E>, whereas add is originally seen in Collection<E> interface. Apart from that both methods do exactly the same thing - insert the specified element into priority queue.from Queue API:The offer method inserts an element if possible, otherwise returning false. This differs from the Collection.add method, which can fail to add an element only by throwing an unchecked exception. The offer method is designed for use when failure is a normal, rather than exceptional occurrence, for example, in fixed-capacity (or "bounded") queues. no different, as declare in javadoc:We can make use of lambda expression introduced in Java 8. In case we have some String values stored in the Priority Queue we can provide inline comparator as: This will print:To reverse the order (to change it to max-priority queue) simply change the order in inline comparator.As per the doc The offer method inserts an element if possible, otherwise returning\n  false. This differs from the Collection.add method, which can fail to\n  add an element only by throwing an unchecked exception. The offer\n  method is designed for use when failure is a normal, rather than\n  exceptional occurrence, for example, in fixed-capacity (or "bounded")\n  queues.When using a capacity-restricted queue, offer() is generally preferable to add(), which can fail to insert an element only by throwing an exception. And PriorityQueue is an unbounded priority queue based on a priority heap.In here, We can define user defined comparator: Below code :Output : Difference between the offer and add methods : linkI was also wondering about print order.  Consider this case, for example:For a priority queue:This code:may print differently than:I found the answer from a discussion on another forum, where a user said, "the offer()/add() methods only insert the element into the queue. If you want a predictable order you should use peek/poll which return the head of the queue."Just to answer the add() vs offer() question (since the other one is perfectly answered imo, and this might not be):According to JavaDoc on interface Queue, "The offer method inserts an element if possible, otherwise returning false. This differs from the Collection.add method, which can fail to add an element only by throwing an unchecked exception. The offer method is designed for use when failure is a normal, rather than exceptional occurrence, for example, in fixed-capacity (or "bounded") queues."That means if you can add the element (which should always be the case in a PriorityQueue), they work exactly the same. But if you can\'t add the element, offer() will give you a nice and pretty false return, while add() throws a nasty unchecked exception that you don\'t want in your code. If failure to add means code is working as intended and/or it is something you\'ll check normally, use offer(). If failure to add means something is broken, use add() and handle the resulting exception thrown according to the Collection interface\'s specifications.They are both implemented this way to fullfill the contract on the Queue interface that specifies offer() fails by returning a false (method preferred in capacity-restricted queues) and also maintain the contract on the Collection interface that specifies add() always fails by throwing an exception.Anyway, hope that clarifies at least that part of the question.Priority Queue has some priority assigned to each element, The element with Highest priority appears at the Top Of Queue. Now, It depends on you how you want priority assigned to each of the elements. If you don\'t, the Java will do it the default way. The element with the least value is assigned the highest priority and thus is removed from the queue first. If there are several elements with the same highest priority, the tie is broken arbitrarily. You can also specify an ordering using Comparator in the constructor PriorityQueue(initialCapacity, comparator)Example Code:Output:Else, You can also define Custom Comparator:Here is the simple example which you can use for initial learning:As an alternative to using Comparator, you can also have the class you\'re using in your PriorityQueue implement Comparable (and correspondingly override the compareTo method).Note that it\'s generally best to only use Comparable instead of Comparator if that ordering is the intuitive ordering of the object - if, for example, you have a use case to sort Person objects by age, it\'s probably best to just use Comparator instead.Output: