I have to format std::string with sprintf and send it into file stream. How can I do this?You can\'t do it directly, because you don\'t have write access to the underlying buffer (until C++11; see Dietrich Epp\'s comment). You\'ll have to do it first in a c-string, then copy it into a std::string:But I\'m not sure why you wouldn\'t just use a string stream? I\'m assuming you have specific reasons to not just do this:A safer and more efficient (I tested it, and it is faster) approach:The fmt_str is passed by value to conform with the requirements of va_start.NOTE: The "safer" and "faster" version doesn\'t work on some systems. Hence both are still listed. Also, "faster" depends entirely on the preallocation step being correct, otherwise the strcpy renders it slower.Utilising C++11 std::snprintf, this becomes a pretty easy and safe task. I see a lot of answers on this question that were apparently written before the time of C++11 which use fixed buffer lengths and vargs, something I would not recommend for safety, efficiency and clarity reasons.Aim: Write to a char* by using  std::snprintf and then convert that to a std::string.First, we determine the desired length of the char array.From cppreference.com:Return value[...] If the resulting string gets truncated due to buf_size limit,\n  function returns the total number of characters (not including the\n  terminating null-byte) which would have been written, if the limit was\n  not imposed.This means that the desired size is the number of characters plus one, so that the null-terminator will sit after all other characters and that it can be cut off by the string constructor again. This issue was explained by @alexk7 in the comments.Then, we allocate a new character array and assign it to a std::unique_ptr. This is generally advised, as you won\'t have to manually delete it again.Note that this is not a safe way to allocate a unique_ptr with user-defined types as you can not deallocate the memory if the constructor throws an exception!After that, we can of course just use snprintf for its intended use and write the formatted string to the char[] and afterwards create and return a new std::string from that.You can see an example in action here.Additional information for Visual Studio users:As explained in this answer, Microsoft renamed std::snprintf to _snprintf (yes, without std::). MS further set it as deprecated and advises to use _snprintf_s instead, however _snprintf_s won\'t accept the buffer to be zero or smaller than the formatted output and will not calculate the outputs length if that occurs. \nSo in order to get rid of the deprecation warnings during compilation, you can insert the following line at the top of the file which contains the use of _snprintf:boost::format() provides the functionality you want:As from the Boost format libraries synopsis:A format object is constructed from a format-string, and is then given arguments through repeated calls to operator%.\n  Each of those arguments are then converted to strings, who are in turn combined into one string, according to the format-string.Unfortunately, most of the answers here use varargs which are inherently unsafe unless you use something like GCC\'s format attribute which only works with literal format strings. You can see why these functions are unsafe on the following example:where string_format is an implementation from the Erik Aronesty\'s answer. This code compiles, but it will most likely crash when you try to run it:It is possible to implement a safe printf and extend it to format std::string using (variadic) templates. This has been done in the fmt library, which provides a safe alternative to sprintf returning std::string:fmt keeps track of the argument types and and if the type doesn\'t match format specification there is no segmentation fault, just an exception.Disclaimer: I\'m the author of this library.If you only want a printf-like syntax (without calling printf yourself), have a look at Boost Format.I wrote my own using vsnprintf so it returns string instead of having to create my own buffer.So you can use it like[edit \'17/8/31] Adding a variadic templated version \'vtspf(..)\':which is effectively a comma-delimited version (instead) of the sometimes hindering <<-operators, used like this:[edit] Adapted to make use of the technique in Erik Aronesty\'s answer (above):[previous answer]\nA very late answer, but for those who, like me, do like the \'sprintf\'-way: I\'ve written and are using the following functions. If you like it, you can expand the %-options to more closely fit the sprintf ones; the ones in there currently are sufficient for my needs.\nYou use stringf() and stringfappend() same as you would sprintf. Just remember that the parameters for ... must be POD types.In order to format std::string in a \'sprintf\' manner, call snprintf (arguments nullptr and 0) to get length of buffer needed. Write your function using C++11 variadic template like this:Compile with C++11 support, for example in GCC: g++ -std=c++11Usage:This is how google does it: StringPrintf (BSD License)\nand facebook does it in a quite similar fashion: StringPrintf (Apache License)\nBoth provide with a convenient StringAppendF too.string doesn\'t have what you need, but std::stringstream does. Use a stringstream to create the string and then extract the string. Here is a comprehensive list on the things you can do. For example:will give you 10 decimal places of precision when printing a double or float.My two cents on this very popular question.To quote the manpage of printf-like functions:Upon successful return, these functions return the number of characters printed (excluding the null byte used to end output to strings).The  functions  snprintf()  and vsnprintf() do not write more than size bytes (including the terminating null byte (\'\\0\')).  If the output  was truncated  due  to  this  limit  then the return value is the number of characters (excluding the terminating null byte) which would have  been written  to the final string if enough space had been available.  Thus, a return value of size or more means that  the  output  was  truncated.In other words, a sane C++11 implementation should be the following:It works quite well :)Variadic templates are supported only in C++11. The answer from pixelpoint show a similar technique using older programming styles.It\'s weird that C++ does not have such a thing out of the box. They recently added to_string(), which in my opinion is a great step forward. I\'m wondering if they will add a .format operator to the std::string eventually...As alexk7 pointed out, A +1 is needed on the return value of std::snprintf, since we need to have space for the \\0 byte. Intuitively, on most architectures missing the +1 will cause the required integer to be partially overwritten with a 0. This will happen after the evaluation of required as actual parameter for std::snprintf, so the effect should not be visible.This problem could however change, for instance with compiler optimization: what if the compiler decides to use a register for the required variable? This is the kind of errors which sometimes result in security issues.Based on the answer provided by Erik Aronesty:This avoids the need to cast away const from the result of .c_str() which was in the original answer. Using C99 snprintf and C++11 If you are on a system that has asprintf(3), you can easily wrap it:You could try this:This is the code I use to do this in my program... It\'s nothing fancy, but it does the trick... Note, you will have to adjust your size as applicable. MAX_BUFFER for me is 1024.Took the idea from Dacav and pixelpoint\'s answer.  I played around a bit and got this:With sane programming practice I believe the code should be enough, however I\'m still open to more secure alternatives that are still simple enough and would not require C++11.And here\'s another version that makes use of an initial buffer to prevent second call to vsnprintf() when initial buffer is already enough.(It turns out that this version is just similar to Piti Ongmongkolkul\'s answer, only that it doesn\'t use new and delete[], and also specifies a size when creating std::string.  The idea here of not using new and delete[] is to imply usage of the stack over the heap since it doesn\'t need to call allocation and deallocation functions, however if not properly used, it could be dangerous to buffer overflows in some (perhaps old, or perhaps just vulnerable) systems.  If this is a concern, I highly suggest using new and delete[] instead.  Note that the only concern here is about the allocations as vsnprintf() is already called with limits, so specifying a limit based on the size allocated on the second buffer would also prevent those.)Very-very simple solution.I usually use this:Disadvantage: not all systems support vasprintBelow slightly modified version of @iFreilicht answer, updated to C++14 (usage of make_unique function instead of raw declaration) and added support for std::string arguments (based on Kenny Kerr article)Output:Feel free to merge this answer with the original one if desired.One solution I\'ve favoured is to do this with sprintf directly into the std::string buffer, after making said buffer big enough:So, create the std::string, resize it, access its buffer directly...Poco Foundation library has a very convenient format function, which supports std::string in both the format string and the values:You can format C++ output in cout using iomanip header file.\nMake sure that you include iomanip header file before you use any of the helper functions like\nsetprecision, setfill etc.Here is a code snippet I have used in the past to print the average waiting time in the vector, which I have "accumulated".Here is a brief description of how we can format C++ streams.\nhttp://www.cprogramming.com/tutorial/iomanip.htmlThere can be problems, if the buffer is not large enough to print the string. You must determine the length of the formatted string before printing a formatted message in there.\nI make own helper to this (tested on Windows and Linux GCC), and you can try use it.String.cpp: http://pastebin.com/DnfvzyKP\nString.h: http://pastebin.com/7U6iCUMaString.cpp:String.h:I gave it a try, with regular expressions. I implemented it for ints and const strings as an example, but you can add whatever other types (POD types but with pointers you can print anything).Here is an example of use of it:Output:I am bob and I have 3 catsthis can be tried out. simple. really does not use nuances of the string class though.All the answers so far here seems to have problems: (1) it may not work on VC++ (2) it requires additional dependencies like boost or fmt (3) its too complicated custom implementation and probably not tested well.Below code addresses all above issues.Notes:Tested on,