Is there a way to find how many values an array has?  Detecting whether or not I\'ve reached the end of an array would also work.If you mean a C-style array, then you can do something like:This doesn\'t work on pointers, though, i.e. it won\'t work for either of the following:or:In C++, if you want this kind of behaviour, then you should be using a container class; probably std::vector.As other\'s said you can use the sizeof(arr)/sizeof(*arr) but this will give you the wrong answer for pointer types that aren\'t arrays.This has the nice property of failing to compile for non array types (visual studio has _countof which does this). The constexpr makes this a compile time expression so it doesn\'t have any drawbacks over the macro (at least none I know of).You can also consider using std::array from C++11 which exposes its length with no overhead over a native C array.Doing sizeof( myArray ) will get you the total number of bytes allocated for that array. You can then find out the number of elements in the array by dividing by the size of one element in the array: sizeof( myArray[0] )Is there a way to find how many values an array has? Yes!Try sizeof(array)/sizeof(array[0])Detecting whether or not I\'ve reached the end of an array would also work.I dont see any way for this unless your array is an array of characters (i.e string).P.S : In C++ always use std::vector. There are several inbuilt functions and an extended functionality.std::vector has a method size() which returns the number of elements in the vector.(Yes, this is tongue-in-cheek answer)There\'s also the TR1/C++11/C++17 way (see it Live on Coliru):Since C++11, some new templates are introduced to help reduce the pain when dealing with array length. All of them are defined in header <type_traits>. std::rank<T>::valueIf T is an array type, provides the member constant value equal to the number of dimensions of the array. For any other type, value is 0.std::extent<T, N>::valueIf T is an array type, provides the member constant value equal to the number of elements along the Nth dimension of the array, if N is in [0, std::rank<T>::value). For any other type, or if T is array of unknown bound along its first dimension and N is 0, value is 0.std::remove_extent<T>::typeIf T is an array of some type X, provides the member typedef type equal to X, otherwise type is T. Note that if T is a multidimensional array, only the first dimension is removed.std::remove_all_extents<T>::typeIf T is a multidimensional array of some type X, provides the member typedef type equal to X, otherwise type is T.To get the length on any dimension of a multidimential array, decltype could be used to combine with std::extent. For example:BTY, to get the total number of elements in a multidimentional array:Or put it in a function template:More examples of how to use them could be found by following the links.Instead of using the built in array function aka:you should use the array class and the array template. Try:so now if you want to find the length of the array all you have to do use the size function in the array class.and that should return the length of elements in the array.In C++, using the std::array class to declare an array, one can easily find the size of an array and also the last element.In fact, array class has a whole lot of other functions which let us use array a standard container.\nReference 1 to C++ std::array class\nReference 2 to std::array class\nThe examples in the references are helpful.Here is one implementation of ArraySize from Google Protobuf.ARRAYSIZE(arr) works by inspecting sizeof(arr) (the # of bytes in\n   the array) and sizeof(*(arr)) (the # of bytes in one array\n   element).  If the former is divisible by the latter, perhaps arr is\n   indeed an array, in which case the division result is the # of\n   elements in the array.  Otherwise, arr cannot possibly be an array,\n   and we generate a compiler error to prevent the code from\n   compiling.Since the size of bool is implementation-defined, we need to cast\n   !(sizeof(a) & sizeof(*(a))) to size_t in order to ensure the final\n   result has type size_t.This macro is not perfect as it wrongfully accepts certain\n   pointers, namely where the pointer size is divisible by the pointee\n   size.  Since all our code has to go through a 32-bit compiler,\n   where a pointer is 4 bytes, this means all pointers to a type whose\n   size is 3 or greater than 4 will be (righteously) rejected.A good solution that uses generics:Then simply call arraysize(_Array); to get the length of the array.SourceIn visual studio 2015.\nWe can find the number  of values in an array by  simply using the size() function.Source Code:If you cout the size_of_array the output will be:Just a thought, but just decided to create a counter variable and store the array size in position [0].  I deleted most of the code I had in the function but you\'ll see after exiting the loop, prime[0] is assigned the final value of \'a\'. I tried using vectors but VS Express 2013 didn\'t like that very much.  Also make note that \'a\' starts at one to avoid overwriting [0] and it\'s initialized in the beginning to avoid errors.  I\'m no expert, just thought I\'d share. One of the most common reasons you would end up looking for this is because you want to pass an array to a function, and not have to pass another argument for it\'s size.  You would also generally like the array size to be dynamic.  That array might contain objects, not primitives, and the objects maybe complex such that size_of() is a not safe option for calculating the count.  As others have suggested, consider using an std::vector or list, etc in instead of a primitive array.  On old compilers, however, you still wouldn\'t have the final solution you probably want by doing simply that though, because populating the container requires a bunch of ugly push_back() lines. If you\'re like me, want a single line solution with anonymous objects involved.If you go with STL container alternative to a primitive array, this SO post may be of use to you for ways to initialize it:\nWhat is the easiest way to initialize a std::vector with hardcoded elements?Here\'s a method that I\'m using for this which will work universally across compilers and platforms:Create a struct or class as container for your collection of objects.  Define an operator overload function for <<.You can create functions which take your struct as a parameter, e.g.: Then, you can call that function, like this:That way, you can build and pass a dynamically sized collection of objects to a function in one single clean line!Avoid using the type together with sizeof, as sizeof(array)/sizeof(char), suddenly gets corrupt if you change the type of the array.In visual studio, you have the equivivalent if sizeof(array)/sizeof(*array).\nYou can simply type _countof(array)For old g++ compiler, you can do thisLets say you have an global array declared at the top of the pageTo find out how many elements are there (in c++) in the array type the following code:The sizeof(NAME_OF_ARRAY) / 4 will give you back the number of elements for the given array name.