I\'ve been programming in C# and Java recently and I am curious where the best place is to initialize my class fields.Should I do it at declaration?:or in a constructor?:I\'m really curious what some of you veterans think is the best practice. I want to be consistent and stick to one approach.My rules:In C# it doesn\'t matter. The two code samples you give are utterly equivalent. In the first example the C# compiler (or is it the CLR?) will construct an empty constructor and initialise the variables as if they were in the constructor.\nIf there is already a constructor then any initialisation "above" will be moved into the top of it.In terms of best practice the former is less error prone than the latter as someone could easily add another constructor and forget to chain it.The semantics of C# differs slightly from Java here. In C# assignment in declaration is performed before calling the superclass constructor. In Java it is done immediately after which allows \'this\' to be used (particularly useful for anonymous inner classes), and means that the semantics of the two forms really do match.If you can, make the fields final.I think there is one caveat. I once committed such an error: Inside of a derived class, I tried to "initialize at declaration" the fields inherited from an abstract base class. The result was that there existed two sets of fields, one is "base" and another is the newly declared ones, and it cost me quite some time to debug.The lesson: to initialize inherited fields, you\'d do it inside of the constructor.Assuming the type in your example, definitely prefer to initialize fields in the constructor. The exceptional cases are:I always think of the field listing at the top of a class as the table of contents (what is contained herein, not how it is used), and the constructor as the introduction. Methods of course are chapters.What if I told you, it depends?I in general initialize everything and do it in a consistent way. Yes it\'s overly explicit but it\'s also a little easier to maintain. If we are worried about performance, well then I initialize only what has to be done and place it in the areas it gives the most bang for the buck.In a real time system, I question if I even need the variable or constant at all.And in C++ I often do next to no initialization in either place and move it into an Init() function. Why? Well, in C++ if you\'re initializing something that can throw an exception during object construction you open yourself to memory leaks.In Java, an initializer with the declaration means the field is always initialized the same way, regardless of which constructor is used (if you have more than one) or the parameters of your constructors (if they have arguments), although a constructor might subsequently change the value (if it is not final). So using an initializer with a declaration suggests to a reader that the initialized value is the value that the field has in all cases, regardless of which constructor is used and regardless of the parameters passed to any constructor. Therefore use an initializer with the declaration only if, and always if, the value for all constructed objects is the same.There are many and various situations.I just need an empty listThe situation is clear. I just need to prepare my list and prevent an exception from being thrown when someone adds an item to the list.I know the valuesI exactly know what values I want to have by default or I need to use some other logic.orEmpty list with possible valuesSometimes I expect an empty list by default with a possibility of adding values through another constructor.There is a slight performance benefit to setting the value in the declaration.  If you set it in the constructor it is actually being set twice (first to the default value, then reset in the ctor).  The design of C# suggests that inline initialization is preferred, or it wouldn\'t be in the language. Any time you can avoid a cross-reference between different places in the code, you\'re generally better off.There is also the matter of consistency with static field initialization, which needs to be inline for best performance. The Framework Design Guidelines for Constructor Design say this:\xe2\x9c\x93 CONSIDER initializing static fields inline rather than explicitly using static constructors, because the runtime is able to optimize the performance of types that don\xe2\x80\x99t have an explicitly defined static constructor."Consider" in this context means to do so unless there\'s a good reason not to. In the case of static initializer fields, a good reason would be if initialization is too complex to be coded inline.Being consistent is important, but this is the question to ask yourself:\n"Do I have a constructor for anything else?"Typically, I am creating models for data transfers that the class itself does nothing except work as housing for variables.In these scenarios, I usually don\'t have any methods or constructors. It would feel silly to me to create a constructor for the exclusive purpose of initializing my lists, especially since I can initialize them in-line with the declaration.So as many others have said, it depends on your usage. Keep it simple, and don\'t make anything extra that you don\'t have to.I normally try the constructor to do nothing but getting the dependencies and initializing the related instance members with them. This will make you life easier if you want to unit test your classes.If the value you are going to assign to an instance variable does not get influenced by any of the parameters you are going to pass to you constructor then assign it at declaration time.