In iOS 7, sizeWithFont: is now deprecated. How do I now pass in the UIFont object into the replacement method sizeWithAttributes:?Use sizeWithAttributes: instead, which now takes an NSDictionary. Pass in the pair with key UITextAttributeFont and your font object like this:I believe the function was deprecated because that series of NSString+UIKit functions (sizewithFont:..., etc) were based on the UIStringDrawing library, which wasn\'t thread safe.  If you tried to run them not on the main thread (like any other UIKit functionality), you\'ll get unpredictable behaviors.  In particular, if you ran the function on multiple threads simultaneously, it\'ll probably crash your app.  This is why in iOS 6, they introduced a the boundingRectWithSize:... method for NSAttributedString.  This was built on top of the NSStringDrawing libraries and is thread safe.  If you look at the new NSString boundingRectWithSize:... function, it asks for an attributes array in the same manner as a NSAttributeString.  If I had to guess, this new NSString function in iOS 7 is merely a wrapper for the NSAttributeString function from iOS 6.  On that note, if you were only supporting iOS 6 and iOS 7, then I would definitely change all of your NSString sizeWithFont:... to the NSAttributeString boundingRectWithSize.  It\'ll save you a lot of headache if you happen to have a weird multi-threading corner case!  Here\'s how I converted NSString sizeWithFont:constrainedToSize::What used to be:Can be replaced with:Please note the documentation mentions: In iOS 7 and later, this method returns fractional sizes (in the size\n  component of the returned CGRect); to use a returned size to size\n  views, you must use raise its value to the nearest higher integer\n  using the ceil function.So to pull out the calculated height or width to be used for sizing views, I would use:As you can see sizeWithFont at Apple Developer site it is deprecated so we need to use sizeWithAttributes.I created a category to handle this problem, here it is :This way you only have to find/replace sizeWithFont: with sizeWithMyFont: and you\'re good to go.In iOS7 I needed the logic to return the correct height for the tableview:heightForRowAtIndexPath method, but the sizeWithAttributes always returns the same height regardless of the string length because it doesn\'t know that it is going to be put in a fixed width table cell.  I found this works great for me and calculates the correct height taking in consideration the width for the table cell!  This is based on Mr. T\'s answer above.Multi-line labels using dynamic height may require additional information to set the size properly.  You can use sizeWithAttributes with UIFont and NSParagraphStyle to specify both the font and the line-break mode.  You would define the Paragraph Style and use an NSDictionary like this:You can use the CGSize \'adjustedSize\' or CGRect as rect.size.height property if you\'re looking for the height.More info on NSParagraphStyle here: https://developer.apple.com/library/mac/documentation/cocoa/reference/applicationkit/classes/NSParagraphStyle_Class/Reference/Reference.htmlCreate a function that takes a UILabel instance. and returns CGSizeAlternate solution-Building on @bitsand, this is a new method I just added to my NSString+Extras category:I just use the size of the resulting frame.You can still use sizeWithFont. but, in iOS >= 7.0 method cause crashing if the string contains leading and trailing spaces or end lines \\n.Trimming text before using itThat\'s also may apply to sizeWithAttributes and [label sizeToFit].also, whenever you have nsstringdrawingtextstorage message sent to deallocated instance in iOS 7.0 device it deals with this.Better use automatic dimensions (Swift):NB:\n 1. UITableViewCell prototype should be properly designed  (for the instance don\'t forget set UILabel.numberOfLines = 0 etc)\n 2. Remove HeightForRowAtIndexPath methodVIDEO:\nhttps://youtu.be/Sz3XfCsSb6kAccepted answer in Xamarin would be (use sizeWithAttributes and UITextAttributeFont):None of this worked for me in ios 7.  Here is what I ended up doing.  I put this in my custom cell class and call the method in my heightForCellAtIndexPath method.My cell looks similar to the description cell when viewing an app in the app store.First in the storyboard, set your label to \'attributedText\', set the number of lines to 0 (which will resize the label automatically (ios 6+ only)) and set it to word wrap.  Then i just add up all the heights of the content of the cell in my custom Cell Class.  In my case I have a Label at the top that always says "Description" (_descriptionHeadingLabel), a smaller label that is variable in size that contains the actual description (_descriptionLabel) a constraint from the top of the cell to the heading (_descriptionHeadingLabelTopConstraint).  I also added 3 to space out the bottom a little bit (about the same amount apple places on the subtitle type cell.)And in my Table View delegate:You can change the if statement to be a little \'smarter\' and actually get the cell identifier from some sort of data source.  In my case the cells are going to be hard coded since there will be fixed amount of them in a specific order. Here is the monotouch equivalent if anyone needs it:which can be used like this:Try  this syntax: