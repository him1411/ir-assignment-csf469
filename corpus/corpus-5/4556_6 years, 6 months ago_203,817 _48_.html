I\'m having a hard time figuring out how to move an array element. For example, given the following:How can I write a function to move \'d\' before \'b\'?Or \'a\' after \'c\'?After the move, the indices of the rest of the elements should be updated. This means in the first example after the move arr[0] would = \'a\', arr[1] = \'d\' arr[2] = \'b\', arr[3] = \'c\', arr[4] = \'e\'This seems like it should be pretty simple, but I can\'t wrap my head around it.I had fairly good success with this function:Example code: [1, 2, 3].move(0, 1) gives [2, 1, 3].Note that the last return is simply for testing purposes: splice performs operations on the array in-place, so a return is not necessary. By extension, this move is an in-place operation. If you want to avoid that and return a copy, use slice.Stepping through the code:A fancier version to account for negative indices: Which should account for things like [1, 2, 3, 4, 5].move(-1, -2) properly (move the last element to the second to last place). Result for that should be [1, 2, 3, 5, 4]. ChillyPenguin has uploaded this version to npm for convenient installation: https://www.npmjs.com/package/array.prototype.move Thanks ChillyPenguin!Either way, in your original question, you would do arr.move(0, 2) for a after c. For d before b, you would do arr.move(3, 1).Here\'s a one liner I found on JSPerf....which is awesome to read, but if you want performance (in small data sets) try...I can\'t take any credit, it should all go to Richard Scarrott. It beats the splice based method for smaller data sets in this performance test. It is however significantly slower on larger data sets as Darwayne points out.I like this way. It works, it\'s quick and elegant.Note: always remember to check your array bounds.The splice() method adds/removes items to/from an array, and returns the removed item(s). Note: This method changes the original array. /w3schools/as the function is chainable this works too:demo hereMy 2c. Easy to read, it works, it\'s fast, it doesn\'t create new arrays.Got this idea from @Reid of pushing something in the place of the item that is supposed to be moved to keep the array size constant. That does simplify calculations. Also, pushing an empty object has the added benefits of being able to search for it uniquely later on. This works because two objects are not equal until they are referring to the same object.So here\'s the function which takes in the source array, and the source, destination indexes. You could add it to the Array.prototype if needed.This is based on @Reid\'s solution. Except:Function:Unit tests:The splice method of Array might help: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/spliceJust keep in mind it might be relatively expensive since it has to actively re-index the array.One approach would be to create a new array with the pieces in the order you want, using the slice method.ExampleYou can implement some basic Calculus and create a universal function for moving array element from one position to the other.For JavaScript it looks like this:Check out "moving array elements" at "gloommatter" for detailed explanation.http://www.gloommatter.com/DDesign/programming/moving-any-array-elements-universal-function.htmlhttp://plnkr.co/edit/JaiAaO7FQcdPGPY6G337?p=previewI needed an immutable move method (one that didn\'t change the original array), so I adapted @Reid\'s accepted answer to simply use Object.assign to create a copy of the array before doing the splice.Here is a jsfiddle showing it in action.Moves elements within an array, returning an array containing the moved elements.index: Index at which to move elements. If negative, index will start from the end.howMany: Number of elements to move from index.toIndex: Index of the array at which to place the moved elements. If negative, toIndex will start from the end.I ended up combining two of these to work a little better when moving both small and large distances. I get fairly consistent results, but this could probably be tweaked a little bit by someone smarter than me to work differently for different sizes, etc. Using some of the other methods when moving objects small distances was significantly faster (x10) than using splice.  This might change depending on the array lengths though, but it is true for large arrays.http://jsperf.com/arraymove-many-sizesI used the nice answer of @Reid, but struggled with moving an element from the end of an array one step further - to the beginning (like in a loop).\nE.g. [\'a\', \'b\', \'c\'] should become [\'c\', \'a\', \'b\'] by calling .move(2,3)I achieved this by changing the case for new_index >= this.length.