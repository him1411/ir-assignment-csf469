Is it worth my learning NumPy?I have approximately 100 financial markets series, and I am going to create a cube array of 100x100x100 = 1 million cells. I will be regressing (3-variable) each x with each y and z, to fill the array with standard errors.I have heard that for "large matrices" I should use NumPy as opposed to Python lists, for performance and scalability reasons. Thing is, I know Python lists and they seem to work for me. Is the scale of the above problem worth moving to NumPy? What if I had 1000 series (that is, 1 billion floating point cells in the cube)? NumPy\'s arrays are more compact than Python lists -- a list of lists as you describe, in Python, would take at least 20 MB or so, while a NumPy 3D array with single-precision floats in the cells would fit in 4 MB. Access in reading and writing items is also faster with NumPy.Maybe you don\'t care that much for just a million cells, but you definitely would for a billion cells -- neither approach would fit in a 32-bit architecture, but with 64-bit builds NumPy would get away with 4 GB or so, Python alone would need at least about 12 GB (lots of pointers which double in size) -- a much costlier piece of hardware!The difference is mostly due to "indirectness" -- a Python list is an array of pointers to Python objects, at least 4 bytes per pointer plus 16 bytes for even the smallest Python object (4 for type pointer, 4 for reference count, 4 for value -- and the memory allocators rounds up to 16). A NumPy array is an array of uniform values -- single-precision numbers takes 4 bytes each, double-precision ones, 8 bytes. Less flexible, but you pay substantially for the flexibility of standard Python lists!NumPy is not just more efficient; it is also more convenient. You get a lot of vector and matrix operations for free, which sometimes allow one to avoid unnecessary work. And they are also efficiently implemented.For example, you could read your cube directly from a file into an array:Sum along the second dimension:Find which cells are above a threshold:Remove every even-indexed slice along the third dimension:Also, many useful libraries work with NumPy arrays.  For example, statistical analysis and visualization libraries.Even if you don\'t have performance problems, learning NumPy is worth the effort.Alex mentioned memory efficiency, and Roberto mentions convenience, and these are both good points. For a few more ideas, I\'ll mention speed and functionality.Functionality: You get a lot built in with NumPy, FFTs, convolutions, fast searching, basic statistics, linear algebra, histograms, etc. And really, who can live without FFTs?Speed: Here\'s a test on doing a sum over a list and a NumPy array, showing that the sum on the NumPy array is 10x faster (in this test -- mileage may vary).which on my systems (while I\'m running a backup) gives:Here\'s a nice answer from the FAQ on the scipy.org website:What advantages do NumPy arrays offer over (nested) Python lists?Python\xe2\x80\x99s lists are efficient general-purpose containers. They support\n  (fairly) efficient insertion, deletion, appending, and concatenation,\n  and Python\xe2\x80\x99s list comprehensions make them easy to construct and\n  manipulate. However, they have certain limitations: they don\xe2\x80\x99t support\n  \xe2\x80\x9cvectorized\xe2\x80\x9d operations like elementwise addition and multiplication,\n  and the fact that they can contain objects of differing types mean\n  that Python must store type information for every element, and must\n  execute type dispatching code when operating on each element. This\n  also means that very few list operations can be carried out by\n  efficient C loops \xe2\x80\x93 each iteration would require type checks and other\n  Python API bookkeeping.Note also that there is support for timeseries based on NumPy in the timeseries scikits:http://pytseries.sourceforge.netFor regression, I am pretty sure NumPy will be orders of magnitude faster and more convenient than lists even for the 100^3 problem.Speed-wise I\'m not so sure of. Here is a quick example: I\'ve created a function(of x) that returns a list of prime numbers between 2 and x:Regular Python function using lists:and C-like Python function using NumPy arrays:The former, supposedly slow implementation using lists, is executed in 0.6 seconds and the later, supposedly fast NumPy implementation, is needs 50 seconds. If someone can point out why I\'d greatly appreciate it.BTW, pure C program which is more or less a copy of NumPy version of the function executes in less than 0.04Â s. The speed of C is even more obvious with large x: