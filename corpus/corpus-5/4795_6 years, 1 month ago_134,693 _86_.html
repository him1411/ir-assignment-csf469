I understand the syntax and general semantics of pointers versus references, but how should I decide when it is more-or-less appropriate to use references or pointers in an API?Naturally some situations need one or the other (operator++ needs a reference argument), but in general I\'m finding I prefer to use pointers (and const pointers) as the syntax is clear that the variables are being passed destructively.E.g. in the following code:With the pointer, it\'s always (more) obvious what\'s going on, so for APIs and the like where clarity is a big concern are pointers not more appropriate than references? Does that mean references should only be used when necessary (e.g. operator++)? Are there any performance concerns with one or the other?EDIT (OUTDATED):Besides allowing NULL values and dealing with raw arrays, it seems the choice comes down to personal preference. I\'ve accepted the answer below that references Google\'s C++ Style Guide, as they present the view that "References can be confusing, as they have value syntax but pointer semantics.".Due to the additional work required to sanitise pointer arguments that should not be NULL (e.g. add_one(0) will call the pointer version and break during runtime), it makes sense from a maintainability perspective to use references where an object MUST be present, though it is a shame to lose the syntactic clarity.Use reference wherever you can, pointers wherever you must.Avoid pointers until you can\'t.The reason is that pointers make things harder to follow/read, less safe and far more dangerous manipulations than any other constructs.So the rule of thumb is to use pointers only if there is no other choice. For example, returning a pointer to an object is a valid option when the function can return nullptr in some cases and it is assumed it will. That said, a better option would be to use something similar to boost::optional.Another example is to use pointers to raw memory for specific memory manipulations. That should be hidden and localized in very narrow parts of the code, to help limit the dangerous parts of the whole code base. In your example, there is no point in using a pointer as argument because:If the behaviour of the function would have to work with or without a given object, then using a pointer as attribute suggests that you can pass nullptr as the argument and it is fine for the function. That\'s kind of a contract between the user and the implementation.The performances are exactly the same, as references are implemented internally as pointers. Thus you do not need to worry about that.There is no generally accepted convention regarding when to use references and pointers. In a few cases you have to return or accept references (copy constructor, for instance), but other than that you are free to do as you wish. A rather common convention I\'ve encountered is to use references when the parameter must refer an existing object and pointers when a NULL value is ok.Some coding convention (like Google\'s) prescribe that one should always use pointers, or const references, because references have a bit of unclear-syntax: they have reference behaviour but value syntax.From C++ FAQ Lite - Use references when you can, and pointers when you have to.References are usually preferred over pointers whenever you don\'t need\n  "reseating". This usually means that references are most useful in a\n  class\'s public interface. References typically appear on the skin of\n  an object, and pointers on the inside.The exception to the above is where a function\'s parameter or return\n  value needs a "sentinel" reference \xe2\x80\x94 a reference that does not refer\n  to an object. This is usually best done by returning/taking a pointer,\n  and giving the NULL pointer this special significance (references must\n  always alias objects, not a dereferenced NULL pointer).Note: Old line C programmers sometimes don\'t like references since\n  they provide reference semantics that isn\'t explicit in the caller\'s\n  code. After some C++ experience, however, one quickly realizes this is\n  a form of information hiding, which is an asset rather than a\n  liability. E.g., programmers should write code in the language of the\n  problem rather than the language of the machine.My rule of thumb is:Regardless which one you use, don\'t forget to document your functions and the meaning of their parameters if they are not obvious.Disclaimer: other than the fact that references cannot be NULL nor "rebound" (meaning thay can\'t change the object they\'re the alias of), it really comes down to a matter of taste, so I\'m not going to say "this is better".That said, I disagree with your last statement in the post, in that I don\'t think the code loses clarity with references. In your example,might be clearer thansince you know that most likely the value of a is going to change. On the other hand though, the signature of the functionis somewhat not clear either: is n going to be a single integer or an array? Sometimes you only have access to (poorly documentated) headers, and signatures likeare not easy to interpret at first sight.Imho, references are as good as pointers when no (re)allocation nor rebinding (in the sense explained before) is needed. Moreover, if a developer only uses pointers for arrays, functions signatures are somewhat less ambiguous. Not to mention the fact that operators syntax is way more readable with references.Like others already answered: Always use references, unless the variable being NULL/nullptr is really a valid state.John Carmack\'s viewpoint on the subject is similar:NULL pointers are the biggest problem in C/C++, at least in our code.  The dual use of a single value as both a flag and an address causes an incredible number of fatal issues.  C++ references should be favored over pointers whenever possible; while a reference is \xe2\x80\x9creally\xe2\x80\x9d just a pointer, it has the implicit contract of being not-NULL.  Perform NULL checks when pointers are turned into references, then you can ignore the issue thereafter.http://www.altdevblogaday.com/2011/12/24/static-code-analysis/User Bret Kuhns rightly remarks:The C++11 standard has been finalized. I think it\'s time in this thread to mention that most code should do perfectly fine with a combination of references, shared_ptr, and unique_ptr.True enough, but the question still remains, even when replacing raw pointers with smart pointers.For example, both std::unique_ptr and std::shared_ptr can be constructed as "empty" pointers through their default constructor:... meaning that using them without verifying they are not empty risks a crash, which is exactly what J. Carmack\'s discussion is all about.And then, we have the amusing problem of "how do we pass a smart pointer as a function parameter?"Jon\'s answer for the question C++ - passing references to boost::shared_ptr, and the following comments show that even then, passing a smart pointer by copy or by reference is not as clear cut as one would like (I favor myself the "by-reference" by default, but I could be wrong).Any performance difference would be so small that it wouldn\'t justify using the approach that\'s less clear.First, one case that wasn\'t mentioned where references are generally superior is const references. For non-simple types, passing a const reference avoids creating a temporary and doesn\'t cause the confusion you\'re concerned about (because the value isn\'t modified). Here, forcing a person to pass a pointer causes the very confusion you\'re worried about, as seeing the address taken and passed to a function might make you think the value changed.In any event, I basically agree with you. I don\'t like functions taking references to modify their value when it\'s not very obvious that this is what the function is doing. I too prefer to use pointers in that case.When you need to return a value in a complex type, I tend to prefer references. For example:Here, the function name makes it clear that you\'re getting information back in an array. So there\'s no confusion.The main advantages of references are that they always contain a valid value, are cleaner than pointers, and support polymorphism without needing any extra syntax. If none of these advantages apply, there is no reason to prefer a reference over a pointer.It is not a matter of taste. Here are some definitive rules.If you want to refer to a statically declared variable within the scope in which it was declared then use a C++ reference, and it will be perfectly safe. The same applies to a statically declared smart pointer. Passing parameters by reference is an example of this usage.If you want to refer to anything from a scope that is wider than the scope in which it is declared then you should use a reference counted smart pointer for it to be perfectly safe.You can refer to an element of a collection with a reference for syntactic convenience, but it is not safe; the element can be deleted at anytime.To safely hold a reference to an element of a collection you must use a reference counted smart pointer.Copied from wiki-A consequence of this is that in many implementations, operating on a variable with automatic or static lifetime through a reference, although syntactically similar to accessing it directly, can involve hidden dereference operations that are costly. References are a syntactically controversial feature of C++ because they obscure an identifier\'s level of indirection; that is, unlike C code where pointers usually stand out syntactically, in a large block of C++ code it may not be immediately obvious if the object being accessed is defined as a local or global variable or whether it is a reference (implicit pointer) to some other location, especially if the code mixes references and pointers. This aspect can make poorly written C++ code harder to read and debug (see Aliasing).I agree 100% with this, and this is why I believe that you should only use a reference when you a have very good reason for doing so.There is problem with "use references wherever possible" rule and it arises if you want to keep reference for further use. To illustrate this with example, imagine you have following classes.At first it may seem to be a good idea to have parameter in RefPhone(const SimCard & card) constructor passed by a reference, because it prevents passing wrong/null pointers to the constructor. It somehow encourages allocation of variables on stack and taking benefits from RAII.But then temporaries come to destroy your happy world.So if you blindly stick to references you trade off possibility of passing invalid pointers for the possibility of storing references to destroyed objects, which has basically same effect.edit: Note that I sticked to the rule "Use reference wherever you can, pointers wherever you must. Avoid pointers until you can\'t." from the most upvoted and accepted answer (other answers also suggest so). Though it should be obvious, example is not to show that references as such are bad. They can be misused however, just like pointers and they can bring their own threats to the code.There are following differences between pointers and references.Taking those into account my current rules are as follows.The following are some guidelines.If the data object is small, such as a built-in data type or a small structure, pass it by value.If the data object is an array, use a pointer because that\xe2\x80\x99s your only choice. Make the pointer a pointer to const.If the data object is a good-sized structure, use a const pointer or a const \nreference to increase program efficiency.You save the time and space needed to \ncopy a structure or a class design. Make the pointer or reference const.If the data object is a class object, use a const reference.The semantics of class design often require using a reference, which is the main reason C++ added \nthis feature.Thus, the standard way to pass class object arguments is by reference.1.If the data object is a built-in data type, use a pointer. If you spot code \nlike fixit(&x), where x is an int, it\xe2\x80\x99s pretty clear that this function intends to modify x.2.If the data object is an array, use your only choice: a pointer.3.If the data object is a structure, use a reference or a pointer.4.If the data object is a class object, use a reference.Of course, these are just guidelines, and there might be reasons for making different\nchoices. For example, cin uses references for basic types so that you can use cin >> n\ninstead of cin >> &n.Just putting my dime in. I just performed a test. A sneeky one at that. I just let g++ create the assembly files of the same mini-program using pointers compared to using references.\nWhen looking at the output they are exactly the same. Other than the symbolnaming. So looking at performance (in a simple example) there is no issue.Now on the topic of pointers vs references. IMHO I think clearity stands above all. As soon as I read implicit behaviour my toes start to curl. I agree that it is nice implicit behaviour that a reference cannot be NULL.Dereferencing a NULL pointer is not the problem. it will crash your application and will be easy to debug. A bigger problem is uninitialized pointers containing invalid values. This will most likely result in memory corruption causing undefined behaviour without a clear origin.This is where I think references are much safer than pointers. And I agree with a previous statement, that the interface (which should be clearly documented, see design by contract, Bertrand Meyer) defines the result of the parameters to a function. Now taking this all into consideration my preferences go to \nusing references wherever/whenever possible.In general a member variable should never be a reference because there is no point in that. It causes the class to be non-assignable if you do not provide an assignment operator. Also once you set the member reference to refer to some object, it is not possible to change that member for referring another object. The most appropriate usage of a reference is using as a function parameter which enables pass by reference.References are cleaner and easier to use, and they do a better job of hiding information. \nReferences cannot be reassigned, however. \nIf you need to point first to one object and then to another, you must use a pointer. References cannot be null, so if any chance exists that the object in question might be null, you must not use a reference. You must use a pointer. \nIf you want to handle object manipulation on your own i.e if you want to allocate memory space for an object on the Heap rather on the Stack you must use PointerFor pointers, you need them to point to something, so pointers cost memory space.For example a function that takes an integer pointer will not take the integer variable. So you will need to create a pointer for that first to pass on to the function.As for a reference, it will not cost memory. You have an integer variable, and you can pass it as a reference variable. That\'s it. You don\'t need to create a reference variable specially for it.I prefer to use pointers. At least it is clear what you are doing.\nI have the feeling that references are mostly used because of STL and its syntax implications on code.\nBecause of that also so many C++ standard library novelties like std::move ..... to get exactly what you want, and not what you intuitively would have thought of.Use references as a last resort. Allocate an instance on the stack or the heap, use them. Use references for parameter scope to get the least impact. If you use reference because pointers are too hard for you then move to another language.   