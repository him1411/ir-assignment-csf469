How do you kill a thread in Java?See this thread by Sun on why they deprecated Thread.stop().  It goes into detail about why this was a bad method and what should be done to safely stop threads in general.  The way they recomend is to use a shared variable as a flag which asks the background thread to stop.  This variable can then be set by a different object requesting the thread terminate.  Generally you don\'t..You ask it to interrupt whatever it is doing using Thread.interrupt() (javadoc link)A good explanation of why is in the javadoc here  (java technote link)In Java threads are not killed, but the stopping of a thread is done in a cooperative way. The thread is asked to terminate and the thread can then shutdown gracefully.Often a volatile boolean field is used which the thread periodically checks and terminates when it is set to the corresponding value.I would not use a boolean to check whether the thread should terminate. If you use volatile as a field modifier, this will work reliable, but if your code becomes more complex, for instead uses other blocking methods inside the while loop, it might happen, that your code will not terminate at all or at least takes longer as you might want.Certain blocking library methods support interruption.Every thread has already a boolean flag interrupted status and you should make use of it. It can be implemented like this:Source code taken from Java Concurrency in Practice. Since the cancel() method is public you can let another thread invoke this method as you wanted.There is also a poorly named static method interrupted which clears the interrupted status of the current thread.One way is by setting a class variable and using it as a sentinel.Set an external class variable, i.e. flag = true in the above example. Set it to false to \'kill\' the thread.There is a way how you can do it. But if you had to use it, either you are a bad programmer or you are using a code written by bad programmers. So, you should think about stopping being a bad programmer or stopping using this bad code.\nThis solution is only for situations when THERE IS NO OTHER WAY.I want to add several observations, based on the comments that have accumulated.The question is rather vague. If you meant \xe2\x80\x9chow do I write a program so that a thread stops running when I want it to\xe2\x80\x9d, then various other responses should be helpful. But if you meant \xe2\x80\x9cI have an emergency with a server I cannot restart right now and I just need a particular thread to die, come what may\xe2\x80\x9d, then you need an intervention tool to match monitoring tools like jstack.For this purpose I created jkillthread. See its instructions for usage.I\'d vote for Thread.stop().As for instance you have a long lasting operation (like a network request).\nSupposedly you are waiting for a response, but it can take time and the user navigated to other UI.\nThis waiting thread is now a) useless b) potential problem because when he will get result, it\'s completely useless and he will trigger callbacks that can lead to number of errors.All of that and he can do response processing that could be CPU intense. And you, as a developer, cannot even stop it, because you can\'t throw if (Thread.currentThread().isInterrupted()) lines in all code.So the inability to forcefully stop a thread it weird.There is of course the case where you are running some kind of not-completely-trusted code. (I personally have this by allowing uploaded scripts to execute in my Java environment. Yes, there are security alarm bell ringing everywhere, but it\'s part of the application.) In this unfortunate instance you first of all are merely being hopeful by asking script writers to respect some kind of boolean run/don\'t-run signal. Your only decent fail safe is to call the stop method on the thread if, say, it runs longer than some timeout.But, this is just "decent", and not absolute, because the code could catch the ThreadDeath error (or whatever exception you explicitly throw), and not rethrow it like a gentlemanly thread is supposed to do. So, the bottom line is AFAIA there is no absolute fail safe. There is no way to gracefully kill a thread.You can try to interrupt the thread, one commons strategy is to use a poison pill to message the thread to stop itself}http://anandsekar.github.io/cancel-support-for-threads/Attempts of abrupt thread termination are well-known bad programming practice and evidence of poor application design. All threads in the multithreaded application explicitly and implicitly share the same process state and forced to cooperate with each other to keep it consistent, otherwise your application will be prone to the bugs which will be really hard to diagnose. So, it is a responsibility of developer to provide an assurance of such consistency via careful and clear application design.There are two main right solutions for the controlled threads terminations:Good and detailed explanation of the issues related to the abrupt threads termination as well as examples of wrong and right solutions for the controlled threads termination can be found here:https://www.securecoding.cert.org/confluence/display/java/THI05-J.+Do+not+use+Thread.stop%28%29+to+terminate+threadsHere are a couple of good reads on the subject:What Do You Do With InterruptedException?Shutting down threads cleanlyI didn\'t get the interrupt to work in Android, so I used this method, works perfectly: