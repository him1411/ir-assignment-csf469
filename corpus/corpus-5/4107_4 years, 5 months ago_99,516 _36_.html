In one of my development branches, I made some changes to my codebase. Before I was able to complete the features I was working on, I had to switch my current branch to master to demo some features. But just using a "git checkout master" preserved the changes I also made in my development branch, thus breaking some of the functionality in master. So what I did was commit the changes on my development branch with a commit message "temporary commit" and then checkout master for the demo.Now that I\'m done with the demo and back to work on my development branch, I would like to remove the "temporary commit" that I made while still preserving the changes I made. Is that possible?It\'s as simple as this: git reset without a --hard or --soft moves your HEAD to point to the specified commit, without changing any files. HEAD^ refers to the (first) parent commit of your current commit, which in your case is the commit before the temporary one.Note that another option is to carry on as normal, and then at the next commit point instead run:which will instead edit the most recent commit, having the same effect as above.Note that this (as with nearly every git answer) can cause problems if you\'ve already pushed the bad commit to a place where someone else may have pulled it from. Try to avoid thatThere are two ways of handling this. Which is easier depends on your situationResetIf the commit you want to get rid of was the last commit, and you have not done any additional work you can simply use git-resetTakes your branch back to the commit just before your current HEAD. However, it doesn\'t actually change the files in your working tree. As a result, the changes that were in that commit show up as modified - its like an \'uncommit\' command. In fact, I have an alias to do just that.Then you can just used git uncommit in the future to back up one commit.SquashingSquashing a commit means combining two or more commits into one. I do this quite often. In your case you have a half done feature commited, and then you would finish it off and commit again with the proper, permanent commit message.I say  above because I want to make it clear this could be any number of commits back. Run git log and find the commit you want to get rid of, copy its SHA1 and use it in place of . Git will take you into interactive rebase mode. It will show all the commits between your current state and whatever you put in place of . So if  is 10 commits ago, it will show you all 10 commits.In front of each commit, it will have the word pick. Find the commit you want to get rid of and change it from pick to fixup or squash. Using fixup simply discards that commits message and merges the changes into its immediate predecessor in the list. The squash keyword does the same thing, but allows you to edit the commit message of the newly combined commit.Note that the commits will be re-committed in the order they show up on the list when you exit the editor. So if you made a temporary commit, then did other work on the same branch, and completed the feature in a later commit, then using rebase would allow you to re-sort the commits and squash them.WARNING:Rebasing modifies history - DONT do this to any commits you have already shared with other developers.StashingIn the future, to avoid this problem consider using git stash to temporarily store uncommitted work.This will store your current changes off to the side in your stash list. Above is the most explicit version of the stash command, allowing for a comment to describe what you are stashing. You can also simply run git stash and nothing else, but no message will be stored. You can browse your stash list with...This will show you all your stashes, what branches they were done on, and the message and at the beginning of each line, and identifier for that stash which looks like this stash@{#} where # is its position in the array of stashes.To restore a stash (which can be done on any branch, regardless of where the stash was originally created) you simply run...Again, there # is the position in the array of stashes. If the stash you want to restore is in the 0 position - that is, if it was the most recent stash. Then you can just run the command without specifying the stash position, git will assume you mean the last one: git stash apply.So, for example, if I find myself working on the wrong branch - I may run the following sequence of commands.In your case you moved around branches a bit more, but the same idea still applies.Hope this helps.Yes, you can delete your commit without deleting the changes:\n    git reset @~In my case, I already pushed to the repo. Ouch! You can revert a specific commit while keeping the changes in your local files by doing: This way I was able to keep the changes which I needed and undid a commit which had already been pushed.One more way to do it.Add commit on the top of temporary commit and then do:To merge two commits into one (command will open text file with explicit instructions, edit it).