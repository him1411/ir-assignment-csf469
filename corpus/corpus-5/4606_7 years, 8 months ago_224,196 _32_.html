In Solution properties, I have Configuration set to "release" for my one and only project. At the beginning of the main routine, I have this code, and it is showing "Mode=Debug". \nI also have these two lines at the very top: Am I testing the right variable? My goal is to set different defaults for variables based on debug vs release mode. Remove the #define DEBUG in your code. Set preprocessors in the build configuration for that specific build (DEBUG/_DEBUG should be defined in VS already).The reason it prints "Mode=Debug" is because of your #define and then skips the elif.Also, the right way to check is:Don\'t check for RELEASEBy default, Visual Studio defines DEBUG if project is compiled in Debug mode and doesn\'t define it if it\'s in Release mode. RELEASE is not defined in Release mode by default. Use something like this:If you want to do something only in release mode:Also, it\'s worth pointing out that you can use [Conditional("DEBUG")] attribute on methods that return void to have them only executed if a certain symbol is defined. The compiler would remove all calls to those methods if the symbol is not defined:I prefer checking it like this vs looking for #defines:With the caveat that of course you could compile and deploy something in debug mode but still not have the debugger attached.I\'m not a huge fan of the #if stuff, especially if you spread it all around your code base as it will give you problems where Debug builds pass but Release builds fail if you\'re not careful.So here\'s what I have come up with (inspired by #ifdef in C#):If you are trying to use the variable defined for the build type you should remove the two lines ...... these will cause the #if (DEBUG) to always be true.Also there isn\'t a default Conditional compilation symbol for RELEASE.  If you want to define one go to the project properties, click on the Build tab and then add RELEASE to the Conditional compilation symbols text box under the General heading.The other option would be to do this...The method Debug.Assert has conditional attribute DEBUG. If it is not defined, the call and the assignment isDebug = true are eliminated:If the symbol is defined, the call is included; otherwise, the call (including evaluation of the parameters of the call) is omitted.If DEBUG is defined, isDebug is set to true (and passed to Debug.Assert , which does nothing in that case).Remove your defines at the topNameSpaceMethodSlightly modified (bastardized?) version of the answer by Tod Thomson as a static function rather than a separate class (I wanted to be able to call it in a WebForm viewbinding from a viewutils class I already had included).A tip that may save you a lot of time - don\'t forget that even if you choose debug under the build configuration (on vs2012/13 menu it\'s under BUILD => CONFIGURATION MANAGER) - that\'s not enough. You need to pay attention to the PUBLISH Configuration, as such: Since the purpose of these COMPILER directives are to tell the compiler NOT to include code, debug code,beta code, or perhaps code that is needed by all of your end users, except say those the advertising department, i.e. #Define AdDept you want to be able include or remove them based on your needs. Without having to change your source code if for example a non AdDept merges into the AdDept. Then all that needs to be done is to include the #AdDept directive in the compiler options properties page of an existing version of the program and do a compile and wa la! the merged program\'s code springs alive!.You might also want to use a declarative for a new process that is not ready for prime time or that can not be active in the code until it\'s time to release it.Anyhow, that\'s the way I do it.