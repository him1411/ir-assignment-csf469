I\'m just revising chapter 4 of C# in Depth which deals with nullable types, and I\'m adding a section about using the "as" operator, which allows you to write:I thought this was really neat, and that it could improve performance over the C# 1 equivalent, using "is" followed by a cast - after all, this way we only need to ask for dynamic type checking once, and then a simple value check.This appears not to be the case, however. I\'ve included a sample test app below, which basically sums all the integers within an object array - but the array contains a lot of null references and string references as well as boxed integers. The benchmark measures the code you\'d have to use in C# 1, the code using the "as" operator, and just for kicks a LINQ solution. To my astonishment, the C# 1 code is 20 times faster in this case - and even the LINQ code (which I\'d have expected to be slower, given the iterators involved) beats the "as" code.Is the .NET implementation of isinst for nullable types just really slow? Is it the additional unbox.any that causes the problem? Is there another explanation for this? At the moment it feels like I\'m going to have to include a warning against using this in performance sensitive situations...Results:Cast: 10000000 : 121\n  As: 10000000 : 2211\n  LINQ: 10000000 : 2143  Code:Clearly the machine code the JIT compiler can generate for the first case is much more efficient.  One rule that really helps there is that an object can only be unboxed to a variable that has the same type as the boxed value.  That allows the JIT compiler to generate very efficient code, no value conversions have to be considered.The is operator test is easy, just check if the object isn\'t null and is of the expected type, takes but a few machine code instructions.  The cast is also easy, the JIT compiler knows the location of the value bits in the object and uses them directly.  No copying or conversion occurs, all machine code is inline and takes but about a dozen instructions.  This needed to be really efficient back in .NET 1.0 when boxing was common.Casting to int? takes a lot more work.  The value representation of the boxed integer is not compatible with the memory layout of Nullable<int>.  A conversion is required and the code is tricky due to possible boxed enum types.  The JIT compiler generates a call to a CLR helper function named JIT_Unbox_Nullable to get the job done.  This is a general purpose function for any value type, lots of code there to check types.  And the value is copied.  Hard to estimate the cost since this code is locked up inside mscorwks.dll, but hundreds of machine code instructions is likely.The Linq OfType() extension method also uses the is operator and the cast.  This is however a cast to a generic type.  The JIT compiler generates a call to a helper function, JIT_Unbox() that can perform a cast to an arbitrary value type.  I don\'t have a great explanation why it is as slow as the cast to Nullable<int>, given that less work ought to be necessary.  I suspect that ngen.exe might cause trouble here.It seems to me that the isinst is just really slow on nullable types. In method FindSumWithCast I changedtowhich also significantly slows down execution. The only differenc in IL I can see is that gets changed toThis originally started out as a Comment to Hans Passant\'s excellent answer, but it got too long so I want to add a few bits here:First, the C# as operator will emit an isinst IL instruction (so does the is operator). (Another interesting instruction is castclass, emited when you do a direct cast and the compiler knows that runtime checking cannot be ommited.)Here is what isinst does (ECMA 335 Partition III, 4.6):Format: isinst typeToktypeTok is a metadata token (a typeref, typedef or typespec), indicating the desired class.If typeTok is a non-nullable value type or a generic parameter type it is interpreted as \xe2\x80\x9cboxed\xe2\x80\x9d typeTok.If typeTok is a nullable type, Nullable<T>, it is interpreted as \xe2\x80\x9cboxed\xe2\x80\x9d TMost importantly:If the actual type (not the verifier tracked type) of obj is verifier-assignable-to the type typeTok then isinst succeeds and obj (as result) is returned unchanged while verification tracks its type as typeTok. Unlike coercions (\xc2\xa71.6) and conversions (\xc2\xa73.27), isinst never changes the actual type of an object and preserves object identity (see Partition I).So, the performance killer isn\'t isinst in this case, but the additional unbox.any. This wasn\'t clear from Hans\' answer, as he looked at the JITed code only. In general, the C# compiler will emit an unbox.any after a isinst T? (but will omit it in case you do isinst T, when T is a reference type).Why does it do that? isinst T? never has the effect that would have been obvious, i.e. you get back a T?. Instead, all these instructions ensure is that you have a "boxed T" that can be unboxed to T?. To get an actual T?, we still need to unbox our "boxed T" to T?, which is why the compiler emits an unbox.any after isinst. If you think about it, this makes sense because the "box format" for T? is just a "boxed T" and making castclass and isinst perform the unbox would be inconsistent.Backing up Hans\' finding with some information from the standard, here it goes:(ECMA 335 Partition III, 4.33): unbox.anyWhen applied to the boxed form of a value type, the unbox.any instruction extracts the value contained within obj (of type O). (It is equivalent to unbox followed by ldobj.) When applied to a reference type, the unbox.any instruction has the same effect as castclass typeTok.(ECMA 335 Partition III, 4.32): unboxTypically, unbox simply computes the address of the value type that is already present inside of the boxed object. This approach is not possible when unboxing nullable value types. Because Nullable<T> values are converted to boxed Ts during the box operation, an implementation often must manufacture a new Nullable<T> on the heap and compute the address to the newly allocated object.Interestingly, I passed on feedback about operator support via dynamic being an order-of-magnitude slower for Nullable<T> (similar to this early test) - I suspect for very similar reasons.Gotta love Nullable<T>. Another fun one is that even though the JIT spots (and removes) null for non-nullable structs, it borks it for Nullable<T>:This is the result of FindSumWithAsAndHas above: alt text http://www.freeimagehosting.net/uploads/9e3c0bfb75.pngThis is the result of FindSumWithCast: alt text http://www.freeimagehosting.net/uploads/ce8a5a3934.pngFindings:Using as, it test first if an object is an instance of Int32; under the hood it is using isinst Int32 (which is similar to hand-written code: if (o is int) ). And using as, it also unconditionally unbox the object.  And it\'s a real performance-killer to call a property(it\'s still a function under the hood), IL_0027Using cast, you test first if object is an int if (o is int); under the hood this is using isinst Int32.  If it is an instance of int, then you can safely unbox the value, IL_002DSimply put, this is the pseudo-code of using as approach:And this is the pseudo-code of using cast approach:So the cast ((int)a[i], well the syntax looks like a cast, but it\'s actually unboxing, cast and unboxing share the same syntax, next time I\'ll be pedantic with the right terminology) approach is really faster, you only needed to unbox a value when an object is decidedly an int.  The same thing can\'t be said to using an as approach.Profiling further:Output: What can we infer from these figures?    I don\'t have time to try it, but you may want to have:asYou are creating a new object each time, which won\'t completely explain the problem, but may contribute.I tried the exact type check constructtypeof(int) == item.GetType(), which performs as fast as the item is int version, and always returns the number (emphasis: even if you wrote a Nullable<int> to the array, you would need to use typeof(int)). You also need an additional null != item check here.Howevertypeof(int?) == item.GetType() stays fast (in contrast to item is int?), but always returns false.The typeof-construct is in my eyes the fastest way for exact type checking, as it uses the RuntimeTypeHandle. Since the exact types in this case don\'t match with nullable, my guess is, is/as have to do additional heavylifting here on ensuring that it is in fact an instance of a Nullable type.And honestly: what does your is Nullable<xxx> plus HasValue buy you? Nothing. You can always go directly to the underlying (value) type (in this case). You either get the value or "no, not an instance of the type you were asking for". Even if you wrote (int?)null to the array, the type check will return false.Outputs:[EDIT: 2010-06-19]Note: Previous test was done inside VS, configuration debug, using VS2009, using Core i7(company development machine).  The following was done on my machine using Core 2 Duo, using VS2010In order to keep this answer up-to-date, it\'s worth mentioning that the most of the discussion on this page is now moot now with C# 7.1 and .NET 4.7 which supports a slim syntax that also produces the best IL code.The OP\'s original example...becomes simply...I have found that the most common use for the new syntax is when you are writing a .NET value type (i.e. struct in C#) that implements IEquatable<MyStruct> (as most should). After implementing the strongly-typed Equals(MyStruct other) method, you can now gracefully redirect the untyped Equals(Object obj) override (inherited from Object) to it as follows:Â Appendix: The Release build IL code for the first two example functions shown above in this answer (respectively) are given here. While the new syntax gives slightly smaller IL code, it mostly wins big by making zero calls (vs. two) and avoiding the unbox operation altogether when possible.