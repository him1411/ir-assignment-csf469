With git remote prune origin I can remove the local branches that are not any more on the remote.But I want to remove also those local branches that were created from those remote branches (a check if they are unmerged would be nice).How can I do this?After pruning, you can get the list of remote branches with git branch -r.  The list of branches with their remote tracking branch can be retrieved with git branch -vv.  So using these two lists you can find the remote tracking branches that are not in the list of remotes.This line should do the trick (requires bash or zsh, won\'t work with standard Bourne shell):git branch -r | awk \'{print $1}\' | egrep -v -f /dev/fd/0 <(git branch -vv | grep origin) | awk \'{print $1}\' | xargs git branch -dThis string gets the list of remote branches and passes it into egrep through the standard input.  And filters the branches that have a remote tracking branch (using git branch -vv and filtering for those that have origin) then getting the first column of that output which will be the branch name.  Finally passing all the branch names into the delete branch command.Since it is using the -d option, it will not delete branches that have not been merged into the branch that you are on when you run this command.Also remember that you\'ll need to run git fetch --prune first, otherwise git branch -r will still see the remote branches.If you want to delete all local branches that are already merged into master, you can use the following command:More info.Amidst the information presented by git help fetch, there is this little item:So, perhaps, git fetch -p is what you are looking for?EDIT: Ok, for those still debating this answer 3 years after the fact, here\'s a little more information on why I presented this answer...First, the OP says they want to "remove also those local branches that were created from those remote branches [that are not any more on the remote]". This is not unambiguously possible in git. Here\'s an example.Let\'s say I have a repo on a central server, and it has two branches, called A and B. If I clone that repo to my local system, my clone will have local refs (not actual branches yet) called origin/A and origin/B. Now let\'s say I do the following:The pertinent facts here are that I for some reason chose to create a branch on my local repo that has a different name than its origin, and I also have a local branch that does not (yet) exist on the origin repo.Now let\'s say I remove both the A and B branches on the remote repo and update my local repo (git fetch of some form), which causes my local refs origin/A and origin/B to disappear. Now, my local repo has three branches still, A, Z, and C. None of these have a corresponding branch on the remote repo. Two of them were "created from ... remote branches", but even if I know that there used to be a branch called B on the origin, I have no way to know that Z was created from B, because it was renamed in the process, probably for a good reason. So, really, without some external process recording branch origin metadata, or a human who knows the history, it is impossible to tell which of the three branches, if any, the OP is targeting for removal. Without some external information that git does not automatically maintain for you, git fetch -p is about as close as you can get, and any automatic method for literally attempting what the OP asked runs the risk of either deleting too many branches, or missing some that the OP would otherwise want deleted.There are other scenarios, as well, such as if I create three separate branches off origin/A to test three different approaches to something, and then origin/A goes away. Now I have three branches, which obviously can\'t all match name-wise, but they were created from origin/A, and so a literal interpretation of the OPs question would require removing all three. However, that may not be desirable, if you could even find a reliable way to match them...This will delete the local branches for which the remote tracking branches have been pruned. (Make sure you are on master branch!)Details: git branch -vv displays "gone" for local branches that the remote has been pruned.-d will check if it has been merged (-D will delete it regardless)One can configure Git to automatically remove references to deleted remote branches when fetching:When calling git fetch or git pull afterwards, references to deleted remote branches get removed automatically.It will list the local branches whose remote tracking branch is deleted from remoteIf you want to de-reference these local branches from local which are un trackedIf using Windows and Powershell, you can use the following to delete all local branches that have been merged into the branch currently checked out:ExplanationIt\'s worth running git branch --merged by itself first just to make sure it\'s only going to remove what you expect it to.(Ported/automated from http://railsware.com/blog/2014/08/11/git-housekeeping-tutorial-clean-up-outdated-branches-in-local-and-remote-repositories/.)not sure how to do it all at once, but git git branch -d <branchname> will delete a local branch ONLY if it is completely merged. Note the lowercase d.git branch -D <branchname> (note the capital D) will delete a local branch regardless of its merged status.Even shorter and safer one-liner:Be sure to checkout to branch that is not merged yet, before run it. Because you can not delete branch that you are currently checked in.Using a variant on @wisbucky\'s answer, I added the following as an alias to my ~/.gitconfig file:With this, a simple git pruneitgood will clean up both local & remote branches that are no longer needed after merges.Based on the answers above I came with this one line solution:There\'s a neat NPM package that does it for you (and it should work cross platform).Install it with: npm install -g git-removed-branchesAnd then git removed-branches will show you all the stale local branches, and git removed-branches --prune to actually delete them.More info here.Schleis\' variant does not work for me (Ubuntu 12.04), so let me propose my (clear and shiny :) variants:Variant 1 (I would prefer this option):Variant 2:a. Dry-run:b. Remove branches:I have turned the accepted answer into a robust script. You\'ll find it in my git-extensions repository.Following is an adaptation of @wisbucky\'s answer for Windows users:for /f "tokens=1" %i in (\'git branch -vv ^| findstr ": gone]"\') DO git branch %i -dI use posh-git and unfortunately PS doesn\'t like the naked for, so I created a plain \'ol command script named PruneOrphanBranches.cmd:Call it with no parameters to see a list, and then call it with "-d" to perform the actual deletion or "-D" for any branches that are not fully merged but which you want to delete anyway.Try this in git bash, to fetch and prune references to deleted branches, and then prune the local branches that were tracking the removed ones:Remember to checkout first a branch that won\'t be deleted, so that does not block the deleting of the branch.Delete any branch that isn\'t up to date with masterif you are removing from your local computer, here is my direct way:Just go to: C:\\Repo\\your-project\\.git\\refs\\headsEach branch is a file created under this folder, just remove the files which match your branch namesIt\'s hard to find method on Windows, I am using sourcetree, and I do not want to delete one by one. I just figure out this way, and it did rescue me on my Windows. I\'m pretty sure that git remote prune origin is what you want.You can run it as git remote prune origin --dry-run to see what it would do without making any changes.Using the GUI? Manual procedure, but quick and easy.Select "Branch -> Delete". You can select multiple branches with ctrl-click (windows) and remove all of them.