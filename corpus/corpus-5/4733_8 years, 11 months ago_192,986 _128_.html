When scripting in bash or any other shell in *NIX, while running a command that will take more than a few seconds, a progress bar is needed.For example, copying a big file, opening a big tar file.What ways do you recommend to add progress bars to shell scripts?You can implement this by overwriting a line.  Use \\r to go back to the beginning of the line without writing \\n to the terminal.Write \\n when you\'re done to advance the line.Use echo -ne to:Here\'s a demo:Some posts have showed how to display the command\'s progress.  In order to calculate it, you\'ll need to see how much you\'ve progressed.  On BSD systems some commands, such as dd(1),  accept a SIGINFO signal, and will report their progress.  On Linux systems some commands will respond similarly to SIGUSR1.  If this facility is available, you can pipe your input through dd to monitor the number of bytes processed.Alternatively, you can use lsof to obtain the offset of the file\'s read pointer, and thereby calculate the progress.  I\'ve written a command, named pmonitor, that displays the progress of processing a specified process or file.  With it you can do things, such as the following.An earlier version of Linux and FreeBSD shell scripts appears on my blog.You may also be interested in how to do a spinner:Sure!Each time the loop iterates, it displays the next character in the sp\n  string, wrapping around as it reaches the end. (i is the position of\n  the current character to display and ${#sp} is the length of the sp\n  string).The \\b string is replaced by a \'backspace\' character. Alternatively,\n  you could play with \\r to go back to the beginning of the line.If you want it to slow down, put a sleep command inside the loop\n  (after the printf).A POSIX equivalent would be:If you already have a loop which does a lot of work, you can call the\n  following function at the beginning of each iteration to update the\n  spinner:use the linux command pv:http://linux.die.net/man/1/pvit doesn\'t know the size if it\'s in the middle of the stream, but it gives a speed and total and from there you can figure out how long it should take and get feedback so you know it hasn\'t hung.Got an easy progress bar function that i wrote the other day:Or snag it from,\nhttps://github.com/fearside/ProgressBar/GNU tar has a useful option which gives a functionality of a simple progress bar.(...) Another available checkpoint action is \xe2\x80\x98dot\xe2\x80\x99 (or \xe2\x80\x98.\xe2\x80\x99). It instructs tar to print a single dot on the standard listing stream, e.g.:The same effect may be obtained by:A simpler method that works on my system using the pipeview ( pv ) utility.This lets you visualize that a command is still executing:This will create an infinite while loop that executes in the background and echoes a "." every second. This will display . in the shell. Run the tar command or any a command you want. When that command finishes executing then kill the last job running in the background - which is the infinite while loop.I was looking for something more sexy than the selected answer, so did my own script.I put it on github progress-bar.shFirst of all bar is not the only one pipe progress meter. The other (maybe even more known) is pv (pipe viewer). Secondly bar and pv can be used for example like this:or even:one useful trick if you want to make use of bar and pv in commands that are working with files given in arguments, like e.g. copy file1 file2, is to use process substitution:Process substitution is a bash magic thing that creates temporary fifo pipe files /dev/fd/ and connect stdout from runned process (inside parenthesis) through this pipe and copy sees it just like an ordinary file (with one exception, it can only read it forwards).Update:bar command itself allows also for copying. After man bar:But process substitution is in my opinion more generic way to do it. An it uses cp program itself.Haven\'t seen anything similar so... my very simple solution:I used it long time ago in a simple "hacking video" to simulate typing code. ;)Most unix commands will not give you the sort of direct feedback from which you can do this.\nSome will give you output on stdout or stderr that you can use.For something like tar you could use the -v switch and pipe the output to a program that updates a small animation for each line it reads.  As tar writes out a list of files it\'s unravelled the program can update the animation.  To do a percent complete you would have to know the number of files and count the lines.cp doesn\'t give this sort of output as far as I know.  To monitor the progress of cp you would have to monitor the source and destination files and watch the size of the destination.  You could write a small c program using the stat (2) system call to get the file size.  This would read the size of the source then poll the destination file and update a % complete bar based on the size of the file written to date.My solution displays the percentage of the tarball that\nis currently being uncompressed and written. I use this\nwhen writing out 2GB root filesystem images. You really\nneed a progress bar for these things. What I do is use\ngzip --list to get the total uncompressed size of the\ntarball. From that I calculate the blocking-factor needed\nto divide the file into 100 parts. Finally, I print a\ncheckpoint message for each block. For a 2GB file this\ngives about 10MB a block. If that is too big then you can\ndivide the BLOCKING_FACTOR by 10 or 100, but then it\'s\nharder to print pretty output in terms of a percentage.Assuming you are using Bash then you can use the\nfollowing shell functionI prefer to use dialog with the --gauge param. Is used very often in .deb package installations and other basic configuration stuff of many distros. So you don\'t need to reinvent the wheel... againJust put an int value from 1 to 100 @stdin. One basic and silly example:I have this /bin/Wait file (with chmod u+x perms) for cooking purposes :P\nSo I can put:Wait "34 min" "warm up the oven"or Wait "dec 31" "happy new year"for me easiest to use and best looking so far is command pv or bar like some guy already wrotefor example: need to make a backup of entire drive with ddnormally you use dd if="$input_drive_path" of="$output_file_path" with pv you can make it like this : dd if="$input_drive_path" | pv | dd of="$output_file_path" and the progress goes directly to STDOUT as this:after it is done summary comes upI would also like to contribute my own progress barIt achieves sub-character precision by using Half unicode blocksCode is includedI used an answer from Creating string of repeated characters in shell script for char repeating. I have two relatively small bash versions for scripts that need to display progress bar (for example, a loop that goes through many files, but not useful for big tar files or copy operations). The faster one consists of two functions, one to prepare the strings for bar display:and one to display a progress bar:It could be used as:which means prepare strings for bar with 50 "#" characters, and after that:will display the number of "#" characters that corresponds to 35/80 ratio:Be aware that function displays the bar on the same line over and over until you (or some other program) prints a newline. If you put -1 as first parameter, the bar would be erased:The slower version is all in one function:and it can be used as (the same example as above):If you need progressbar on stderr, just add >&2 at the end of each printf command. To indicate progress of activity, try the following commands:OROROROne can use flags/variables inside the while loop to check and display the value/extent of progress.Many answers describe writing your own commands for printing out \'\\r\' + $some_sort_of_progress_msg. The problem sometimes is that printing out hundreds of these updates per second will slow down the process.However, if any of your processes produce output (eg 7z a -r newZipFile myFolder will output each filename as it compresses it) then a simpler, fast, painless and customisable solution exists.Install the python module tqdm.Help: tqdm -h. An example using more options:As a bonus you can also use tqdm to wrap iterables in python code.https://github.com/tqdm/tqdm/blob/master/README.rst#moduleBased on the work of Edouard Lopez, I created a progress bar that fits the size of the screen, whatever it is. Check it out.It\'s also posted on Git Hub.EnjoyThis is only applicable using gnome zenity.  Zenity provides a great native interface to bash scripts:\nhttps://help.gnome.org/users/zenity/stable/From Zenity Progress Bar  Example:I did a pure shell version for an embedded system taking advantage of:/usr/bin/dd\'s SIGUSR1 signal handling feature.Basically, if you send a \'kill SIGUSR1 $(pid_of_running_dd_process)\', it\'ll output\na summary of throughput speed and amount transferred. backgrounding dd and then querying it regularly for updates, and generating\nhash ticks like old-school ftp clients used to.Using /dev/stdout as the destination for non-stdout friendly programs like scpThe end result allows you to take any file transfer operation and get progress update that looks like old-school FTP \'hash\' output where you\'d just get a hash mark for every X bytes.This is hardly production quality code, but you get the idea. I think it\'s cute. For what it\'s worth, the actual byte-count might not be reflected correctly in the number of hashes - you may have one more or less depending on rounding issues. Don\'t use this as part of a test script, it\'s just eye-candy. And, yes, I\'m aware this is terribly inefficient - it\'s a shell script and I make no apologies for it. Examples with wget, scp and tftp provided at the end. It should work with anything that has emits data. Make sure to use /dev/stdout for programs that aren\'t stdout friendly.Examples:I have built on the answer provided by fearsideThis connects to an Oracle database to retrieve the progress of an RMAN restore.This is a psychedelic progressbar for bash scripting by nExace. It can be called from command line as \'./progressbar x y\' where \'x\' is a time in seconds and \'y\' is a message associated with that portion of the progress.The inner progressbar() function itself is good standalone as well if you want other portions of your script to control the progressbar. For instance, sending \'progressbar 10 "Creating directory tree";\' will display: Of course it will be nicely psychedelic though...First execute the process to the background, then watch it\'s running status frequently,that was running print the pattern and again check it status was running or not;Using while loop to watch the status of the process frequently.use the pgrep or any other command to watch and getting running status of a process.if using pgrep redirect the unnecessary output to /dev/null as needed.Code:This "#" will printed until sleep terminate,this method used to implement the progress bar for progress time of program.you can also use this method to the commands to shell scripts for analyze it process time as visual.BUG:\n this pgrep method doesn\'t works in all situations,unexpectedly the another process was running with same name, the while loop does not end.so getting the process running status by specify it\'s PID, using\nmay the process can available with some commands, the command ps a will list all the process with id,you need grep to find-out the pid of the specified processI wanted to track progress based on the number of lines a command output against a target number of lines from a previous run:Then use it like this:It outputs a progress bar that looks something like this:The bar grows as the number of lines output reaches the target. If the number of lines exceeds the target, the bar starts over (hopefully the target is good).BTW: I\'m using bash on Mac OSX. I based this code on a spinner from mariascio.could create a function that draws this on a scale say 1-10 for the number of bars :In case you have to show a temporal progress bar (by knowing in advance the showing time), you can use Python as follows:Then, assuming you saved the Python script as progressbar.py, it\'s possible to show the progress bar from your bash script by running the following command:It would show a progress bar sized 50 characters and "running" for 10 seconds.To make a tar progress barWhere "19" is the number of files in the tar divided the length of the intended progress bar.\nExample: the .tgz contains 140 files and you\'ll want a progress bar of 76 ".", you can put -L 2.You\'ll need nothing else.Once I also had a busy script which was occupied for hours without showing any progress. So I implemented a function which mainly includes the techniques of the previous answers: