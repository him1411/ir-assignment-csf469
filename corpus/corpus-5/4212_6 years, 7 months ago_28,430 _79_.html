Please take note of the updates at the end of this post.Update: I have created a public project on GitHub for this library!I would like to have a single template that once and for all takes care of pretty-printing all STL containers via operator<<. In pseudo code, I\'m looking for something like this:Now I\'ve seen plenty of template magic here on SO that I never thought possible, so I\'m wondering if anyone can suggest something that would match all containers C. Maybe something trait-ish that can figure out if something has the necessary iterator?Many thanks!Update (and solution)After raising this problem again on Channel 9, I got a fantastic answer from Sven Groot, which, combined with a bit of SFINAE type traiting, appears to solve the problem in a completely general and nestable fashion. The delimiters may be individually specialised, an example specialization for std::set is included, as well as an example of using custom delimiters.The helper "wrap_array()" can be used to print raw C arrays. Update: Pairs and tuples are available for printing; default delimiters are round brackets.The enable-if type trait requires C++0x, but with some modifications it should be possible to make a C++98 version of this. Tuples require variadic templates, hence C++0x.I have asked Sven to post the solution here so that I can accept it, but in the meantime I\'d like to post the code myself for reference. (Update: Sven has now posted his code below, which I made the accepted answer. My own code uses container type traits, which work for me but may cause unexpected behaviour with non-container classes that provide iterators.)Header (prettyprint.h):Usage example:Further ideas for improvements:Recent updates:Notes:Thank you to everyone who contributed!Note: If you are looking for a quick way to deploy custom delimiters, here is one way using type erasure. We assume that you have already constructed a delimiter class, say MyDel, like so:Now we want to be able to write std::cout << MyPrinter(v) << std::endl; for some container v using those delimiters. MyPrinter will be a type-erasing class, like so:This solution was inspired by Marcelo\'s solution, with a few changes:Like Marcelo\'s version, it uses an is_container type trait that must be specialized for all containers that are to be supported. It may be possible to use a trait to check for value_type, const_iterator, begin()/end(), but I\'m not sure I\'d recommend that since it might match things that match those criteria but aren\'t actually containers, like std::basic_string. Also like Marcelo\'s version, it uses templates that can be specialized to specify the delimiters to use.The major difference is that I\'ve built my version around a pretty_ostream_iterator, which works similar to the std::ostream_iterator but doesn\'t print a delimiter after the last item. Formatting the containers is done by the print_container_helper, which can be used directly to print containers without an is_container trait, or to specify a different delimiters type.I\'ve also defined is_container and delimiters so it will work for containers with non-standard predicates or allocators, and for both char and wchar_t. The operator<< function itself is also defined to work with both char and wchar_t streams.Finally, I\'ve used std::enable_if, which is available as part of C++0x, and works in Visual C++ 2010 and g++ 4.3 (needs the -std=c++0x flag) and later. This way there is no dependency on Boost.This has been edited a few times, and we have decided to call the main class that wraps a collection RangePrinterThis should work automatically with any collection once you have written the one-time operator<< overload, except that you will need a special one for maps to print the pair, and may want to customise the delimiter there.You could also have a special "print" function to use on the item instead of just outputting it direct. A bit like STL algorithms allow you to pass in custom predicates. With map you would use it this way, with a custom printer for the std::pair.Your "default" printer would just output it to the stream.Ok, let\'s work on a custom printer. I will change my outer class to RangePrinter. So we have 2 iterators and some delimiters but have not customised how to print the actual items.Now by default it will work for maps as long as the key and value types are both printable and you can put in your own special item printer for when they are not (as you can with any other type), or if you do not want = as the delimiter.I am moving the free-function to create these to the end now:A free-function (iterator version) would look like something this and you could even have defaults:You could then use it for std::set byYou can also write free-function version that take a custom printer and ones that take two iterators. In any case they will resolve the template parameters for you, and you will be able to pass them through as temporaries.Here is a working library, presented as a complete working program, that I just hacked together:It currently only works with vector and set, but can be made to work with most containers, just by expanding on the IsContainer specializations. I haven\'t thought much about whether this code is minimal, but I can\'t immediately think of anything I could strip out as redundant.EDIT: Just for kicks, I included a version that handles arrays. I had to exclude char arrays to avoid further ambiguities; it might still get into trouble with wchar_t[].I am going to add another answer here, because I have come up with a different approach to my previous one, and that is to use locale facets.The basics are hereEssentially what you do is:I like this method because you can use a default print whilst still being able to use a custom override.The downsides are needing a library for your facet if used in multiple projects (so can\'t just be headers-only) and also the fact that you need to beware about the expense of creating a new locale object. I have written this as a new solution rather than modify my other one because I believe both approaches can be correct and you take your pick.The code proved to be handy on several occasions now and I feel the expense to get into customization as usage is quite low. Thus, I decided to release it under MIT license and provide a github repository where the header and a small example file can be downloaded. A \'decoration\' in terms of this answer is a set of prefix-string, delimiter-string and a postfix-string.\nWhere the prefix string is inserted into a stream before and the postfix string after the values of a container (see 2. Target containers).\nThe delimiter string is inserted between the values of the respective container.Note: Actually, this answer does not address the question to 100% since the decoration is not strictly compile time constant because runtime checks are required to check whether a custom decoration has been applied to the current stream.\nNevertheless, I think it has some decent features.Note2: May have minor bugs since it is not yet well tested.It is to be kept as easy as... with respect to specific stream objector with respect to all streams:If no pretty::decor<T> object for this stream has been set up explicitly pretty::defaulted<T, charT, chartraitT>::decoration() is called to obtain the default decoration for the given type.\nThe class pretty::defaulted is to be specialized to customize default decorations.Target objects obj for the \'pretty decoration\' of this code are objects having eitherThe code includes a trait for identification of classes with range features (begin/end).\n(There\'s no check included, whether begin(obj) == end(obj) is a valid expression, though.)The code provides operator<<s in the global namespace that only apply for classes not having a more specialized version of operator<< available.\nTherefore, in example std::string is not printed using the operator in this code although having a valid begin/end pair.Decorations can be imposed seperately for every type (except different tuples) and stream (not stream type!).\n(I.e. a std::vector<int> can have a different decorations for different stream objects.)The default prefix is "" (nothing) as is the default postfix, while the default delimiter is ", " (comma+space).The struct defaulted has a static member function decoration() returning a decor object which includes the default values for the given type.Cutomize default array printing:Print an arry array:The macro expands toenabling the above partial specialization to be rewritten toor inserting a full specialization likeAnother macro for wchar_t streams is included: PRETTY_DEFAULT_WDECORATION.The function pretty::decoration is used to impose a decoration on a certain stream.\nThere are overloads taking either \n- one string argument being the delimiter (adopting prefix and postfix from the defaulted class)\n- or three string arguments assembling the complete decorationInstead of allowing a specialization for every possible tuple type, this code applies any decoration available for std::tuple<void*> to all kind of std::tuple<...>s.To go back to the defaulted decoration for a given type use pretty::clear function template on the stream s.Printing "matrix-like" with newline delimiterPrintsMy solution is simple.h, which is part of scc package. All std containers, maps, sets, c-arrays are printable.The goal here is to use ADL to do customization of how we pretty print.You pass in a formatter tag, and override 4 functions (before, after, between and descend) in the tag\'s namespace.  This changes how the formatter prints \'adornments\' when iterating over containers.A default formatter that does {(a->b),(c->d)} for maps, (a,b,c) for tupleoids, "hello" for strings, [x,y,z] for everything else included.It should "just work" with 3rd party iterable types (and treat them like "everything else").If you want custom adornments for your 3rd party iterables, simply create your own tag.  It will take a bit of work to handle map descent (you need to overload pretty_print_descend( your_tag to return pretty_print::decorator::map_magic_tag<your_tag>).  Maybe there is a cleaner way to do this, not sure.A little library to detect iterability, and tuple-ness:A library that lets us visit the contents of an iterable or tuple type object:A pretty printing library:Test code:live exampleThis does use C++14 features (some _t aliases, and auto&& lambdas), but none are essential.