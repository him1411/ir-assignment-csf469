What is an elegant way to find all the permutations of a string. E.g. ba, would be ba and ab, but what about abcdefgh? Is there any example Java implementation?(via Introduction to Programming in Java)Use recursion.Here is my solution that is based on the idea of the book "Cracking the Coding Interview" (P54):Running output of string "abcd":Step 1: Merge [a] and b:\n[ba, ab]Step 2: Merge [ba, ab] and c:\n[cba, bca, bac, cab, acb, abc]Step 3: Merge [cba, bca, bac, cab, acb, abc] and d:\n[dcba, cdba, cbda, cbad, dbca, bdca, bcda, bcad, dbac, bdac, badc, bacd, dcab, cdab, cadb, cabd, dacb, adcb, acdb, acbd, dabc, adbc, abdc, abcd]Of all the solutions given here and in other forums, i liked Mark Byers the most. That description actually made me think and code it myself.\nToo bad i cannot voteup his solution as i am newbie.\nAnyways here is my implementation of his descriptionI prefer this solution ahead of the first one in this thread because this solution uses StringBuffer.I wouldn\'t say my solution doesn\'t create any temporary string (it actually does in system.out.println where the toString() of StringBuffer is called). But i just feel this is better than the first solution where too many string literals are created . May be some performance guy out there can evalute this in terms of \'memory\' (for \'time\' it already lags due to that extra \'swap\')A very basic solution in Java is to use recursion + Set ( to avoid repetitions ) if you want to store and return the solution strings :All the previous contributors have done a great job explaining and providing the code. I thought I should share this approach too because it might help someone too. The solution is based on (heaps\' algorithm ) Couple of things: Notice the last item which is depicted in the excel is just for helping you better visualize the logic. So, the actual values in the last column would be 2,1,0 (if we were to run the code because we are dealing with arrays and arrays start with 0).The swapping algorithm happens based on even or odd values of current position. It\'s very self explanatory if you look at where the swap method is getting called.You can see what\'s going on.Here is what happens:\nThis one is without recursion Let\'s use input abc as an example.Start off with just the last element (c) in a set (["c"]), then add the second last element (b) to its front, end and every possible positions in the middle, making it ["bc", "cb"] and then in the same manner it will add the next element from the back (a) to each string in the set making it:Thus entire permutation:Code:Well here is an elegant, non-recursive, O(n!) solution:One of the simple solution could be just keep swapping the characters recursively using two pointers.Use recursion.when the input is an empty string the only permutation is an empty string.Try for each of the letters in the string by making it as the first letter and then find all the permutations of the remaining letters using a recursive call.this worked for me..  python implementationHere is a straightforward minimalist recursive solution in Java:This is what I did through basic understanding of Permutations and Recursive function calling. Takes a bit of time but it\'s done independently.which generates Output as [abc, acb, bac, bca, cab, cba].Basic logic behind it is For each character, consider it as 1st character & find the combinations of remaining characters. e.g. [abc](Combination of abc)->.And then recursively calling each [bc],[ac] & [ab] independently.We can use factorial to find how many strings started with particular letter.Example: take the input abcd. (3!) == 6 strings will start with every letter of abcd.Here is a java implementation:http://ideone.com/nWPb3kRecursion is not necessary, even you can calculate any permutation directly, this solution uses generics to permute any array.Here is a good information about this algorihtm.For C# developers here is more useful implementation.This algorithm has O(N) time and space complexity to calculate each permutation.Java implementation without recursion//insert each character into an arraylistImproved Code for the sameThis can be done iteratively by simply inserting each letter of the string in turn in all locations of the previous partial results.We start with [A], which with B becomes [BA, AB], and with C, [CBA, BCA, BAC, CAB, etc].The running time would be O(n!), which, for the test case ABCD, is 1 x 2 x 3 x 4.In the above product, the 1 is for A, the 2 is for B, etc.Dart sample:Here are two c# versions (just for reference): \n1. Prints all permuations\n2. returns all permutationsBasic gist of the algorithm is (probably below code is more intuitive - nevertheless, here is some explanation of what below code does):\n- from the current index to for the rest of the collection, swap the element at current index\n- get the permutations for the remaining elements from next index recursively\n- restore the order, by re-swapping Note: the above recursive function will be invoked from the start index.version 2 (same as above - but returns the permutations in lieu of printing)Unit TestsAnother simple way is to loop through the string, pick the character that is not used yet and put it to a buffer, continue the loop till the buffer size equals to the string length. I like this back tracking solution better because:Here is the java code:Input str: 1231Output list: {1123, 1132, 1213, 1231, 1312, 1321, 2113, 2131, 2311, 3112, 3121, 3211}Noticed that the output is sorted, and there is no duplicate result.This is a C solution:My implementation based on Mark Byers\'s description above: