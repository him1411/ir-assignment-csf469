I recently learned about the ability of iPhone apps to receive nearly instantaneous notifications to apps notifications to apps.This is provided in the form of push notifications, a bespoke protocol which keeps an always on data connection to the iPhone and messages binary packets to the app, which pops up alerts incredibly quickly, between 0.5 - 5 seconds from server app send to phone app response time. This is sent as data - rather than SMS - in very very small packets charged as part of the data plan not as incoming messages. I would like to know if, using Android, there is either a similar facility, or whether it\'s possible to implement something close to this using Android APIs. To clarify, I define similar as: I appreciate the app could be pull based, HTTP request/response style, but ideally I don\'t want to be polling that heavily just to check for notification; besides which it\'s like drip draining the data plan.Firebase Cloud Messaging FCM FAQ is the new version of GCM. It inherits GCM\xe2\x80\x99s core infrastructure to deliver messages reliably on Android, iOS and Chrome. However they\'ll continue to support GCM because lot of developers are using GCM SDKs today to handle notifications, and client app upgrade takes time.As of June 26, 2012, Google Cloud Messaging is the preferred way of sending messages to applications running on devices.Previously (and now deprecated), the service was called Cloud To Device Messaging.XMPP is a good solution. I have used it for a push enabled, realtime, Android application. XMPP is powerful, highly extensible and easy to integrate and use. There are loads of free XMPP servers (though out of courtesy you shouldn\'t abuse them) and there are open source servers you can run on one of your own boxes. OpenFire is an excellent choice.The library you want isn\'t Smack as noted above, it\'s aSmack. But note, this is a build environment - you will have to build the library.This is a calculation I did on battery life impact of an XMPP solution:The Android client must maintain a persistent TCP connection by waking up periodically\n  to send a heartbeat to the XMPP server.\n  This clearly imposes a cost in terms of power usage. An estimate of this cost is\n  provided below:I recently started playing with MQTT http://mqtt.org for Android as a way of doing what you\'re asking for (i.e. not SMS but data driven, almost immediate message delivery, scalable, not polling, etc.)I have a blog post with background information on this in case it\'s helpful http://dalelane.co.uk/blog/?p=938 (Note: MQTT is an IBM technology, and I should point out that I work for IBM.)Have a look at the Xtify platform.  Looks like this is what they are doing, Google is depreciating C2DM, but in its place their introducing GCM (Google Cloud Messaging) I dont think theirs any quota and its free! It does require Android 2.2+ though! http://developer.android.com/guide/google/gcm/index.htmlIf you can depend on the Google libraries being there for you target market, then you may want to piggy back on GTalk functionality (registering a resource on the existing username - the intercepting it the messages as they come in with a BroadcastReceiver).If not, and I expect you can\'t, then you\'re into bundling your own versions of XMPP. This is a pain, but may be made easier if XMPP is bundled separately as a standalone library.You may also consider PubSubHubub, but I have no idea the network usage of it. I believe it is built atop of XMPP.I have been looking into this and PubSubHubBub recommended by jamesh is not an option. PubSubHubBub is intended for server to server communications "I\'m behind a NAT. Can I subscribe to a Hub? The hub can\'t connect to me."/AnonymousNo, PSHB is a server-to-server\n  protocol. If you\'re behind NAT, you\'re\n  not really a server. While we\'ve\n  kicked around ideas for optional PSHB\n  extensions to do hanging gets ("long\n  polling") and/or messagebox polling\n  for such clients, it\'s not in the core\n  spec. The core spec is\n  server-to-server only./Brad Fitzpatrick, San Francisco, CASource: http://moderator.appspot.com/#15/e=43e1a&t=426ac&f=b0c2d (direct link not possible)I\'ve come to the conclusion that the simplest method is to use Comet HTTP push. This is both a simple and well understood solution but it can also be re-used for web applications.There is a new open-source effort to develop a Java library for push notifications on Android, using the Meteor comet server as a backend. You can check it out at the Deacon Project Blog. We need developers, so please spread the word!I cannot find where I read it at, but I believe gmail utilizes an open TCP connection to do the e-mail push.As GTalk is gone from the SDK, it might be a good idea to make a \'standard\' push messaging system. That way, only one service has to run, only one extra tcp connection needs to be open. Applications should talk to this service using Intents and should first request permission to send and receive notification from the service. The service should then notify the user a new application wants to send and receive messages. The user will then grant or deny permission, so he stays in control. The application will then register an action + category to the service, so the service knows how to deliver the pushed message.Would the a good idea or not?Why dont you go with the XMPP implementation. right now there are so many public servers available including gtalk, jabber, citadel etc. For Android there is one SDK is also available named as SMACK. This we cant say a push notification but using the XMPP you can keep a connection open between client and server which will allow a two way communication. Means Android client and server both can communicate to each other. At present this will fulfill the need of Push in android. I have implemented a sample code and it really works greatI have recently developed http://pushdroid.org its a single application that should be installed on the phone just like google has implemented it in 2.2 this works from 1.5 and is broadcasting via intent.Google recently(18May2016) announced that Firebase is now it\'s unified platform for mobile developers including near real time push notifications.It is also multi-platform :The company now offers all Firebase users free and unlimited\n  notifications with support for iOS, Android and the Web.sourceThe problem with GCM is that there is a lot of configuration involved in the process:If you like simple things (like me) you should try UrbanAirship. It is (IMHO) the easiest way to use GCM in your app without doing a lot of configuration. It also gives you a pretty GUI to test that your GCM messages are being delivered correctly.Note: I am not afiliated with UrbanAirship in any wayhttps://github.com/Guti/Google-Cloud-Messaging--Titanium-/blob/master/src/com/google/android/gcm/GCMRegistrar.javaIts reaily good and working solution for push.Please try itThey have their listeners which has to be used by you by using their library classes in your code. You need not to bother about pushing. You have to send the message to server server will push the message to the device. They use OAuth. Regarding Protocols, there are two methods using CCS and XMPP. CCS just uses XMPP as an authenticated transport layer, so you can use most XMPP libraries to manage the connection. To send notifications to device you can write code in android app to send as well as your server code. the message sending will be done only by your code. Rest will be taken care by Google Server in GCM case. You can check detail at this linkhttp://developer.android.com/google/gcm/server.htmlAlso, for security issuesgoogle cloud messaging security https://groups.google.com/forum/#!topic/android-gcm/M-EevBitbhQIn case your app is not running then also devices can recieve notification because you have to write code for broadcast listeners. In background it will be listening to server and whenever any message packet will be there it will recieve the message as notification. Android has service you need to not to bother about it. You have only to use those resources using the library class that makes your work easier and let them write if your app is not running then also it recieve notification. Obviously, there would be some listener whick make the app to recieve.Check "Recieve the message" section in this linkhttp://developer.android.com/google/gcm/client.htmlIt will acccept request from users also. For GCM it will do. Please check "Send a message"http://developer.android.com/google/gcm/client.html