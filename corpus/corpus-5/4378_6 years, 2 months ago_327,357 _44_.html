I have a table which I want to get the latest entry for each group. Here\'s the table:DocumentStatusLogs TableThe table will be grouped by DocumentID and sorted by DateCreated in descending order. For each DocumentID, I want to get the latest status. My preferred output:Is there any aggregate function to get only the top from each group? See pseudo-code GetOnlyTheTop below:select DocumentID, GetOnlyTheTop(Status), GetOnlyTheTop(DateCreated)\nfrom DocumentStatusLogs\ngroup by DocumentID\norder by DateCreated descIf such function doesn\'t exist, is there any way I can achieve the output I want?Please see the parent table for more information:Current Documents TableShould the parent table be like this so that I can easily access its status?UPDATE\nI just learned how to use "apply" which makes it easier to address such problems.If you expect 2 entries per day, then this will arbitrarily pick one. To get both entries for a day, use DENSE_RANK insteadAs for normalised or not, it depends if you want to:As it stands, you preserve status history. If you want latest status in the parent table too (which is denormalisation) you\'d need a trigger to maintain "status" in the parent. or drop this status history table.I just learned how to use cross apply. Here\'s how to use it in this scenario:I\'ve done some timings over the various recommendations here, and the results really depend on the size of the table involved, but the most consistent solution is using the CROSS APPLY  These tests were run against SQL Server 2008-R2, using a table with 6,500 records, and another (identical schema) with 137 million records.  The columns being queried are part of the primary key on the table, and the table width is very small (about 30 bytes).  The times are reported by SQL Server from the actual execution plan.I think the really amazing thing was how consistent the time was for the CROSS APPLY regardless of the number of rows involved.What database server? This code doesn\'t work on all of them.Regarding the second half of your question, it seems reasonable to me to include the status as a column. You can leave DocumentStatusLogs as a log, but still store the latest info in the main table.BTW, if you already have the DateCreated column in the Documents table you can just join DocumentStatusLogs using that (as long as DateCreated is unique in DocumentStatusLogs).Edit: MsSQL does not support USING, so change it to:If you\'re worried about performance, you can also do this with MAX():ROW_NUMBER() requires a sort of all the rows in your SELECT statement, whereas MAX does not. Should drastically speed up your query.This is quite an old thread, but I thought I\'d throw my two cents in just the same as the accepted answer didn\'t work particularly well for me.  I tried gbn\'s solution on a large dataset and found it to be terribly slow (>45 seconds on 5 million plus records in SQL Server 2012).  Looking at the execution plan it\'s obvious that the issue is that it requires a SORT operation which slows things down significantly.Here\'s an alternative that I lifted from the entity framework that needs no SORT operation and does a NON-Clustered Index search.  This reduces the execution time down to < 2 seconds on the aforementioned record set.Now I\'m assuming something that isn\'t entirely specified in the original question, but if your table design is such that your ID column is an auto-increment ID, and the DateCreated is set to the current date with each insert, then even without running with my query above you could actually get a sizable performance boost to gbn\'s solution (about half the execution time) just from ordering on ID instead of ordering on DateCreated as this will provide an identical sort order and it\'s a faster sort.My code to select top 1 from each groupVerifying Clint\'s awesome and correct answer from above:The performance between the two queries below is interesting. 52% being the top one. And 48% being the second one. A 4% improvement in performance using DISTINCT instead of ORDER BY. But ORDER BY has the advantage to sort by multiple columns.Option 1:Option 2:M$\'s Management Studio: After highlighting and running the first block, highlight both Option 1 and Option 2, Right click -> [Display Estimated Execution Plan]. Then run the entire thing to see the results.Option 1 Results:Option 2 Results:In scenarios where you want to avoid using row_count(), you can also use a left join:For the example schema, you could also use a "not in subquery", which generally compiles to the same output as the left join: Note, the subquery pattern wouldn\'t work if the table didn\'t have at least one single-column unique key/constraint/index, in this case the primary key "Id".Both of these queries tend to be more "expensive" than the row_count() query (as measured by Query Analyzer).  However, you might encounter scenarios where they return results faster or enable other optimizations.Try this:If you want to return only recent document order by DateCreated, it will return only top 1 document by DocumentIDThis is the most vanilla TSQL I can come up withIt is checked in SQLite that you can use the following simple query with GROUP BYHere MAX help to get the maximum DateCreated FROM each group.But it seems that MYSQL doesn\'t associate *-columns with the value of max DateCreated :(