Which is better to use, and why, on a large project:orIt really depends on what you\'re going for:Personally I use both depending on the situation:Conditional("DEBUG") Example: I use this so that I don\'t have to go back and edit my code later during release, but during debugging I want to be sure I didn\'t make any typos. This function checks that I type a property name correctly when trying to use it in my INotifyPropertyChanged stuff.You really don\'t want to create a function using #if DEBUG unless you are willing to wrap every call to that function with the same #if DEBUG:versus:#if DEBUG example: I use this when trying to setup different bindings for WCF communication.In the first example, the code all exists, but is just ignored unless DEBUG is on. In the second example, the const ENDPOINT is set to "Localhost" or "BasicHttpBinding" depending on if DEBUG is set or not.Update: Because this answer is the highest voted answer to the question, I am updating this answer to clarify an important and tricky point. If you choose to use the ConditionalAttribute, keep in mind that calls are omitted during compilation, and not runtime. That is:MyLibrary.dllWhen the library is compiled against release mode (i.e. no DEBUG symbol), it will forever have the call to B() from within A() omitted, even if a call to A() is included because DEBUG is defined in the calling assembly.Well, it\'s worth noting that they don\'t mean the same thing at all.If the DEBUG symbol isn\'t defined, then in the first case the SetPrivateValue itself won\'t be called... whereas in the second case it will exist, but any callers who are compiled without the DEBUG symbol will have those calls omitted.If the code and all its callers are in the same assembly this difference is less important - but it means that in the first case you also need to have #if DEBUG around the calling code as well.Personally I\'d recommend the second approach - but you do need to keep the difference between them clear in your head.I\'m sure plenty will disagree with me, but having spent time as a build guy constantly hearing "But it works on my machine!", I take the standpoint that you should pretty much never use either. If you really need something for testing and debugging, figure out a way to make that testability seperate from the actual production code.Abstract the scenarios with mocking in unit tests, make one off versions of things for one off scenarios you want to test, but don\'t put tests for debug into the code for binaries which you test and write for production release. These debug tests just hide possible bugs from devs so they aren\'t found until later in the process. With the first example, SetPrivateValue won\'t exist in the build if DEBUG is not defined, with the second example, calls to SetPrivateValue won\'t exist in the build if DEBUG is not defined.With the first example, you\'ll have to wrap any calls to SetPrivateValue with #if DEBUG as well.With the second example, the calls to SetPrivateValue will be omitted, but be aware that SetPrivateValue itself will still be compiled.  This is useful if you\'re building a library, so an application referencing your library can still use your function (if the condition is met).If you want to omit the calls and save the space of the callee, you could use a combination of the two techniques:Let\'s presume your code also had an #else statement which defined a null stub function, addressing one of Jon Skeet\'s points. There\'s a second important distinction between the two.Suppose the #if DEBUG or Conditional function exists in a DLL which is referenced by your main project executable. Using the #if, the evaluation of the conditional will be performed with regard to the library\'s compilation settings. Using the Conditional attribute, the evaluation of the conditional will be performed with regard to the compilation settings of the invoker.This one can be useful as well:I have a SOAP WebService extension to log network traffic using a custom [TraceExtension]. I use this only for Debug builds and omit from Release builds.  Use the #if DEBUG to wrap the [TraceExtension] attribute thus removing it from Release builds.