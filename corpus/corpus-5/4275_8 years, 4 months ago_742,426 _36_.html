Is this the cleanest way to write a list to a file, since writelines() doesn\'t insert newline characters?It seems like there would be a standard way...EDIT Adding info from Thomas\' commentDon\'t forget to open the file firstthefile = open(\'test.txt\', \'w\')I\'d use a loop:or:If you\'re keen on a single function call, at least remove the square brackets [] so that the strings to be printed get made one at a time (a genexp rather than a listcomp) -- no reason to take up all the memory required to materialize the whole list of strings.What are you going to do with the file?  Does this file exist for humans, or other programs with clear interoperability requirements, or are you just trying to serialize a list to disk for later use by the same python app.  If the second case is it, you should be pickleing the list.To read it back:The best way is:Yet another way.  Serialize to json using simplejson (included as json in python 2.6):If you examine output.txt:[1, 2, 3, 4]This is useful because the syntax is pythonic, it\'s human readable, and it can be read by other programs in other languages.Using Python 3 and Python 2.6+ syntax:This is platform-independent. It also terminates the final line with a newline character, which is a UNIX best practice.I thought it would be interesting to explore the benefits of using a genexp, so here\'s my take.The example in the question uses square brackets to create a temporary list, and so is equivalent to:Which needlessly constructs a temporary list of all the lines that will be written out, this may consume significant amounts of memory depending on the size of your list and how verbose the output of str(item) is.Drop the square brackets (equivalent to removing the wrapping list() call above) will instead pass a temporary generator to file.writelines():This generator will create newline-terminated representation of your item objects on-demand (i.e. as they are written out). This is nice for a couple of reasons:This avoids memory issues, such as:(I triggered this error by limiting Python\'s max. virtual memory to ~100MB with ulimit -v 102400).Putting memory usage to one side, this method isn\'t actually any faster than the original:(Python 2.6.2 on Linux)Following is the syntax for writelines() methodhttp://www.tutorialspoint.com/python/file_writelines.htmSerialize list into text file with comma sepparated valueYou can also use the print function if you\'re on python3 as follows.Because i\'m lazy....Why don\'t you tryLet avg be the list, then:You can use %e or %s depending on your requirement.How It Works:\nFirst, open a \xef\xac\x81le by using the built-in open function and specifying the name of\nthe \xef\xac\x81le and the mode in which we want to open the \xef\xac\x81le. The mode can be a\nread mode (\xe2\x80\x99r\xe2\x80\x99), write mode (\xe2\x80\x99w\xe2\x80\x99) or append mode (\xe2\x80\x99a\xe2\x80\x99). We can also specify\nwhether we are reading, writing, or appending in text mode (\xe2\x80\x99t\xe2\x80\x99) or binary\nmode (\xe2\x80\x99b\xe2\x80\x99). There are actually many more modes available and help(open)\nwill give you more details about them. By default, open() considers the \xef\xac\x81le to\nbe a \xe2\x80\x99t\xe2\x80\x99ext \xef\xac\x81le and opens it in \xe2\x80\x99r\xe2\x80\x99ead mode.\nIn our example, we \xef\xac\x81rst open the \xef\xac\x81le in write text mode and use the write\nmethod of the \xef\xac\x81le object to write to the \xef\xac\x81le and then we \xef\xac\x81nally close the \xef\xac\x81le.The above example is from the book "A Byte of Python" by Swaroop C H.\nswaroopch.com