Basically I need to run the script with paths related to the shell script file location, how can I change the current directory to the same directory as where the script file resides?In Bash, you should get what you need like this:The original post contains the solution (ignore the responses, they don\'t add anything useful). The interesting work is done by the mentioned unix command readlink with option -f. Works when the script is called by an absolute as well as by a relative path.For bash, sh, ksh:For tcsh, csh:See also: https://stackoverflow.com/a/246128/59087Assuming you\'re using bashThis script, when ran, should print the directory that you\'re in, and then the directory the script is in, for example, when calling it from / (the script is in /home/mez/), it outputsRemember, when assigning variables from the output of a command, wrap the command in $( and ) - or you\'ll not get the desired output.\n`If you\'re using bash....An earlier comment on an answer said it, but it is easy to miss among all the other answers.When using bash:Bash Reference Manual, 5.2 Bash VariablesAs theMarko suggests:This works unless you execute the script from the same directory where the script resides, in which case you get a value of \'.\'To get around that issue use:You can now use the variable current_dir throughout your script to refer to the script directory.  However this may still have the symlink issue. Inspired by blueyed\xe2\x80\x99s answerLet\'s make it POSIX:Tested on many Bourne-compatible shells including the BSD ones.As far as I know I am the author and I put it into public domain. For more info see:\nhttps://www.jasan.tk/posix/2017/05/11/posix_shell_dirname_replacementSo many answers, all plausible, each with pro\'s and con\'s & slightly differeing objectives (which should probably be stated for each). Here\'s another solution that meets a primary objective of both being clear and working across all systems, on all bash (no assumptions about bash versions, or readlink or pwd options), and reasonably does what you\'d expect to happen (eg, resolving symlinks is an interesting problem, but isn\'t usually what you actually want), handle edge cases like spaces in paths, etc., ignores any errors and uses a sane default if there are any issues.Each component is stored in a separate variable that you can use individually:The best answer for this question was answered here:\nGetting the source directory of a Bash script from withinAnd is:One-liner which will give you the full directory name of the script no matter where it is being called from.To understand how it works you can execute the following script:That should do the trick:It might look ugly depending on how it was invoked and the cwd but should get you where you need to go (or you can tweak the string if you care how it looks).