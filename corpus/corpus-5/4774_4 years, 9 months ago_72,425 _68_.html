What are the possible reasons for document.getElementById, $("#id") or any other DOM method / jQuery selector not finding the elements?Example problems include:jQuery silently failing to bind an event handler, and a standard DOM method returning null resulting in the error:Uncaught TypeError: Cannot set property \'...\' of nullThe element you were trying to find wasn\xe2\x80\x99t in the DOM when your script ran.The position of your DOM-reliant script can have a profound effect upon its behavior. Browsers parse HTML documents from top to bottom. Elements are added to the DOM and scripts are (generally) executed as they\'re encountered. This means that order matters. Typically, scripts can\'t find elements which appear later in the markup because those elements have yet to be added to the DOM.Consider the following markup; script #1 fails to find the <div> while script #2 succeeds:So, what should you do? You\'ve got a few options:Move your script further down the page, just before the closing body tag. Organized in this fashion, the rest of the document is parsed before your script is executed:Note: Placing scripts at the bottom is generally considered a best practice.Defer your script until the DOM has been completely parsed, using ready():Note: You could simply bind to DOMContentLoaded or  window.onload but each has its caveats. jQuery\'s ready() delivers a hybrid solution.Delegated events have the advantage that they can process events from descendant elements that are added to the document at a later time.When an element raises an event (provided that it\'s a bubbling event and nothing stops its propagation), each parent in that element\'s ancestry receives the event as well. That allows us to attach a handler to an existing element and sample events as they bubble up from its descendants... even those added after the handler is attached. All we have to do is check the event to see whether it was raised by the desired element and, if so, run our code. jQuery\'s on() performs that logic for us. We simply provide an event name, a selector for the desired descendant, and an event handler:Note: Typically, this pattern is reserved for elements which didn\'t exist at load-time or to avoid attaching a large amount of handlers. It\'s also worth pointing out that while I\'ve attached a handler to document (for demonstrative purposes), you should select the nearest reliable ancestor.Use the defer attribute of <script>.[defer, a Boolean attribute,] is set to indicate to a browser that the script is meant to be executed after the document has been parsed.For reference, here\'s the code from that external script:Note: The defer attribute certainly seems like a magic bullet but it\'s important to be aware of the caveats...\n1. defer can only be used for external scripts, i.e.: those having a src attribute.\n2. be aware of browser support, i.e.: buggy implementation in IE < 10Short and simple: Because the elements you are looking for do not exist in the document (yet).For the remainder of this answer I will use getElementById as example, but the same applies to getElementsByTagName, querySelector and any other DOM method that selects elements.Possible ReasonsThere are two reasons why an element might not exist:An element with the passed ID really does not exist in the document. You should double check that the ID you pass to getElementById really matches an ID of an existing element in the (generated) HTML and that you have not misspelled the ID (IDs are case-sensitive!).Incidentally, in the majority of contemporary browsers, which implement querySelector() and querySelectorAll() methods, CSS-style notation is used to retrieve an element by its id, for example: document.querySelector(\'#elementID\'), as opposed to the method by which an element is retrieved by its id under document.getElementById(\'elementID\'); in the first the # character is essential, in the second it would lead to the element not being retrieved.The element does not exist at the moment you call getElementById.The latter case is quite common. Browsers parse and process the HTML from top to bottom. That means that any call to a DOM element which occurs before that DOM element appears in the HTML, will fail.Consider the following example:The div appears after the script. At the moment the script is executed, the element does not exist yet and getElementById will return null.jQueryThe same applies to all selectors with jQuery. jQuery won\'t find elements if you misspelled your selector or you are trying to select them before they actually exist.An added twist is when jQuery is not found because you have loaded the script without protocol and are running from file system:this syntax is used to allow the script to load via HTTPS on a page with protocol https:// and to load the HTTP version on a page with protocol http://It has the unfortunate side effect of attempting and failing to load file://somecdn.somewhere.com...SolutionsBefore you make a call to getElementById (or any DOM method for that matter), make sure the elements you want to access exist, i.e. the DOM is loaded.This can be ensured by simply putting your JavaScript after the corresponding DOM elementin which case you can also put the code just before the closing body tag (</body>) (all DOM elements will be available at the time the script is executed).Other solutions include listening to the load [MDN] or DOMContentLoaded [MDN] events. In these cases it does not matter where in the document you place the JavaScript code, you just have to remember to put all DOM processing code in the event handlers.Example:Please see the articles at quirksmode.org for more information regarding event handling and browser differences.jQueryFirst make sure that jQuery is loaded properly. Use the browser\'s developer tools to find out whether the jQuery file was found and correct the URL if it wasn\'t (e.g. add the http: or https: scheme at the beginning, adjust the path, etc.)Listening to the load/DOMContentLoaded  events is exactly what jQuery is doing with .ready() [docs]. All your jQuery code that affects DOM element should be inside that event handler.In fact, the jQuery tutorial explicitly states:As almost everything we do when using jQuery reads or manipulates the document object model (DOM), we need to make sure that we start adding events etc. as soon as the DOM is ready.To do this, we register a ready event for the document.Alternatively you can also use the shorthand syntax:Both are equivalent.As @FelixKling pointed out, the most likely scenario is that the nodes you are looking for do not exist (yet).However, modern development practices can often manipulate document elements outside of the document tree either with DocumentFragments or simply detaching/reattaching current elements directly.  Such techniques may be used as part of JavaScript templating or to avoid excessive repaint/reflow operations while the elements in question are being heavily altered.Similarly, the new "Shadow DOM" functionality being rolled out across modern browsers allows elements to be part of the document, but not query-able by document.getElementById and all of its sibling methods (querySelector, etc.). This is done to encapsulate functionality and specifically hide it.Again, though, it is most likely that the element you are looking for simply is not (yet) in the document, and you should do as Felix suggests. However, you should also be aware that that is increasingly not the only reason that an element might be unfindable (either temporarily or permanently).Reasons why id based selectors don\'t worksolutionstry to access element after its declaration or alternatively use stuff like $(document).ready();for elements coming from ajax responses, use .bind() method of jquery, older versions of jquery had .live() for the same.use tools [eg webdeveloper plugin for browsers] to find duplicate ids and remove them. If the element you are trying to access is inside an iframe and you try to access it outside the context of the iframe this will also cause it to fail.If you want to get an element in an iframe you can find out how here.I just struggled with this. Sharing in case useful. Even when I used the debugger and found the items already existed at runtime, so there was no apparent reason why console logged (and fell over) with an undefined.In the end I rewrote the line of code. I had not spelled it wrongly, but I think I\'d capitalised the D of "ID". Now works great.