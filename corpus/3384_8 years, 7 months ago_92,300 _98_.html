I like instantiating my WCF service clients within a using block as it\'s pretty much the standard way to use resources that implement IDisposable:But, as noted in this MSDN article, wrapping a WCF client in a using block could mask any errors that result in the client being left in a faulted state (like a timeout or communication problem). Long story short, when Dispose() is called, the client\'s Close() method fires, but throws an error because it\'s in a faulted state. The original exception is then masked by the second exception. Not good.The suggested workaround in the MSDN article is to completely avoid using a using block, and to instead instantiate your clients and use them something like this:Compared to the using block, I think that\'s ugly. And a lot of code to write each time you need a client.Luckily, I found a few other workarounds, such as this one on IServiceOriented. You start with:Which then allows:That\'s not bad, but I don\'t think it\'s as expressive and easily understandable as the using block.The workaround I\'m currently trying to use I first read about on blog.davidbarret.net. Basically you override the client\'s Dispose() method wherever you use it. Something like:This appears to be able to allow the using block again without the danger of masking a faulted state exception. So, are there any other gotchas I have to look out for using these workarounds? Has anybody come up with anything better?Actually, although I blogged (see Luke\'s answer), I think this is better than my IDisposable wrapper. Typical code:(edit per comments)Since Use returns void, the easiest way to handle return values is via a captured variable:Given a choice between the solution advocated by IServiceOriented.com and the solution advocated by David Barret\'s blog, I prefer the simplicity offered by overriding the client\'s Dispose() method.  This allows me to continue to use the using() statement as one would expect with a disposable object.  However, as @Brian pointed out, this solution contains a race condition in that the State might not be faulted when it is checked but could be by the time Close() is called, in which case the CommunicationException still occurs.So, to get around this, I\'ve employed a solution that mixes the best of both worlds.I wrote a higher order function to make it work right. We\'ve used this in several projects and it seems to work great. This is how things should have been done from the start, without the "using" paradigm or so on.You can make calls like this:This is pretty much just like you have in your example. In some projects, we write strongly typed helper methods, so we end up writing things like "Wcf.UseFooService(f=>f...)".I find it quite elegant, all things considered. Is there a particular problem you encountered?This allows other nifty features to be plugged in. For instance, on one site, the site authenticates to the service on behalf of the logged in user. (The site has no credentials by itself.) By writing our own "UseService" method helper, we can configure the channel factory the way we want, etc. We\'re also not bound to using the generated proxies -- any interface will do.This is Microsoft\'s recommended way to handle WCF client calls:For more detail see: Expected ExceptionsAdditional information\nSo many people seem to be asking this question on WCF that Microsoft even created a dedicated sample to demonstrate how to handle exceptions:c:\\WF_WCF_Samples\\WCF\\Basic\\Client\\ExpectedExceptions\\CS\\clientDownload the sample:\nC# or  VB Considering that there are so many issues involving the using statement, (heated?) Internal discussions and threads on this issue, I\'m not going to waste my time trying to become a code cowboy and find a cleaner way.  I\'ll just suck it up, and implement WCF clients this verbose (yet trusted) way for my server applications.  Optional Additional Failures to catchMany exceptions derive from CommunicationException and I don\'t think most of those exceptions should be retried.  I drudged through each exception on MSDN and found a short list of retry-able exceptions (in addition to TimeOutException above). Do let me know if I missed an exception that should be retried.Admittedly, this is a bit of mundane code to write.  I currently prefer this answer, and don\'t see any "hacks" in that code that may cause issues down the road.I\'ve finally found some solid steps towards a clean solution to this problem.This custom tool extends WCFProxyGenerator to provide an exception handling proxy. It generates an additional proxy called ExceptionHandlingProxy<T> which inherits ExceptionHandlingProxyBase<T> - the latter of which implements the meat of the proxy\'s functionality. The result is that you can choose to use the default proxy that inherits ClientBase<T> or ExceptionHandlingProxy<T> which encapsulates managing the lifetime of the channel factory and channel. ExceptionHandlingProxy respects your selections in the Add Service Reference dialog with respect to asynchronous methods and collection types.Codeplex has a project called Exception Handling WCF Proxy Generator. It basically installs a new custom tool to Visual Studio 2008, then use this tool to generate the new service proxy (Add service reference). It has some nice functionality to deal with faulted channels, timeouts and safe disposal. There\'s an excellent video here called ExceptionHandlingProxyWrapper explaining exactly how this works.You can safely use the Using statement again, and if the channel is faulted on any request (TimeoutException or CommunicationException), the Wrapper will re-initialize the faulted channel and retry the query. If that fails then it will call the Abort() command and dispose of the proxy and rethrow the Exception. If the service throws a FaultException code it will stop executing, and the proxy will be aborted safely throwing the correct exception as expected.Based on answers by Marc Gravell, MichaelGG, and Matt Davis, our developers came up with the following:Example of use:It\'s as close to the "using" syntax as possible, you don\'t have to return a dummy value when calling a void method, and you can make multiple calls to the service (and return multiple values) without having to use tuples.Also, you can use this with ClientBase<T> descendants instead of ChannelFactory if desired.The extension method is exposed if a developer wants to manually dispose of a proxy/channel instead.@Marc GravellWouldn\'t it be OK to use this:Or, the same thing (Func<T, TResult>) in case of Service<IOrderService>.UseThese would make returning variables easier.What is this?This is the CW version of the accepted answer but with (what I consider complete) Exception handling included.The accepted answer references this website that is no longer around.  To save you trouble, I am including the most relevant parts here.  In addition, I modified it slightly to include exception retry handling to handle those pesky network timeouts.Simple WCF Client UsageOnce you generate your client side proxy, this is all you need to implement it.ServiceDelegate.csAdd this file to your solution.  No changes are needed to this file, unless you want to alter the number of retries or what exceptions you want to handle.PS: I\'ve made this post a community wiki.  I won\'t collect "points" from this answer, but prefer you upvote it if you agree with the implementation, or edit it to make it better.Below is an enhanced version of the source from the question and extended to cache multiple channel factories and attempt to look up the endpoint in the configuration file by contract name.It uses .NET 4 (specifically: contravariance, LINQ, var):A wrapper like this would work:That should enable you to write code like:The wrapper could of course catch more exceptions if that is required, but the principle remains the same.I used Castle dynamic proxy to solve the Dispose() issue, and also implemented auto-refreshing the channel when it is in an unusable state.  To use this you must create a new interface that inherits your service contract and IDisposable.  The dynamic proxy implements this interface and wraps a WCF channel:I like this since you can inject WCF services without consumers needing to worry about any details of WCF.  And there\'s no added cruft like the other solutions.Have a look at the code, it\'s actually pretty simple:\nWCF Dynamic ProxyIf you don\'t need IoC or are using an autogenerated client (Service Reference), then you can simple use a wrapper to manage the closing and let the GC take the clientbase when it is in a safe state that will not throw any exception. The GC will call Dispose in serviceclient, and this will call Close. Since it is alread closed, it cannot cause any damage. I am using this without problems in production code.Then when you are accessing the server, you create the client and use using in the autodisconect:Use an extension method:Using the techniques described in this answer one can consume a WCF service in a using block with the following syntax:You can of course adapt this even further to achieve a more concise programming model specific to your situation - but the point is that we can create an implementation of IMyService reprenting the channel which correctly implements the disposable pattern.All the answers given thus far address the problem of getting around the "bug" in the WCF Channel implemention of IDisposable.  The answer that seems to offer the most concise programming model (allowing you to use the using block to dispose on unmanaged resources) is this one - where the proxy is modifed to implement IDisposable with a bug-free implementation.  The problem with this approach is maintainability - we have to re-implement this functionality for ever proxy we use.  On a variation of this answer we will see how we can use composition rather than inheritance to make this technique generic.There seem to various implementations for the IDisposable implementation, but for sake of argument we will use an adaption of that used by the currently accepted answer.  Armed with the above classes we can now writeThis allows us to consume our service using the using block:All we have done so far is to reformulate Tomas\' solution.  What prevents this code from being generic is the fact that ProxyWrapper class has to be re-implemented for every service contract we want.  We will now look at a class that allows us to create this type dynamically using IL:With our new helper class we can now writeNote that you could also use the same technique (with slight modifications) for auto-generated clients inheriting for ClientBase<> (instead of using ChannelFactory<>), or if you want to use a different implementation of IDisposable to close your channel.I have written a simple base class that handles this. It\'s available as a NuGet package and it\'s quite easy to use.So it allows to write return statements nicely:I\'d like to add implementation of Service from Marc Gravell\'s answer for case of using ServiceClient instead of ChannelFactory.For those interested, here\'s a VB.NET translation of the accepted answer (below). I\'ve refined it a bit for brevity, combining some of the tips by others in this thread.I admit it\'s off-topic for the originating tags (C#), but as I wasn\'t able to find a VB.NET version of this fine solution I assume that others will be looking as well. The Lambda translation can be a bit tricky, so I\'d like to save someone the trouble.Note that this particular implementation provides the ability to configure the ServiceEndpoint at runtime.Code:Usage:Our system architecture often uses the Unity IoC framework to create instances of ClientBase so there\'s no sure way to enforce that the other developers even use using{} blocks. In order to make it as fool-proof as possible, I made this custom class that extends ClientBase, and handles closing down the channel on dispose, or on finalize in case someone doesn\'t explicitly dispose of the Unity created instance.There is also stuff that needed to be done in the constructor to set up the channel for custom credentials and stuff, so that\'s in here too...Then a client can simply:And the caller can do any of these:I like this way of closing connection:I referred few answers on this post and customized it as per my needs. I wanted the ability to do something with WCF client before using it so the DoSomethingWithClient() method.Here is the helper class: And I can use it as: I have my own wrapper for a channel which implements Dispose as follows:This seems to work well and allows a using block to be used.The following helper allows to call void and non-void methods. Usage:The class itself is:Override the client\'s Dispose() without the need to generate a proxy class based on ClientBase, also without the need to manage channel creation and caching!  (Note that WcfClient is not an ABSTRACT class and is based on ClientBase)My method of doing this has been to create an inherited class that explicitly implements IDisposable. This is useful for folks who use the gui to add the service reference ( Add Service Reference ). I just drop this class in the project making the service reference and use it instead of the default client:Note: This is just a simple implementation of dispose, you can implement more complex dispose logic if you like.You can then replace all your calls made with the regular service client with the safe clients, like this:I like this solution as it does not require me to have access to the Interface definitions and I can use the using statement as I would expect while allowing my code to look more or less the same. You will still need to handle the exceptions which can be thrown as pointed out in other comments in this thread.You could also use a DynamicProxy to extend the Dispose() method. This way you could do something like: