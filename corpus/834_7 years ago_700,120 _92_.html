How do I know if a variable is set in Bash?For example, how do I check if the user gave the first parameter to a function?where ${var+x} is a parameter expansion which evaluates to nothing if var is unset, and substitutes the string x otherwise.Quotes can be omitted (so we can say ${var+x} instead of "${var+x}") because this syntax & usage guarantees this will only expand to something that does not require quotes (since it either expands to x (which contains no word breaks so it needs no quotes), or to nothing (which results in [ -z  ], which conveniently evaluates to the same value (true) that [ -z "" ] does as well)).However, while quotes can be safely omitted, and it was not immediately obvious to all (it wasn\'t even apparent to the first author of this quotes explanation who is also a major Bash coder), it would sometimes be better to write the solution with quotes as [ -z "${var+x}" ], at the very small possible cost of an O(1) speed penalty.  The first author also added this as a comment next to the code using this solution giving the URL to this answer, which now also includes the explanation for why the quotes can be safely omitted.This is because it doesn\'t distinguish between a variable that is unset and a variable that is set to the empty string. That is to say, if var=\'\', then the above solution will incorrectly output that var is unset.But this distinction is essential in situations where the user has to specify an extension, or additional list of properties, and that not specifying them defaults to a non-empty value, whereas specifying the empty string should make the script use an empty extension or list of additional properties.To check for non-null/non-zero string variable, i.e. if set, useIt\'s the opposite of -z.  I find myself using -n more than -z.Here\'s how to test whether a parameter is unset, or empty ("Null") or set with a value:Source: POSIX: Parameter Expansion:In all cases shown with "substitute", the expression is replaced with the value shown. In all cases shown with "assign", parameter is assigned that value, which also replaces the expression.There are many ways to do this with the following being one of them:This succeeds if $1 is null or unsetWhile most of the techniques stated here are correct, bash 4.2 supports an actual test for the presence of a variable (man bash), rather than testing the value of the variable.\nTo see if a variable is nonempty, I useThe opposite tests if a variable is either unset or empty:To see if a variable is set (empty or nonempty), I useThe opposite tests if a variable is unset:On a modern version of Bash (4.2 or later I think; I don\'t know for sure), I would try this:Although for arguments it is normally best to test $#, which is the number of arguments, in my opinion.Read the "Parameter Expansion" section of the bash man page. Parameter expansion doesn\'t provide a general test for a variable being set, but there are several things you can do to a parameter if it isn\'t set.For example:will set first_arg equal to $1 if it is assigned, otherwise it uses the value "foo". If a absolutely must take a single parameter, and no good default exists, you can exit with an error message when no parameter is given:(Note the use of : as a null command, which just expands the values of its arguments. We don\'t want to do anything with $1 in this example, just exit if it isn\'t set)To check whether a variable is set with a non-empty value, use [ -n "$x" ], as others have already indicated.Most of the time, it\'s a good idea to treat a variable that has an empty value in the same way as a variable that is unset. But you can distinguish the two if you need to: [ -n "${x+set}" ] ("${x+set}" expands to set if x is set and to the empty string if x is unset).To check whether a parameter has been passed, test $#, which is the number of parameters passed to the function (or to the script, when not in a function) (see Paul\'s answer).In bash you can use -v inside the [[ ]] builtin:This worked for me. I wanted my script to exit with an error message if a parameter wasn\'t set.This returns with an error when it\'s runTry this option if you just want to check if the value set=VALID or unset/empty=INVALID.Or, Even short tests ;-)And this is the answer to the question.\nUse this if you just want to check if the value set/empty=VALID or unset=INVALID.NOTE, the "1" in "..-1}" is insignificant,\nit can be anything (like x)Short testsI dedicate this answer to @mklement0 (comments) who challenged me to answer the question accurately.Reference http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_02I always find the POSIX table in the other answer slow to grok, so here\'s my take on it:Note that each group (with and without preceding colon) has the same set and unset cases, so the only thing that differs is how the empty cases are handled.With the preceding colon, the empty and unset cases are identical, so I would use those where possible (i.e. use :=, not just =, because the empty case is inconsistent).Headings:Values:You can do:The answers above do not work when Bash option set -u is enabled.  Also, they are not dynamic, e.g., how to test is variable with name "dummy" is defined?  Try this:Related: In Bash, how do I test if a variable is defined in "-u" modeUsing [[ -z "$var" ]] is the easiest way to know if a variable was set or not, but that option -z doesn\'t distinguishes between a unset variable, and a variable set to an empty string:It\'s best to check it according to the type of variable: env variable, parameter or regular variable. For a env variable:For a parameter (for example, to check existence of parameter "$5":For a regular variable (using an auxiliar function, to do it in an elegant way):Notes:In a shell you can use the -z operator which is True if the length of string is zero.A simple one-liner to set default MY_VAR if it\'s not set, otherwise optionally you can display the message:My prefered way is this:So basically, if a variable is set, it becomes "a negation of the resulting false" (what will be true = "is set").And, if it is unset, it will become "a negation of the resulting true" (as the empty result evaluates to true) (so will end as being false = "NOT set").For those that are looking to check for unset or empty when in a script with  set -u:The regular [ -z "$var" ] check will fail with var; unbound variable if set -u but [ -z "${var-}" ] expands to empty string if var is unset without failing.I found a (much) better code to do this if you want to check for anything in $@.Why this all? Everything in $@ exists in Bash, but by default it\'s blank, so test -z and test -n couldn\'t help you.Update: You can also count number of characters in a parameters.I always use this one, based on the fact that it seems easy to be understood by anybody who sees the code for the very first time:And, if wanting to check if not empty;That\'s it.This is what I use every day:This works well under Linux and Solaris down to bash 3.0.If var can be an array, then [ -z "${var+x}" ] parameter substitution is incorrect. To be really sure in Bash you need to use array syntax like [ "${#var[@]}" = 0 ], as shown below.In almost all cases, they agree. The only situation I\'ve found where the array method is more accurate is when the variable is a non-empty array with position 0 unset (e.g., in tests 7 and A below). This disagreement comes from $var being shorthand for ${var[0]}, so [ -z "${var+x}" ] isn\'t checking the whole array.Here are my test cases.Here\'s the output.In sum:If you wish to test that a variable is bound or unbound, this works well, even after you\'ve turned on the nounset option:OrOrOrI like auxiliary functions to hide the crude details of bash. In this case, doing so adds even more (hidden) crudeness:Because I first had bugs in this implementation (inspired by the answers of Jens and Lionel), I came up with a different solution:I find it to be more straight-forward, more bashy and easier to understand/remember. Test case shows it is equivalent:The test case also shows that local var does NOT declare var (unless followed by \'=\'). For quite some time I thought i declared variables this way, just to discover now that i merely expressed my intention... It\'s a no-op, i guess.IsDeclared_Tricky xyz: 1\n  IsDeclared_Tricky foo: 1\n  IsDeclared_Tricky bar: 0\n  IsDeclared_Tricky baz: 0\n  IsDeclared xyz: 1\n  IsDeclared foo: 1\n  IsDeclared bar: 0\n  IsDeclared baz: 0  BONUS: usecaseI mostly use this test to give (and return) parameters to functions in a somewhat "elegant" and safe way (almost resembling an interface...):If called with all requires variables declared:Hello world!else:Error: variable not declared: outputStr\nThe following functions test if the given name exists as a variableThis functions would test as showed in the following conditions:.and a test script see my answer to the question "How do I check if a variable exists in bash?".\n  \n  \n  Remark: The similar usage of declare -p, as it is also shown by Peregring-lk\'s answer, is truly coincidental. Otherwise I would of course have credited it!