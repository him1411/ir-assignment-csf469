How do I do a SELECT * INTO [temp table] FROM [stored procedure]? Not FROM [Table] and without defining [temp table]?Select all data from BusinessLine into tmpBusLine works fine.I am trying the same, but using a stored procedure that returns data, is not quite the same.Output message:Msg 156, Level 15, State 1, Line 2\n  Incorrect syntax near the keyword\n  \'exec\'.I have read several examples of creating a temporary table with the same structure as the output stored procedure, which works fine, but it would be nice to not supply any columns.You can use OPENROWSET for this.  Have a look.  I\'ve also included the sp_configure code to enable Ad Hoc Distributed Queries, in case it isn\'t already enabled.If you want to do it without first declaring the temporary table, you could try creating a user-defined function rather than a stored procedure and make that user-defined function return a table. Alternativly, if you want to use the stored procedure, try something like this:In SQL Server 2005 you can use INSERT INTO ... EXEC to insert the result of a stored procedure into a table. From MSDN\'s INSERT documentation (for SQL Server 2000, in fact):This is an answer to a slightly modified version of your question.  If you can abandon the use of a stored procedure for a user-defined function, you can use an inline table-value user-defined function.  This is essentially a stored procedure (will take parameters) that returns a table as a result set; and therefore will place nicely with an INTO statement.  Here\'s a good quick article on it and other user-defined functions.  If you still have a driving need for a stored procedure, you can wrap the inline table-value user-defined function with a stored procedure. The stored procedure just passes parameters when it calls select * from the inline table-value user-defined function.  So for instance, you\'d have a inline table-value user-defined function to get a list of customers for a particular region:You can then call this function to get what your results a such:Or to do a SELECT INTO:If you still need a stored procedure, then wrap the function as such:I think this is the most \'hack-less\' method to obtain the desired results.  It uses the existing features as they were intended to be used without additional complications.  By nesting the inline table-value user-defined function in the stored procedure, you have access to the functionality in two ways.  Plus!  You have only one point of maintenance for the actual SQL code.The use of OPENROWSET has been suggested, but this is not what the OPENROWSET function was intended to be used for (From Books Online):Includes all connection information\n  that is required to access remote data\n  from an OLE DB data source. This\n  method is an alternative to accessing\n  tables in a linked server and is a\n  one-time, ad hoc method of connecting\n  and accessing remote data by using OLE\n  DB. For more frequent references to\n  OLE DB data sources, use linked\n  servers instead.Using OPENROWSET will get the job done, but it will incur some additional overhead for opening up local connections and marshalling data.  It also may not be an option in all cases since it requires an ad hoc query permission which poses a security risk and therefore may not be desired.  Also, the OPENROWSET approach will preclude the use of stored procedures returning more than one result set.  Wrapping multiple inline table-value user-defined functions in a single stored procedure can achieve this.When the stored procedure returns a lot of columns and you do not want to manually "create" a temporary table to hold the result, I\'ve found the easiest way is to go into the stored procedure and add an "into" clause on the last select statement and add 1=0 to the where clause.Run the stored procedure once and go back and remove the SQL code you just added. Now, you\'ll have an empty table matching the stored procedure\'s result. You could either "script table as create" for a temporary table or simply insert directly into that table.If you don\'t know the schema then you can do the following. Please\nnote that there are sever security risks in this method.Does your stored procedure only retrieve the data or modify it too? If it\'s used only for retrieving, you can convert the stored procedure into a function and use the Common Table Expressions (CTEs) without having to declare it, as follows:However, whatever needs to be retrieved from the CTE should be used in one statement only. You cannot do a with temp as ... and try to use it after a couple of lines of SQL. You can have multiple CTEs in one statement for more complex queries.For example,If the results table of your stored proc is too complicated to type out the "create table" statement by hand, and you can\'t use OPENQUERY OR OPENROWSET, you can use sp_help to generate the list of columns and data types for you.  Once you have the list of columns, it\'s just a matter of formatting it to suit your needs.  Step 1: Add "into #temp" to the output query (e.g. "select [...] into #temp from [...]"). The easiest way is to edit the output query in the proc directly.  if you can\'t change the stored proc, you can copy the contents into a new query window and modify the query there.  Step 2: Run sp_help on the temp table.  (e.g. "exec tempdb..sp_help #temp")After creating the temp table, run sp_help on the temp table to get a list of the columns and data types including the size of varchar fields.   Step 3: Copy the data columns & types into a create table statement I have an Excel sheet that I use to format the output of sp_help into a "create table" statement.  You don\'t need anything that fancy, just copy and paste into your SQL editor.  Use the column names, sizes, and types to construct a "Create table #x [...]" or "declare @x table  [...]" statement which you can use to INSERT the results of the stored procedure.  Step 4: Insert into the newly created tableNow you\'ll have a query that\'s like the other solutions described in this thread.  This technique can also be used to convert a temp table (#temp) to a table variable (@temp).  While this may be more steps than just writing the create table statement yourself, it prevents manual error such as typos and data type mismatches in large processes.  Debugging a typo can take more time than writing the query in the first place.Quassnoi put me most of the way there, but one thing was missing:So I found a way to work the system and also not have to make the table definition so rigid, and redefine it inside another stored procedure (and of course take the chance it may break)!Yes, you can dynamically create the table definition returned from the stored procedure by\nusing the OPENQUERY statement with bogus varaiables (as long the NO RESULT SET returns the\nsame number of fields and in the same position as a dataset with good data).Once the table is created, you can use exec stored procedure into the temporary table all day long.Thanks for the information which was provided originally...\nYes, finally I do not have to create all these bogus (strict) table defintions when using data from\nanother stored procedure or database, and yes you can use parameters too.Search reference tags:SQL 2005 stored procedure into temp tableopenquery with stored procedure and variables 2005openquery with variablesexecute stored procedure into temp tableUpdate: this will not work with temporary tables so I had to resort to manually creating the temporary table.Bummer notice: this will not work with temporary tables, http://www.sommarskog.se/share_data.html#OPENQUERYReference: The next thing is to define LOCALSERVER. It may look like a keyword in the example, but it is in fact only a name. This is how you do it:To create a linked server, you must have the permission ALTER ANY SERVER, or be a member of any of the fixed server roles sysadmin or setupadmin.OPENQUERY opens a new connection to SQL Server. This has some implications:The procedure that you call with OPENQUERY cannot refer temporary tables created in the current connection.The new connection has its own default database (defined with sp_addlinkedserver, default is master), so all object specification must include a database name.If you have an open transaction and are holding locks when you call OPENQUERY, the called procedure can not access what you lock. That is, if you are not careful you will block yourself.Connecting is not for free, so there is a performance penalty.If the OPENROWSET is causing you issues, there is another way from 2012 onwards; make use of sys.dm_exec_describe_first_result_set_for_object, as mentioned here: Retrieve column names and types of a stored procedure?First, create this stored procedure to generate the SQL for the temporaryTo use the procedure, call it in the following way:Note that I\'m using a global temporary table. That\'s because using EXEC to run the dynamic SQL creates its own session, so an ordinary temporary table would be out of scope to any subsequent code. If a global temporary table is a problem, you can use an ordinary temporary table, but any subsequent SQL would need to be dynamic, that is, also executed by the EXEC statement.This stored proc does the job:It\'s a slight rework of this: Insert stored procedure results into table so that it actually works.If you want it to work with a temporary table then you will need to use a ##GLOBAL table and drop it afterwards.In order to insert the first record set of a stored procedure into a temporary table you need to know the following:The above may look as limitation, but IMHO it perfectly makes sense - if you are using sp_executesql you can once return two columns and once ten, and if you have multiple result sets, you cannot insert them in several tables as well - you can insert maximum in two table in one T-SQL statement (using OUTPUT clause and no triggers).So, the issue is mainly how to define the temporary table structure before performing the EXEC ... INTO ... statement.The first works with OBJECT_ID while the second and the third works with Ad-hoc queries as well. I prefer to use the DMV instead the sp as you can use CROSS APPLY and build the temporary table definitions for multiple procedures at the same time.Also, pay attention to the system_type_name field as it can be very useful. It stores the column complete definition. For, example:and you can use it directly in most of the cases to create the table definition.So, I think in most of the cases (if the stored procedure match certain criteria) you can easily build a dynamic statements for solving such issues (create the temporary table, insert the stored procedure result in it, do what you need with the data).Note, that the objects above fail to defined the first result set data in some cases like when dynamic T-SQL statements are executed or temporary tables are used in the stored procedure. CodeI hope this helps. Please qualify as appropriate.I found Passing Arrays/DataTables into Stored Procedures which might give you another idea on how you might go solving your problem.The link suggests to use an Image type parameter to pass into the stored procedure. Then in the stored procedure, the image is transformed into a table variable containing the original data.Maybe there is a way this can be used with a temporary table.Now I know what the result of my procedure is, so I am performing the following query.If the query doesn\'t contain parameter, use OpenQuery else use OpenRowset.Basic thing would be to create schema as per stored procedure and insert into that table. e.g.:If you\'re lucky enough to have SQL 2012 or higher, you can use dm_exec_describe_first_result_set_for_objectI have just edited the sql provided by gotqn. Thanks gotqn.This creates a global temp table with name same as procedure name. The temp table can later be used as required. Just don\'t forget to drop it before re-executing.Another method is to create a type and use PIPELINED to then pass back your object. This is limited to knowing the columns however. But it has the advantage of being able to do:I met the same problem and here is what I did for this from Paul\'s suggestion. The main part is here is to use NEWID() to avoid multiple users run the store procedures/scripts at the same time, the pain for global temporary table.If you know the parameters that are being passed and if you don\'t have access to make sp_configure, then edit the stored procedure with these parameters and the same can be stored in a ##global table.This can be done in SQL Server 2014+ provided SP only returns one table. If anyone finds a way of doing this for multiple tables I\'d love to know about it.This pulls the definition of the returned table from system tables, and uses that to build the temp table for you. You can then populate it from the SP as stated before.There are also variants of this that work with Dynamic SQL too.I would do the followingCreate (convert SP to) a UDF (Table value UDF).select * into #tmpBusLine from dbo.UDF_getBusinessLineHistory \'16 Mar 2009\'