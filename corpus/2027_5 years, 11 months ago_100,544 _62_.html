I am developing exclusively for iOS 5 using ARC. Should IBOutlets to UIViews (and subclasses) be strong or weak?The following:Would get rid of all of this:Are there any problems doing this? The templates are using strong as are the automatically generated properties created when connecting directly to the header from the \'Interface Builder\' editor, but why? The UIViewController already has a strong reference to its view which retains its subviews.The current recommended best practice from Apple is for IBOutlets to be strong unless weak is specifically needed to avoid a retain cycle. As Johannes mentioned above, this was commented on in the "Implementing UI Designs in Interface Builder" session from WWDC 2015 where an Apple Engineer said:And the last option I want to point out is the storage type, which can\n  either be strong or weak. In general you should make your outlet\n  strong, especially if you are connecting an outlet to a subview or to\n  a constraint that\'s not always going to be retained by the view\n  hierarchy. The only time you really need to make an outlet weak is if\n  you have a custom view that references something back up the view\n  hierarchy and in general that\'s not recommended.I asked about this on Twitter to an engineer on the IB team and he confirmed that strong should be the default and that the developer docs are being updated.https://twitter.com/_danielhall/status/620716996326350848\nhttps://twitter.com/_danielhall/status/620717252216623104WARNING, OUTDATED ANSWER: this answer is not up to date as per WWDC 2015, for the correct answer refer to the accepted answer (Daniel Hall) above. This answer will stay for record.Summarized from the developer library:From a practical perspective, in iOS and OS X outlets should be defined as declared properties. Outlets should generally be weak, except for those from File\xe2\x80\x99s Owner to top-level objects in a nib file (or, in iOS, a storyboard scene) which should be strong. Outlets that you create will therefore typically be weak by default, because:Outlets that you create to, for example, subviews of a view controller\xe2\x80\x99s view or a window controller\xe2\x80\x99s window, are arbitrary references between objects that do not imply ownership.The strong outlets are frequently specified by framework classes (for example, UIViewController\xe2\x80\x99s view outlet, or NSWindowController\xe2\x80\x99s window outlet).While the documentation recommends using weak on properties for subviews, since iOS 6 it seems to be fine to use strong (the default ownership qualifier) instead. That\'s caused by the change in UIViewController that views are not unloaded anymore.That said, I am torn between usingandin iOS 6 and after:Using weak clearly states that the controller doesn\'t want ownership of the button.But omitting weak doesn\'t hurt in iOS 6 without view unloading, and is shorter. Some may point out that is also faster, but I have yet to encounter an app that is too slow because of weak IBOutlets.Not using weak may be perceived as an error.Bottom line: Since iOS 6 we can\'t get this wrong anymore as long as we don\'t use view unloading. Time to party. ;)I don\'t see any problem with that. Pre-ARC, I\'ve always made my IBOutlets assign, as they\'re already retained by their superviews. If you make them weak, you shouldn\'t have to nil them out in viewDidUnload, as you point out. One caveat: You can support iOS 4.x in an ARC project, but if you do, you can\'t use weak, so you\'d have to make them assign, in which case you\'d still want to nil the reference in viewDidUnload to avoid a dangling pointer. Here\'s an example of a dangling pointer bug I\'ve experienced:A UIViewController has a UITextField for zip code. It uses CLLocationManager to reverse geocode the user\'s location and set the zip code. Here\'s the delegate callback:I found that if I dismissed this view at the right time and didn\'t nil self.zip in viewDidUnload, the delegate callback could throw a bad access exception on self.zip.text.In iOS development NIB loading is a little bit different from Mac development. In Mac development an IBOutlet is usually a weak reference: if you have a subclass of NSViewController only the top-level view will be retained and when you dealloc the controller all its subviews and outlets are freed automatically. UiViewController use Key Value Coding to set the outlets using strong references. So when you dealloc your UIViewController, the top view will automatically deallocated, but you must also deallocate all its outlets in the dealloc method. In this post from the Big Nerd Ranch, they cover this topic and also explain why using a strong reference in IBOutlet is not a good choice (even if it is recommended by Apple in this case). From WWDC 2015 there is a session on Implementing UI Designs in Interface Builder. Around the 32min mark he says that you always want to make your @IBOutlet strong.IBOutlet should be strong, for performance reason. See Storyboard Reference, Strong IBOutlet, Scene Dock in iOS 9As explained in this paragraph, the outlets to subviews of the view\n  controller\xe2\x80\x99s view can be weak, because these subviews are already\n  owned by the top-level object of the nib file. However, when an Outlet\n  is defined as a weak pointer and the pointer is set, ARC calls the\n  runtime function:id objc_storeWeak(id *object, id value); This adds the pointer\n  (object) to a table using the object value as a key. This table is\n  referred to as the weak table. ARC uses this table to store all the\n  weak pointers of your application. Now, when the object value is\n  deallocated, ARC will iterate over the weak table and set the weak\n  reference to nil. Alternatively, ARC can call:void objc_destroyWeak(id * object)Then, the object is\n  unregistered and objc_destroyWeak calls again:objc_storeWeak(id *object, nil)This book-keeping associated\n  with a weak reference can take 2\xe2\x80\x933 times longer over the release of a\n  strong reference. So, a weak reference introduces an overhead for the\n  runtime that you can avoid by simply defining outlets as strong.As of Xcode 7, it suggests strongOne thing I wish to point out here, and that is, despite what the Apple engineers have stated in their own WWDC 2015 video here:https://developer.apple.com/videos/play/wwdc2015/407/Apple keeps changing their mind on the subject, which tells us that there is no single right answer to this question.  To show that even Apple engineers are split on this subject, take a look at Apple\'s most recent\nsample code, and you\'ll see some people use weak, and some don\'t.This Apple Pay example uses weak:\nhttps://developer.apple.com/library/ios/samplecode/Emporium/Listings/Emporium_ProductTableViewController_swift.html#//apple_ref/doc/uid/TP40016175-Emporium_ProductTableViewController_swift-DontLinkElementID_8As does this picture-in-picture example:\nhttps://developer.apple.com/library/ios/samplecode/AVFoundationPiPPlayer/Listings/AVFoundationPiPPlayer_PlayerViewController_swift.html#//apple_ref/doc/uid/TP40016166-AVFoundationPiPPlayer_PlayerViewController_swift-DontLinkElementID_4As does the Lister example:\nhttps://developer.apple.com/library/ios/samplecode/Lister/Listings/Lister_ListCell_swift.html#//apple_ref/doc/uid/TP40014701-Lister_ListCell_swift-DontLinkElementID_57As does the Core Location example:\nhttps://developer.apple.com/library/ios/samplecode/PotLoc/Listings/Potloc_PotlocViewController_swift.html#//apple_ref/doc/uid/TP40016176-Potloc_PotlocViewController_swift-DontLinkElementID_6As does the view controller previewing example:\nhttps://developer.apple.com/library/ios/samplecode/ViewControllerPreviews/Listings/Projects_PreviewUsingDelegate_PreviewUsingDelegate_DetailViewController_swift.html#//apple_ref/doc/uid/TP40016546-Projects_PreviewUsingDelegate_PreviewUsingDelegate_DetailViewController_swift-DontLinkElementID_5As does the HomeKit example:\nhttps://developer.apple.com/library/ios/samplecode/HomeKitCatalog/Listings/HMCatalog_Homes_Action_Sets_ActionSetViewController_swift.html#//apple_ref/doc/uid/TP40015048-HMCatalog_Homes_Action_Sets_ActionSetViewController_swift-DontLinkElementID_23All those are fully updated for iOS 9, and all use weak outlets.  From this we learn that A.  The issue is not as simple as some people make it out to be.  B. Apple has changed their mind repeatedly, and C. You can use whatever makes you happy :)Special thanks to Paul Hudson (author of www.hackingwithsift.com) who gave me the clarification, and references for this answer.I hope this clarifies the subject a bit better!Take care.Be aware, IBOutletCollection should be @property (strong, nonatomic).It looks like something has changed over the years and now Apple recommends to use strong in general. The evidence on their WWDC session is in session 407 - Implementing UI Designs in Interface Builder and starts at 32:30. My note from what he says is (almost, if not exactly, quoting him):outlet connections in general should be strong especially if we connect a subview or constraint that is not always retained by the\nview hierarchyweak outlet connection might be needed when creating custom views that has some reference to something back up in the view hierarchy\nand in general it is not recommendedIn other wards it should be always strong now as long as some of our custom view doesn\'t create a retain cycle with some of the view up in the view hierarchyEDIT :Some may ask the question. Does keeping it with a strong reference doesn\'t create a retain cycle as the root view controller and the owning view keeps the reference to it? Or why that changed happened?\nI think the answer is earlier in this talk when they describe how the nibs are created from the xib. There is a separate nib created for a VC and for the view. I think this might be the reason why they change the recommendations. Still it would be nice to get a deeper explanation from Apple.I think that most important information is:\nElements in xib are automatically in subviews of view. Subviews is NSArray. NSArray owns it\'s elements. etc have strong pointers on them. So in most cases you don\'t want to create another strong pointer (IBOutlet)And with ARC you don\'t need to do anything in viewDidUnload