In the section about inheritance in the MDN article Introduction to Object Oriented Javascript, I noticed they set the prototype.constructor:Does this serve any important purpose? Is it okay to omit it?It\'s not always necessary, but it does have its uses. Suppose we wanted to make a copy method on the base Person class. Like this:Now what happens when we create a new Student and copy it?       The copy is not an instance of Student. This is because (without explicit checks), we\'d have no way to return a Student copy from the "base" class. We can only return a Person. However, if we had reset the constructor:...then everything works as expected:Does this serve any important purpose?Yes and no.In ES5 and earlier, JavaScript itself didn\'t use constructor for anything. It defined that the default object on a function\'s prototype property would have it and that it would refer back to the function, and that was it. Nothing else in the specification referred to it at all.That changed in ES2015 (ES6), which started using it in relation to inheritance hierarchies. For instance, Promise#then uses the constructor property of the promise you call it on (via SpeciesConstructor) when building the new promise to return. It\'s also involved in subtyping arrays (via ArraySpeciesCreate).Outside of the language itself, sometimes people would use it when trying to build generic "clone" functions or just generally when they wanted to refer to what they believed would be the object\'s constructor function. My experience is that using it is rare, but sometimes people do use it.Is it okay to omit it?It\'s there by default, you only need to put it back when you replace the object on a function\'s prototype property:If you don\'t do this:...then Student.prototype.constructor inherits from Person.prototype which (presumably) has constructor = Person. So it\'s misleading. And of course, if you\'re subclassing something that uses it (like Promise or Array) and not using class\xc2\xb9 (which handles this for you), you\'ll want to make sure you set it correctly. So basically: It\'s a good idea.It\'s okay if nothing in your code (or library code you use) uses it. I\'ve always ensured it was correctly wired up.Of course, with ES2015 (aka ES6)\'s class keyword, most of the time we would have used it, we don\'t have to anymore, because it\'s handled for us when we do\xc2\xb9 "...if you\'re subclassing something that uses it (like Promise or Array) and not using class..." — It\'s possible to do that, but it\'s a real pain (and a bit silly). You have to use Reflect.construct.I\'d disagree. It isn\'t necessary to set the prototype. Take that exact same code but remove the prototype.constructor line. Does anything change? No. Now, make the following changes:and at the end of the test code...The color will be blue.A change to the prototype.constructor, in my experience, doesn\'t do much unless you\'re doing very specific, very complicated things that probably aren\'t good practice anyway :)Edit:\nAfter poking around the web for a bit and doing some experimentation, it looks like people set the constructor so that it \'looks\' like the thing that is being constructed with \'new\'. I guess I would argue that the problem with this is that javascript is a prototype language - there is no such thing as inheritence. But most programmers come from a background of programming that pushes inheritence as \'the way\'. So we come up with all sorts of things to try and make this prototypical language a \'classic\' language.. such as extending \'classes\'. Really, in the example they gave, a new student is a person - it isn\'t \'extending\' from another student.. the student is all about the person, and whatever the person is the student is as well. Extend the student, and whatever you\'ve extended is a student at heart, but is customized to fit your needs. Crockford is a bit crazy and overzealous, but do some serious reading on some of the stuff that he\'s written.. it\'ll make you look at this stuff very differently.This has the huge pitfall that if you wrote but then if there was a Teacher whose prototype was also Person and you wrotethen the Student constructor is now Teacher!Edit:\nYou can avoid this by ensuring that you had set the Student and Teacher prototypes using new instances of the Person class created using Object.create, as in the Mozilla example.TLDR; Not super necessary, but will probably help in the long run, and it is more accurate to do so.NOTE: Much edited as my previous answer was confusingly written and had some errors that I missed in my rush to answer. Thanks to those who pointed out some egregious errors.Basically, it\'s to wire subclassing up correctly in Javascript. When we subclass, we have to do some funky things to make sure that the prototypal delegation works correctly, including overwriting a prototype object. Overwriting a prototype object includes the constructor, so we then need to fix the reference.Let\'s quickly go through how \'classes\' in ES5 work.Let\'s say you have a constructor function and its prototype:When you call the constructor to instantiate, say Adam:The new keyword invoked with \'Person\' basically will run the Person constructor with a few additional lines of code:If we console.log(adam.species), the lookup will fail at the adam instance, and look up the prototypal chain to its .prototype, which is Person.prototype - and Person.prototype has a .species property, so the lookup will succeed at Person.prototype. It will then log \'human\'.Here, the Person.prototype.constructor will correctly point to Person.So now the interesting part, the so-called \'subclassing\'. If we want to create a Student class, that is a subclass of the Person class with some additional changes, we\'ll need to make sure that the Student.prototype.constructor points to Student for accuracy.It doesn\'t do this by itself. When you subclass, the code looks like this:Calling new Student() here would return an object with all of the properties we want. Here, if we check eve instanceof Person, it would return false. If we try to access eve.species, it would return undefined.In other words, we need to wire up the delegation so that eve instanceof Person returns true and so that instances of Student delegate correctly to Student.prototype, and then Person.prototype.BUT since we\'re calling it with the new keyword, remember what that invocation adds? It would call Object.create(Student.prototype), which is how we set up that delegational relationship between Student and Student.prototype. Note that right now, Student.prototype is empty. So looking up .species an instance of Student would fail as it delegates to only Student.prototype, and the .species property doesn\'t exist on Student.prototype.When we do assign Student.prototype to Object.create(Person.prototype), Student.prototype itself then delegates to Person.prototype, and looking up eve.species will return human as we expect. Presumably we would want it to inherit from Student.prototype AND Person.prototype. So we need to fix all of that.Now the delegation works, but we\'re overwriting Student.prototype with an of Person.prototype. So if we call Student.prototype.constructor, it would point to Person instead of Student. This is why we need to fix it. In ES5, our constructor property is a reference that refers to a function that we\'ve written with the intent to be a \'constructor\'. Aside from what the new keyword gives us, the constructor is otherwise a \'plain\' function.In ES6, the constructor is now built into the way we write classes -  as in, it\'s provided as a method when we declare a class. This is simply syntactic sugar but it does accord us some conveniences like access to a super when we are extending an existing class. So we would write the above code like this:So far confusion is still there.Following the original example, as you have an existing object student1 as:Suppose you don\'t want to know how student1 is created, you just want another object like it, you can use the constructor property of student1 like:Here it will fail to get the properties from Student if the constructor property is not set. Rather it will create a Person object.Got a nice code example of why it is really necessary to set the prototype constructor..It is necessary when you need an alternative to toString without monkeypatching:Yes, it is necessary. When you do Student.prototype.constructor becomes Person. Therefore, calling Student() would return an object created by Person. If you then doStudent.prototype.constructor is reset back to Student. Now when you call Student() it executes Student, which calls the parent constructor Parent(), it returns the correctly inherited object. If you didn\'t reset Student.prototype.constructor before calling it you would get an object that would not have any of the properties set in Student().No need for sugared function \'classes\' or using \'New\' these days. Use object literals.The Object prototype is already a \'class\'. When you define an object literal, it is already an instance of the prototype Object. These can also act as another object\'s prototype, etc.This is worth a read:Class-based object-oriented languages, such as Java and C++, are\n  founded on the concept of two distinct entities: classes and\n  instances....A prototype-based language, such as JavaScript, does not make this\n  distinction: it simply has objects. A prototype-based language has the\n  notion of a prototypical object, an object used as a template from\n  which to get the initial properties for a new object. Any object can\n  specify its own properties, either when you create it or at run time.\n  In addition, any object can be associated as the prototype for another\n  object, allowing the second object to share the first object\'s\n  propertiesIt is not needed if you use factories instead of constructors with prototypal inheritance. Additional advantages include:The following code demonstrates how to use that approach to avoid all those problems and to achieve the same result:Here is jsbin to play with.Given simple constructor function:By default (from the specification https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor), all prototypes automatically get a property called constructor that points back to the function on which it is a property. \nDepending on the constructor, other properties and methods might be added to the prototype which is not a very common practice but still it is allowed for extensions. So simply answering: we need make sure that the value in prototype.constructor is correctly set as it is supposed by the specification to be.Do we have to always set correctly this value? It helps with debugging and makes internal structure consistent against specification. We should definitely when our API is being used by the thirdparties, but not really when the code is finally executed in the runtime.It is not necessary. It is just one of the many things traditional, OOP champions do to try to turn JavaScript\'s prototypical inheritance into classical inheritance. The only thing that the followingdoes, is that you now have a reference of the current "constructor".In Wayne\'s answer, that has been marked as correct, you could the exact same thing that the following code doeswith the code below (just replace this.constructor with Person)Thank God that with ES6 classical inheritance purists can use language\'s native operators like class, extends and super and we don\'t have to see like prototype.constructor corrections and parent refereces.