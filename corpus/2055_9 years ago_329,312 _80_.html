How do I use RelativeSource with WPF bindings and what are the different use-cases?If you want to bind to another property on the object:If you want to get a property on an ancestor:If you want to get a property on the templated parent (so you can do 2 way bindings in a ControlTemplate)or, shorter (this only works for OneWay bindings):The default attribute of RelativeSource is the Mode property.  A complete set of valid values is given here (from MSDN):PreviousData Allows you to bind the previous data item (not that control that contains the data item) in the list of data items being displayed.TemplatedParent Refers to the element to which the template (in which the data-bound element exists) is applied. This is similar to setting a TemplateBindingExtension and is only applicable if the Binding is within a template.Self Refers to the element on which you are setting the binding and allows you to bind one property of that element to another property on the same element.FindAncestor Refers to the ancestor in the parent chain of the data-bound element. You can use this to bind to an ancestor of a specific type or its subclasses. This is the mode you use if you want to specify AncestorType and/or AncestorLevel.Here\'s a more visual explanation in the context of a MVVM architecture:Imagine this case, a rectangle that we want that its height is always equal to its width, a square let\'s say. We can do this using the element nameBut in this above case we are obliged to indicate the name of the binding object, namely the rectangle. We can reach the same purpose differently using the RelativeSource For that case we are not obliged to mention the name of the binding object and the Width will be always equal to the Height whenever the height is changed. If you want to parameter the Width to be the half of the height then you can do this by adding a converter to the Binding markup extension.\nLet\'s imagine another case now:The above case is used to tie a given property of a given element to one of its direct parent ones as this element holds a property that is called Parent. This leads us to another relative source mode which is the FindAncestor one. Bechir Bejaoui exposes the use cases of the RelativeSources in WPF in his article here:The RelativeSource is a markup extension that is used in particular\n  binding cases when we try to bind a property of a given object to\n  another property of the object itself, when we try to bind a property\n  of a object to another one of its relative parents, when binding a\n  dependency property value to a piece of XAML in case of custom control\n  development and finally in case of using a differential of a series of\n  a bound data. All of those situations are expressed as relative source\n  modes. I will expose all of those cases one by one.Imagine this case, a rectangle that we want that its height is always\n  equal to its width, a square let\'s say. We can do this using the\n  element nameBut in this above case we are obliged to indicate the name of the\n  binding object, namely the rectangle. We can reach the same purpose\n  differently using the RelativeSource For that case we are not obliged to mention the name of the binding\n  object and the Width will be always equal to the Height whenever the\n  height is changed. If you want to parameter the Width to be the half of the height then\n  you can do this by adding a converter to the Binding markup extension.\n  Let\'s imagine another case now:The above case is used to tie a given property of a given element to\n  one of its direct parent ones as this element holds a property that is\n  called Parent. This leads us to another relative source mode which is\n  the FindAncestor one. In this case, a property of a given element will be tied to one of its\n  parents, Of Corse. The main difference with the above case is the fact\n  that, it\'s up to you to determine the ancestor type and the ancestor\n  rank in the hierarchy to tie the property. By the way try to play with\n  this piece of XAMLThe above situation is of two TextBlock elements those are embedded\n  within a series of borders and canvas elements those represent their\n  hierarchical parents. The second TextBlock will display the name of\n  the given parent at the relative source level.So try to change AncestorLevel=2 to AncestorLevel=1 and see what\n  happens. Then try to change the type of the ancestor from\n  AncestorType=Border to AncestorType=Canvas and see what\'s happens. The displayed text will change according to the Ancestor type and\n  level. Then what\'s happen if the ancestor level is not suitable to the\n  ancestor type? This is a good question, I know that you\'re about to\n  ask it. The response is no exceptions will be thrown and nothings will\n  be displayed at the TextBlock level. This mode enables tie a given ControlTemplate property to a property\n  of the control that the ControlTemplate is applied to. To well\n  understand the issue here is an example bellowIf I want to apply the properties of a given control to its control\n  template then I can use the TemplatedParent mode. There is also a\n  similar one to this markup extension which is the TemplateBinding\n  which is a kind of short hand of the first one, but the\n  TemplateBinding is evaluated at compile time at the contrast of the\n  TemplatedParent which is evaluated just after the first run time. As\n  you can remark in the bellow figure, the background and the content\n  are applied from within the button to the control template.Don\'t forget TemplatedParent:orI created a library to simplify the binding syntax of WPF including making it easier to use RelativeSource. Here are some examples. Before:After:Here is an example of how method binding is simplified. Before:After:You can find the library here: http://www.simplygoodcode.com/2012/08/simpler-wpf-binding.htmlNote in the \'BEFORE\' example that I use for method binding that code was already optimized by using RelayCommand which last I checked is not a native part of WPF. Without that the \'BEFORE\' example would have been even longer.In WPF RelativeSource binding exposes 3 properties to set:1. Mode :  This is an enum that could have four values:a. PreviousData(value=0) : It assigns the previous value of the property to\n  the bound oneb. TemplatedParent(value=1) :  This is used when defining the templates of\n  any control and want to bind to a value/Property of the control. Ex. define ControlTemplatec. Self(value=2) :  When want to bind from a self or a property of self. Ex. Send checked state of checkbox as CommandParameter while setting the Command on CheckBoxd. FindAncestor(value=3) : When want to bind from a parent control \n  in Visual Tree.Ex. bind a checkbox in records if a grid,if header checkbox is checked2. AncestorType :  when mode is FindAncestor then define what type of ancestor3. AncestorLevel :   when mode is FindAncestor then what level of ansector (if there are two same type of parent in visual tree)Above are all use-cases for RelativeSource binding.Here is a ref linkIt\'s worthy of note that for those stumbling across this thinking of Silverlight:Silverlight offers a reduced subset only, of these commandsSince this is top of Google for this problem, I thought I would some useful bits and pieces:\nHere\'s how to do it mostly in code:I largely copied this from:\nhttp://social.msdn.microsoft.com/Forums/en/wpf/thread/c5a59f07-c932-4715-8774-fa7e8472b75bAlso, the MSDN page is pretty good as far as examples go:\nhttp://msdn.microsoft.com/en-us/library/system.windows.data.relativesource.aspxI just posted another solution for accessing the DataContext of a parent element in Silverlight that works for me. It uses Binding ElementName.This is an example of the use of this pattern that worked for me on empty datagrids.I didn\'t read every answer but I just want to add this information in case of relative source Command Binding of a button. When you use relative source with Mode=FindAncestor, the binding must be like: If you don\'t add DataContext in your path, at execution time he can\'t retrieve the property. If an element is not part of the visual tree, then RelativeSource will never work.In this case, you need to try a different technique, pioneered by Thomas Levesque.He has the solution on his blog under [WPF] How to bind to data when the DataContext is not inherited. And it works absolutely brilliantly!In the unlikely event that his blog is down, Appendix A contains a mirror copy of his article.Please do not comment here, please comment directly on his blog post.The DataContext property in WPF is extremely handy, because it is automatically inherited by all children of the element where you assign it; therefore you don\xe2\x80\x99t need to set it again on each element you want to bind. However, in some cases the DataContext is not accessible: it happens for elements that are not part of the visual or logical tree. It can be very difficult then to bind a property on those elements\xe2\x80\xa6Let\xe2\x80\x99s illustrate with a simple example: we want to display a list of products in a DataGrid. In the grid, we want to be able to show or hide the Price column, based on the value of a ShowPrice property exposed by the ViewModel. The obvious approach is to bind the Visibility of the column to the ShowPrice property:Unfortunately, changing the value of ShowPrice has no effect, and the column is always visible\xe2\x80\xa6 why? If we look at the Output window in Visual Studio, we notice the following line:System.Windows.Data Error: 2 : Cannot find governing FrameworkElement or FrameworkContentElement for target element. BindingExpression:Path=ShowPrice; DataItem=null; target element is \xe2\x80\x98DataGridTextColumn\xe2\x80\x99 (HashCode=32685253); target property is \xe2\x80\x98Visibility\xe2\x80\x99 (type \xe2\x80\x98Visibility\xe2\x80\x99)The message is rather cryptic, but the meaning is actually quite simple: WPF doesn\xe2\x80\x99t know which FrameworkElement to use to get the DataContext, because the column doesn\xe2\x80\x99t belong to the visual or logical tree of the DataGrid.We can try to tweak the binding to get the desired result, for instance by setting the RelativeSource to the DataGrid itself:Or we can add a CheckBox bound to ShowPrice, and try to bind the column visibility to the IsChecked property by specifying the element name:But none of these workarounds seems to work, we always get the same result\xe2\x80\xa6At this point, it seems that the only viable approach would be to change the column visibility in code-behind, which we usually prefer to avoid when using the MVVM pattern\xe2\x80\xa6 But I\xe2\x80\x99m not going to give up so soon, at least not while there are other options to consider \xf0\x9f\x98\x89The solution to our problem is actually quite simple, and takes advantage of the Freezable class. The primary purpose of this class is to define objects that have a modifiable and a read-only state, but the interesting feature in our case is that Freezable objects can inherit the DataContext even when they\xe2\x80\x99re not in the visual or logical tree. I don\xe2\x80\x99t know the exact mechanism that enables this behavior, but we\xe2\x80\x99re going to take advantage of it to make our binding work\xe2\x80\xa6The idea is to create a class (I called it BindingProxy for reasons that should become obvious very soon) that inherits Freezable and declares a Data dependency property:We can then declare an instance of this class in the resources of the DataGrid, and bind the Data property to the current DataContext:The last step is to specify this BindingProxy object (easily accessible with StaticResource) as the Source for the binding:Note that the binding path has been prefixed with \xe2\x80\x9cData\xe2\x80\x9d, since the path is now relative to the BindingProxy object.The binding now works correctly, and the column is properly shown or hidden based on the ShowPrice property.