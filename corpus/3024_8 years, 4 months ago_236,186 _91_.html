A common task when calling web resources from a code is building a query string to including all the necessary parameters. While by all means no rocket science, there are some nifty details you need to take care of like, appending an & if not the first parameter, encoding the parameters etc.The code to do it is very simple, but a bit tedious:This is such a common task one would expect a utility class to exist that makes it more elegant and readable. Scanning MSDN, I failed to find oneâ€”which brings me to the following question:What is the most elegant clean way you know of doing the above?If you look under the hood the QueryString property is a NameValueCollection. When I\'ve done similar things I\'ve usually been interested in serialising AND deserialising so my suggestion is to build a NameValueCollection up and then pass to:Possibly I could\'ve formatted that better :)I imagine there\'s a super elegant way to do this in LINQ too...You can create a new writeable instance of HttpValueCollection by calling System.Web.HttpUtility.ParseQueryString(string.Empty), and then use it as any NameValueCollection. Once you have added the values you want, you can call ToString on the collection to get a query string, as follows:The HttpValueCollection is internal and so you cannot directly construct an instance. However, once you obtain an instance you can use it like any other NameValueCollection. Since the actual object you are working with is an HttpValueCollection, calling ToString method will call the overridden method on HttpValueCollection, which formats the collection as a URL-encoded query string.After searching SO and the web for an answer to a similar issue, this is the most simple solution I could find..NET CoreIf you\'re working in .NET Core, you can use the Microsoft.AspNetCore.WebUtilities.QueryHelpers class, which simplifies this greatly.https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.aspnetcore.webutilities.queryhelpersWith the inspiration from Roy Tinker\'s comment, I ended up using a simple extension method on the Uri class that keeps my code concise and clean:Usage:Edit - Standards compliant variantAs several people pointed out, httpValueCollection.ToString() encodes Unicode characters in a non-standards-compliant way. This is a variant of the same extension method that handles such characters by invoking HttpUtility.UrlEncode method instead of the deprecated HttpUtility.UrlEncodeUnicode method.I answered a similar question a while ago. Basically, the best way would be to use the class HttpValueCollection, which ASP.NET\'s Request.QueryString property actually is, unfortunately it is internal in the .NET framework.\nYou could use Reflector to grab it (and place it into your Utils class). This way you could manipulate the query string like a NameValueCollection, but with all the url encoding/decoding issues taken care for you.HttpValueCollection extends NameValueCollection, and has a constructor that takes an encoded query string (ampersands and question marks included), and it overrides a ToString() method to later rebuild the query string from the underlying collection.Example:Here\'s a fluent/lambda-ish way as an extension method (combining concepts in previous posts) that supports multiple values for the same key.  My personal preference is extensions over wrappers for discover-ability by other team members for stuff like this.  Note that there\'s controversy around encoding methods, plenty of posts about it on Stack Overflow (one such post) and MSDN bloggers (like this one).edit: with null support, though you\'ll probably need to adapt it for your particular situationHere\'s my late entry.  I didn\'t like any of the others for various reasons, so I wrote my own.This version features:Use of StringBuilder only.  No ToArray() calls or other extension methods.  It doesn\'t look as pretty as some of the other responses, but I consider this a core function so efficiency is more important than having "fluent", "one-liner" code which hide inefficiencies.Handles multiple values per key. (Didn\'t need it myself but just to silence Mauricio ;)Flurl [disclosure: I\'m the author] supports building query strings via anonymous objects (among other ways):[UPDATE]Flurl now has a companion lib for doing HTTP calls off the fluent chain:Also includes a nifty set of testing features. Full package is available on NuGet:PM> Install-Package Flurl.Httpor just the stand-alone URL builder:PM> Install-Package FlurlHow about creating extension methods that allow you to add the parameters in a fluent style like this?Here\'s the overload that uses a string:And here\'s the overload that uses a StringBuilder:I needed to solve the same problem for a portable class library (PCL) that I\'m working on.  In this case, I don\'t have access to System.Web so I can\'t use ParseQueryString.Instead I used System.Net.Http.FormUrlEncodedContent like so:My offering:Usage:Add this class to your projectAnd use it like this:Untested, but I think something along these lines would work quite nicelyA quick extension method based version:You could use a where clause to select which parameters get added to the string. Assuming that you want to reduce dependencies to other assemblies and to keep things simple, you can do:This works well with loops too.  The final ampersand removal needs to go outside of the loop.Note that the concatenation operator is used to improve readability.  The cost of using it compared to the cost of using a StringBuilder is minimal (I think Jeff Atwood posted something on this topic).[Also late entry]Chain-able wrapper class for HttpValueCollection:Example usage:Same as accepted solution, but transfred to "dot" LINQ syntax...Combined the top answers to create an anonymous object version:That generates this:key2=value2&key1=value1Here\'s the code:I added the following method to my PageBase class.To call:I wrote some extension methods that I have found very useful when working with QueryStrings.  Often I want to start with the current QueryString and modify before using it.  Something like,For more and the source: http://www.charlesrcook.com/archive/2008/07/23/c-extension-methods-for-asp.net-query-string-operations.aspxIt\'s basic, but I like the style.Just wanted to throw in my 2 cents:The docs say that uri.Query will start with a ? if it\'s non-empty and you should trim it off if you\'re going to modify it.Note that HttpUtility.UrlEncode is found in System.Web.Usage:I have an extension method for Uri that:The documented version can be found here.The extension:The query parser:Here are the tests:Output:http://www.google.com/SomePathName/AnotherPathName?A=BC&SomeQueryKey=SomeQueryValueThe code; you can all thank me somewhere, somehow :DI went with the solution proposed by DSO (answered on Aug 2 \'11 at 7:29), his solution does not require using HttpUtility. However, as per an article posted in Dotnetpearls, using a Dictionary is faster (in performance) than using NameValueCollection. Here is DSO\'s solution modified to use Dictionary in place of NameValueCollection.I wrote a helper for my razor project using some of the hints from other answers.The ParseQueryString business is necessary because we are not allowed to tamper with the QueryString object of the current request.I use it like this:If you want it to take more than one value, just change the parameters to a Dictionary and add the pairs to the query string.The code below  is taken off the HttpValueCollection implementation of ToString, via ILSpy, which gives you a name=value querystring.Unfortunately HttpValueCollection is an internal class which you only ever get back if you use HttpUtility.ParseQueryString(). I removed all the viewstate parts to it, and it encodes by default:This is the identical to the accepted answer except slightly more compact:Just for those that need the VB.NET version of the top-answer:And the version without LINQ:And the C# version without LINQ:Works for multiple values per key in NameValueCollection. ex: { {"k1", "v1"}, {"k1", "v1"} } => ?k1=v1&k1=v1This is another (maybe redundant :-]) way for do that.The conceptuals are the same of the Vedran answer in this page (take a look here).But this class is more efficient, because it iterate through all Keys only one time: when ToString is invoked.The formatting code is also semplified and improved.Hope that could be helpful.