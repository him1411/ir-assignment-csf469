I\'ve been working on Android SDK platform, and it is a little unclear how to save an application\'s state. So given this minor re-tooling of the \'Hello, Android\' example:I thought it would be enough for the simplest case, but it always responds with the first message, no matter how I navigate away from the app.I\'m sure the solution is as simple as overriding onPause or something like that, but I\'ve been poking away in the documentation for 30 minutes or so and haven\'t found anything obvious.You need to override onSaveInstanceState(Bundle savedInstanceState) and write the application state values you want to change to the Bundle parameter like this:The Bundle is essentially a way of storing a NVP ("Name-Value Pair") map, and it will get passed in to onCreate() and also onRestoreInstanceState() where you\'d extract the values like this:You would usually use this technique to store instance values for your application (selections, unsaved text, etc.).The savedInstanceState is only for saving state associated with a current instance of an Activity, for example current navigation or selection info, so that if Android destroys and recreates an Activity, it can come back as it was before.  See the documentation for onCreate and onSaveInstanceStateFor more long lived state, consider using a SQLite database, a file, or preferences.  See Saving Persistent State.Note that it is NOT safe to use onSaveInstanceState and onRestoreInstanceState for persistent data, according to the documentation on Activity states in http://developer.android.com/reference/android/app/Activity.html.The document states (in the \'Activity Lifecycle\' section):Note that it is important to save\n  persistent data in onPause() instead\n  of onSaveInstanceState(Bundle)\n  because the later is not part of the\n  lifecycle callbacks, so will not be\n  called in every situation as described\n  in its documentation.In other words, put your save/restore code for persistent data in onPause() and onResume()!EDIT: For further clarification, here\'s the onSaveInstanceState() documentation:This method is called before an activity may be killed so that when it\n  comes back some time in the future it can restore its state. For\n  example, if activity B is launched in front of activity A, and at some\n  point activity A is killed to reclaim resources, activity A will have\n  a chance to save the current state of its user interface via this\n  method so that when the user returns to activity A, the state of the\n  user interface can be restored via onCreate(Bundle) or\n  onRestoreInstanceState(Bundle).My colleague wrote an article explaining Application State on Android devices including explanations on Activity Lifecycle and State Information, How to Store State Information, and saving to State Bundle and SharedPreferences and take a look at here.The article covers three approaches:This is a classic \'gotcha\' of Android development. There are two issues here:Browsing across all these threads, I suspect that much of the time developers are talking about these two different issues simultaneously ... hence all the confusion and reports of "this doesn\'t work for me".First, to clarify the \'intended\' behavior: onSaveInstance and onRestoreInstance are fragile and only for transient state. The intended usage (afaict) is to handle Activity recreation when the phone is rotated (orientation change). In other words, the intended usage is when your Activity is still logically \'on top\', but still must be reinstantiated by the system. The saved Bundle is not persisted outside of the process/memory/gc, so you cannot really rely on this if your activity goes to the background. Yes, perhaps your Activity\'s memory will survive its trip to the background and escape GC, but this is not reliable (nor is it predictable).So if you have a scenario where there is meaningful \'user progress\' or state that should be persisted between \'launches\' of your application, the guidance is to use onPause and onResume. You must choose and prepare a persistent store yourself.BUT - there is a very confusing bug which complicates all of this. Details are here:http://code.google.com/p/android/issues/detail?id=2373http://code.google.com/p/android/issues/detail?id=5277Basically, if your application is launched with the SingleTask flag, and then later on you launch it from the home screen or launcher menu, then that subsequent invocation will create a NEW task ... you\'ll effectively have two different instances of your app inhabiting the same stack ... which gets very strange very fast. This seems to happen when you launch your app during development (i.e. from Eclipse or Intellij), so developers run into this a lot. But also through some of the app store update mechanisms (so it impacts your users as well).I battled through these threads for hours before I realized that my main issue was this bug, not the intended framework behavior. A great writeup and workaround (UPDATE: see below) seems to be from user @kaciula in this answer:Home key press behaviourUPDATE June 2013: Months later, I have finally found the \'correct\' solution. You don\'t need to manage any stateful startedApp flags yourself,  you can detect this from the framework and bail appropriately. I use this near the beginning of my LauncherActivity.onCreate:onSaveInstanceState is called when the system needs memory and kills an application. It is not called when the user just closes the application. So I think application state should also be saved in onPause It should be saved to some persistent storage like Preferences or SqliteBoth methods are useful and valid and both are best suited for different scenarios:If you save the state data in a persistent manner, it can be reloaded in an onResume() or onCreate() (or actually on any lifecycle call). This may or may not be desired behaviour. If you store it in a bundle in an InstanceState, then it is transient and is only suitable for storing data for use in the same user \xe2\x80\x98session\xe2\x80\x99 (I use the term session loosely) but not between \xe2\x80\x98sessions\xe2\x80\x99.It is not that one approach is better than the other, like everything, it is just important to understand what behaviour you require and to select the most appropriate approach.Saving state is a kludge at best as far as I\'m concerned. If you need to save persistent data, just use an SQLite database. Android makes it SOOO easy.Something like this:A simple call after thatI think I found the answer. Let me tell what I have done in simple words:Suppose I have two activities, activity1 and activity2 and I am navigating from activity1 to activity2 (I have done some works in activity2) and again back to activity 1 by clicking on a button in activity1. Now at this stage I wanted to go back to activity2 and I want to see my activity2 in the same condition when I last left activity2.For the above scenario what I have done is that in the manifest I made some changes like this:And in the activity1 on the button click event I have done like this:And in activity2 on button click event I have done like this:Now what will happen is that whatever the changes we have made in the activity2 will not be lost, and we can view activity2 in the same state as we left previously.I believe this is the answer and this works fine for me. Correct me if I am wrong.onSaveInstanceState() for transient data (restored in onCreate()/onRestoreInstanceState()), onPause() for persistent data (restored in onResume()). \nFrom Android technical resources:onSaveInstanceState() is called by Android if the Activity is being stopped and may be killed before it is resumed! This means it should store any state necessary to re-initialize to the same condition when the Activity is restarted. It is the counterpart to the onCreate() method, and in fact the savedInstanceState Bundle passed in to onCreate() is the same Bundle that you construct as outState in the onSaveInstanceState() method.onPause() and onResume() are also complimentary methods. onPause() is always called when the Activity ends, even if we instigated that (with a finish() call for example). We will use this to save the current note back to the database. Good practice is to release any resources that can be released during an onPause() as well, to take up less resources when in the passive state.Really onSaveInstance state callen when the Activity goes to backgroundQuote from the docs:\n"the method onSaveInstanceState(Bundle)  is called before placing the activity in such a background state"To help reduce boilerplate I use the following interface and class to read/write to a Bundle for saving instance state.First, create an interface that will be used to annotate your instance variables:Then, create a class where reflection will be used to save values to the bundle:Note: This code was adapted from a library project named AndroidAutowire which is licensed under the MIT license.Meanwhile I do in general no more use the live cycle is for most activities too complicated and not necessary.\nAnd google states itself, it is NOT even reliable.My way is to save any changes immediately in the preferencesin some way SharedPreferences work similar like Bundles.\nAnd naturally and at first such values have to be red from preferences.In the case of complex data you may use Sqlite instead of using preferences.When applying this concept, the activity just continues to use the last saved state, regardless whether it was an initial open with reboots in between or a reopen due to the back stack.The onSaveInstanceState(bundle) and onRestoreInstanceState(bundle) methods are useful for data persistence merely while rotating the screen (orientation change).\nThey are not even good while switching between applications (since the onSaveInstanceState() method is called but onCreate(bundle) and onRestoreInstanceState(bundle) is not invoked again.\nFor more persistence use shared preferences. read this article To answer the original question directly. savedInstancestate is null because your Activity is never being re-created.Your Activity will only be re-created with a state bundle when:Android will destroy background activities when under memory pressure or after they\'ve been in the background for an extended period of time.When testing your hello world example there are a few ways to leave and return to the Activity.In most cases if you\'re just pressing home and then launching the app again the activity won\'t need to be re-created. It already exists in memory so onCreate() won\'t be called.There is an option under Settings -> Developer Options called "Don\'t keep activities". When it\'s enabled Android will always destroy activities and recreate them when they\'re backgrounded. This is a great option to leave enabled when developing because it simulates the worst case scenario. ( A low memory device recycling your activities all the time ).The other answers are valuable in that they teach you the correct ways to store state but I didn\'t feel they really answered WHY your code wasn\'t working in the way you expected.Recreating an ActivityThere are a few scenarios in which your activity is destroyed due to normal app behavior, such as when the user presses the Back button or your activity signals its own destruction by calling finish(). The system may also destroy your activity if it\'s currently stopped and hasn\'t been used in a long time or the foreground activity requires more resources so the system must shut down background processes to recover memory.When your activity is destroyed because the user presses Back or the activity finishes itself, the system\'s concept of that Activity instance is gone forever because the behavior indicates the activity is no longer needed. However, if the system destroys the activity due to system constraints (rather than normal app behavior), then although the actual Activity instance is gone, the system remembers that it existed such that if the user navigates back to it, the system creates a new instance of the activity using a set of saved data that describes the state of the activity when it was destroyed. The saved data that the system uses to restore the previous state is called the "instance state" and is a collection of key-value pairs stored in a Bundle object.To save additional data about the activity state, you must override the onSaveInstanceState() callback method. The system calls this method when the user is leaving your activity and passes it the Bundle object that will be saved in the event that your activity is destroyed unexpectedly. If the system must recreate the activity instance later, it passes the same Bundle object to both the onRestoreInstanceState() and onCreate() methods.\nAs the system begins to stop your activity, it calls onSaveInstanceState() (1) so you can specify additional state data you\'d like to save in case the Activity instance must be recreated. If the activity is destroyed and the same instance must be recreated, the system passes the state data defined at (1) to both the onCreate() method (2) and the onRestoreInstanceState() method (3).Save Your Activity StateAs your activity begins to stop, the system calls onSaveInstanceState() so your activity can save state information with a collection of key-value pairs. The default implementation of this method saves information about the state of the activity\'s view hierarchy, such as the text in an EditText widget or the scroll position of a ListView.To save additional state information for your activity, you must implement onSaveInstanceState() and add key-value pairs to the Bundle object. For example:Caution: Always call the superclass implementation of onSaveInstanceState() so the default implementation can save the state of the view hierarchy.Restore Your Activity StateWhen your activity is recreated after it was previously destroyed, you can recover your saved state from the Bundle that the system passes your activity. Both the onCreate() and onRestoreInstanceState() callback methods receive the same Bundle that contains the instance state information.Because the onCreate() method is called whether the system is creating a new instance of your activity or recreating a previous one, you must check whether the state Bundle is null before you attempt to read it. If it is null, then the system is creating a new instance of the activity, instead of restoring a previous one that was destroyed.For example, here\'s how you can restore some state data in onCreate():Instead of restoring the state during onCreate() you may choose to implement onRestoreInstanceState(), which the system calls after the onStart() method. The system calls onRestoreInstanceState() only if there is a saved state to restore, so you do not need to check whether the Bundle is null:My problem was that I needed persistence only during the application lifetime (i.e. a single execution including starting other sub-activities within the same app and rotating the device etc). I tried various combinations of the above answers but did not get what I wanted in all situations. In the end what worked for me was to obtain a reference to the savedInstanceState during onCreate:and use that to obtain the contents of my variable when I needed it, along the lines of:I use onSaveInstanceStateand onRestoreInstanceState as suggested above but I guess i could also or alternatively use my method to save the variable when it changes (e.g. using putBoolean)Although the accepted answer is correct, there is a faster and easier method to save the Activity state on Android using a library called Icepick. Icepick is an annotation processor that takes care of all the boilerplate code used in saving and restoring state for you. Doing something like this with Icepick:Is the same as doing this:Icepick will work with any object that saves its state with a Bundle.There are basically two ways to implement this change.I really do not recommend to use second method. Since in one of my experience it was causing half of the device screen black while rotating from portrait to landscape and vice versa. Using first method mentioned above , we can persist data when orientation is changed or any config change happens.\nI know a way in which you can store any type of data inside savedInstance state object.Example: Consider a case if you want to persist Json object.\ncreate a model class with getters and setters .Now in your activity in onCreate and onSaveInstanceState method do the following. It will look something like this:When an activity is created it\'s  onCreate() method is called.savedInstanceState is an object of Bundle class which is null for the first time, but it contains values when it is recreated. To save Activity\'s state you have to override onSaveInstanceState().put your values in "outState" Bundle object like outState.putString("key","Welcome Back") and save by calling super.\nWhen activity will be destroyed it\'s state get saved in Bundle object and can be restored after recreation in onCreate() or onRestoreInstanceState(). Bundle received in onCreate() and onRestoreInstanceState() are same.orNot sure if my solution is frowned upon or not but I use a bound service to persist ViewModel state. Whether you store it in memory in the service or persist and retrieve from a SqlLite database depends on your requirements. This is what services of any flavor do, they provide services such as maintaining  application state and abstract common business logic. Because of memory and processing constraints inherent on mobile devices, I treat Android views in a similar way to a web page. The page does not maintain state, it is purely a presentation layer component whose only purpose is to present application state and accept user input. Recent trends in web app architecture employ the use of the age old Model, View, Controller (MVC) pattern, where the page is the View, Domain data is the model and the controller sits behind a web service. The same pattern can be employed in android with the View being well ... the View, the model is your domain data and the Controller is implemented as an Android bound service. Whenever you want a view to interact with the controller, bind to it on start/resume and unbind on stop/pause.This approach gives you the added bonus of enforcing the Separation of Concern design principle in that all of you application business logic can be moved into your service which reduces duplicated logic across multiple views and allows the view to enforce another important design principle, Single Responsibility.Simple quick to solve this problem is using IcePickFirst, setup the library in app/build.gradleNow, let\'s check this example below how to save state in ActivityIt works for Activities, Fragments or any object that needs to serialize its state on a Bundle (e.g. mortar\'s ViewPresenters)Icepick can also generate the instance state code for custom Views:To get activity state data stored in onCreate(), first you have to save data in savedInstanceState by overrding SaveInstanceState(Bundle savedInstanceState) method.When activity destroy SaveInstanceState(Bundle savedInstanceState) method gets called and there you save data you want to save. And you get same in onCreate() when activity restart.(savedInstanceState wont be null since you have saved some data in it before activity get destroyed)Here is a comment from Steve Moseley\'s answer (by ToolmakerSteve) that puts things into perspective (in the whole onSaveInstanceState vs onPause, east cost vs west cost saga)@VVK - I partially disagree. Some ways of exiting an app don\'t trigger\n  onSaveInstanceState (oSIS). This limits the usefulness of oSIS. Its\n  worth supporting, for minimal OS resources, but if an app wants to\n  return the user to the state they were in, no matter how the app was\n  exited, it is necessary to use a persistent storage approach instead.\n  I use onCreate to check for bundle, and if it is missing, then check\n  persistent storage. This centralizes the decision making. I can\n  recover from a crash, or back button exit or custom menu item Exit, or\n  get back to screen user was on many days later. \xe2\x80\x93 ToolmakerSteve Sep\n  19 \'15 at 10:38