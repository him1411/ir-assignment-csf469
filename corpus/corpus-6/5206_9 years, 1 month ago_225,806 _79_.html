I\'m trying to use a select statement to get all of the columns from a certain MySQL table except one. Is there a simple way to do this?EDIT: There are 53 columns in this table (NOT MY DESIGN)Actually there is a way, you need to have permissions of course for doing this ...Replacing <table>, <database> and <columns_to_omit>Would a View work better in this case? In mysql definitions (manual) there is no such thing. But if you have a really big number of columns col1, ..., col100, the following can be useful:If you are looking to exclude the value of a field, e.g. for security concerns / sensitive info, you can retrieve that column as null.e.g.You can do:without getting column3, though perhaps you were looking for a more general solution?To the best of my knowledge, there isn\'t. You can do something like:and manually choose the columns you want. However, if you want a lot of columns, then you might just want to do a:and just ignore what you don\'t want.In your particular case, I would suggest:unless you only want a few columns. If you only want four columns, then:would be fine, but if you want 50 columns, then any code that makes the query would become (too?) difficult to read.If the column that you didn\'t want to select had a massive amount of data in it, and you didn\'t want to include it due to speed issues and you select the other columns often, I would suggest that you create a new table with the one field that you don\'t usually select with a key to the original table and remove the field from the original table. Join the tables when that extra field is actually required.While trying the solutions by @Mahomedalid and @Junaid I found a problem. So thought of sharing it. If the column name is having spaces or hyphens like check-in then the query will fail. The simple workaround is to use backtick around column names. The modified query is belowYou could use DESCRIBE my_table and use the results of that to generate the SELECT statement dynamically.My main problem is the many columns I get when joining tables. While this is not the answer to your question (how to select all but certain columns from one table), I think it is worth mentioning that you can specify table. to get all columns from a particular table, instead of just specifying . Here is an example of how this could be very useful:The result is all the columns from the users table, and two additional columns which were joined from the meta table.It is good practice to specify the columns that you are querying even if you query all the columns.So I would suggest you write the name of each column in the statement (excluding the one you don\'t want).I liked the answer from @Mahomedalid besides this fact informed in comment from @Bill Karwin. The possible problem  raised by @Jan Koritak is true I faced that but I have  found a trick for that and just want to share it here for anyone facing the issue.we can replace the REPLACE function with where clause in the sub-query of Prepared statement like this:Using my table and column nameSo, this is going to exclude only the field id but not company_idHope this will help anyone looking for a solution.RegardsI agree with the "simple" solution of listing all the columns, but this can be burdensome, and typos can cause lots of wasted time.  I use a function "getTableColumns" to retrieve the names of my columns suitable for pasting into a query.  Then all I need to do is to delete those I don\'t want. Your result returns a comma delimited string, for example...col1,col2,col3,col4,...col53I agree that it isn\'t sufficient to Select *, if that one you don\'t need, as mentioned elsewhere, is a BLOB, you don\'t want to have that overhead creep in. I would create a view with the required data, then you can Select * in comfort --if the database software supports them. Else, put the huge data in another table.At first I thought you could use regular expressions, but as I\'ve been reading the MYSQL docs it seems you can\'t. If I were you I would use another language (such as PHP) to generate a list of columns you want to get, store it as a string and then use that to generate the SQL. I wanted this too so I created a function instead.So how it works is that you enter the table, then a column you don\'t want or as in an array: array("id","name","whatevercolumn")So in select you could use it like this:orWhile I agree with Thomas\' answer (+1 ;)), I\'d like to add the caveat that I\'ll assume the column that you don\'t want contains hardly any data. If it contains enormous amounts of text, xml or binary blobs, then take the time to select each column individually. Your performance will suffer otherwise. Cheers!Just doThen drop the column in you favourite programming language: phpYes, though it can be high I/O depending on the table here is a workaround I found for it.The answer posted by Mahomedalid has a small problem:Inside replace function code was replacing "<columns_to_delete>," by "", this replacement has a problem if the field to replace is the last one in the concat string due to the last one doesn\'t have the char comma "," and is not removed from the string.My proposal:Replacing <table>, <database> and `The column removed is replaced by the string "FIELD_REMOVED" in my case this works because I was trying to safe memory. (The field I was removing is a BLOB of around 1MB)Based on @Mahomedalid answer, I have done some improvements to support "select all columns except some in mysql"If you do have a lots of cols, use this sql to change group_concat_max_lenMay be I have a solution to Jan Koritak\'s pointed out discrepancyTable : ================================================================Query Result:If it\'s always the same one column, then you can create a view that doesn\'t have it in it.Otherwise, no I don\'t think so.You can use SQL to generate SQL if you like and evaluate the SQL it produces.  This is a general solution as it extracts the column names from the information schema. Here is an example from the Unix command line. SubstitutingYou will really only need to extract the column names in this way only once to construct the column list excluded that column, and then just use the query you have constructed.So something like:Now you can reuse the $column_list string in queries you construct.I would like to add another point of view in order to solve this problem, specially if you have a small number of columns to remove.You could use a DB tool like MySQL Workbench in order to generate the select statement for you, so you just have to manually remove those columns for the generated statement and copy it to your SQL script.In MySQL Workbench the way to generate it is: Right click on the table -> send to Sql Editor -> Select All Statement.Agree on @Mahomedalid\'s answer. But I didn\'t wanted to do something like prepared statement and I didn\'t wanted to type all the fields. \nSo What I had was a silly solution. \nGo to the table in phpmyadmin->sql->select, it dumps the query copy replace and done! :)Im pretty late at throing out an answer for this, put this is the way i have always done it and frankly, its 100 times better and neater than the best answer, i only hope someone will see it. And find it usefulSelect * is a SQL antipattern. It should not be used in production code for many reasons including:It takes a tiny bit longer to process. When things are run millions of times, those tiny bits can matter. A slow database where the slowness is caused by this type of sloppy coding throughout is the hardest kind to performance tune.It means you are probably sending more data than you need which causes both server and network bottlenecks. If you have an inner join, the chances of sending more data than you need are 100%. It causes maintenance problems especially when you have added new columns that you do not want seen everywhere. Further if you have a new column, you may need to do something to the interface to determine what to do with that column. It can break views (I know this is true in SQl server, it may or may not be true in mysql). If someone is silly enough to rebuild the tables with the columns in a differnt order (which you shouldn\'t do but it happens all teh time), all sorts of code can break. Espcially code for an insert for example where suddenly you are putting the city into the address_3 field becasue without specifying, the database can only go on the order of the columns.  This is bad enough when the data types change but worse when the swapped columns have the same datatype becasue you can go for sometime inserting bad data that is a mess to clean up.  You need to care about data integrity. If it is used in an insert, it will break the insert if a new column is added in one table but not the other. It might break triggers. Trigger problems can be difficult to diagnose. Add up all this against the time it take to add in the column names (heck you may even have an interface that allows you to drag over the columns names (I know I do in SQL Server, I\'d bet there is some way to do this is some tool you use to write mysql queries.) Let\'s see, "I can cause maintenance problems, I can cause performance problems and I can cause data integrity problems, but hey I saved five minutes of dev time." Really just put in the specific columns you want.I also suggest you read this book:\nhttp://www.amazon.com/SQL-Antipatterns-Programming-Pragmatic-Programmers-ebook/dp/B00A376BB2/ref=sr_1_1?s=digital-text&ie=UTF8&qid=1389896688&sr=1-1&keywords=sql+antipatterns