Major differences I\'ve seen are:(Please correct me if I\'m wrong with the above.)Are there any other major differences I am missing?You\'ve pretty much nailed it, however Mustache templates can also be compiled.Mustache is missing helpers and the more advanced blocks because it strives to be logicless.  Handlebars\' custom helpers can be very useful, but often end up introducing logic into your templates.Mustache has many different compilers (JavaScript, Ruby, Python, C, etc.). Handlebars began in JavaScript, now there are projects like django-handlebars, handlebars.java, handlebars-ruby, lightncandy (PHP), and handlebars-objc.Mustache pros:Mustache cons:Handlebars pros:Handlebars cons:Source: The client-side templating throwdown: mustache, handlebars, dust.js, and moreOne subtle but significant difference is in the way the two libraries approach scope. Mustache will fall back to parent scope if it can\'t find a variable within the current context; Handlebars will return a blank string.This is barely mentioned in the GitHub README, where there\'s one line for it:Handlebars deviates from Mustache slightly in that it does not perform recursive lookup by default.However, as noted there, there is a flag to make Handlebars behave in the same way as Mustache -- but it affects performance.This has an effect on the way you can use # variables as conditionals.For example in Mustache you can do this:It basically means "if variable exists and is truthy, print a span with the variable in it". But in Handlebars, you would either have to:More details on this, if you want them, here.NOTE: This answer is outdated. It was true at the time it was posted, but no longer is.Mustache has interpreters in many languages, while Handlebars is Javascript only.Another difference between them is the size of the file:To see the performance benefits of Handlebars.js we must use precompiled templates.Source: An Overview of JavaScript Templating EnginesOne more subtle difference is the treatment of falsy values in {{#property}}...{{/property}} blocks. Most mustache implementations will just obey JS falsiness here, not rendering the block if property is \'\' or \'0\'.Handlebars will render the block for \'\' and 0, but not other falsy values. This can cause some trouble when migrating templates.I feel that one of the mentioned cons for "Handlebars" isnt\' really valid anymore.Handlebars.java now allows us to share the same template languages for both client and server which is a big win for large projects with 1000+ components that require serverside rendering for SEOTake a look at https://github.com/jknack/handlebars.java \xe2\x80\x94In addition to using "this" for handlebars, and the nested variable within variable block for mustache, you can also use the nested dot in a block for mustache: