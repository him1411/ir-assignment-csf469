I\'ve submitted a change to an Open Source project on Github, and received code review comments from one of the core team members.I would like to update the code taking into account the review comments, and re-submit it. What is the best workflow for doing this? From my limited knowledge of git/github, I could do any of the following:Update the code as a new commit, and add both the initial and updated commit to my pull request.Somehow (??) rollback the old commit from my repository, and create a single new commit containing everything, then raise a pull request for that?git commit has an amend feature, but I\'ve heard that you shouldn\'t use it after you\'ve pushed the commit outside of your local repository? In this case I have made the change on my local PC and pushed to my github branch of the project. Would this be OK to use \'amend\'?Something else?It seems like option 2/3 would be nice, as the open source project would only have one commit in their history which would implement everything, but I\'m not sure how to do this.Note: I don\'t know if this affects the answer or not, but I didn\'t make the changes in a separate branch, I just did a commit on top of masterJust add a new commit to the branch used in the pull request and push the branch to GitHub. The pull request will automatically be updated with the additional commit.#2 and #3 are unnecessary. If people want to see only where your branch was merged in (and not the additional commits), they can use git log --first-parent to only view the merge commit in the log.To update a pull request (point #1), the only thing you need to do is checkout the same branch the pull request is from and push to it again:You may be asked to squash your commits together so that the repository history is clean, or yourself want to remove intermediary commits which distract from "the message" in your pull request (point #2). For example if your commit history looks like this:It\'s a good idea to squash things together so they appear as a single commit:This will prompt you to choose how to rewrite the history of your pull request, the following will be in your editor:For any commit you want to be part of the previous commit - change pick to squash:And close your editor. Git will then rewrite the history and prompt you to provide a commit message for the one combined commit. Amend accordingly and your commit history will now be concise:Push that to your fork:and your pull request will contain a single commit, incorporating all changes previously split into several commits.Rewriting history and using git push -f on a branch that, potentially, someone else has already cloned is a bad thing - it causes the repository\'s history and that of the checkout to diverge.However, amending the history of your fork to correct the change you are proposing to be integrated into a repository - is a good thing. As such have no reservations squashing "noise" out of your pull requests.In the above I show the pull request as having come from the master branch of your fork, there\'s nothing wrong with that necessarily but it does create certain limitations such as, if this is your standard technique, only being able to have one PR open per repository. It\'s a better idea though to create a branch for each individual change you wish to propose:My opinion on best practice: once you are ready to package up a pull request, it should get its own unique topic branch, specifically for that purpose, at the outset. You start by pushing that branch to your github repository, e.g.and basing the pull request off that branch. Having done that, any commits you push to that branch will automatically be appended to the pull request. You use that branch for nothing else.Some prefer that you namespace such branches with your github userid. That way they can freely check it out locally to try it out, with benefits likeI usually name my pull request branches something like