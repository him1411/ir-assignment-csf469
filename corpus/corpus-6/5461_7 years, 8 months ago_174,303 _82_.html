Brief background: Many (most?) contemporary programming languages in widespread use have at least a handful of ADTs [abstract data types] in common, in particular,string (a sequence comprised of characters)list (an ordered collection of values), andmap-based type (an unordered array that maps keys to values)In the R programming language, the first two are implemented as character and vector, respectively.When I began learning R, two things were obvious almost from the start: list is the most important data type in R (because it is the parent class for the R data.frame), and second, I just couldn\'t understand how they worked, at least not well enough to use them correctly in my code.For one thing, it seemed to me that R\'s list data type was a straightforward implementation of the map ADT (dictionary in Python, NSMutableDictionary in Objective C, hash in Perl and Ruby, object literal in Javascript, and so forth).For instance, you create them just like you would a Python dictionary, by passing key-value pairs to a constructor (which in Python is dict not list):And you access the items of an R List just like you would those of a Python dictionary, e.g., x[\'ev1\']. Likewise, you can retrieve just the \'keys\' or just the \'values\' by: but R lists are also unlike other map-type ADTs (from among the languages I\'ve learned anyway). My guess is that this is a consequence of the initial spec for S, i.e., an intention to design a data/statistics DSL [domain-specific language] from the ground-up. three significant differences between R lists and mapping types in other languages in widespread use (e.g,. Python, Perl, JavaScript):first, lists in R are an ordered collection, just like vectors, even though the values are keyed (ie, the keys can be any hashable value not just sequential integers). Nearly always, the mapping data type in other languages is unordered.second, lists can be returned from functions even though you never passed in a list when you called the function, and even though the function that returned the list doesn\'t contain an (explicit) list constructor (Of course, you can deal with this in practice by wrapping the returned result in a call to unlist):A third peculiar feature of R\'s lists: it doesn\'t seem that they can be members of another ADT, and if you try to do that then the primary container is coerced to a list. E.g.,my intention here is not to criticize the language or how it is documented; likewise, I\'m not suggesting there is anything wrong with the list data structure or how it behaves. All I\'m after is to correct is my understanding of how they work so I can correctly use them in my code. Here are the sorts of things I\'d like to better understand:What are the rules which determine when a function call will return a list (e.g., strsplit expression recited above)?If I don\'t explicitly assign names to a list (e.g., list(10,20,30,40)) are the default names just sequential integers beginning with 1?  (I assume, but I am far from certain that the answer is yes, otherwise we wouldn\'t be able to coerce this type of list to a vector w/ a call to unlist.)Why do these two different operators, [], and [[]], return the same result?x = list(1, 2, 3, 4)both expressions return "1":x[1]x[[1]]why do these two expressions not return the same result?x = list(1, 2, 3, 4)x2 = list(1:4)Please don\'t point me to the R Documentation (?list, R-intro)--I have read it carefully and it does not help me answer the type of questions I recited just above.(lastly, I recently learned of and began using an R Package (available on CRAN) called hash which implements conventional map-type behavior via an S4 class; I can certainly recommend this Package.)Just to address the last part of your question, since that really points out the difference between a list and vector in R:Why do these two expressions not return the same result?x = list(1, 2, 3, 4); x2 = list(1:4)A list can contain any other class as each element.  So you can have a list where the first element is a character vector, the second is a data frame, etc.  In this case, you have created two different lists.  x has four vectors, each of length 1.  x2 has 1 vector of length 4:So these are completely different lists.  R lists are very much like a hash map data structure in that each index value can be associated with any object.  Here\'s a simple example of a list that contains 3 different classes (including a function):Given that the last element is the search function, I can call it like so:As a final comment on this: it should be noted that a data.frame is really a list (from the data.frame documentation):A data frame is a list of variables of the same number of rows with unique row names, given class \xe2\x80\x98"data.frame"\xe2\x80\x99That\'s why columns in a data.frame can have different data types, while columns in a matrix cannot.  As an example, here I try to create a matrix with numbers and characters:Note how I cannot change the data type in the first column to numeric because the second column has characters:Regarding your questions, let me address them in order and give some examples:1) A list is returned if and when the return statement adds one. Consider 2) Names are simply not set:3) They do not return the same thing. Your example giveswhere x[1] returns the first element of x -- which is the same as x. Every scalar is a vector of length one. On the other hand x[[1]] returns the first element of the list.4) Lastly, the two are different between they create, respectively, a list containing four scalars and a list with a single element (that happens to be a vector of four elements).Just to take a subset of your questions:This article on indexing addresses the question of the difference between [] and [[]].In short [[]] selects a single item from a list and [] returns a list of the selected items. In your example, x = list(1, 2, 3, 4)\' item 1 is a single integer but x[[1]] returns a single 1 and x[1] returns a list with only one value. One reason lists work as they do (ordered) is to address the need for an ordered container that can contain any type at any node, which vectors do not do.  Lists are re-used for a variety of purposes in R, including forming the base of a data.frame, which is a list of vectors of arbitrary type (but the same length).Why do these two expressions not return the same result?To add to @Shane\'s answer, if you wanted to get the same result, try:Which coerces the vector 1:4 into a list.Just to add one more point to this: R does have a data structure equivalent to the Python dict in the hash package.  You can read about it in this blog post from the Open Data Group.  Here\'s a simple example:In terms of usability, the hash class is very similar to a list.  But the performance is better for large datasets.You say:For another, lists can be returned\n  from functions even though you never\n  passed in a List when you called the\n  function, and even though the function\n  doesn\'t contain a List constructor,\n  e.g.,And I guess you suggest that this is a problem(?). I\'m here to tell you why it\'s not a problem :-). Your example is a bit simple, in that when you do the string-split, you have a list with elements that are 1 element long, so you know that x[[1]] is the same as unlist(x)[1]. But what if the result of strsplit returned results of different length in each bin. Simply returning a vector (vs. a list) won\'t do at all.For instance:In the first case (x : which returns a list), you can tell what the 2nd "part" of the 3rd string was, eg: x[[3]][2]. How could you do the same using xx now that the results have been "unraveled" (unlist-ed)?is not the same because 1:4 is the same as c(1,2,3,4).\nIf you want them to be the same then:Regarding vectors and the hash/array concept from other languages:Vectors are the atoms of R. Eg, rpois(1e4,5) (5 random numbers), numeric(55) (length-55 zero vector over doubles), and character(12) (12 empty strings), are all "basic".Either lists or vectors can have names.Vectors require everything to be the same data type. Watch this:Lists can contain varying data types, as seen in other answers and the OP\'s question itself.I\'ve seen languages (ruby, javascript) in which "arrays" may contain variable datatypes, but for example in C++ "arrays" must be all the same datatype. I believe this is a speed/efficiency thing: if you have a numeric(1e6) you know its size and the location of every element a priori; if the thing might contain "Flying Purple People Eaters" in some unknown slice, then you have to actually parse stuff to know basic facts about it.Certain standard R operations also make more sense when the type is guaranteed. For example cumsum(1:9) makes sense whereas cumsum(list(1,2,3,4,5,\'a\',6,7,8,9)) does not, without the type being guaranteed to be double.As to your second question:Lists can be returned from functions even though you never passed in a List when you called the functionFunctions return different data types than they\'re input all the time. plot returns a plot even though it doesn\'t take a plot as an input. Arg returns a numeric even though it accepted a complex. Etc.(And as for strsplit: the source code is here.)If it helps, I tend to conceive "lists" in R as "records" in other pre-OO languages:The name "record" would clash with the standard meaning of "records" (aka rows) in database parlance, and may be this is why their name suggested itself: as lists (of fields).Alhough this is pretty old question I must say it is touching exactly the knowledge I was missing during my first steps in R - i.e. how to express data in my hand as object in R or how to select from existing objects. It is not easy for a R novice to think "in a R box" from the very beginning.So I myself started to use crutches below which helped me a lot to find out what object to use for what data, and basically to imagine real world usage.Though I not giving exact answers to the question the short text below might help reader who just started with R and is asking simmilar questions.So for lists you can end up with more ways how to select a leaf depending on situation like in following example.This way of thinking helped me a lot.why do these two different operators, [ ], and [[ ]], return the same result?[ ] provides sub setting operation. In general sub set of any object\nwill have the same type as the original object. Therefore, x[1]\nprovides a list. Similarly x[1:2] is a subset of original list,\ntherefore it is a list. Ex.[[ ]] is for extracting an element from the list. x[[1]] is valid\nand extract the first element from the list. x[[1:2]] is not valid as [[ ]]\ndoes not provide sub setting like [ ]. 