Inspired by Raymond Chen\'s post, say you have a 4x4 two dimensional array, write a function that rotates it 90 degrees. Raymond links to a solution in pseudo code, but I\'d like to see some real world stuff.Becomes:Update: Nick\'s answer is the most straightforward, but is there a way to do it better than n^2? What if the matrix was 10000x10000?Here it is in C#O(n^2) time and O(1) space algorithm ( without any workarounds and hanky-panky stuff! )Rotate by +90:Rotate by -90:Method 1 :Method 2 :Rotate by +180:Method 1: Rotate by +90 twiceMethod 2: Reverse each row and then reverse each column (Transpose)Rotate by -180:Method 1: Rotate by -90 twiceMethod 2: Reverse each column and then reverse each rowMethod 3: Rotate by +180 as they are samePython:Cheap, I know.And counterclockwise:How this works: (Requested in comments)zip(*original) will swap axes of 2d arrays by stacking corresponding items from lists into new lists. (The * operator tells the function to distribute the contained lists into arguments)The [::-1] statement reverses array elements (please see Extended Slices).Finally, combining the two will result in the rotation transformation.The change in placement of [::-1] will reverse lists in different levels of the matrix.I\xe2\x80\x99d like to add a little more detail. In this answer, key concepts are repeated, the pace is slow and intentionally repetitive. The solution provided here is not the most syntactically compact, it is however intended for those who wish to learn what matrix rotation is and the resulting implementation.  Firstly, what is a matrix? For the purposes of this answer, a matrix is just a grid where the width and height are the same. Note, the width and height of a matrix can be different, but for simplicity, this tutorial considers only matrices with equal width and height (and yes, matrices is the plural of matrix). Example matrices are: 2\xc3\x972, 3\xc3\x973 or 5\xc3\x975. Or, more generally, N\xc3\x97N. A 2\xc3\x972 matrix will have 4 squares because 2\xc3\x972=4. A 5\xc3\x975 matrix will have 25 squares because 5\xc3\x975=25. Each square is called an element or entry. We\xe2\x80\x99ll represent each element with a period (.) in the diagrams below:2\xc3\x972 matrix3\xc3\x973 matrix4\xc3\x974 matrixSo, what does it mean to rotate a matrix? Let\xe2\x80\x99s take a 2\xc3\x972 matrix and put some numbers in each element so the rotation can be observed:Rotating this by 90 degrees gives us:We literally turned the whole matrix once to the right just like turning the steering wheel of a car. It may help to think of \xe2\x80\x9ctipping\xe2\x80\x9d the matrix onto its right side. We want to write a function, in Python, that takes a matrix and rotates in once to the right. The function signature will be:The matrix will be defined using a two-dimensional array:Therefore the first index position accesses the row. The second index position accesses the column:We\xe2\x80\x99ll define a utility function to print a matrix. One method of rotating a matrix is to do it a layer at a time. But what is a layer?  Think of an onion. Just like the layers of an onion, as each layer is removed, we move towards the center. Other analogies is a Matryoshka doll or a game of pass-the-parcel. The width and height of a matrix dictate the number of layers in that matrix.  Let\xe2\x80\x99s use different symbols for each layer:A 2\xc3\x972 matrix has 1 layerA 3\xc3\x973 matrix has 2 layersA 4\xc3\x974 matrix has 2 layersA 5\xc3\x975 matrix has 3 layersA 6\xc3\x976 matrix has 3 layersA 7\xc3\x977 matrix has 4 layersYou may notice that incrementing the width and height of a matrix by one, does not always increase the number of layers. Taking the above matrices and tabulating the layers and dimensions, we see the number of layers increases once for every two increments of width and height:However, not all layers need rotating. A 1\xc3\x971 matrix is the same before and after rotation. The central 1\xc3\x971 layer is always the same before and after rotation no matter how large the overall matrix:Given N\xc3\x97N matrix, how can we programmatically determine the number of layers we need to rotate? If we divide the width or height by two and ignore the remainder we get the following results. Notice how N/2 matches the number of layers that need to be rotated? Sometimes the number of rotatable layers is one less the total number of layers in the matrix. This occurs when the innermost layer is formed of only one element (i.e. a 1\xc3\x971 matrix) and therefore need not be rotated. It simply gets ignored.We will undoubtedly need this information in our function to rotate a matrix, so let\xe2\x80\x99s add it now:Now we know what layers are and how to determine the number of layers that actually need rotating, how do we isolate a single layer so we can rotate it? Firstly, we inspect a matrix from the outermost layer, inwards, to the innermost layer. A 5\xc3\x975 matrix has three layers in total and two layers that need rotating:Let\xe2\x80\x99s look at columns first. The position of the columns defining the outermost layer, assuming we count from 0, are 0 and 4:0 and 4 are also the positions of the rows for the outermost layer.This will always be the case since the width and height are the same. Therefore we can define the column and row positions of a layer with just two values (rather than four).Moving inwards to the second layer, the position of the columns are 1 and 3. And, yes, you guessed it, it\xe2\x80\x99s the same for rows. It\xe2\x80\x99s important to understand we had to both increment and decrement the row and column positions when moving inwards to the next layer.So, to inspect each layer, we want a loop with both increasing and decreasing counters that represent moving inwards, starting from the outermost layer. We\xe2\x80\x99ll call this our \xe2\x80\x98layer loop\xe2\x80\x99. The code above loops through the (row and column) positions of any layers that need rotating. We now have a loop providing the positions of the rows and columns of each layer. The variables first and last identify the index position of the first and last rows and columns. Referring back to our row and column tables:So we can navigate through the layers of a matrix. Now we need a way of navigating within a layer so we can move elements around that layer. Note, elements never \xe2\x80\x98jump\xe2\x80\x99 from one layer to another, but they do move within their respective layers. Rotating each element in a layer rotates the entire layer. Rotating all layers in a matrix rotates the entire matrix. This sentence is very important, so please try your best to understand it before moving on.Now, we need a way of actually moving elements, i.e. rotate each element, and subsequently the layer, and ultimately the  matrix. For simplicity, we\xe2\x80\x99ll revert to a 3x3 matrix \xe2\x80\x94 that has one rotatable layer.Our layer loop provides the indexes of the first and last columns, as well as first and last rows:Because our matrices are always square, we need just two variables, first and last, since index positions are the same for rows and columns.The variables first and last can easily be used to reference the four corners of a matrix. This is because the corners themselves can be defined using various permutations of first and last (with no subtraction, addition or offset of those variables):For this reason, we start our rotation at the outer four corners \xe2\x80\x94 we\xe2\x80\x99ll rotate those first. Let\xe2\x80\x99s highlight them with *.We want to swap each * with the * to the right of it. So let\xe2\x80\x99s go ahead a print out our corners defined using only various permutations of first and last:Output should be:Now we could quite easily swap each of the corners from within our layer loop:Matrix before rotating corners:Matrix after rotating corners:Great! We have successfully rotated each corner of the matrix. But, we haven\xe2\x80\x99t rotated the elements in the middle of each layer. Clearly we need a way of iterating within a layer. The problem is, the only loop in our function so far (our layer loop), moves to the next layer on each iteration. Since our matrix has only one rotatable layer, the layer loop exits after rotating only the corners. Let\xe2\x80\x99s look at what happens with a larger, 5\xc3\x975 matrix (where two layers need rotating). The function code has been omitted, but it remains the same as above:The output is:It shouldn\xe2\x80\x99t be a surprise that the corners of the outermost layer have been rotated, but, you may also notice the corners of the next layer (inwards) have also been rotated. This makes sense. We\xe2\x80\x99ve written code to navigate through layers and also to rotate the corners of each layer. This feels like progress, but unfortunately we must take a step back. It\xe2\x80\x99s just no use moving onto the next layer until the previous (outer) layer has been fully rotated. That is, until each element in the layer has been rotated. Rotating only the corners won\xe2\x80\x99t do!Take a deep breath. We need another loop. A nested loop no less. The new, nested loop, will use the first and last variables, plus an offset to navigate within a layer. We\xe2\x80\x99ll call this new loop our \xe2\x80\x98element loop\xe2\x80\x99. The element loop will visit each element along the top row, each element down the right side, each element along the bottom row and each element up the left side. This sounds complex, but it\xe2\x80\x99s made easy because the number of times we increment and decrement to achieve the above remains the same along all four sides of the matrix. For example:This means we can use a single variable in combination with the first and last variables to move within a layer. It may help to note that moving across the top row and down the right side both require incrementing. While moving backwards along the bottom and up the left side both require decrementing.Now we simply need to assign the top to the right side, right side to the bottom, bottom to the left side, and left side to the top. Putting this all together we get:Given the matrix:Our rotate function results in: Here is one that does the rotation in place instead of using a completely new array to hold the result.  I\'ve left off initialization of the array and printing it out.  This only works for square arrays but they can be of any size.  Memory overhead is equal to the size of one element of the array so you can do the rotation of as large an array as you want.There are tons of good code here but I just want to show what\'s going on geometrically so you can understand the code logic a little better.  Here is how I would approach this.first of all, do not confuse this with transposition which is very easy..the basica idea is to treat it as layers and we rotate one layer at a time..say we have a 4x4after we rotate it clockwise by 90 we getso let\'s decompose this, first we rotate the 4 corners essentiallythen we rotate the following diamond which is sort of askewand then the 2nd skewed diamondso that takes care of the outer edge so essentially we do that one shell at a time until finally the middle square (or if it\'s odd just the final element which does not move)so now let\'s figure out the indices of each layer, assume we always work with the outermost layer, we are doingso on and so on\nuntil we are halfway through the edgeso in general the pattern is As I said in my previous post, here\'s some code in C# that implements an O(1) matrix rotation for any size matrix. For brevity and readability there\'s no error checking or range checking. The code:OK, I\'ll put my hand up, it doesn\'t actually do any modifications to the original array when rotating. But, in an OO system that doesn\'t matter as long as the object looks like it\'s been rotated to the clients of the class. At the moment, the Matrix class uses references to the original array data so changing any value of m1 will also change m2 and m3. A small change to the constructor to create a new array and copy the values to it will sort that out.Whilst rotating the data in place might be necessary (perhaps to update the physically stored representation), it becomes simpler and possibly more performant to add a layer of indirection onto the array access, perhaps an interface:If your Matrix already implements this interface, then it can be rotated via a decorator class like this:Rotating +90/-90/180 degrees, flipping horizontally/vertically and scaling can all be achieved in this fashion as well.Performance would need to be measured in your specific scenario.  However the O(n^2) operation has now been replaced with an O(1) call.  It\'s a virtual method call which is slower than direct array access, so it depends upon how frequently the rotated array is used after rotation.  If it\'s used once, then this approach would definitely win.  If it\'s rotated then used in a long-running system for days, then in-place rotation might perform better.  It also depends whether you can accept the up-front cost.As with all performance issues, measure, measure, measure!This a better version of it in Java: I\'ve made it for a matrix with a different width and height This code is based on Nick Berardi\'s post.Ruby-way: .transpose.map &:reverseThere are a lot of answers already, and I found two claiming O(1) time complexity. The real O(1) algorithm is to leave the array storage untouched, and change how you index its elements. The goal here is that it does not consume additional memory, nor does it require additional time to iterate the data.Rotations of 90, -90 and 180 degrees are simple transformations which can be performed as long as you know how many rows and columns are in your 2D array; To rotate any vector by 90 degrees, swap the axes and negate the Y axis. For -90 degree, swap the axes and negate the X axis. For 180 degrees, negate both axes without swapping.Further transformations are possible, such as mirroring horizontally and/or vertically by negating the axes independently.This can be done through e.g. an accessor method. The examples below are JavaScript functions, but the concepts apply equally to all languages.This code assumes an array of nested arrays, where each inner array is a row.The method allows you to read (or write) elements (even in random order) as if the array has been rotated or transformed. Now just pick the right function to call, probably by reference, and away you go!The concept can be extended to apply transformations additively (and non-destructively) through the accessor methods. Including arbitrary angle rotations and scaling.A couple of people have already put up examples which involve making a new array.  A few other things to consider:(a) Instead of actually moving the data, simply traverse the "rotated" array differently.  (b) Doing the rotation in-place can be a little trickier.  You\'ll need a bit of scratch place (probably roughly equal to one row or column in size).  There\'s an ancient ACM paper about doing in-place transposes (http://doi.acm.org/10.1145/355719.355729), but their example code is nasty goto-laden FORTRAN.Addendum:http://doi.acm.org/10.1145/355611.355612 is another, supposedly superior, in-place transpose algorithm.Nick\'s answer would work for an NxM array too with only a small modification (as opposed to an NxN).One way to think about this is that you have moved the center of the axis (0,0) from the top left corner to the top right corner.  You\'re simply transposing from one to the other.Here\'s my Ruby version (note the values aren\'t displayed the same, but it still rotates as described).The output:Time - O(N), Space - O(1)here\'s a in-space rotate method, by java, only for square. for non-square 2d array, you will have to create new array anyway.code to rotate any size 2d array by creating new array:Implementation of dimple\'s +90 pseudocode (e.g. transpose then reverse each row) in JavaScript:You can do this in 3 easy steps:1)Suppose we have a matrix2)Take the transpose of the matrix3)Interchange rows to get rotated matrixJava source code for this:Output:PHP:Here is the Java version:the method first rotate the mostouter layer, then move to the inner layer squentially.From a linear point of view, consider the matrices:Now take A transposeAnd consider the action of A\' on B, or B on A\'.\nRespectively:This is expandable for any n x n matrix.\nAnd applying this concept quickly in code:C# code to rotate [n,m] 2D arrays 90 deg rightResult:For i:= 0 to X do\n       For j := 0 to X do\n               graphic[j][i] := graphic2[X-i][j]X is the size of the array the graphic is in.#transpose is a standard method of Ruby\'s Array class, thus:The implementation is an n^2 transposition function written in C. You can see it here:\nhttp://www.ruby-doc.org/core-1.9.3/Array.html#method-i-transpose\nby choosing "click to toggle source" beside "transpose".I recall better than O(n^2) solutions, but only for specially constructed matrices (such as sparse matrices)This is my implementation, in C, O(1) memory complexity, in place rotation, 90 degrees clockwise:C code for matrix rotation 90 degree clockwise IN PLACE for any M*N matrixhere is my In Place implementation in CHere is my attempt for matrix 90 deg rotation which is a 2 step solution in C. First transpose the matrix in place and then swap the cols.@dagorym: Aw, man. I had been hanging onto this as a good "I\'m bored, what can I ponder" puzzle. I came up with my in-place transposition code, but got here to find yours pretty much identical to mine...ah, well. Here it is in Ruby.Simple C++ method, tho there would be a big memory overhead in a big array.