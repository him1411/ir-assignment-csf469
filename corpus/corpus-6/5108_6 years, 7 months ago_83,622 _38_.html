I have been working on a method to sync core data stored in an iPhone application between multiple devices, such as an iPad or a Mac. There are not many (if any at all) sync frameworks for use with Core Data on iOS. However, I have been thinking about the following concept:Is there anything fancy that I need to be thinking about? I have looked at REST frameworks such as ObjectiveResource, Core Resource, and RestfulCoreData. Of course, these are all working with Ruby on Rails, which I am not tied to, but it\'s a place to start. The main requirements I have for my solution are:I have thought about a number of the challenges:Is there anything else I am missing here? What kinds of frameworks should I look at to make this possible?I suggest carefully reading and implementing the sync strategy discussed by Dan Grover at iPhone 2009 conference, available here as a pdf document.This is a viable solution and is not that difficult to implement (Dan implemented this in several of its applications), overlapping the solution described by Chris. For an in-depth, theoretical discussion of syncing, see the paper from Russ Cox (MIT) and William Josephson (Princeton):File Synchronization with Vector Time Pairswhich applies equally well to core data with some obvious modifications. This provides an overall much more robust and reliable sync strategy, but requires more effort to be implemented correctly.EDIT:It seems that the Grover\'s pdf file is no longer available (broken link, March 2015). UPDATE: the link is available through the Way Back Machine hereThe Objective-C framework called ZSync and developed by Marcus Zarra has been deprecated, given that iCloud finally seems to support correct core data synchronization. I\'ve done something similar to what you\'re trying to do.  Let me tell you what I\'ve learned and how I did it.I assume you have a one-to-one relationship between your Core Data object and the model (or db schema) on the server.  You simply want to keep the server contents in sync with the clients, but clients can also modify and add data.  If I got that right, then keep reading.I added four fields to assist with synchronization:On the client, add code to set sync_status to 1 on your model object whenever something changes and needs to be synchronized to the server.  New model objects must generate a GUID.Synchronization is a single request.  The request contains:The server gets the request and does this:The app receives the response and does this:I hope that helps.  I used the word record and model interchangeably, but I think you get the idea.  Good luck.If you are still looking for a way to go, look into the Couchbase mobile. This basically does all you want. (http://www.couchbase.com/nosql-databases/couchbase-mobile) Similar like @Cris I\'ve implemented class for synchronization between client and server and solved all known problems so far (send/receive data to/from server, merge conflicts based on timestamps, removed duplicate entries in unreliable network conditions, synchronize nested data and files etc .. )You just tell the class which entity and which columns should it sync and where is your server. You can find source, working example and more instructions here: github.com/knagode/M3Synchronization.Notice user to update data via push notification.\nUse a background thread in the app to check the local data and the data on the cloud server,while change happens on server,change the local data,vice versa.So I think the most difficult part is to estimate data in which side is invalidate.Hope this can help uI have just posted the first version of my new Core Data Cloud Syncing API, known as SynCloud. \nSynCloud has a lot of differences with iCloud because it allows for Multi-user sync interface. It is also different from other syncing api\'s because it allows for multi-table, relational data.Please find out more at http://www.syncloudapi.comBuild with iOS 6 SDK, it is very up to date as of 9/27/2012.I think a good solution to the GUID issue is "distributed ID system".  I\'m not sure what the correct term is, but I think that\'s what MS SQL server docs used to call it (SQL uses/used this method for distributed/sync\'ed databases).  It\'s pretty simple:The server assigns all IDs.  Each time a sync is done, the first thing that is checked are "How many IDs do I have left on this client?"  If the client is running low, it asks the server for a new block of IDs.  The client then uses IDs in that range for new records.  This works great for most needs, if you can assign a block large enough that it should "never" run out before the next sync, but not so large that the server runs out over time.  If the client ever does run out, the handling can be pretty simple, just tell the user "sorry you cannot add more items until you sync"... if they are adding that many items, shouldn\'t they sync to avoid stale data issues anyway?I think this is superior to using random GUIDs because random GUIDs are not 100% safe, and usually need to be much longer than a standard ID (128-bits vs 32-bits).  You usually have indexes by ID and often keep ID numbers in memory, so it is important to keep them small.Didn\'t really want to post as answer, but I don\'t know that anyone would see as a comment, and I think it\'s important to this topic and not included in other answers.First you should rethink how many data, tables and relations you will have. In my solution I\xe2\x80\x99ve implemented syncing through Dropbox files. I observe changes in main MOC and save these data to files (each row is saved as gzipped json). If there is an internet connection working, I check if there are any changes on Dropbox (Dropbox gives me delta changes), download them and merge (latest wins), and finally put changed files. Before sync I put lock file on Dropbox to prevent other clients syncing incomplete data. When downloading changes it\xe2\x80\x99s safe that only partial data is downloaded (eg lost internet connection). When downloading is finished (fully or partial) it starts to load files into Core Data. When there are unresolved relations (not all files are downloaded) it stops loading files and tries to finish downloading later. Relations are stored only as GUID, so I can easly check which files to load to have full data integrity. \nSyncing is starting after changes to core data are made. If there are no changes, than it checks for changes on Dropbox every few minutes and on app startup. Additionaly when changes are sent to server I send a broadcast to other devices to inform them about changes, so they can sync faster.\nEach synced entity has GUID property (guid is used also as a filename for exchange files). I have also Sync database where I store Dropbox revision of each file (I can compare it when Dropbox delta resets it\xe2\x80\x99s state). Files also contain entity name, state (deleted/not deleted), guid (same as filename), database revision (to detect data migrations or to avoid syncing with never app versions) and of course the data (if row is not deleted).This solution is working for thousands of files and about 30 entities. Instead of Dropbox I could use key/value store as REST web service which I want to do later, but have no time for this :) For now, in my opinion, my solution is more reliable than iCloud and, which is very important, I have full control on how it\xe2\x80\x99s working (mainly because it\xe2\x80\x99s my own code).Another solution is to save MOC changes as transactions - there will be much less files exchanged with server, but it\xe2\x80\x99s harder to do initial load in proper order into empty core data. iCloud is working this way, and also other syncing solutions have similar approach, eg TICoreDataSync.--\nUPDATEAfter a while, I migrated to Ensembles - I recommend this solution over reinventing the wheel.