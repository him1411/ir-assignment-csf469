The way you would normally include a script is with "source"eg:main.sh:incl.sh:The output of executing "./main.sh" is:... Now, if you attempt to execute that shell script from another location, it can\'t find the include unless it\'s in your path.What\'s a good way to ensure that your script can find the include script, especially if for instance, the script needs to be portable?I tend to make my scripts all be relative to one another. \nThat way I can use dirname:I know I am late to the party, but this should work no matter how you start the script and uses builtins exclusively:. (dot) command is alias to source, $PWD is the Path for the Working Directory, BASH_SOURCE is an array variable whose members are the source filenames, ${string%substring} strips shortest match of $substring from back of $stringAn alternative to:is:.. the advantage being not having the dependence on dirname, which is not a built-in command (and not always available in emulators)If it is in the same directory you can use dirname $0:I think the best way to do this is to use the Chris Boran\'s way, BUT you should compute MY_DIR this way:To quote the man pages for readlink:I\'ve never encountered a use case where MY_DIR is not correctly computed. If you access your script through a symlink in your $PATH it works.This works even if the script is sourced:You need to specify the location of the other scripts, there is no other way around it.  I\'d recommend a configurable variable at the top of your script:Alternatively, you can insist that the user maintain an environment variable indicating where your program home is at, like PROG_HOME or somesuch.  This can be supplied for the user automatically by creating a script with that information in /etc/profile.d/, which will be sourced every time a user logs in.All those solutions doesn\'t work for me.Please, use more robust method:It supports:I\'d suggest that you create a setenv script whose sole purpose is to provide locations for various components across your system.All other scripts would then source this script so that all locations are common across all scripts using the setenv script.This is very useful when running cronjobs. You get a minimal environment when running cron, but if you make all cron scripts first include the setenv script then you are able to control and synchronise the environment that you want the cronjobs to execute in.We used such a technique on our build monkey that was used for continuous integration across a project of about 2,000 kSLOC.Steve\'s reply is definitely the correct technique but it should be refactored so that your installpath variable is in a separate environment script where all such declarations are made.Then all scripts source that script and should installpath change, you only need to change it in one location. Makes things more, er, futureproof. God I hate that word! (-:BTW You should really refer to the variable using ${installpath} when using it in the way shown in your example:If the braces are left out, some shells will try and expand the variable "installpath/incl.sh"!I put all my startup scripts in a .bashrc.d directory.\nThis is a common technique in such places as /etc/profile.d, etc.The problem with the solution using globbing......is you might have a file list which is "too long".\nAn approach like... ...runs but doesn\'t change the environment as desired.Of course, to each their own, but I think the block below is pretty solid. I believe this involves the "best" way to find a directory, and the "best" way to call another bash script:So this may be the "best" way to include other scripts. This is based off another "best" answer that tells a bash script where it is stored This should work reliably:Using source or $0 will not give you the real path of your script. You could use the process id of the script to retrieve its real pathI am using this script and it has always served me well :)we just need to find out the folder where our incl.sh and main.sh is stored; just change your main.sh with this:main.shShell Script Loader is my solution for this.It provides a function named include() that can be called many times in many scripts to refer a single script but will only load the script once. The function can accept complete paths or partial paths (script is searched in a search path). A similar function named load() is also provided that will load the scripts unconditionally.It works for bash, ksh, pd ksh and zsh with optimized scripts for each one of them; and other shells that are generically compatible with the original sh like ash, dash, heirloom sh, etc., through a universal script that automatically optimizes its functions depending on the features the shell can provide.[Fowarded example]start.shThis is an optional starter script. Placing the startup methods here is just a convenience and can be placed in the main script instead. This script is also not needed if the scripts are to be compiled.main.sha.shb.shoutput:What\'s best is scripts based on it may also be compiled to form a single script with the available compiler.Here\'s a project that uses it: http://sourceforge.net/p/playshell/code/ci/master/tree/. It can run portably with or without compiling the scripts. Compiling to produce a single script can also happen, and is helpful during installation.I also created a simpler prototype for any conservative party that may want to have a brief idea of how an implementation script works: https://sourceforge.net/p/loader/code/ci/base/tree/loader-include-prototype.bash. It\'s small and anyone can just include the code in their main script if they want to if their code is intended to run with Bash 4.0 or newer, and it also doesn\'t use eval.You can also use: