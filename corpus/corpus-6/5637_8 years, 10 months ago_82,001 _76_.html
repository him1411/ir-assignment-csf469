How do you properly override isEqual: in Objective-C?  The "catch" seems to be that if two objects are equal (as determined by the isEqual: method), they must have the same hash value.The Introspection section of the Cocoa Fundamentals Guide does have an example on how to override isEqual:, copied as follows, for a class named MyWidget:It checks pointer equality, then class equality, and finally compares the objects using isEqualToWidget:, which only checks  the name and data properties.  What the example doesn\'t show is how to override hash.Let\'s assume there are other properties that do not affect equality, say age.  Shouldn\'t the hash method be overridden such that only name and data affect the hash?  And if so, how would you do that? Just add the hashes of name and data?  For example:Is that sufficient?  Is there a better technique?  What if you have primitives, like int?  Convert them to NSNumber to get their hash?  Or structs like NSRect?(Brain fart: Originally wrote "bitwise OR" them together with |=. Meant add.)Start withThen for every primitive you doFor 64bit you might also want to shift and xor.For objects you use 0 for nil and otherwise their hashcode.For booleans you use two different valuesThis is not tcurdt\'s work, and comments were asking for more explanation, so I believe an edit for attribution is fair.This algorithm was popularized in the book "Effective Java", and the relevant chapter can currently be found online here.  That book popularized the algorithm, which is now a default in a number of Java applications (including Eclipse).  It derived, however, from an even older implementation which is variously attributed to Dan Bernstein or Chris Torek.  That older algorithm originally floated around on Usenet, and certain attribution is difficult.  For example, there is some interesting commentary in this Apache code (search for their names) that references the original source.Bottom line is, this is a very old, simple hashing algorithm.  It is not the most performant, and it is not even proven mathematically to be a "good" algorithm.  But it is simple, and a lot of people have used it for a long time with good results, so it has a lot of historical support.I\'m just picking up Objective-C myself, so I can\'t speak for that language specifically, but in the other languages I use if two instances are "Equal" they must return the same hash - otherwise you are going to have all sorts of problems when trying to use them as keys in a hashtable (or any dictionary-type collections).  On the other hand, if 2 instances are not equal, they may or may not have the same hash - it is best if they don\'t.  This is the difference between an O(1) search on a hash table and an O(N) search - if all your hashes collide you may find that searching your table is no better than searching a list.In terms of best practices your hash should return a random distribution of values for its input.  This means that, for example, if you have a double, but the majority of your values tend to cluster between 0 and 100, you need to make sure that the hashes returned by those values are evenly distributed across the entire range of possible hash values.  This will significantly improve your performance.There are a number of hashing algorithms out there, including several listed here.  I try to avoid creating new hash algorithms as it can have large performance implications, so using the existing hash methods and doing a bitwise combination of some sort as you do in your example is a good way to avoid it.I found this thread extremely helpful supplying everything I needed to get my isEqual: and hash methods implemented with one catch. When testing object instance variables in isEqual: the example code uses:This repeatedly failed (i.e., returned NO) without and error, when I knew the objects were identical in my unit testing. The reason was, one of the NSString instance variables was nil so the above statement was:and since nil will respond to any method, this is perfectly legal but returns nil, which is NO, so when both the object and the one being tested had a nil object they would be considered not equal (i.e., isEqual: would return NO).This simple fix was to change the if statement to:This way, if their addresses are the same it skips the method call no matter if they are both nil or both pointing to the same object but if either is not nil or they point to different objects then the comparator is appropriately called.I hope this saves someone a few minutes of head scratching.A simple XOR over the hash values of critical properties is sufficient\n  99% of the time.For example:Solution found at http://nshipster.com/equality/ by Mattt Thompson (which also referred this question in his post!)The hash function should create a semi-unique value that is not likely to collide or match another object\'s hash value.Here is the full hash function, which can be adapted to your classes instance variables. It uses NSUInteger\'s rather than int for compatibility on 64/32bit applications.If the result becomes 0 for different objects, you run the risk of colliding hashes. Colliding hashes can result in unexpected program behavior when working with some of the collection classes that depend on the hash function. Make sure to test your hash function prior to use.This helped me a lot! Might be the answer your looking for. \nimplementing equality and hashingThe easy but inefficient way is to return the same -hash value for every instance. Otherwise, yes, you must implement hash based only on objects which affect equality. This is tricky if you use lax comparisons in -isEqual: (e.g. case-insensitive string comparisons). For ints, you can generally use the int itself, unless you\xe2\x80\x99ll be comparing with NSNumbers.Don\xe2\x80\x99t use |=, though, it will saturate. Use ^= instead.Random fun fact: [[NSNumber numberWithInt:0] isEqual:[NSNumber numberWithBool:NO]], but [[NSNumber numberWithInt:0] hash] != [[NSNumber numberWithBool:NO] hash]. (rdar://4538282, open since 05-May-2006)Remember that you only need to provide hash that\'s equal when isEqual is true. When isEqual is false, the hash doesn\'t have to be unequal though presumably it is. Hence:Keep hash simple. Pick a member (or few members) variable that is the most distinctive.For example, for CLPlacemark, the name only is enough. Yes there are 2 or 3 distincts CLPlacemark with the exact same name but those are rare. Use that hash....Notice I do not bother specifying the city, the country, etc. The name is enough. Perhaps the name and CLLocation.Hash should be evenly distributed. So you can combine several members variable using the caret ^ (xor sign)So it\'s something likeThat way the hash will be evenly distributed.So what to do in array?Again, simple. You do not have to hash all members of the array. Enough to hash the first element, last element, the count, maybe some middle elements, and that\'s it.Hold on, surely a far easier way to do this is to first override - (NSString )description and provide a string representation of your object state (you must represent the entire state of your object in this string).Then, just provide the following implementation of hash:This is based on the principle that "if two string objects are equal (as determined by the isEqualToString: method), they must have the same hash value."Source: NSString Class ReferenceThis doesn\'t directly answer your question (at all) but I\'ve used MurmurHash before to generate hashes: murmurhashGuess I should explain why: murmurhash is bloody fast...I\'ve found this page to be a helpful guide in override equals- and hash-type methods. It includes a decent algorithm for calculating hash codes. The page is geared towards Java, but it\'s pretty easy to adapt it to Objective-C/Cocoa.I\'m an Objective C newbie too, but I found an excellent article about identity vs. equality in Objective C here. From my reading it looks like you might be able to just keep the default hash function (which should provide a unique identity) and implement the isEqual method so that it compares data values.The equals and hash contracts are well specified and thoroughly researched in the Java world (see @mipardi\'s answer), but all the same considerations should apply to Objective-C.Eclipse does a reliable job of generating these methods in Java, so here\'s an Eclipse example ported by hand to Objective-C:And for a subclass YourWidget which adds a property serialNo:This implementation avoids some subclassing pitfalls in the sample isEqual: from Apple:The second issue can be fixed by only considering objects to be equal if they belong to the exact same class, hence the [self class] != [object class] test here. For typical application classes, this seems to be the best approach.However, there certainly are cases where the isKindOfClass: test is preferable. This is more typical of framework classes than application classes. For example, any NSString should compare equal to any other other NSString with the same underlying character sequence, regardless of the NSString/NSMutableString distinction, and also regardless of what private classes in the NSString class cluster are involved.In such cases, isEqual: should have well-defined, well-documented behaviour, and it should be made clear that subclasses can\'t override this. In Java, the \'no override\' restriction can be enforced by flagging the equals and hashcode methods as final, but Objective-C has no equivalent.Combining @tcurdt\'s answer with @oscar-gomez\'s answer for getting property names, we can create an easy drop-in solution for both isEqual and hash:Now, in your custom class you can easily implement isEqual: and hash:Note that if you\'re creating a object that can be mutated after creation, the hash value must not change if the object is inserted into a collection. Practically speaking, this means that the hash value must be fixed from the point of the initial object creation.  See Apple\'s documentation on the NSObject protocol\'s -hash method for more information:If a mutable object is added to a collection that uses hash values to determine the object\xe2\x80\x99s position in the collection, the value returned by the hash method of the object must not change while the object is in the collection. Therefore, either the hash method must not rely on any of the object\xe2\x80\x99s internal state information or you must make sure the object\xe2\x80\x99s internal state information does not change while the object is in the collection. Thus, for example, a mutable dictionary can be put in a hash table but you must not change it while it is in there. (Note that it can be difficult to know whether or not a given object is in a collection.)This sounds like complete whackery to me since it potentially effectively renders hash lookups far less efficient, but I suppose it\'s better to err on the side of caution and follow what the documentation says.Quinn is just wrong that the reference to the murmur hash is useless here.  Quinn is right that you want to understand the theory behind hashing.  The murmur distills a lot of that theory into an implementation.  Figuring out how to apply that implementation to this particular application is worth exploring.Some of the key points here:The example function from tcurdt suggests that \'31\' is a good multiplier because it is prime.  One needs to show that being prime is a necessary and sufficient condition.  In fact 31 (and 7) are probably not particularly good primes because 31 == -1 % 32.  An odd multiplier with about half the bits set and half the bits clear is likely to be better.  (The murmur hash multiplication constant has that property.)This type of hash function would likely be stronger if, after multiplying, the result value were adjusted via a shift and xor.  The multiplication tends to produce the results of lots of bit interactions at the high end of the register and low interaction results at the bottom end of the register.  The shift and xor increases the interactions at the bottom end of the register.Setting the initial result to a value where about half the bits are zero and about half the bits are one would also tend to be useful.It may be useful to be careful about the order in which elements are combined.  One should probably first process booleans and other elements where the values are not strongly distributed.It may be useful to add a couple of extra bit scrambling stages at the end of the computation.Whether or not the murmur hash is actually fast for this application is an open question.  The murmur hash premixes the bits of each input word.  Multiple input words can be processed in parallel which helps multiple-issue pipelined cpus.Sorry if I risk sounding a complete boffin here but...\n...nobody bothered mentioning that to follow \'best practices\' you should definitely not specify an equals method that would NOT take into account all data owned by your target object, e.g whatever data is aggregated to your object, versus an associate of it, should be taken into account when implementing equals.\nIf you don\'t want to take, say \'age\' into account in a comparison, then you should write a comparator and use that to perform your comparisons instead of isEqual:.If you define an isEqual: method that performs equality comparison arbitrarily, you incur the risk that this method is misused by another developer, or even yourself, once you\'ve forgotten the \'twist\' in your equals interpretation.Ergo, although this is a great q&a about hashing, you don\'t normally need to redefine the hashing method, you should probably define an ad-hoc comparator instead.