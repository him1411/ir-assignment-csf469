I have an associative array in the form key => value where key is a numerical value, however it is not a sequential numerical value. The key is actually an ID number and the value is a count. This is fine for most instances, however I want a function that gets the human-readable name of the array and uses that for the key, without changing the value.I didn\'t see a function that does this, but I\'m assuming I need to provide the old key and new key (both of which I have) and transform the array. Is there an efficient way of doing this?The way you would do this and preserve the ordering of the array is by putting the array keys into a separate array, find and replace the key in that array and then combine it back with the values. Here is a function that does just that:if your array is built from a database query, you can change the key directly from the mysql statement:instead ofuse something like:You could use a second associative array that maps human readable names to the id\'s.  That would also provide a Many to 1 relationship.  Then do something like this:The answer from KernelM is nice, but in order to avoid the issue raised by Greg in the comment (conflicting keys), using a new array would be saferIf you want also the position of the new array key to be the same as the old one you can do this:I like KernelM\'s solution, but I needed something that would handle potential key conflicts (where a new key may match an existing key). Here is what I came up with:You can then cycle through an array like this:If your array is recursive you can use this function:\ntest this data:here is the function:Easy stuff:this function will accept the target $hash and $replacements is also a hash containing newkey=>oldkey associations.This function will preserve original order, but could be problematic for very large (like above 10k records) arrays regarding performance & memory.this alternative function would do the same, with far better performance & memory usage, at the cost of loosing original order (which should not be a problem since it is hashtable!)Here is a helper function to achieve that:pretty based on @KernelM answer.Usage:It will return true on successful rename, otherwise false.this code will help to change the oldkey to new onedisplay likethis works for renaming the first key:then, print_r($a) renders a repaired in-order array:this works for renaming an arbitrary key:print_r($a)a generalized function:There is an alternative way to change the key of an array element when working with a full array - without changing the order of the array.\nIt\'s simply to copy the array into a new array.For instance, I was working with a mixed, multi-dimensional array that contained indexed and associative keys - and I wanted to replace the integer keys with their values, without breaking the order.I did so by switching key/value for all numeric array entries - here: [\'0\'=>\'foo\']. Note that the order is intact.Output:If you want to replace several keys at once (preserving order):Usage:Hmm, I\'m not test before, but I think this code working