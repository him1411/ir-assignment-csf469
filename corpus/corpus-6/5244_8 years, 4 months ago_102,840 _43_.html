What is JavaScript garbage collection? What\'s important for a web programmer to understand about JavaScript garbage collection, in order to write better code?Eric Lippert wrote a detailed blog post about this subject a while back (additionally comparing it to VBScript). More accurately, he wrote about JScript, which is Microsoft\'s own implementation of ECMAScript, although very similar to JavaScript. I would imagine that you can assume the vast majority of behaviour would be the same for the JavaScript engine of Internet Explorer. Of course, the implementation will vary from browser to browser, though I suspect you could take a number of the common principles and apply them to other browsers.Quoted from that page:JScript uses a nongenerational\n  mark-and-sweep garbage collector.  It\n  works like this: Every variable which is "in scope"\n  is called a "scavenger".  A scavenger\n  may refer to a number, an object, a\n  string, whatever.  We maintain a list\n  of scavengers -- variables are moved\n  on to the scav list when they come\n  into scope and off the scav list when\n  they go out of scope.Every now and then the garbage\n  collector runs.   First it puts a\n  "mark" on every object, variable,\n  string, etc \xe2\x80\x93 all the memory tracked\n  by the GC.  (JScript uses the VARIANT\n  data structure internally and there\n  are plenty of extra unused bits in\n  that structure, so we just set one of\n  them.)Second, it clears the mark on the\n  scavengers and the transitive closure\n  of scavenger references.  So if a\n  scavenger object references a\n  nonscavenger object then we clear the\n  bits on the nonscavenger, and on\n  everything that it refers to.  (I am\n  using the word "closure" in a\n  different sense than in my earlier\n  post.)At this point we know that all the\n  memory still marked is allocated\n  memory which cannot be reached by any\n  path from any in-scope variable.  All\n  of those objects are instructed to\n  tear themselves down, which destroys\n  any circular references.The main purpose of garbage collection is to allow the programmer not to worry about memory management of the objects they create and use, though of course there\'s no avoiding it sometimes - it is always beneficial to have at least a rough idea of how garbage collection works.There are a few particular points of which to be aware. The Apple developer site has some guidelines on the matter. Two important ones from there:I would imagine that the practices should apply to all JavaScript engines (in different browsers), though because this is from an Apple site, they may be somewhat specific to Safari. (Perhaps someone could clarify that?)Hope that helps.Beware of circular references when DOM objects are involved:Memory leak patterns in JavaScriptKeep in mind that memory can only be reclaimed when there are no active references to the object. This is a common pitfall with closures and event handlers, as some JS engines will not check which variables actually are referenced in inner functions and just keep all local variables of the enclosing functions.Here\'s a simple example:A naive JS implementation can\'t collect bigString as long as the event handler is around. There are several ways to solve this problem, eg setting bigString = null at the end of init() (delete won\'t work for local variables and function arguments: delete removes properties from objects, and the variable object is inaccessible - ES5 in strict mode will even throw a ReferenceError if you try to delete a local variable!).I recommend to avoid unnecessary closures as much as possible if you care for memory consumption.To the best of my knowledge, JavaScript\'s objects are garbage collected periodically when there are no references remaining to the object.  It is something that happens automatically, but if you want to see more about how it works, at the C++ level, it makes sense to take a look at the WebKit or V8 source codeTypically you don\'t need to think about it, however, in older browsers, like IE 5.5 and early versions of IE 6, and perhaps current versions, closures would create circular references that when unchecked would end up eating up memory.  In the particular case that I mean about closures, it was when you added a JavaScript reference to a dom object, and an object to a DOM object that referred back to the JavaScript object.  Basically it could never be collected, and would eventually cause the OS to become unstable in test apps that looped to create crashes.  In practice these leaks are usually small, but to keep your code clean you should delete the JavaScript reference to the DOM object.Usually it is a good idea to use the delete keyword to immediately de-reference big objects like JSON data that you have received back and done whatever you need to do with it, especially in mobile web development.  This causes the next sweep of the GC to remove that object and free its memory.Good quote taken from a blogThe DOM component is "garbage collected", as is the JScript component, which means that if you create an object within either component, and then lose track of that object, it will eventually be cleaned up.For example:When you call that function, the JScript component creates an object (named bigArray) that is accessible within the function. As soon as the function returns, though, you "lose track" of bigArray because there\'s no way to refer to it anymore. Well, the JScript component realizes that you\'ve lost track of it, and so bigArray is cleaned up--its memory is reclaimed. The same sort of thing works in the DOM component. If you say document.createElement(\'div\'), or something similar, then the DOM component creates an object for you. Once you lose track of that object somehow, the DOM component will clean up the related.garbage collection (GC) is a form of automatic memory management by removing the objects that no needed anymore.any process deal with memory follow these steps:1 - allocate your memory space you need2 - do some processing3 - free this memory spacethere are two main algorithm used to detect which objects no needed anymore.Reference-counting garbage collection: this algorithm reduces the definition of "an object is not needed anymore" to "an object has no other object referencing to it", the object will removed if no reference point to itMark-and-sweep algorithm: connect each objects to root source. any object doesn\'t connect to root or other object. this object will be removed.currently most modern browsers using the second algorithm.  "In computer science, garbage collection (GC) is a form of automatic memory management. The garbage collector, or just collector, attempts to reclaim garbage, or memory used by objects that will never be accessed or mutated again by the application."All JavaScript engines have their own garbage collectors, and they may differ. Most time you do not have to deal with them because they just do what they supposed to do.Writing better code mostly depends of how good do you know programming principles, language and particular implementation.What is JavaScript garbage collection? check this What\'s important for a web programmer to understand about JavaScript garbage collection, \n  in order to write better code?In Javascript you don\'t care about memory allocation and deallocation. The whole problem is demanded to the Javascript interpreter. Leaks are still possible in Javascript, but they are bugs of the interpreter. If you are interested in this topic you could read more in \nwww.memorymanagement.org On windows you can use Drip.exe to find memory leaks or check if your free mem routine works. It\'s really simple, just enter a website URL and you will see the memory consumption of the integrated IE renderer. Then hit refresh, if the memory increases, you found a memory leak somewhere on the webpage. But this is also very useful to see if routines for freeing memory work for IE. 