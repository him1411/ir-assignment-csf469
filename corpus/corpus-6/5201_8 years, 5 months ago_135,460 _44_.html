I am creating an application which connects to the server using username/password and I would like to enable the option "Save password" so the user wouldn\'t have to type the password each time the application starts.I was trying to do it with Shared Preferences but am not sure if this is the best solution.I would appreciate any suggestion on how to store user values/settings in Android application.In general SharedPreferences are your best bet for storing preferences, so in general I\'d recommend that approach for saving application and user settings.The only area of concern here is what you\'re saving. Passwords are always a tricky thing to store, and I\'d be particularly wary of storing them as clear text. The Android architecture is such that your application\'s SharedPreferences are sandboxed to prevent other applications from being able to access the values so there\'s some security there, but physical access to a phone could potentially allow access to the values.If possible I\'d consider modifying the server to use a negotiated token for providing access, something like OAuth. Alternatively you may need to construct some sort of cryptographic store, though that\'s non-trivial. At the very least, make sure you\'re encrypting the password before writing it to disk.I agree with Reto and fiXedd.  Objectively speaking it doesn\'t make a lot of sense investing significant time and effort into encrypting passwords in SharedPreferences since any attacker that has access to your preferences file is fairly likely to also have access to your application\'s binary, and therefore the keys to unencrypt the password.However, that being said, there does seem to be a publicity initiative going on identifying mobile applications that store their passwords in cleartext in SharedPreferences and shining unfavorable light on those applications.  See http://blogs.wsj.com/digits/2011/06/08/some-top-apps-put-data-at-risk/ and http://viaforensics.com/appwatchdog for some examples.  While we need more attention paid to security in general, I would argue that this sort of attention on this one particular issue doesn\'t actually significantly increase our overall security.  However, perceptions being as they are, here\'s a solution to encrypt the data you place in SharedPreferences.Simply wrap your own SharedPreferences object in this one, and any data you read/write will be automatically encrypted and decrypted.  eg.Here\'s the code for the class:About the simplest way to store a single preference in an Android Activity is to do something like this:If you\'re worried about the security of these then you could always encrypt the password before storing it.Using the snippet provided by Richard, you can encrypt the password before saving it.  The preferences API however doesn\'t provide an easy way to intercept the value and encrypt it - you can block it being saved via an OnPreferenceChange listener, and you theoretically could modify it through a preferenceChangeListener, but that results in an endless loop.I had earlier suggested adding a "hidden" preference in order to accomplish this.  It\'s definitely not the best way.  I\'m going to present two other options that I consider to be more viable. First, the simplest, is in a preferenceChangeListener, you can grab the entered value, encrypt it, and then save it to an alternative preferences file:The second way, and the way I now prefer, is to create your own custom preference, extending EditTextPreference, @Override\'ing the setText() and getText() methods, so that setText() encrypts the password, and getText() returns null.Okay; it\'s been a while since the answer is kind-of mixed, but here\'s a few common answers. I researched this like crazy and it was hard to build a good answerThe MODE_PRIVATE method is considered generally safe, if you assume that the user didn\'t root the device. Your data is stored in plain text in a part of the file system that can only be accessed by the original program. This makings grabbing the password with another app on a rooted device easy. Then again, do you want to support rooted devices?AES is still the best encryption you can do. Remember to look this up if you are starting a new implementation if it\'s been a while since I posted this. The largest issue with this is "What to do with the encryption key?"So, now we are at the "What to do with the key?" portion. This is the hard part. Getting the key turns out to be not that bad. You can use a key derivation function to take some password and make it a pretty secure key. You do get into issues like "how many passes do you do with PKFDF2?", but that\'s another topicIdeally, you store the AES key off the device. You have to figure out a good way to retrieve the key from the server safely, reliably, and securely thoughYou have a login sequence of some sort (even the original login sequence you do for remote access). You can do two runs of your key generator on the same password. How this works is that you derive the key twice with a new salt and a new secure initialization vector. You store one of those generated passwords on the device, and you use the second password as the AES key.When you log in, you re-derive the key on the local login and compare it to the stored key. Once that is done, you use derive key #2 for AES.You can do a lot of variations of these. For example, instead of a full login sequence, you can do a quick PIN (derived). The quick PIN might not be as secure as a full login sequence, but it\'s many times more secure than plain textI\'ll throw my hat into the ring just to talk about securing passwords in general on Android.  On Android, the device binary should be considered compromised - this is the same for any end application which is in direct user control.  Conceptually, a hacker could use the necessary access to the binary to decompile it and root out your encrypted passwords and etc.As such there\'s two suggestions I\'d like to throw out there if security is a major concern for you:1) Don\'t store the actual password.  Store a granted access token and use the access token and the signature of the phone to authenticate the session server-side.  The benefit to this is that you can make the token have a limited duration, you\'re not compromising the original password and you have a good signature that you can use to correlate to traffic later (to for instance check for intrusion attempts and invalidate the token rendering it useless).2) Utilize 2 factor authentication.  This may be more annoying and intrusive but for some compliance situations unavoidable.I know this is a little bit of necromancy, but you should use the Android AccountManager.  It\'s purpose-built for this scenario.  It\'s a little bit cumbersome but one of the things it does is invalidate the local credentials if the SIM card changes, so if somebody swipes your phone and throws a new SIM in it, your credentials won\'t be compromised.This also gives the user a quick and easy way to access (and potentially delete) the stored credentials for any account they have on the device, all from one place.SampleSyncAdapter is an example that makes use of stored account credentials.You can also check out this little lib, containing the functionality you mention.https://github.com/kovmarci86/android-secure-preferencesIt is similar to some of the other aproaches here. Hope helps :)This answer is based on a suggested approach by Mark. A custom version of the EditTextPreference class is created which converts back and forth between the plain text seen in the view and an encrypted version of the password stored in the preferences storage. As has been pointed out by most who have answered on this thread, this is not a very secure technique, although the degree of security depends partly on the encryption/decryption code used. But it\'s fairly simple and convenient, and will thwart most casual snooping. Here is the code for the custom EditTextPreference class:This shows how it can be used - this is the "items" file that drives the preferences display. Note it contains three ordinary EditTextPreference views and one of the custom EditPasswordPreference views.As for the actual encryption/decryption, that is left as an exercise for the reader. I\'m currently using some code based on this article http://zenu.wordpress.com/2011/09/21/aes-128bit-cross-platform-java-and-c-encryption-compatibility/, although with different values for the key and the initialization vector.First of all I think User\'s data shouldn\'t be stored on phone, and if it is must to store data somewhere on the phone it should be encrypted with in the apps private data. Security of users credentials should be the priority of the application.The sensitive data should be stored securely or not at all. In the event of a lost device or malware infection, data stored insecurely can be compromised.you need to use the sqlite, security apit to store the passwords.\nhere is best example, which stores passwords, -- passwordsafe.\nhere is link for the source and explanation -- \nhttp://code.google.com/p/android-passwordsafe/shared preferences is easiest way to store our application data. but it is possible that anyone can clear our shared preferences data through application manager.so i don\'t think it is completely safe for our application.  