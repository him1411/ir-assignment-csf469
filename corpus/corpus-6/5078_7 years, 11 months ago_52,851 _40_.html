Is there a common way to pass a single item of type T to a method which expects an  IEnumerable<T> parameter? Language is C#, framework version 2.0.Currently I am using a helper method (it\'s .Net 2.0, so I have a whole bunch of casting/projecting helper methods similar to LINQ), but this just seems silly:Other way would of course be to create and populate a List<T> or an Array and pass it instead of IEnumerable<T>.[Edit] As an extension method it might be named:Am I missing something here?[Edit2] We found someObject.Yield() (as @Peter suggested in the comments below) to be the best name for this extension method, mainly for brevity, so here it is along with the XML comment if anyone wants to grab it:Your helper method is the cleanest way to do it, IMO. If you pass in a list or an array, then an unscrupulous piece of code could cast it and change the contents, leading to odd behaviour in some situations. You could use a read-only collection, but that\'s likely to involve even more wrapping. I think your solution is as neat as it gets.Well, if the method expects an IEnumerable you\'ve got to pass something that is a list, even if it contains one element only.passing as the argument should be enough I thinkIn C# 3.0 you can utilize the System.Linq.Enumerable class:This will create a new IEnumerable that only contains your item.In C# 3 (I know you said 2), you can write a generic extension method which might make the syntax a little more acceptable:client code is then item.ToEnumerable().I\'m kind of surprised that no one suggested a new overload of the method with an argument of type T to simplify the client API.Now your client code can just do this:or with a list:As I have just found, and seen that user LukeH suggested too, a nice simple way of doing this is as follows:This pattern will allow you to call the same functionality in a multitude of ways: a single item; multiple items (comma-separated); an array; a list; an enumeration, etc.I\'m not 100% sure on the efficiency of using the AsEnumerable method though, but it does work a treat.Update: The AsEnumerable function looks pretty efficient! (reference)Either (as has previously been said)orAs a side note, the last version can also be nice if you want an empty list of an anonymous object, e.g.This may not be any better but it\'s kind of cool:This helper method is works for item or many.I agree with @EarthEngine\'s comments to the original post, which is that \'AsSingleton\' is a better name. See this wikipedia entry.  Then it follows from the definition of singleton that if a null value is passed as an argument that \'AsSingleton\' should return an IEnumerable with a single null value instead of an empty IEnumerable which would settle the if (item == null) yield break; debate. I think the best solution is to have two methods: \'AsSingleton\' and \'AsSingletonOrEmpty\'; where, in the event that a null is passed as an argument, \'AsSingleton\' will return a single null value and \'AsSingletonOrEmpty\' will return an empty IEnumerable.  Like this:Then, these would, more or less, be analogous to the \'First\' and \'FirstOrDefault\' extension methods on IEnumerable which just feels right.This is 30% faster than yield or Enumerable.Repeat when used in foreach due to this C# compiler optimization, and of the same performance in other cases.in this test:IanG has a good post on the topic, suggesting EnumerableFrom() as the name and mentions that the discussion points out that Haskell and Rx call it Return. IIRC F# calls it Return too. F#\'s Seq calls the operator singleton<\'T>.Tempting if you\'re prepared to be C#-centric is to call it Yield [alluding to the yield return involved in realizing it].If you\'re interested in the perf aspects of it, James Michael Hare has a returning zero or one items post too which is well worth a scan.Although it\'s overkill for one method, I believe some people may find the Interactive Extensions useful.The Interactive Extensions (Ix) from Microsoft includes the following method.Which can be utilized like so:Ix adds new functionality not found in the original Linq extension methods, and is a direct result of creating the Reactive Extensions (Rx).Think, Linq Extension Methods + Ix = Rx for IEnumerable.You can find both Rx and Ix on CodePlex.The easiest way I\'d say would be new T[]{item};; there\'s no syntax to do this. The closest equivalent that I can think of is the params keyword, but of course that requires you to have access to the method definition and is only usable with arrays.