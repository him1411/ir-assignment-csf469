I have a project with a submodule that is pointing to an invalid commit: the submodule commit remained local and when I try to fetch it from another repo I get:I know what the submodule HEAD should be, is there any way I can change this locally, without pushing from the repo that does have commit 2d7cfbd09fc96c04c4c41148d44ed7778add6b43 ?I\'m not sure if I\'m being clear... here\'s a similar situation I found.Assuming the submodule\'s repository does contain a commit you want to use (unlike the commit that is referenced from current state of the super-project), there are two ways to do it.The first requires you to already know the commit from the submodule that you want to use. It works from the \xe2\x80\x9cinside, out\xe2\x80\x9d by directly adjusting the submodule then updating the super-project. The second works from the \xe2\x80\x9coutside, in\xe2\x80\x9d by finding the super-project\'s commit that modified the submodule and then reseting the super-project\'s index to refer to a different submodule commit.If you already know which commit you want the submodule to use, cd to the submodule, check out the commit you want, then git add and git commit it back in the super-project.Example:Oops, someone made a super-project commit that refers to an unpublished commit in the submodule sub. Somehow, we already know that we want the submodule to be at commit 5d5a3ee314476701a20f2c6ec4a53f88d651df6c. Go there and check it out directly.Since we are checking out a commit, this produces a detached HEAD in the submodule. If you want to make sure that the submodule is using a branch, then use git checkout -b newbranch <commit> to create and checkout a branch at the commit or checkout the branch that you want (e.g. one with the desired commit at the tip).A checkout in the submodule is reflected in the super-project as a change to the working tree. So we need to stage the change in the super-project\'s index and verify the results.The submodule update was silent because the submodule is already at the specified commit. The first diff shows that the index and worktree are the same. The third diff shows that the only staged change is moving the sub submodule to a different commit.This commits the fixed-up submodule entry.If you are not sure which commit you should use from the submodule, you can look at the history in the superproject to guide you. You can also manage the reset directly from the super-project.This is the same situation as above. But this time we will focus on fixing it from the super-project instead of dipping into the submodule.OK, it looks like it went bad in ce5d37c, so we will restore the submodule from its parent (ce5d37c~).Alternatively, you can take the submodule\'s commit from the patch text (5d5a3ee314476701a20f2c6ec4a53f88d651df6c) and use the above \xe2\x80\x9cinside, out\xe2\x80\x9d process instead.This reset the submodule entry for sub to what it was at commit ce5d37c~ in the super-project.The submodule update went OK (it indicates a detached HEAD).The first diff shows that sub is now the same in ce5d37c~. The second diff shows that the index and worktree are the same. The third diff shows the only staged change is moving the sub submodule to a different commit.This commits the fixed-up submodule entry.try this:This error can mean that a commit is missing in the submodule.  That is, the repository (A) has a submodule (B).  A wants to load B so that it is pointing to a certain commit (in B).  If that commit is somehow missing, you\'ll get that error.  Once possible cause: the reference to the commit was pushed in A, but the actual commit was not pushed from B.  So I\'d start there.Less likely, there\'s a permissions problem, and the commit cannot be pulled (possible if you\'re using git+ssh).Make sure the submodule paths look ok in .git/config and .gitmodules.One last thing to try - inside the submodule directory: git reset HEAD --hardThis can happens when: e.g. something like this happened:Should have submodule pushed at this point.As a result, the missing commits could not possibly be found by the remote user because they are still on the local disk.Informa the person who modified the submodule to push, i.e.I got this error when I did:but the commit in the parent project was pointing at an earlier commit.\nDeleting the submodule folder and runningdid NOT solve the problem. I deleted the repo and tried again without the depth flag and it worked.This may also happen when you have a submodule pointing to a repository that was rebased and the given commit is "gone". While the commit may still be in the remote repository, it is not in a branch. If you can\'t create a new branch (e.g. not your repository), you\'re stuck with having to update the super project to point to a new commit. Alternatively you can push one of your copies of the submodules elsewhere and then update the super-project to point to that repository instead.This answer is for users of SourceTree with limited terminal git experience. Open the problematic submodule from within the Git project (super-project).Fetch and ensure \'Fetch all tags\' is checked.Rebase pull your Git project.This will solve the \'reference is not a tree\' problem 9 out of ten times. That 1 time it won\'t, is a terminal fix as described by the top answer.Your submodule history is safely preserved in the submodule git anyway.So, why not just delete the submodule and add it again?Otherwise, did you try manually editing the HEAD or the refs/master/head within the submodule .gitJust to be sure, try updating your git binaries.GitHub for Windows has the version git version 1.8.4.msysgit.0 which in my case was the problem. Updating solved it.In my case, none of answer above solve the problem even thoungh they are good answers. So I post my solution (in my case there are two git clients, client A and B):go to submodule\'s dir:checkout to master:rebase to a commit code which both client can seego back to the parent\'s dir:commit to masterchange to the other client\xef\xbc\x8c do rebase again.finally it works fine now! Maybe lose a couple of commits but it works.FYI, don\'t try to remove your submodule, it will remain .git/modules there and cannot readd this submodule again, unless reactive local one.To sync the git repo with the submodule\'s head, in case that is really what you want, I found that removing the submodule and then readding it avoids the tinkering with the history. Unfortunately removing a submodule requires hacking rather than being a single git command, but doable.Steps I followed to remove the submodule, inspired by https://gist.github.com/kyleturner/1563153:Again, this can be useful if all you want is to point at the submodule\'s head again, and you haven\'t complicated things by needing to keep the local copy of the submodule intact. It assumes you have the submodule "right" as its own repo, wherever the origin of it is, and you just want to get back to properly including it as a submodule. Note: always make a full copy of your project before engaging in these kinds of manipulation or any git command beyond simple commit or push. I\'d advise that with all other answers as well, and as a general git guideline.