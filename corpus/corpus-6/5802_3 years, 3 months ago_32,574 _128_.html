Assuming I have this pseudo-code:Functions executeStepX should be executed if and only if the previous succeed.\nIn any case, the executeThisFunctionInAnyCase function should be called at the end.\nI\'m a newbie in programming, so sorry for the very basic question: is there a way (in C/C++ for example) to avoid that long if chain producing that sort of "pyramid of code", at the expense of the code legibility?I know that if we could skip the executeThisFunctionInAnyCase function call, the code could be simplified as:But the constraint is the executeThisFunctionInAnyCase function call.\nCould the break statement be used in some way?You can use an && (logic AND):this will satisfy both of your requirements:Just use an additional function to get your second version to work:Using either deeply nested ifs (your first variant) or the desire to break out of "part of a function" usually means you do need an extra function.Old school C programmers use goto in this case. It is the one usage of goto that\'s actually encouraged by the Linux styleguide, it\'s called the centralized function exit:Some people work around using goto by wrapping the body into a loop and breaking from it, but effectively both approaches do the same thing. The goto approach is better if you need some other cleanup only if executeStepA() was successfull:With the loop approach you would end up with two levels of loops in that case.This is a common situation and there are many common ways to deal with it.  Here\'s my attempt at a canonical answer.  Please comment if I missed anything and I\'ll keep this post up to date.What you are discussing is known as the arrow anti-pattern.  It is called an arrow because the chain of nested ifs form code blocks that expand farther and farther to the right and then back to the left, forming a visual arrow that "points" to the right side of the code editor pane.  Some common ways of avoiding the Arrow are discussed here.  The most common method is to use a guard pattern, in which the code handles the exception flows first and then handles the basic flow, e.g. instead of... you\'d use....When there is a long series of guards this flattens the code considerably as all the guards appear all the way to the left and your ifs are not nested.  In addition, you are visually pairing the logic condition with its associated error, which makes it far easier to tell what is going on:Arrow:Guard:This is objectively and quantifiably easier to read becauseThe problem with the guard pattern is that it relies on what is called "opportunistic return" or "opportunistic exit."  In other words, it breaks the pattern that each and every function should have exactly one point of exit.  This is a problem for two reasons:Below I\'ve provided some options for working around this limitation either by using language features or by avoiding the problem altogether.Unfortunately, as a c++ developer, you can\'t do this.  But this is the number one answer for languages that contain a finally keyword, since this is exactly what it is for.You can avoid the problem by breaking the code into two functions.  This solution has the benefit of working for any language, and additionally it can reduce cyclomatic complexity, which is a proven way to reduce your defect rate, and improves the specificity of any automated unit tests.  Here\'s an example:Another common trick I see is using while(true) and break, as shown in the other answers.  While this is less "honest" than using goto, it is less prone to being messed up when refactoring, as it clearly marks the boundaries of logic scope.  A naive coder who cuts and pastes your labels or your goto statements can cause major problems!  (And frankly the pattern is so common now I think it clearly communicates the intent, and is therefore not "dishonest" at all).There are other variants of this options.  For example, one could use switch instead of while.  Any language construct with a break keyword would probably work.One other approach leverages the object life cycle.  Use a context object to carry around your parameters (something which our naive example suspiciously lacks) and dispose of it when you\'re done.Note: Be sure you understand the object life cycle of your language of choice.  You need some sort of deterministic garbage collection for this to work, i.e. you have to know when the destructor will be called.  In some languages you will need to use Dispose instead of a destructor.If you\'re going to use an object-oriented approach, may as well do it right.  This option uses a class to "wrap" the resources that require cleanup, as well as its other operations.  Again, be sure you understand your object life cycle.Another technique is to take advantage of short-circuit evaluation.This solution takes advantage of the way the && operator works.  When the left hand side of && evaluates to false, the right hand side is never evaluated.This trick is most useful when compact code is required and when the code is not likely to see much maintenance, e.g you are implementing a well-known algorithm.  For more general coding the structure of this code is too brittle; even a minor change to the logic could trigger a total rewrite.Just doIt\'s that simple.Due to three edits that each has fundamentally changed the question (four if one counts the revision back to version #1), I include the code example I\'m answering to:There is actually a way to defer actions in C++: making use of an object\'s destructor.Assuming that you have access to C++11:And then using that utility:There\'s a nice technique which doesn\'t need an additional wrapper function with the return statements (the method prescribed by Itjax). It makes use of a do while(0) pseudo-loop. The while (0) ensures that it is actually not a loop but executed only once. However, the loop syntax allows the use of the break statement. You could also do this:This way you have a minimal linear growth size, +1 line per call, and it\'s easily maintenable.EDIT: (Thanks @Unda) Not a big fan because you loose visibility IMO :Would this work? I think this is equivalent with your code.Assuming the desired code is as I currently see it:I would say that the correct approach, in that it\'s the simplest to read and easiest to maintain, would have fewer levels of indentation, which is (currently) the stated purpose of the question.This avoids any need for gotos, exceptions, dummy while loops, or other difficult constructs and simply gets on with the simple job at hand.Could break statement be used in some way?Maybe not the best solution but you can put your statements in a do ..  while (0) loop and use break statements instead of  return.You could put all the if conditions, formatted as you want it in a function of their own, the on return execute the executeThisFunctionInAnyCase() function.From the base example in the OP, the condition testing and execution can be split off as such;And then called as such;If C++11 lambdas are available (there was no C++11 tag in the OP, but they may still be an option), then we can forgo the seperate function and wrap this up into a lambda.If you dislike goto and dislike do { } while (0); loops and like to use C++ you can also use a temporary lambda to have the same effect.The chains of IF/ELSE in your code is not the language issue, but the design of your program. If you\'re able to re-factor  or re-write your program I\'d like to suggest that you look in Design Patterns (http://sourcemaking.com/design_patterns) to find a better solution.Usually, when you see a lot of IF\'s & else\'s in your code , it is an opportunity to implement the Strategy Design Pattern (http://sourcemaking.com/design_patterns/strategy/c-sharp-dot-net) or maybe a combination of other patterns.I\'m sure there\'re alternatives to write a long list of if/else , but I doubt they will change anything except that the chain will look pretty to you (However, the beauty is in the eye of the beholder still applies to code too:-) ) . You should be concerned about things like (in 6 months when I have a new condition and I don\'t remember anything about this code , will I be able to add it easily? Or what if the chain changes, how quickly and error-free will I be implement it) You just do this..99 times of 100, this is the only way to do it.Never, ever, ever try to do something "tricky" in computer code.By the way, I\'m pretty sure the following is the actual solution you had in mind...The continue statement is critical in algorithmic programming. (Much as, the goto statement is critical in algorithmic programming.)In many programming languages you can do this:(Note first of all: naked blocks like that example are a critical and important part of writing beautiful code, particularly if you are dealing with "algorithmic" programming.)Again, that\'s exactly what you had in your head, right? And that\'s the beautiful way to write it, so you have good instincts.However, tragically, in the current version of objective-c (Aside - I don\'t know about Swift, sorry) there is a risible feature where it checks if the enclosing block is a loop.So don\'t forget that ..just means "do this block once".ie, there is utterly no difference between writing do{}while(false); and simply writing {} .This now works perfectly as you wanted...here\'s the output...So, it\'s possible that\'s how you see the algorithm in your head. You should always try to write what\'s in your head. ( Particularly if you are not sober, because that\'s when the pretty comes out! :) )In "algorithmic" projects where this happens a lot, in objective-c, we always have a  macro like...... so then you can do this ...There are two points:a, even though it\'s stupid that objective-c checks the type of block a continue statement is in, it\'s troubling to "fight that".  So it\'s a tough decision.b, there\'s the question should you indent, in the example, that block? I lose sleep over questions like that, so I can\'t advise.Hope it helps.Have your execute functions throw an exception if they fail instead of returning false. Then your calling code could look like this:Of course I\'m assuming that in your original example the execution step would only return false in the case of an error occuring inside the step?A lot of good answers already, but most of them seem to tradeoff on some (admittedly very little) of the flexibility. A common approach which doesn\'t require this tradeoff is adding a status/keep-going variable. The price is, of course, one extra value to keep track of:In C++ (the question is tagged both C and C++), if you can\'t change the functions to use exceptions, you still can use the exception mechanism if you write a little helper function likeThen your code could read as follows:If you\'re into fancy syntax, you could instead make it work via explicit cast:Then you can write your code asIf your code is as simple as your example and your language supports short-circuit evaluations, you could try this:If you are passing arguments to your functions and getting back other results so that your code cannot be written in the previous fashion, many of the other answers would be better suited to the problem.For C++11 and beyond, a nice approach might be to implement a scope exit system similar to D\'s scope(exit) mechanism.One possible way to implement it is using C++11 lambdas and some helper macros:This will allow you to return early from the function and ensure whatever cleanup code you define is always executed upon scope exit:The macros are really just decoration. MakeScopeExit() can be used directly.Assuming you don\'t need individual condition variables, inverting the tests and using the else-falthrough as the "ok" path would allow you do get a more vertical set of if/else statements:Omitting the failed variable makes the code a bit too obscure IMO.Declaring the variables inside is fine, no worry about = vs ==.This is obscure, but compact:This looks like a state machine, which is handy because you can easily implement it with a state-pattern.In Java it would look something like this:An implementation would work as follows:And so on. Then you can substitute the big if condition with:As Rommik mentioned, you could apply a design pattern for this, but I would use the Decorator pattern rather than Strategy since you are wanting to chain calls.  If the code is simple, then I would go with one of the nicely structured answers to prevent nesting.  However, if it is complex or requires dynamic chaining, then the Decorator pattern is a good choice.  Here is a yUML class diagram:Here is a sample LinqPad C# program:The best book to read on design patterns, IMHO, is Head First Design Patterns.Why is nobody giving the simplest solution ? :DIf all your functions have the same signature then you can do it this way (for C language):For a clean C++ solution, you should create an interface class that contains an  execute method and wraps your steps in objects.\nThen, the solution above will look like this:Several answers hinted at a pattern that I saw and used many times, especially in network programming. In network stacks there is often a long sequence of requests, any of which can fail and will stop the process. The common pattern was to use do { } while (false);I used a macro for the while(false) to make it do { } once; The common pattern was:This pattern was relatively easy to read, and allowed objects to be used that would properly destruct and also avoided multiple returns making stepping and debugging a bit easier.It\'s seems like you want to do all your call from a single block. \nAs other have proposed it, you should used either a while loop and leave using break or a new function that you can leave with return (may be cleaner).I personally banish goto, even for function exit. They are harder to spot when debugging. An elegant alternative that should work for your workflow is to build a function array and iterate on this one.an interesting way is to work with exceptions.If you write such code you are going somehow in the wrong direction. I wont see it as "the problem" to have such code, but to have such a messy "architecture".Tip: discuss those cases with a seasoned developer which you trust ;-)Another approach - do - while loop, even though it was mentioned before there was no example of it which would show how it looks like:(Well there\'s already an answer with while loop but do - while loop does not redundantly check for true (at the start) but instead at the end xD (this can be skipped, though)).To improve on Mathieu\'s C++11 answer and avoid the runtime cost incurred through the use of std::function, I would suggest to use the followingThis simple template class will accept any functor that can be called without any parameters, and does so without any dynamic memory allocations and therefore better conforms to C++\'s goal of abstraction without unnecessary overhead. The additional function template is there to simplify use by template parameter deduction (which is not available for class template parameters)Usage example:Just as Mathieu\'s answer this solution is fully exception safe, and executeThisFunctionInAnyCase will be called in all cases. Should executeThisFunctionInAnyCase itself throw, destructors are implicitly marked noexceptand therefore a call to std::terminate would be issued instead of causing an exception to be thrown during stack unwinding.Because you also have [...block of code...] between executions, I guess you have memory allocation or object initializations. In this way you have to care about cleaning all you already initialized at exit, and also clean it if you will meet problem and any of functions will return false.In this case, best what I had in my experience (when I worked with CryptoAPI) was creating small classes, in constructor you initialize your data, in destructor you uninitialize it. Each next function class have to be child of previous function class. If something went wrong - throw exception.And then in your code you just need to call:I guess it is best solution if every call of ConditionX initialize something, allocs memory and etc. Best to be sure everything will be cleaned.