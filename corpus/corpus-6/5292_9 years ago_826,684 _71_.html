I am writing a client-side Swing application (graphical font designer) on Java 5. Recently, I am running into java.lang.OutOfMemoryError: Java heap space error because I am not being conservative on memory usage. The user can open unlimited number of files, and the program keeps the opened objects in the memory. After a quick research I found Ergonomics in the 5.0 Java Virtual Machine and others saying on Windows machine the JVM defaults max heap size as 64MB.Given this situation, how should I deal with this constraint?I could increase the max heap size using command line option to java, but that would require figuring out available RAM and writing some launching program or script. Besides, increasing to some finite max does not ultimately get rid of the issue.I could rewrite some of my code to persist objects to file system frequently (using database is the same thing) to free up the memory. It could work, but it\'s probably a lot work too.If you could point me to details of above ideas or some alternatives like automatic virtual memory, extending heap size dynamically, that will be great.Ultimately you always have a finite max of heap to use no matter what platform you are running on. In Windows 32 bit this is around 2gb (not specifically heap but total amount of memory per process). It just happens that Java chooses to make the default smaller (presumably so that the programmer can\'t create programs that have runaway memory allocation without running into this problem and having to examine exactly what they are doing).So this given there are several approaches you could take to either determine what amount of memory you need or to reduce the amount of memory you are using. One common mistake with garbage collected languages such as Java or C# is to keep around references to objects that you no longer are using, or allocating many objects when you could reuse them instead. As long as objects have a reference to them they will continue to use heap space as the garbage collector will not delete them.In this case you can use a Java memory profiler to determine what methods in your program are allocating large number of objects and then determine if there is a way to make sure they are no longer referenced, or to not allocate them in the first place. One option which I have used in the past is "JMP" http://www.khelekore.org/jmp/.If you determine that you are allocating these objects for a reason and you need to keep around references (depending on what you are doing this might be the case), you will just need to increase the max heap size when you start the program. However, once you do the memory profiling and understand how your objects are getting allocated you should have a better idea about how much memory you need. In general if you can\'t guarantee that your program will run in some finite amount of memory (perhaps depending on input size) you will always run into this problem. Only after exhausting all of this will you need to look into caching objects out to disk etc. At this point you should have a very good reason to say "I need Xgb of memory" for something and you can\'t work around it by improving your algorithms or memory allocation patterns. Generally this will only usually be the case for algorithms operating on large datasets (like a database or some scientific analysis program) and then techniques like caching and memory mapped IO become useful.Run Java with the command-line option -Xmx, which sets the maximum size of the heap.See here for details..You could specify per project how much heap space your project wantsFollowing is for Eclipse Helios/Juno/Kepler:Right mouse click onthen add thisBig caveat ---- at my office, we were finding that (on some windows machines) we could not allocate more than 512m for Java heap. This turned out to be due to the Kaspersky anti-virus product installed on some of those machines. After uninstalling that AV product, we found we could allocate at least 1.6gb,   i.e,   -Xmx1600m (m is mandatory other wise it will lead to another error "Too small initial heap")   works.No idea if this happens with other AV products but presumably this is happening because the AV program is reserving a small block of memory in every address space, thereby preventing a single really large allocation. Increasing the heap size is not a "fix" it is a "plaster", 100% temporary. It will crash again in somewhere else. To avoid these issues, write high performance code.VM argument worked for me in eclipse. If you are using eclipse version 3.4, do the followinggo to Run --> Run Configurations --> then select the project under maven build --> then select the tab "JRE" --> then enter -Xmx1024m.Alternatively you could do Run --> Run Configurations --> select the "JRE" tab --> then enter -Xmx1024mThis should increase the memory heap for all the builds/projects. The above memory size is 1 GB. You can optimize the way you want.Yes, with -Xmx you can configure more memory for you JVM. \nTo be sure that you don\'t leak or waste memory. Take a heap dump and use the Eclipse Memory Analyzer to analyze your memory consumption. I would like to add recommendations from oracle trouble shooting articleException in thread thread_name: java.lang.OutOfMemoryError: Java heap spaceThe detail message Java heap space indicates object could not be allocated in the Java heap. This error does not necessarily imply a memory leakPossible causes:Simple configuration issue, where the specified heap size is insufficient for the application.Application is unintentionally holding references to objects, and this prevents the objects from being garbage collected.Excessive use of finalizers. One other potential source of this error arises with applications that make excessive use of finalizers. If a class has a finalize method, then objects of that type do not have their space reclaimed at garbage collection timeAfter garbage collection, the objects are queued for finalization, which occurs at a later time.  finalizers are executed by a daemon thread that services the finalization queue. If the finalizer thread cannot keep up with the finalization queue, then the Java heap could fill up and this type of OutOfMemoryError exception would be thrown. One scenario that can cause this situation is when an application creates high-priority threads that cause the finalization queue to increase at a rate that is faster than the rate at which the finalizer thread is servicing that queue.If you need to monitor your memory usage at runtime, the java.lang.management package offers MBeans that can be used to monitor the memory pools in your VM (eg, eden space, tenured generation etc), and also garbage collection behaviour.The free heap space reported by these MBeans will vary greatly depending on GC behaviour, particularly if your application generates a lot of objects which are later GC-ed. One possible approach is to monitor the free heap space after each full-GC, which you may be able to use to make a decision on freeing up memory by persisting objects.Ultimately, your best bet is to limit your memory retention as far as possible whilst performance remains acceptable. As a previous comment noted, memory is always limited, but your app should have a strategy for dealing with memory exhaustion. I have faced same problem of java heap size.\nI have two solutions if you are using java 5(1.5).1st:-just install jdk1.6 and go to the preferences of eclipse and set the jre path of jav1 1.6 as you have installed.2nd:-Check your VM argument and let it be whatever it is.\njust add one line below of all the arguments present in VM arguments as \n-Xms512m  -Xmx512m -XX:MaxPermSize=...m(192m).I think it will work...Note that if you need this in a deployment situation, consider using Java WebStart (with an "ondisk" version, not the network one - possible in Java 6u10 and later) as it allows you to specify the various arguments to the JVM in a cross platform way.Otherwise you will need a operating system specific launcher which sets the arguments you need.I read somewhere else that you can try - catch java.lang.OutOfMemoryError and on the catch block, you can free all resources that you know might use alot of memory, close connections and so forth, then do a System.gc() then re-try whatever you were going to do.Another way is this although, i don\'t know whether this would work, but I am currently testing whether it will work on my application.The Idea is to do Garbage collection by calling System.gc() which is known to increase free memory. You can keep checking this after a memory gobbling code executes.Easy way to solve OutOfMemoryError in java is to increase the maximum heap size by using JVM options -Xmx512M, this will immediately solve your OutOfMemoryError. This is my preferred solution when I get OutOfMemoryError in Eclipse, Maven or ANT while building project because based upon size of project you can easily ran out of Memory.Here is an example of increasing maximum heap size of JVM, Also its better to keep -Xmx to -Xms ration either 1:1 or 1:1.5 if you are setting heap size in your java application.export JVM_ARGS="-Xms1024m -Xmx1024m"Reference LinkFollow below steps:Open catalina.sh from tomcat/bin.Chnage JAVA_OPTS to Restart your tomcatIf you keep on allocating & keeping references to object, you will fill up any ammount of memory you have.One option is to do a transparent file close & open when they switch tabs (you only keep a pointer to the file, and when the user switches tab, you close & clean all the objects... it\'ll make the file change slower... but...), and maybe keep only 3 or 4 files on memory.Other thing you should do is, when the user opens a file, load it, and intercept any OutOfMemoryError, then (as it is not possible to open the file) close that file, clean its objects and warn the user that he should close unused files.Your idea of dynamically extending virtual memory doesn\'t solve the issue, for the machine is limited on resources, so you should be carefull & handle memory issues (or at least, be carefull with them).A couple of hints i\'ve seen with memory leaks is:--> Keep on mind that if you put something into a collection and afterwards forget about it, you still have a strong reference to it, so nullify the collection, clean it or do something with it... if not you will find a memory leak difficult to find.--> Maybe, using collections with weak references (weakhashmap...) can help with memory issues, but you must be carefull with it, for you might find that the object you look for has been collected.--> Another idea i\'ve found is to develope a persistent collection that stored on database objects least used and transparently loaded. This would probably be the best approach... Regarding to netbeans, you could set max heap size to solve the problem. Firstly, go to \'Run\', then --> \'Set Project Configuration\' --> \'Customise\' --> \'run\' of its popped up window --> \'VM Option\' --> fill in \'-Xms2048m -Xmx2048m\'.If this issue is happening in Wildfly 8 and JDK1.8,then we need to specify MaxMetaSpace settings instead of PermGen settings.For example we need to add below configuration in setenv.sh file of wildfly.\nJAVA_OPTS="$JAVA_OPTS -XX:MaxMetaspaceSize=256M"For more information, please check Wildfly Heap IssueFor exampl: On linux Platform for production mode preferable settings. After downloading and configuring server with this way http://www.ehowstuff.com/how-to-install-and-setup-apache-tomcat-8-on-centos-7-1-rhel-7/ 1.create setenv.sh file on folder /opt/tomcat/bin/2.Open and write this params for setting preferable mode.3.service tomcat restart