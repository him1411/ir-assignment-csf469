The question is directed at people who have thought about code style in the context of the upcoming ECMAScript 6 (Harmony) and who have already worked with the language.With () => {} and function () {} we are getting two very similar ways to write functions in ES6. In other languages lambda functions often distinguish themselves by being anonymous, but in ECMAScript any function can be anonymous. Each of the two types have unique usage domains (namely when this needs to either be bound explicitly or explicitly not be bound). Between those domains there is a vast number of cases where either notation will do.Arrow functions in ES6 have at least two limitations:These two limitations aside, arrow functions could theoretically replace regular functions almost anywhere. What is the right approach using them in practice? Should arrow functions be used e.g.:What I am looking for is a guideline to selecting the appropriate function notation in the future version of ECMAScript. The guideline will need to be clear, so that it can be taught to developers in a team, and to be consistent so that it does not require constant refactoring back and forth from one function notation to another.A while ago our team migrated all its code (a mid-sized AngularJS app) to JavaScript compiled using Traceur Babel. I\'m now using the following rule of thumb for functions in ES6 and beyond:Why use arrow functions almost everywhere?Why always use regular functions on the global scope or module scope?\nObject constructorsAttempting to instantiate an arrow function throws an exception:One key advantage of functions over arrow functions is therefore that functions double as object constructors:However, the functionally identical2 ES Harmony draft class definition is almost as compact:I expect that use of the former notation will eventually be discouraged. The object constructor notation may still be used by some for simple anonymous object factories where objects are programmatically generated, but not for much else.Where an object constructor is needed one should consider converting the function to a class as shown above. The syntax works with anonymous functions/classes as well.\nReadability of arrow functionsThe probably best argument for sticking to regular functions - scope safety be damned - would be that arrow functions are less readable than regular functions. If your code is not functional in the first place, then arrow functions may not seem necessary, and when arrow functions are not used consistently they look ugly.ECMAScript has changed quite a bit since ECMAScript 5.1 gave us the functional Array.forEach, Array.map and all of these functional programming features that have us use functions where for-loops would have been used before. Asynchronous JavaScript has taken off quite a bit. ES6 will also ship a Promise object, which means even more anonymous functions. There is no going back for functional programming. In functional JavaScript, arrow functions are preferable over regular functions.Take for instance this (particularly confusing) piece of code3:The same piece of code with regular functions:While any one of the arrow functions can be replaced by a standard function, there would be very little to gain from doing so. Which version is more readable? I would say the first one. I think the question whether to use arrow functions or regular functions will become less relevant over time. Most functions will either become class methods, which make away with the function keyword, or they will become classes. Functions will remain in use for patching classes through the Object.prototype. In the mean time I suggest reserving the function keyword for anything that should really be a class method or a class.NotesAccording to the proposal, arrows aimed "to address and resolve several common pain points of traditional Function Expression." They intended to improve matters by binding this lexically and offering terse syntax.However,Therefore, arrow functions create opportunities for confusion and errors, and should be excluded from a JavaScript programmer\'s vocabulary, replaced with function exclusively.Regarding lexical thisthis is problematic:Arrow functions intend to fix the problem where we need to access a property of this inside a callback. There are already several ways to do that: One could assign this to a variable, use bind, or use the 3rd argument available on the Array aggregate methods. Yet arrows seem to be the simplest workaround, so the method could be refactored like this:However, consider if the code used a library like jQuery, whose methods bind this specially. Now, there are two this values to deal with:We must use function in order for each to bind this dynamically. We can\'t use an arrow function here.Dealing with multiple this values can also be confusing, because it\'s hard to know which this an author was talking about:Did the author actually intend to call Book.prototype.reformat? Or did he forget to bind this, and intend to call Reader.prototype.reformat? If we change the handler to an arrow function, we will similarly wonder if the author wanted the dynamic this, yet chose an arrow because it fit on one line:One may pose: "Is it exceptional that arrows could sometimes be the wrong function to use? Perhaps if we only rarely need dynamic this values, then it would still be okay to use arrows most of the time."But ask yourself this: "Would it be \'worth it\' to debug code and find that the result of an error was brought upon by an \'edge case?\'" I\'d prefer to avoid trouble not just most of the time, but 100% of the time.There is a better way: Always use function (so this can always be dynamically bound), and always reference this via a variable. Variables are lexical and assume many names. Assigning this to a variable will make your intentions clear:Furthermore, always assigning this to a variable (even when there is a single this or no other functions) ensures one\'s intentions remain clear even after the code is changed.Also, dynamic this is hardly exceptional. jQuery is used on over 50 million websites (as of this writing in February 2016). Here are other APIs binding this dynamically:(Stats via http://trends.builtwith.com/javascript/jQuery and https://www.npmjs.com.)You are likely to require dynamic this bindings already.A lexical this is sometimes expected, but sometimes not; just as a dynamic this is sometimes expected, but sometimes not. Thankfully, there is a better way, which always produces and communicates the expected binding.Regarding terse syntaxArrow functions succeeded in providing a "shorter syntactical form" for functions. But will these shorter functions make you more successful?Is x => x * x "easier to read" than function (x) { return x * x; }? Maybe it is, because it\'s more likely to produce a single, short line of code. Accoring to Dyson\'s The influence of reading speed and line length on the effectiveness of reading from screen,A medium line length (55 characters per line) appears to support effective reading at normal and fast speeds. This produced the highest level of comprehension . . .Similar justifications are made for the conditional (ternary) operator, and for single-line if statements.However, are you really writing the simple mathematical functions advertised in the proposal? My domains are not mathematical, so my subroutines are rarely so elegant. Rather, I commonly see arrow functions break a column limit, and wrap to another line due to the editor or style guide, which nullifies "readability" by Dyson\'s definition.One might pose, "How about just using the short version for short functions, when possible?" But now a stylistic rule contradicts a language constraint: "Try to use the shortest function notation possible, keeping in mind that sometimes only the longest notation will bind this as expected." Such conflation makes arrows particularly prone to misuse.There are numerous issues with arrow function syntax:Both of these functions are syntactically valid. But doSomethingElse(x); is not in the body of b, it is just a poorly-indented, top-level statement.When expanding to the block form, there is no longer an implicit return, which one could forget to restore. But the expression may only have been intended to produce a side-effect, so who knows if an explicit return will be necessary going forward?What may be intended as a rest parameter can be parsed as the spread operator:Assignment can be confused with default arguments:Blocks look like objects:What does this mean?Did the author intend to create a no-op, or a function that returns an empty object? (With this in mind, should we ever place { after =>? Should we restrict ourselves to the expression syntax only? That would further reduce arrows\' frequency.)=> looks like <= and >=:To invoke an arrow function expression immediately, one must place () on the outside, yet placing () on the inside is valid and could be intentional.Although, if one writes (() => doSomething()()); with the intention of writing an immediately-invoked function expression, simply nothing will happen.It\'s hard to argue that arrow functions are "more understandable" with all the above cases in mind. One could learn all the special rules required to utilize this syntax. Is it really worth it?The syntax of function is unexceptionally generalized. To use function exclusively means the language itself prevents one from writing confusing code. To write procedures that should be syntactically understood in all cases, I choose function.Regarding a guidelineYou request a guideline that needs to be "clear" and "consistent." Using arrow functions will eventually result in syntactically-valid, logically-invalid code, with both function forms intertwined, meaningfully and arbitrarily. Therefore, I offer the following:Arrow functions were created to simplify function scope and solving the this keyword by making it more simpler. They utilize the => syntax, which looks like an arrow.Note: It does not replace the existing functions. If you replace every function syntax with arrow functions, its not going to work in all cases.Let\'s have a look at the existing ES5 syntax, If the this keyword were inside an object\xe2\x80\x99s method (a function that belongs to an object), what would it refer to?The above snippet would refer to an object and print out the name "RajiniKanth". Let\'s explore the below snippet and see what would this point out here.Now what about if the this keyword were inside of method\xe2\x80\x99s function? Here this would refer to window object than the inner function as its fallen out of scope. Because this, always references the owner of the function it is in, for this case\xe2\x80\x8a\xe2\x80\x94\xe2\x80\x8asince it is now out of scope\xe2\x80\x8a\xe2\x80\x94\xe2\x80\x8athe window/global object.When it is inside of an object\xe2\x80\x99s method\xe2\x80\x8a\xe2\x80\x94\xe2\x80\x8athe function\xe2\x80\x99s owner is the object. Thus the this keyword is bound to the object. Yet when it is inside of a function, either stand alone or within another method, it will always refer to the window/global object.There are ways to solve this problem in our ES5 itself, let us look into that before diving into ES6 arrow functions on how solve it.Typically you would, create a variable outside of the method\xe2\x80\x99s inner function. Now the \xe2\x80\x98forEach\xe2\x80\x99 method gains access to this and thus the object\xe2\x80\x99s properties and their values.using bind to attach the this keyword that refers to the method to the method\xe2\x80\x99s inner function.Now with ES6 arrow function, we can deal with lexical scoping issue in a simpler way.Arrow functions are more like function statements, except that they bind the this to parent scope. If the arrow function is in top scope, this argument will refer to window/global scope, while an arrow function inside a regular function will have its this argument the same as its outer function.With arrow functions this is bound to the enclosing scope at creation time and cannot be changed. The new operator, bind, call, and apply have no effect on this.In the above example, we lost the control of this. We can solve the above example by using a variable reference of this or using bind. With ES6, it becomes easier in managing the this as its bound to lexical scoping.Inside an object literal.Actor.showMovies is defined with an arrow function, but on invocation it alerts undefined because this.name is undefined as the context remains to window. It happens because the arrow function binds the context lexically with the window object... i.e outer scope. Executing this.name is equivalent to window.name, which is undefined.Object prototypeThe same rule applies when defining methods on a prototype object. Instead of using an arrow function for defining sayCatName method, which brings an incorrect context window:Invoking constructorsthis in a construction invocation is the newly created object. When executing new Fn(), the context of the constructor Fn is a new object: this instanceof Fn === true. this is setup from the enclosing context, i.e the outer scope which makes it not assigned to newly created object.Callback with dynamic contextArrow function binds the context statically on declaration and is not possible to make it dynamic. Attaching event listeners to DOM elements is a common task in client side programming. An event triggers the handler function with this as the target element.this is window in an arrow function that is defined in the global context. When a click event happens, browser tries to invoke the handler function with button context, but arrow function does not change its pre-defined context. this.innerHTML is equivalent to window.innerHTML and has no sense.You have to apply a function expression, which allows to change this depending on the target element:When user clicks the button, this in the handler function is button. Thus this.innerHTML = \'Clicked button\' modifies correctly the button text to reflect clicked status.References:\nhttps://rainsoft.io/when-not-to-use-arrow-functions-in-javascript/I prefer to use arrow functions at all times where access to local this is not needed, because arrow function do not bind their own this, arguments, super, or new.target.In addition to the great answers so far, I\'d like to present a very different reason why arrow functions are in a certain sense fundamentally better than "ordinary" JavaScript functions. For the sake of discussion, let\'s temporarily assume we use a type checker like TypeScript or Facebook\'s "Flow". Consider the following toy module, which is valid ECMAScript 6 code plus Flow type annotations: (I\'ll include the untyped code, which would realistically result from Babel, at the end of this answer, so it can actually be run.)Now see what happens when we use the class C from a different module, like this: As you can see, the type checker failed here: f2 was supposed to return a number, but it returned a string!Worse, it seems that no conceivable type checker can handle ordinary (non-arrow) JavaScript functions, because the "this" of f2 does not occur in the argument list of f2, so the required type for "this" could not possibly be added as an annotation to f2.Does this problem also affect people who don\'t use type checkers? I think so, because even when we have no static types, we think as if they\'re there. ("The first parameters must be a number, the second one a string" etc.) A hidden "this"-argument which may or may not be used in the function\'s body makes our mental bookkeeping harder.Here is the runnable untyped version, which would be produced by Babel:In a simple way, Another instance: Ans: The console would print 20. The reason being whenever a function is executed its own stack is created, in this example ex function is executed with the new operator so a context will be created, and when inner is executed it JS would create a new stack and execute the inner function a global context though there is a local context.So, if we want inner function to have a local context which is ex then we need to bind the context to inner function.Arrows solve this problem, instead of taking the Global context they take the local context if exists any. In the given example, it will take new ex() as this.So, in all cases where binding is explicit Arrows solve the problem by defaults.