The question is simple: How do you load custom UITableViewCells from Xib files? Doing so allows you to use Interface Builder to design your cells. The answer apparently is not simple due to memory managment issues. This thread mentions the issue and suggests a solution, but is pre NDA-release and lacks code. Here\'s a long thread that discusses the issue without providing a definitive answer. Here\'s some code I\'ve used:To use this code, create MyCell.m/.h, a new subclass of UITableViewCell and add IBOutlets for the components you want. Then create a new "Empty XIB" file. Open the Xib file in IB, add a UITableViewCell object, set its identifier to "MyCellIdentifier", and set its class to MyCell and add your components. Finally, connect the IBOutlets to the components. Note that we did not set the File\'s Owner in IB.Other methods advocate setting the File\'s Owner and warn of memory leaks if the Xib is not loaded via an additional factory class. I tested the above under Instruments/Leaks and saw no memory leaks. So what\'s the canonical way to load cells from Xibs? Do we set File\'s Owner? Do we need a factory? If so, what\'s the code for the factory look like? If there are multiple solutions, let\'s clarify the pros and cons of each of them...Here are two methods which the original author states was recommended by an IB engineer.See the actual post for more details.  I prefer method #2 as it seems simpler.Method #1:Method #2:Update (2014):\nMethod #2 is still valid but there is no documentation for it anymore. It used to be in the official docs but is now removed in favor of storyboards.I posted a working example on Github:\nhttps://github.com/bentford/NibTableCellExampleThe right solution is this:Took Shawn Craver\'s answer and cleaned it up a bit.BBCell.h:BBCell.m:I make all my UITableViewCell\'s subclasses of BBCell, and then replace the standardwith:After iOS 7, this process has been simplified down to (swift 3.0):(Note) This is also achievable by creating the cells in the .xib or .stroyboard files, as prototype cells.\n  If you need to attach a class to them, you can select the cell prototype and add the corresponding class (must be a descendant of UITableViewCell, of course).And later on, dequeued using (swift 3.0):The difference being that this new method not only dequeues the cell, it also creates if non-existant (that means that you don\'t have to do if (cell == nil) shenanigans), and the cell is ready to use just as in the example above.(Warning) tableView.dequeueReusableCell(withIdentifier:for:) has the new behavior, if you call the other one (without indexPath:) you get the old behavior, in which you need to check for nil and instance it yourself, notice the UITableViewCell? return value.And of course, the type of the associated class of the cell is the one you defined in the .xib file for the UITableViewCell subclass, or alternatively, using the other register method.Ideally, your cells have been already configured in terms of appearance and content positioning (like labels and image views) by the time you registered them, and on the cellForRowAtIndexPath method you simply fill them in.And of course, this is all available in ObjC with the same names.I used bentford\'s Method #2:It works, but watch out for connections to File\'s Owner in your custom UITableViewCell .xib file.By passing owner:self in your loadNibNamed statement, you set the UITableViewController as File\'s Owner of your UITableViewCell.If you drag and drop to the header file in IB to set up actions and outlets, it will set them up as File\'s Owner by default. In loadNibNamed:owner:options, Apple\'s code will try to set properties on your UITableViewController, since that\'s the owner. But you don\'t have those properties defined there, so you get an error about being key value coding-compliant:If an Event gets triggered instead, you\'ll get an NSInvalidArgumentException:An easy workaround is to point your Interface Builder connections at the UITableViewCell instead of File\'s Owner:I\'ve decided to post since I don\'t like any of these answers -- things can always be more simple and this is by far the most concise way I\'ve found.1. Build your Xib in Interface Builder as you like it2. In your UIViewController or UITableViewController subclass3. In your MyTableViewCellSubclassIf you\'re using Interface Builder to make cells, check that you\'ve set the Identifier in the Inspector.  Then check that it\'s the same when calling dequeueReusableCellWithIdentifier.I accidentally forgot to set some identifiers in a table-heavy project, and the performance change was like night and day.Loading UITableViewCells from XIBs saves a lot of code, but usually results in horrible scrolling speed (actually, it\'s not the XIB but the excessive use of UIViews that cause this).I suggest you take a look at this: Link referenceHere\'s the class method that I\'ve been using for creating custom cells out of XIBs:Then, in the XIB, I set the class name, and reuse identifier. After that, I can just call that method in my view controller instead of theIt\'s plenty fast enough, and being used in two of my shipping applications. It\'s more reliable than calling [nib objectAtIndex:0], and in my mind at least, more reliable than Stephan Burlot\'s example because you\'re guaranteed to only grab a view out of a XIB that is the right type.Check this - http://eppz.eu/blog/custom-uitableview-cell/ - really convenient way using a tiny class that ends up one line in controller implementation:Correct Solution is thisReloading the NIB is expensive. Better to load it once, then instantiate the objects when you need a cell. Note that you can add UIImageViews etc to the nib, even multiple cells, using this method (Apple\'s "registerNIB" iOS5 allows only one top level object - Bug 10580062\n"iOS5 tableView registerNib: overly restrictive"So my code is below - you read in the NIB once (in initialize like I did or in viewDidload - whatever. From then on, you instantiate the nib into objects then pick the one you need. This is much more efficient than loading the nib over and over.The correct way to do it is to create a UITableViewCell subclass implementation, header, and XIB. In the XIB remove any views and just add a table cell. Set the class as the name of the UITableViewCell subclass. For file owner, make it the UITableViewController subclass class name. Connect the file owner to the cell using the tableViewCell outlet.In the header file:In the implementation file:What I do for this is declare an IBOutlet UITableViewCell *cell in your controller class.\nThen invoke the NSBundle loadNibNamed class method, which will feed the UITableViewCell to the cell declared above.For the xib I will create an empty xib and add the UITableViewCell object in IB where it can be setup as needed. This view is then connected to the cell IBOutlet in the controller class.NSBundle additions loadNibNamed (ADC login)cocoawithlove.com article I sourced the concept from (get the phone numbers sample app)First import your custom cell file #import "CustomCell.h" and then change the delegate method as below mentioned:I dont know if there is a canonical way, but here\'s my method:And use this code:In your example, usingmay break if Apple changes the order of items in the xib.Here is my method for that: Loading Custom UITableViewCells from XIB Files\xe2\x80\xa6 Yet Another MethodThe idea is to create a SampleCell subclass of the UITableViewCell with a IBOutlet UIView *content property and a property for each custom subview you need to configure from the code. Then to create a SampleCell.xib file. In this nib file, change the file owner to SampleCell. Add a content UIView sized to fit your needs. Add and configure all the subviews (label, image views, buttons, etc) you want. Finally, link the content view and the subviews to the file owner.This extension requires Xcode7 beta6Create an Xib file that contains just 1 custom UITableViewCell.Load it.Here is a universal approach for registering cells in UITableView:Explanation:Usage example:Create your own customized class AbcViewCell subclass from UITableViewCell (Make sure your class file name and nib file name are the same)Create this extension class method.    Use it.let cell: AbcViewCell = UITableViewCell.fromNib()