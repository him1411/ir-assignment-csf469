I understand Ruby and Python\'s yield. What does Scala\'s yield do?It is used in sequence comprehensions (like Python\'s list-comprehensions and generators, where you may use yield too).It is applied in combination with for and writes a new element into the resulting sequence.Simple example (from scala-lang)The corresponding expression in F# would beorin Linq.Ruby\'s yield has a different effect.I think the accepted answer is great, but it seems many people have failed to grasp some fundamental points.First, Scala\'s "for comprehensions" are equivalent to Haskell\'s "do" notation, and it is nothing more than a syntactic sugar for composition of multiple monadic operations. As this statement will most likely not help anyone who needs help, let\'s try again... :-)Scala\'s "for comprehensions" is syntactic sugar for composition of multiple operations with map, flatMap and filter. Or foreach. Scala actually translates a for-expression into calls to those methods, so any class providing them, or a subset of them, can be used with for comprehensions.First, let\'s talk about the translations. There are very simple rules:1) Thisis translated into2) Thisis translated into3) Thisis translated on Scala 2.7 intoor, on Scala 2.8, intowith a fallback into the former if method withFilter is not available but filter is. Please see the edit below for more information on this.4) Thisis translated intoWhen you look at very simple for comprehensions, the map/foreach alternatives look, indeed, better. Once you start composing them, though, you can easily get lost in parenthesis and nesting levels. When that happens, for comprehensions are usually much clearer.I\'ll show one simple example, and intentionally ommit any explanation. You can decide which syntax was easier to understand.orEDITScala 2.8 introduced a method called withFilter, whose main difference is that, instead of returning a new, filtered, collection, it filters on-demand. The filter method has its behavior defined based on the strictness of the collection. To understand this better, let\'s take a look at some Scala 2.7 with List (strict) and Stream (non-strict):The difference happens because filter is immediately applied with List, returning a list of odds -- since found is false. Only then foreach is executed, but, by this time, changing found is meaningless, as filter has already executed.In the case of Stream, the condition is not immediatelly applied. Instead, as each element is requested by foreach, filter tests the condition, which enables foreach to influence it through found. Just to make it clear, here is the equivalent for-comprehension code:This caused many problems, because people expected the if to be considered on-demand, instead of being applied to the whole collection beforehand.Scala 2.8 introduced withFilter, which is always non-strict, no matter the strictness of the collection. The following example shows List with both methods on Scala 2.8:This produces the result most people expect, without changing how filter behaves. As a side note, Range was changed from non-strict to strict between Scala 2.7 and Scala 2.8.Yes, as Earwicker said, it\'s pretty much the equivalent to LINQ\'s select and has very little to do with Ruby\'s and Python\'s yield. Basically, where in C# you would writein Scala you have instead It\'s also important to understand that for-comprehensions don\'t just work with sequences, but with any type which defines certain methods, just like LINQ:Unless you get a better answer from a Scala user (which I\'m not), here\'s my understanding.It only appears as part of an expression beginning with for, which states how to generate a new list from an existing list.Something like:So there\'s one output item for each input (although I believe there\'s a way of dropping duplicates).This is quite different from the "imperative continuations" enabled by yield in other languages, where it provides a way to generate a list of any length, from some imperative code with almost any structure.(If you\'re familiar with C#, it\'s closer to LINQ\'s select operator than it is to yield return).The keyword yield in Scala is simply syntactic sugar which can be easily replaced by a map, as Daniel Sobral already explained in detail.On the other hand, yield is absolutely misleading if you are looking for generators (or continuations) similar to those in Python. See this SO thread for more information: What is the preferred way to implement 'yield' in Scala?Consider the following for-comprehensionIt may be helpful to read it out loud as follows"For each integer i, if it is greater than 3, then yield (produce) i and add it to the list A."In terms of mathematical set-builder notation, the above for-comprehension is analogous towhich may be read as"For each integer , if it is greater than , then it is a member of the set ."or alternatively as" is the set of all integers , such that each  is greater than ."These two pieces of code are equivalent.These two pieces of code are also equivalent.Map is as flexible as yield and vice-versa.yield is more flexible than map(), see example belowyield will print result like:  List(5, 6), which is goodwhile map() will return result like:  List(false, false, true, true, true), which probably is not what you intend.