I\'m reading out lots of texts from various RSS feeds and inserting them into my database.Of course, there are several different character encodings used in the feeds, e.g. UTF-8 and ISO-8859-1.Unfortunately, there are sometimes problems with the encodings of the texts. Example:1) The "\xc3\x9f" in "Fu\xc3\x9fball" should look like this in my database: "\xc3\x82\xc5\xb8". If it is a "\xc3\x82\xc5\xb8", it is displayed correctly.2) Sometimes, the "\xc3\x9f" in "Fu\xc3\x9fball" looks like this in my database: "\xc3\x83\xc6\x92\xc3\x82\xc5\xb8". Then it is displayed wrongly, of course.3) In other cases, the "\xc3\x9f" is saved as a "\xc3\x9f" - so without any change. Then it is also displayed wrongly.What can I do to avoid the cases 2 and 3?How can I make everything the same encoding, preferably UTF-8? When must I use utf8_encode(), when must I use utf8_decode() (it\'s clear what the effect is but when must I use the functions?) and when must I do nothing with the input?Can you help me and tell me how to make everything the same encoding? Perhaps with the function mb-detect-encoding()? Can I write a function for this? So my problems are:\n1) How to find out what encoding the text uses\n2) How to convert it to UTF-8 - whatever the old encoding isEDIT:\nWould a function like this work?I\'ve tested it but it doesn\'t work. What\'s wrong with it?If you apply utf8_encode() to an already UTF8 string it will return a garbled UTF8 output.I made a function that addresses all this issues.  It\xc2\xb4s called Encoding::toUTF8().You dont need to know what the encoding of your strings is. It can be Latin1 (iso 8859-1), Windows-1252 or UTF8, or the string can have a mix of them. Encoding::toUTF8() will convert everything to UTF8.I did it because a service was giving me a feed of data all messed up, mixing UTF8 and Latin1 in the same string.Usage:Download:https://github.com/neitanod/forceutf8Update:I\'ve included another function, Encoding::fixUFT8(), which will fix every UTF8 string that looks garbled.  Usage:Examples:will output:Update: I\'ve transformed the function (forceUTF8) into a family of static functions on a class called Encoding.  The new function is Encoding::toUTF8().You first have to detect what encoding has been used. As you\xe2\x80\x99re parsing RSS feeds (probably via HTTP), you should read the encoding from the charset parameter of the Content-Type HTTP header field. If it is not present, read the encoding from the encoding attribute of the XML processing instruction. If that\xe2\x80\x99s missing too, use UTF-8 as defined in the specification.Edit\xc2\xa0\xc2\xa0\xc2\xa0Here is what I probably would do:I\xe2\x80\x99d use cURL to send and fetch the response. That allows you to set specific header fields and fetch the response header as well. After fetching the response, you have to parse the HTTP response and split it into header and body. The header should then contain the Content-Type header field that contains the MIME type and (hopefully) the charset parameter with the encoding/charset too. If not, we\xe2\x80\x99ll analyse the XML PI for the presence of the encoding attribute and get the encoding from there. If that\xe2\x80\x99s also missing, the XML specs define to use UTF-8 as encoding.Detecting the encoding is hard.mb_detect_encoding works by guessing, based on a number of candidates that you pass it. In some encodings, certain byte-sequences are invalid, an therefore it can distinguish between various candidates. Unfortunately, there are a lot of encodings, where the same bytes are valid (but different). In these cases, there is no way to determine the encoding; You can implement your own logic to make guesses in these cases. For example, data coming from a Japanese site might be more likely to have a Japanese encoding.As long as you only deal with Western European languages, the three major encodings to consider are utf-8, iso-8859-1 and cp-1252. Since these are defaults for many platforms, they are also the most likely to be reported wrongly about. Eg. if people use different encodings, they are likely to be frank about it, since else their software would break very often. Therefore, a good strategy is to trust the provider, unless the encoding is reported as one of those three. You should still doublecheck that it is indeed valid, using mb_check_encoding (note that valid is not the same as being - the same input may be valid for many encodings). If it is one of those, you can then use mb_detect_encoding to distinguish between them. Luckily that is fairly deterministic; You just need to use the proper detect-sequence, which is UTF-8,ISO-8859-1,WINDOWS-1252. Once you\'ve detected the encoding you need to convert it to your internal representation (UTF-8 is the only sane choice). The function utf8_encode transforms ISO-8859-1 to UTF-8, so it can only used for that particular input type. For other encodings, use mb_convert_encoding.This cheatsheet lists some common caveats related to UTF-8 handling in PHP:\nhttp://developer.loftdigital.com/blog/php-utf-8-cheatsheetThis function detecting multibyte characters in a string might also prove helpful (source):A really nice way to implement an isUTF8-function can be found on php.net:A little heads up, you said that the "\xc3\x9f" should be displayed as "\xc3\x82\xc5\xb8" in your database.This is probably because you\'re using a database with latin1 character encoding or possibly your php-mysql connection is set wrong, this is, php believes your mysql is set to use utf-8, so it sends data as utf8, but your mysql belives php is sending data encoded as iso-8859-1, so it may once again try to encode your sent data as utf-8, causing this kind of trouble.Take a look at this, may help you: http://php.net/manual/en/function.mysql-set-charset.phpYour encoding looks like you encoded into UTF-8 twice; that is, from some other encoding, into UTF-8, and again into UTF-8. As if you had iso-8859-1, converted from iso-8859-1 to utf-8, and treated the new string as iso-8859-1 for another conversion into UTF-8.Here\'s some pseudocode of what you did:You should try:That is presuming that in the "middle" conversion you used iso-8859-1. If you used windows-1252, then convert into windows-1252 (latin1). The original source encoding is not important; the one you used in flawed, second conversion is.This is my guess at what happened; there\'s very little else you could have done to get four bytes in place of one extended ASCII byte.German language also uses iso-8859-2 and windows-1250 (latin2).You need test the charset on input since responses can come coded with different encodings.\nI force all content been sent into UTF-8 by doing detection and translation using the following function:That routine will turn all PHP variables that come from the remote host into UTF-8.\nOr ignore the value if the encoding could not be detected or converted.\nYou can customize it to your needs.\nJust invoke it before using the variables.It\'s simple: when you get something that\'s not UTF8, you must ENCODE that INTO utf8.So, when you\'re fetching a certain feed that\'s ISO-8859-1 parse it through utf8_encode.However, if you\'re fetching an UTF8 feed, you don\'t need to do anything.Working out the character encoding of RSS feeds seems to be complicated.  Even normal web pages often omit, or lie about, their encoding.So you could try to use the correct way to detect the encoding and then fall back to some form of auto-detection (guessing).I know this is an older question, but I figure a useful answer never hurts. I was having issues with my encoding between a desktop application, SQLite, and GET/POST variables. Some would be in UTF-8, some would be in ASCII, and basically everything would get screwed up when foreign characters got involved.Here is my solution. It scrubs your GET/POST/REQUEST (I omitted cookies, but you could add them if desired) on each page load before processing. It works well in a header. PHP will throw warnings if it can\'t detect the source encoding automatically, so these warnings are suppressed with @\'s.The interesting thing about mb_detect_encoding and mb_convert_encoding is that the order of the encodings you suggest does matter:So you might want to use a specific order when specifying expected encodings. Still, keep in mind that this is not foolproof.I was checking for solutions to encoding since AGES, and this page is probably the conclusion of years of search!\nI tested some of the suggestions you mentioned and here\'s my notes:This is my test string: this is a "wr\xc3\xb2ng wr\xc3\xactten" string b\xc3\xb9t I n\xc3\xa8ed to p\xc3\xb9 \'s\xc3\xb2me\'  special\n  ch\xc3\xa0rs to see th\xc3\xa8m, convert\xc3\xa8d by f\xc3\xb9nct\xc3\xacon!! & that\'s it!I do an INSERT to save this string on a DB in a field that is set as utf8_general_ciCharset of my page is UTF-8If I do an INSERT just like that, in my DB I have some chars probably coming from Mars...\nso I need to convert them into some "sane" UTF-8.\nI tried utf8_encode() but still aliens chars were invading my database...So I tried to use the function forceUTF8 posted on number 8 but on DB the string saved looks like that:this is a "wr\xc3\x83\xc2\xb2ng wr\xc3\x83\xc2\xactten" string b\xc3\x83\xc2\xb9t I n\xc3\x83\xc2\xa8ed to p\xc3\x83\xc2\xb9 \'s\xc3\x83\xc2\xb2me\' special\n  ch\xc3\x83 rs to see th\xc3\x83\xc2\xa8m, convert\xc3\x83\xc2\xa8d by f\xc3\x83\xc2\xb9nct\xc3\x83\xc2\xacon!! & that\'s it!So collecting some more infos on this page and merging them with other infos on other pages I solved my problem with this solution:Now in my database I have my string with correct encoding.NOTE:\nOnly note to take care of is on function mysql_client_encoding!\nYou need to be connected to DB because this function wants a resource ID as parameter.But well, I just do that re-encoding before my INSERT so for me is not a problem.I hope this will help someone like this page helped me!Thanks to everybody!Mauro@harpax that worked for me.  In my case, this is good enough:php.net/mb_detect_encodingori really don\'t know what the results are, but i\'d suggest you just take some of your feeds with different encodings and try if mb_detect_encoding works or not.update\nauto is short for "ASCII,JIS,UTF-8,EUC-JP,SJIS". it returns the detected charset, which you can use to convert the string to utf-8 with iconv.i haven\'t tested it, so no guarantee. and maybe there\'s a simpler way.After sorting out your php scripts, don\'t forget to tell mysql what charset you are passing and would like to recceive.Example: set character set utf8Passing utf8 data to a latin1 table in a latin1 I/O session gives those nasty birdfeets. I see this every other day in oscommerce shops. Back and fourth it might seem right. But phpmyadmin will show the truth. By telling mysql what charset you are passing it will handle the conversion of mysql data for you.How to recover existing scrambled mysql data is another thread to discuss. :)This version is for German language but you can modifiy the $CHARSETS and the $TESTCHARS\nGet encoding from headers and convert it to utf-8.\xc3\x82\xc5\xb8 is Mojibake for \xc3\x9f.  In your database, you may have hexYou should not use any encoding/decoding functions in PHP; instead, you should set up the database and the connection to it correctly.If MySQL is involved, see: Trouble with utf8 characters; what I see is not what I storedI find solution here http://deer.org.ua/2009/10/06/1/I think that @ is bad decision, and make some changes to solution from deer.org.ua;The most voted answer doesn\'t work. Here is mine and hope it helps.When you try to handle multi languages like Japanese and Korean you might get in trouble. mb_convert_encoding with \'auto\' parameter doesn\'t work well. Setting mb_detect_order(\'ASCII,UTF-8,JIS,EUC-JP,SJIS,EUC-KR,UHC\') doesn\'t help since it will detect EUC-* wrongly.I concluded that as long as input strings comes from HTML, it should use \'charset\' in a meta element. I use Simple HTML DOM Parser because it supports invalid HTML.The below snippet extracts title element from a web page. If you would like to convert entire page, then you may want to remove some lines.I had same issue with phpQuery (ISO-8859-1 instead of UTF-8) and this hack helped me:mb_internal_encoding(\'UTF-8\'), phpQuery::newDocumentHTML($html, \'utf-8\'), mbstring.internal_encoding and other manipulations didn\'t take any effect.Try without \'auto\'That is:instead of:More information can be found here: mb_detect_encoding