What are the best workarounds for using a SQL IN clause with instances of java.sql.PreparedStatement, which is not supported for multiple values due to SQL injection attack security issues: One ? placeholder represents one value, rather than a list of values.Consider the following SQL statement:Using preparedStatement.setString( 1, "\'A\', \'B\', \'C\'" ); is essentially a non-working attempt at a workaround of the reasons for using ? in the first place.  What workarounds are available?An analysis of the various options available, and the pros and cons of each is available here.The suggested options are:None of these options are super great, though.Duplicate questions have been answered in these places with equally sane alternatives, still none of them super great:The Right Answer, if you are using JDBC4 and a server that supports x = ANY(y), is to use PreparedStatement.setArray as described here:There doesn\'t seem to be any way to make setArray work with IN-lists, though.Solution for PostgreSQL:orNo simple way AFAIK.\nIf the target is to keep statement cache ratio high (i.e to not create a statement per every parameter count), you may do the following:create a statement with a few (e.g. 10) parameters:... WHERE A IN (?,?,?,?,?,?,?,?,?,?) ...Bind all actuall parameterssetString(1,"foo");\nsetString(2,"bar");Bind the rest as NULLsetNull(3,Types.VARCHAR)\n...\nsetNull(10,Types.VARCHAR)NULL never matches anything, so it gets optimized out by the SQL plan builder.The logic is easy to automate when you pass a List into a DAO function:An unpleasant work-around, but certainly feasible is to use a nested query. Create a temporary table MYVALUES with a column in it. Insert your list of values into the MYVALUES table. Then execute Ugly, but a viable alternative if your list of values is very large.This technique has the added advantage of potentially better query plans from the optimizer (check a page for multiple values, tablescan only once instead once per value, etc) may save on overhead if your database doesn\'t cache prepared statements. Your "INSERTS" would need to be done in batch and the MYVALUES table may need to be tweaked to have minimal locking or other high-overhead protections.I\'ve never tried it, but would .setArray() do what you\'re looking for?Update: Evidently not.  setArray only seems to work with a java.sql.Array that comes from an ARRAY column that you\'ve retrieved from a previous query, or a subquery with an ARRAY column.My workaround is:Now you can use one variable to obtain some values in a table:So, the prepared statement could be:Regards,Javier IbanezIt works for trivial cases, and you can extend it with "automatic generation of the prepared statement" however it is always having its limits.The in() approach can be good enough for some cases, but not rocket proof :)The rocket-proof solution is to pass the arbitrary number of parameters in a separate call (by passing a clob of params, for example), and then have a view (or any other way) to represent them in SQL and use in your where criteria.A brute-force variant is here http://tkyte.blogspot.hu/2006/06/varying-in-lists.html However if you can use PL/SQL, this mess can become pretty neat.Then you can pass arbitrary number of comma separated customer ids in the parameter, and:The trick here is:The view looks like:where aux_in_list.getpayload refers to the original input string.A possible approach would be to pass pl/sql arrays (supported by Oracle only), however you can\'t use those in pure SQL, therefore a conversion step is always needed. The conversion can not be done in SQL, so after all, passing a clob with all parameters in string and converting it witin a view is the most efficient solution.Here\'s how I solved it in my own application. Ideally, you should use a StringBuilder instead of using + for Strings.Using a variable like x above instead of concrete numbers helps a lot if you decide to change the query at a later time.I suppose you could (using basic string manipulation) generate the query string in the PreparedStatement to have a number of ?\'s matching the number of items in your list.  Of course if you\'re doing that you\'re just a step away from generating a giant chained OR in your query, but without having the right number of ? in the query string, I don\'t see how else you can work around this.try using the instr function?thenAdmittedly this is a bit of a dirty hack, but it does reduce the opportunities for sql injection. Works in oracle anyway.Sormula supports SQL IN operator by allowing you to supply a java.util.Collection object as a parameter. It creates a prepared statement with a ? for each of the elements the collection. See Example 4 (SQL in example is a comment to clarify what is created but is not used by Sormula).I came across a number of limitations related to prepared statement:Among the proposed solutions I would choose the one that doesn\'t decrease the query performance and makes the less number of queries. This will be the #4 (batching few queries) from the @Don link or specifying NULL values for unneeded \'?\' marks as proposed by @Vladimir Dyuzhev Here\'s a complete solution in Java to create the prepared statement for you:You could use setArray method as mentioned in this javadoc:Just for completeness: So long as the set of values is not too large, you could also simply string-construct a statement likewhich you could then pass to prepare(), and then use setXXX() in a loop to set all the values. This looks yucky, but many "big" commercial systems routinely do this kind of thing until they hit DB-specific limits, such as 32 KB (I think it is) for statements in Oracle.Of course you need to ensure that the set will never be unreasonably large, or do error trapping in the event that it is.Following Adam\'s idea. Make your prepared statement sort of select my_column from my_table where search_column in (#)\nCreate a String x and fill it with a number of "?,?,?" depending on your list of values\nThen just change the # in the query for your new String x an populateGenerate the query string in the PreparedStatement to have a number of ?\'s matching the number of items in your list.  Here\'s an example:instead of usinguse the Sql Statement as andor use a stored procedure this would be the best solution, since the sql statements will be compiled and stored in DataBase serverThere are different alternative approaches that we can use for IN clause in PreparedStatement.Use NULL in PreparedStatement queries - Optimal performance, works great when you know the limit of IN clause arguments. If there is no limit, then you can execute queries in batch. \nSample code snippet is;You can check more details about these alternative approaches here.For some situations regexp might help. \nHere is an example I\'ve checked on Oracle, and it works. But there is a number of drawbacks with it:After examining various solutions in different forums and not finding a good solution, I feel the below hack I came up with, is the easiest to follow and code:Example: Suppose you have multiple parameters to pass in the \'IN\' clause. Just put a dummy String inside the \'IN\' clause, say, "PARAM" do denote the list of parameters that will be coming in the place of this dummy String.You can collect all the parameters into a single String variable in your Java code. This can be done as follows:You can append all your parameters separated by commas into a single String variable, \'param1\', in our case.After collecting all the parameters into a single String you can just replace the dummy text in your query, i.e., "PARAM" in this case, with the parameter String, i.e., param1. Here is what you need to do:You can now execute your query using the executeQuery() method. Just make sure that you don\'t have the word "PARAM" in your query anywhere. You can use a combination of special characters and alphabets instead of the word "PARAM" in order to make sure that there is no possibility of such a word coming in the query. Hope you got the solution.Note: Though this is not a prepared query, it does the work that I wanted my code to do.Just for completeness and because I did not see anyone else suggest it:Before implementing any of the complicated suggestions above consider if SQL injection is indeed a problem in your scenario.  In many cases the value provided to IN (...) is a list of ids that have been generated in a way that you can be sure that no injection is possible... (e.g. the results of a previous select some_id from some_table where some_condition.)If that is the case you might just concatenate this value and not use the services or the prepared statement for it or use them for other parameters of this query. Spring allows passing java.util.Lists to NamedParameterJdbcTemplate , which automates the generation of (?, ?, ?, ..., ?), as appropriate for the number of arguments.For Oracle, this blog posting discusses the use of oracle.sql.ARRAY (Connection.createArrayOf doesn\'t work with Oracle). For this you have to modify your SQL statement:The oracle table function transforms the passed array into a table like value usable in the IN statement.PreparedStatement doesn\'t provide any good way to deal with SQL IN clause. Per http://www.javaranch.com/journal/200510/Journal200510.jsp#a2 "You can\'t substitute things that are meant to become part of the SQL statement. This is necessary because if the SQL itself can change, the driver can\'t precompile the statement. It also has the nice side effect of preventing SQL injection attacks." I ended up using following approach:My workaround (JavaScript)SearchTerms is the array which contains your input/keys/fields etc