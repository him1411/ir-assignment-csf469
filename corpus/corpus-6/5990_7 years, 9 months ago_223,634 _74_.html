I am using Entity Framework to populate a grid control. Sometimes when I make updates I get the following error:Store update, insert, or delete statement affected an unexpected number of rows (0). Entities may have been modified or deleted since entities were loaded. Refresh ObjectStateManager entries.I can\'t figure out how to reproduce this. But it might have something to do with how close together I make the updates. Has anyone seen this or does anyone know what the error message refers to?Edit: Unfortunately I am no longer at liberty to reproduce the problem I was having here, because I stepped away from this project and don\'t remember if I eventually found a solution, if another developer fixed it, or if I worked around it. Therefore I cannot accept any answers.That\'s a side-effect of a feature called optimistic concurrency.Not 100% sure how to turn it on/off in Entity Framework but basically what it\'s telling you is that between when you grabbed the data out of the database and when you saved your changes someone else has changed the data (Which meant when you went to save it 0 rows actually got updated). In SQL terms, their update query\'s where clause contains the original value of every field in the row, and if 0 rows are affected it knows something\'s gone wrong.The idea behind it is that you won\'t end up overwriting a change that your application didn\'t know has happened - it\'s basically a little safety measure thrown in by .NET on all your updates.If it\'s consistent, odds are it\'s happening within your own logic (EG: You\'re actually updating the data yourself in another method in-between the select and the update), but it could be simply a race condition between two applications.I ran into this and it was caused by the entity\'s ID (key) field not being set.  Thus when the context went to save the data, it could not find an ID = 0.  Be sure to place a break point in your update statement and verify that the entity\'s ID has been set.From Paul Bellora\'s comment I had this exact issue, caused by forgetting to include the hidden ID\n  input in the .cshtml edit pageWow, lots of answers, but I got this error when I did something slightly different that no on else has mentioned. Long story short, if you create a new object and tell EF that its modified using the EntityState.Modified then it will throw this error as it doesn\'t yet exist in the database. Here is my code:Yes, this seems daft, but it arose because the method in question used to have foo passed to it having been created earlier on, now it only has someValue passed to it and creates foo itself.Easy fix, just change EntityState.Modified to EntityState.Added or change that whole line to:I was facing this same scaring error... :) Then I realized that I was forgetting to set a@Html.HiddenFor(model => model.UserProfile.UserId)for the primary key of the object being updated! I tend to forget this simple, but very important thingy!By the way: HiddenFor is for ASP.NET MVC.Check whether you forgot the "DataKeyNames" attribute in the GridView.\nit\'s a must when modifying data within the GridViewhttp://msdn.microsoft.com/en-us/library/system.web.ui.webcontrols.gridview.datakeynames.aspx The issue is caused by either one of two things :-I was having same problem and @webtrifusion\'s answer helped find the solution. My model was using the Bind(Exclude) attribute on the entity\'s ID which was causing the value of the entity\'s ID to be zero on HttpPost.i had the same problem, i figure out that was caused by the RowVersion which was null.\nCheck that your Id and your RowVersion are not null.for more information refer to this tutorial http://www.asp.net/mvc/tutorials/getting-started-with-ef-using-mvc/handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-applicationWhile editing include the id or primary key of the entity as a hidden field in the viewiethat solves the problem.Also if your model includes non-used item include that too and post that to the controllerYou need to explicitly include a BoundField of the primary key. If you don\'t want the user to see the primary key, you have to hide it via css: Where \'hidden\' is a class in css that has it\'s display set to \'none\'. Just make sure table and form both have primary key and edmx updated.i found that any errors during update were usually because of:\n - No primary key in Table \n - No  primary key in Edit view/form (e.g. @Html.HiddenFor(m=>m.Id)I also came across this error. The problem it turned out was caused by a Trigger on the table I was trying to save to. The Trigger used \'INSTEAD OF INSERT\' which means 0 rows ever got inserted to that table, hence the error. Luckily in may case the trigger functionality was incorrect, but I guess it could be a valid operation that should somehow be handled in code. Hope this helps somebody one day.My rowversion was null, so had to add this to the view\nwhich solved my issueI got this same error because part of the PK was a datetime column, and the record being inserted used DateTime.Now as the value for that column.  Entity framework would insert the value with millisecond precision, and then look for the value it just inserted also with millisecond precision.  However SqlServer had rounded the value to second precision, and thus entity framework was unable to find the millisecond precision value.The solution was to truncate the milliseconds from DateTime.Now before inserting.I got that error when I was deleting some rows in the DB (in the loop), and the adding the new ones in the same table.The solutions for me was, to dynamicaly create a new context in each loop iterationI had the same problem.\nIn my case I was trying to update the primary key, which is not allowed.If you are trying to create mapping in your edmx file to a "function Imports", this can result this error. Just clear the fields for insert, update and delete that is located in Mapping Details for a given entity in your edmx, and it should work. \nI hope I made it clear. This will also happen if you are trying to insert into a unique constraint situation, ie if you can only have one type of address per employer and you try to insert a second of that same type with the same employer, you will get the same problem.ORThis could also happen if all of the object properties that were assigned to, they were assigned with the same values as they had before.Well i have this same issue. But this was due to my own mistake.  Actually i was saving an object instead of adding it. So this was the conflict.One way to debug this problem in an Sql Server environment is to use the Sql Profiler included with your copy of SqlServer, or if using the Express version get a copy of Express Profiler for free off from CodePlex by the following the link below:Express ProfilerBy using Sql Profiler you can get access to whatever is being sent by EF to the DB. In my case this amounted to:I copy pasted this into a query window in Sql Server and executed it. Sure enough, although it ran, 0 records were affected by this query hence the error being returned by EF.In my case the problem was caused by the CategoryID. There was no CategoryID identified by the ID EF sent to the database hence 0 records being affected. This was not EF\'s fault though but rather a buggy null coalescing "??" statement up in a View Controller that was sending nonsense down to data tier.I started getting this error after changing from model-first to code-first. I have multiple threads updating a database where some might update the same row. I don\'t know why I didn\'t have a problem using model-first, assume that it uses a different concurrency default.To handle it in one place knowing the conditions under which it might occur, I added the following overload to my DbContext class:Then called SaveChanges(true) wherever applicable.I got this exception and  i set id column as auto increment in my database\'s table and then it working fineI ran into this using Telerik\'s RadGrid.  I had the primary key as a gridbound column that was set to read only.  It would work fine if the column was display="false" but readonly="true" caused the problem.  I solved it by having the gridbound column display=false and adding a separate template column for displayJust had the same problem.I\'m using EF 6, Code First + Migrations. \nThe problem was that our DBA created a constraint on the table that threw the error.None of the above answers quite covered my situation and the solution to it.Code where the error was thrown in MVC5 controller:I received this exception when I was saving an object off an Edit view.  The reason it threw it was because when I went back to save it, I had modified the properties that formed the primary key on the object.  Thus, setting its state to Modified didn\'t make any sense to EF - it was a new entry, not a previously saved one.You can solve this by either A) modifying the save call to Add the object, or B) just don\'t change the primary key on edit.  I did B).When the accepted answer said "it won\'t end up overwriting a change that your application didn\'t know has happened", I was skeptic because my object was newly created. But then it turns out, there was an INSTEAD OF UPDATE, INSERT- TRIGGER attached to the table which was updating a calculated column of the same table.Once I change this to AFTER INSERT, UPDATE, it was working fine.In our case this error was caused by marking entities as modified when none of their properties \'really\' changed. For example when you assign same value to a property, context may see that as an update where database doesn\'t.Basically we ran a script to repopulate one property with concatenated values from other properties. For a lot of records that meant no change, but it flagged them as modified. DB returned different number of updated objects which presumably triggered that exception.We solved it by checking the property value and only assigning new one if different.Got this error when using SaveChanges(false) and then later SaveChanges() on the same context, in a unitofwork where multiple rows were being deleted from two tables (in the context)(SaveChanges(False) was in one of the deletes. Then in the calling function SaveChanges() was being called.... The solution was to remove the unnecessary SaveChanges(false).I\'ll throw this in just in case someone is running into this issue while working in a parallel loop:I changed it to the following:Not sure if this is \'Best Practice\', but it fixed my issue by having each parallel operation use its own context.