I\'m trying to write a shell script that, when run, will set some environment variables that will stay set in the caller\'s shell.in csh/tcsh, orin sh/bash only set it during the script\'s execution.I already know that will run the commands of the script rather than launching a new shell, and that can result in setting the "caller\'s" environment.But here\'s the rub:I want this script to be callable from either bash or csh.  In other words, I want users of either shell to be able to run my script and have their shell\'s environment changed.  So \'source\' won\'t work for me, since a user running csh can\'t source a bash script, and a user running bash can\'t source a csh script.Is there any reasonable solution that doesn\'t involve having to write and maintain TWO versions on the script?Your shell process has a copy of the parent\'s environment and no access to the parent process\'s environment whatsoever. When your shell process terminates any changes you\'ve made to its environment are lost. Sourcing a script file is the most commonly used method for configuring a shell environment, you may just want to bite the bullet and maintain one for each of the two flavors of shell.dot space scriptruns the script under the running shell instead of loading another shell.You\'re not going to be able to modify the caller\'s shell because it\'s in a different process context.  When child processes inherit your shell\'s variables, they\'re\ninheriting copies themselves.One thing you can do is to write a script that emits the correct commands for tcsh\nor sh based how it\'s invoked.  If you\'re script is "setit" then do:andNow either directly or in an alias, you do this from shor this from cshsetit uses $0 to determine its output style.This is reminescent of how people use to get the TERM environment variable set.The advantage here is that setit is just written in whichever shell you like as in:with the symbolic links given above, and the eval of the backquoted expression, this has the desired result.To simplify invocation for csh, tcsh, or similar shells:or for sh, bash, and the like:One nice thing about this is that you only have to maintain the list in one place.\nIn theory you could even stick the list in a file and put cat nvpairfilename between "in" and "do".This is pretty much how login shell terminal settings used to be done:  a script would output statments to be executed in the login shell.  An alias would generally be used to make invocation simple, as in "tset vt100".  As mentioned in another answer, there is also similar functionality in the INN UseNet news server.In my .bash_profile I have :So when I want to disable the proxy, \nthe function(s) run in the login shell and sets the variables\nas expected and wanted. It\'s "kind of" possible through using gdb and setenv(3), although I have a hard time recommending actually doing this. (Additionally, i.e. the most recent ubuntu won\'t actually let you do this without telling the kernel to be more permissive about ptrace, and the same may go for other distros as well).This works â€” it isn\'t what I\'d use, but it \'works\'.  Let\'s create a script teredo to set the environment variable TEREDO_WORMS:It will be interpreted by the Korn shell, exports the environment variable, and then replaces itself with a new interactive shell.Before running this script, we have SHELL set in the environment to the C shell, and the environment variable TEREDO_WORMS is not set:When the script is run, you are in a new shell, another interactive C shell, but the environment variable is set:When you exit from this shell, the original shell takes over:The environment variable is not set in the original shell\'s environment.  If you use exec teredo to run the command, then the original interactive shell is replaced by the Korn shell that sets the environment, and then that in turn is replaced by a new interactive C shell:If you type exit (or Control-D), then your shell exits, probably logging you out of that window, or taking you back to the previous level of shell from where the experiments started.The same mechanism works for Bash or Korn shell.  You may find that the prompt after the exit commands appears in funny places.Note the discussion in the comments.  This is not a solution I would recommend, but it does achieve the stated purpose of a single script to set the environment that works with all shells (that accept the -i option to make an interactive shell).  You could also add "$@" after the option to relay any other arguments, which might then make the shell usable as a general \'set environment and execute command\' tool.  You might want to omit the -i if there are other arguments, leading to:The "${@-\'-i\'}" bit means \'if the argument list contains at least one argument, use the original argument list; otherwise, substitute -i for the non-existent arguments\'.You should use modules, see http://modules.sourceforge.net/EDIT: The modules package has not been updated since 2012 but still works ok for the basics. All the new features, bells and whistles happen in lmod this day (which I like it more): https://www.tacc.utexas.edu/research-development/tacc-projects/lmodAnother workaround that I don\'t see mentioned is to write the variable value to a file.I ran into a very similar issue where I wanted to be able to run the last set test (instead of all my tests).  My first plan was to write one command for setting the env variable TESTCASE, and then have another command that would use this to run the test.  Needless to say that I had the same exact issue as you did.But then I came up with this simple hack:First command ( testset ):Second command (testrun ):Add the -l flag in top of your bash script i.e.The values with NAME1 and NAME2 will now have been exported to your current environment, however these changes are not permanent. If you want them to be permanent you need to add them to your .bashrc file or other init file. From the man pages:You can instruct the child process to print its environment variables (by calling "env"), then loop over the printed environment variables in the parent process and call "export" on those variables.The following code is based on Capturing output of find . -print0 into a bash arrayIf the parent shell is the bash, you can useIf the parent shell is the dash, then read does not provide the -d flag and the code gets more complicatedYou can invoke another one Bash with the different bash_profile. \nAlso, you can create special bash_profile for using in multi-bashprofile environment. Remember that you can use functions inside of bashprofile, and that functions will be avialable globally.\nfor example, "function user { export USER_NAME $1 }" can set variable in runtime, for example: user olegchir && env | grep olegchirTechnically, that is correct -- only \'eval\' doesn\'t fork another shell.  However, from the point of view of the application you\'re trying to run in the modified environment, the difference is nil: the child inherits the environment of its parent, so the (modified) environment is conveyed to all descending processes.Ipso facto, the changed environment variable \'sticks\' -- as long as you are running under the parent program/shell.If it is absolutely necessary for the environment variable to remain after the parent (Perl or shell) has exited, it is necessary for the parent shell to do the heavy lifting.  One method I\'ve seen in the documentation is for the current script to spawn an executable file with the necessary \'export\' language, and then trick the parent shell into executing it -- always being cognizant of the fact that you need to preface the command with \'source\' if you\'re trying to leave a non-volatile version of the modified environment behind.  A Kluge at best.The second method is to modify the script that initiates the shell environment (.bashrc or whatever) to contain the modified parameter.  This can be dangerous -- if you hose up the initialization script it may make your shell unavailable the next time it tries to launch.  There are plenty of tools for modifying the current shell; by affixing the necessary tweaks to the \'launcher\' you effectively push those changes forward as well.\nGenerally not a good idea; if you only need the environment changes for a particular application suite, you\'ll have to go back and return the shell launch script to its pristine state (using vi or whatever) afterwards.In short, there are no good (and easy) methods.  Presumably this was made difficult to ensure the security of the system was not irrevocably compromised.The short answer is no, you cannot alter the environment of the parent process, but it seems like what you want is an environment with custom environment variables and the shell that the user has chosen.So why not simply something likeThen when you are done with the environment, just exit.You could always use aliasesAnother option is to use "Environment Modules" (http://modules.sourceforge.net/). This unfortunately introduces a third language into the mix. You define the environment with the language of Tcl, but there are a few handy commands for typical modifications (prepend vs. append vs set). You will also need to have environment modules installed. You can then use module load *XXX* to name the environment you want. The module command is basically a fancy alias for the eval mechanism described above by Thomas Kammeyer. The main advantage here is that you can maintain the environment in one language and rely on "Environment Modules" to translate it to sh, ksh, bash, csh, tcsh, zsh, python (?!?!!), etc.I did this many years ago. If I rememeber correctly, I included an alias in each of .bashrc and .cshrc, with parameters, aliasing the respective forms of setting the environment to a common form.Then the script that you will source in any of the two shells has a command with that last form, that is suitable aliased in each shell.If I find the concrete aliases, I will post them.I created a solution using pipes, eval and signal.It might work with any command.Under OS X bash you can do the following:\n\nCreate the bash script file to unset the variableMake the file executableCreate aliasIt should be ready to use so long you have the folder containing your script file appended to the path.Other than writings conditionals depending on what $SHELL/$TERM is set to, no.  What\'s wrong with using Perl?  It\'s pretty ubiquitous (I can\'t think of a single UNIX variant that doesn\'t have it), and it\'ll spare you the trouble.