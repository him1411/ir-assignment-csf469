Python is installed in a local directory.  My directory tree looks like this:My code is in here:To run the example, I write python mountain.py, and in the code I have:And I get the error:I have already checked sys.path and there I have the directory /site-packages. Also, I have the file __init__.py.bin in the toolkit folder to indicate to Python that this is a package. I also have a __init__.py.bin in the examples directory.I do not know why Python cannot find the file when it is in sys.path.  Any ideas?  Can it be a permissions problem?  Do I need some execution permission?Based on your comments to orip\'s post, I guess this is what happened:Doeshave a __init__.py?To make import walk through your directories every directory must have a __init__.py file.On *nix, also make sure that PYTHONPATH is configured correctly, especially that it has this format:(Mind the .: at the beginning, so that it can search on the current directory, too.)It may also be in other locations, depending on the version:I solved my own problem, and I will write a summary of the things that were wrong and the solution:The file needs to be called exactly __init__.py. If the extension is different such as in my case .py.bin then Python cannot move through the directories and then it cannot find the modules. To edit the files you need to use a Linux editor, such as vi or nano. If you use a Windows editor this will write some hidden characters.Another problem that was affecting it was that I had another Python version installed by the root, so if someone is working with a local installation of python, be sure that the Python installation that is running the programs is the local Python. To check this, just do which python, and see if the executable is the one that is in your local directory. If not, change the path, but be sure that the local Python directory is before than the other Python.I ran into something very similar when I did this exercise in LPTHW; I could never get Python to recognise that I had files in the directory I was calling from. But I was able to get it to work in the end. What I did, and what I recommend, is to try this:(NOTE: From your initial post, I am assuming you are using an *NIX-based machine and are running things from the command line, so this advice is tailored to that. Since I run Ubuntu, this is what I did) 1) Change directory (cd) to the directory above the directory where your files are. In this case, you\'re trying to run the mountain.py file, and trying to call the toolkit.interface.py module, which are in separate directories. In this case, you would go to the directory that contains paths to both those files (or in other words, the closest directory that the paths of both those files share). Which in this case is the toolkit directory.2) When you are in the tookit directory, enter this line of code on your command line:export PYTHONPATH=.This sets your PYTHONPATH to ".", which basically means that your PYTHONPATH will now look for any called files within the directory you are currently in, (and more to the point, in the sub-directory branches of the directory you are in. So it doesn\'t just look in your current directory, but in all the directories that are in your current directory).3) After you\'ve set your PYTHONPATH in the step above, run your module from your current directory (the toolkit directory). Python should now find and load the modules you specified.Hope this helps. I was quite frustrated with this myself. To mark a directory as a package you need a file named __init__.py, does this help?Yup. You need the directory to contain the __init__.py file, which is the file that initializes the package. Here, have a look at this.The __init__.py files are required to make Python treat the directories as containing packages; this is done to prevent directories with a common name, such as string, from unintentionally hiding valid modules that occur later on the module search path. In the simplest case, __init__.py can just be an empty file, but it can also execute initialization code for the package or set the __all__ variable, described later.eg:\n/etc/environmentPYTHONPATH=$PYTHONPATH:/opt/folder1:/opt/folder2/opt/folder1/foo/opt/folder2/fooAnd, if you are trying to import foo file, python will not know which one you want.from foo import ...   >>> importerror: no module named fooLinux: Imported modules are located in /usr/local/lib/python2.7/dist-packagesIf you\'re using a module compiled in C, don\'t forget to chmod the .so file after sudo setup.py install.In my case, the problem was I was linking to debug python & boost::Python, which requires that the extension be FooLib_d.pyd, not just FooLib.pyd; renaming the file or updating CMakeLists.txt properties fixed the error.Using PyCharm (part of the JetBrains suite) you need to define your script directory as Source:\nRight Click > Mark Directory as > Sources RootMy two cents:Spit:This confused the hell out of me - went through posts and posts suggesting ugly syspath hacks (as you see my __init__.py were all there). Well turns out that game/oblivion.py and game/oblivion was confusing python\nwhich spit out the rather unhelpful "No module named RecordGroups". I\'d be interested in a workaround and/or links documenting this (same name) behavior -> EDIT (2017.01.24) - have a look at What If I Have a Module and a Package With The Same Name? Interestingly normally packages take precedence but apparently our launcher violates this.EDIT (2015.01.17): I did not mention we use a custom launcher dissected here.After just suffering the same issue I found my resolution was to delete all pyc files from my project, it seems like these cached files were somehow causing this error.Easiest way I found to do this was to navigate to my project folder in Windows explorer and searching for *.pyc, then selecting all (Ctrl+A) and deleting them (Ctrl+X).Its possible I could have resolved my issues by just deleting the specific pyc file but I never tried thisIf you have tried all methods provided above but failed, maybe your module has the same name as a built-in module. Or, a module with the same name existing in a folder that has a high priority in sys.path than your module\'s.To debug, say your from foo.bar import baz complaints ImportError: No module named bar. Changing to import foo; print foo, which will show the path of foo. Is it what you expect?If not, Either rename foo or use absolute imports.I faced the same problem: Import error. In addition the library\'ve been installed 100% correctly. The source of the problem was that on my PC 3 version of python (anaconda packet) have been installed). This is why the library was installed no to the right place. After that I just changed to the proper version of python in the my IDE PyCharm.Fixed my issue by writing print (sys.path) and found out that python was using out of date packages despite a clean install. Deleting these made python automatically use the correct packages.I had the same error. It was caused by somebody creating a folder in the same folder as my script, the name of which conflicted with a module I was importing from elsewhere. Instead of importing the external module, it looked inside this folder which obviously didn\'t contain the expected modules.an easy solution is to install the module using python -m pip install <library-name> instead of pip install <library-name>\nyou may use sudo in case of admin restrictions