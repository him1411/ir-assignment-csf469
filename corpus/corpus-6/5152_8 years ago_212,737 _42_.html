I have some JavaScript code that works in IE containing the following:However, it seems that the \'innerText\' property does not work in Firefox.  Is there some Firefox equivalent?  Or is there a more generic, cross browser property that can be used?Firefox uses the W3C-compliant textContent property.I\'d guess Safari and Opera also support this property.Update: I wrote a blog post detailing all the differences much better.Firefox uses W3C standard Node::textContent, but its behavior differs "slightly" from that of MSHTML\'s proprietary innerText (copied by Opera as well, some time ago, among dozens of other MSHTML features).First of all, textContent whitespace representation is different from innerText one. Second, and more importantly, textContent includes all of SCRIPT tag contents, whereas innerText doesn\'t.Just to make things more entertaining, Opera - besides implementing standard textContent - decided to also add MSHTML\'s innerText but changed it to act as textContent - i.e. including SCRIPT contents (in fact, textContent and innerText in Opera seem to produce identical results, probably being just aliased to each other).textContent is part of Node interface, whereas innerText is part of HTMLElement. This, for example, means that you can "retrieve" textContent but not innerText from text nodes:Finally, Safari 2.x also has buggy innerText implementation. In Safari, innerText functions properly only if an element is\nneither hidden (via style.display == "none") nor orphaned from the document. Otherwise, innerText results in an empty string.I was playing with textContent abstraction (to work around these deficiencies), but it turned out to be rather complex.You best bet is to first define your exact requirements and follow from there. It is often possible to simply strip tags off of innerHTML of an element, rather than deal with all of the possible textContent/innerText deviations.Another possibility, of course, is to walk the DOM tree and collect text nodes recursively.If you only need to set text content and not retrieve, here\'s a trivial DOM version you can use on any browser; it doesn\'t require either the IE innerText extension or the DOM Level 3 Core textContent property.jQuery provides a .text() method that can be used in any browser. For example:As per Prakash K\'s answer Firefox does not support the innerText property. So you can simply test whether the user agent supports this property and proceed accordingly as below:A really simple line of Javascript can get the "non-taggy" text in all main browsers...Note that the Element::innerText property will not contain the text which has been hidden by CSS style "display:none" in Google Chrome (as well it will drop the content that has been masked by other CSS technics (including font-size:0, color:transparent, and a few other similar effects that cause the text not to be rendered in any visible way).Other CSS properties are also considered :But Element::textContent will still contain ALL contents of inner text elements independantly of the applied CSS even if they are invisible. And no extra newlines or whitespaces will be generated in textContent, which just ignores all styles and the structure and inline/block or positioned types of inner elements.A copy/paste operation using mouse selection will discard the hidden text in the plain-text format that is put in the clipboard, so it won\'t contain everything in the textContent, but only what is within innerText (after whitespace/newline generation as above).Both properties are then supported in Google Chrome, but their content may then be different. Older browsers still included in innetText everything like what textContent now contains (but their behavior in relation with then generation of whitespaces/newlines was inconsistant).jQuery will solve these inconsistencies between browsers using the ".text()" method added to the parsed elements it returns via a $() query. Internally, it solves the difficulties by looking into the HTML DOM, working only with the "node" level. So it will return something looking more like the standard textContent.The caveat is that that this jQuery method will not insert any extra spaces or line breaks that may be visible on screen caused by subelements (like <br />) of the content.If you design some scripts for accessibility and your stylesheet is parsed for non-aural rendering, such as plugins used to communicate with a Braille reader, this tool should use the textContent if it must include the specific punctuation signs that are added in spans styled with "display:none" and that are typically included in pages (for example for superscripts/subscripts), otherwise the innerText will be very confusive on the Braille reader.Texts hidden by CSS tricks are now typically ignored by major search engines (that will also parse the CSS of your HTML pages, and will also ignore texts that are not in contrasting colors on the background) using an HTML/CSS parser and the DOM property "innerText" exactly like in modern visual browsers (at least this invisible content will not be indexed so hidden text cannot be used as a trick to force the inclusion of some keywords in the page to check its content) ; but this hidden text will be stil displayed in the result page (if the page was still qualified from the index to be included in results), using the "textContent" property instead of the full HTML to strip the extra styles and scripts.IF you assign some plain-text in any one of these two properties, this will overwrite the inner markup and styles applied to it (only the assigned element will keep its type, attributes and styles), so both properties will then contain the same content. However, some browsers will now no longer honor the write to innerText, and will only let you overwrite the textContent property (you cannot insert HTML markup when writing to these properties, as HTML special characters will be properly encoded using numeric character references to appear literally, if you then read the innerHTML property after the assignment of innerText or textContent.Edit (thanks to Mark Amery for the comment below): Only do it this way if you know beyond a reasonable doubt that no code will be relying on checking the existence of these properties, like (for example) jQuery does.  But if you are using jQuery, you would probably just use the "text" function and do $(\'#myElement\').text(\'foo\') as some other answers show.  innerText has been added to Firefox and should be available in the FF45 release: https://bugzilla.mozilla.org/show_bug.cgi?id=264412A draft spec has been written and is expected to be incorporated into the HTML living standard in the future: http://rocallahan.github.io/innerText-spec/, https://github.com/whatwg/html/issues/465Note that currently the Firefox, Chrome and IE implementations are all incompatible. Going forward, we can probably expect Firefox, Chrome and Edge to converge while old IE remains incompatible.See also: https://github.com/whatwg/compat/issues/5What about something like this?** I needed to make mine uppercase.This has been my experience with innerText, textContent, innerHTML, and value:ie = internet explorer, ff = firefox, ch = google chrome.\nnote 1: ff works until after value is deleted with backspace - see note by Ray Vega above.\nnote 2: works somewhat in chrome - after update it is unchanged then you click away and click back into the field and the value appears.\nThe best of the lot is elem.value = changeVal; which I did not comment out above.Just reposting from comments under the original post. innerHTML works in all browsers. Thanks stefita.myElement.innerHTML = "foo";As in 2016 from Firefox v45, innerText works on firefox, take a look at its support: http://caniuse.com/#search=innerTextIf you want it to work on previous versions of Firefox, you can use textContent, which has better support on Firefox but worse on older IE versions: http://caniuse.com/#search=textContentfound this here:It\'s also possible to emulate innerText behavior in other browsers: