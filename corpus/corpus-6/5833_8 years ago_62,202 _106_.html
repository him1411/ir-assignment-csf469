I want to throw some things in my JS code and I want them to be instanceof Error, but I also want to have them be something else.In Python, typically, one would subclass Exception.  What\'s the appropriate thing to do in JS?The only standard field Error object has is the message property. (See MDN, or EcmaScript Language Specification, section 15.11) Everything else is platform specific.Mosts environments set the stack property, but fileName and lineNumber are practically useless to be used in inheritance.So, the minimalistic approach is:You could sniff the stack, unshift unwanted elements from it and extract information like fileName and lineNumber, but doing so requires information about the platform JavaScript is currently running upon. Most cases that is unnecessary -- and you can do it in post-mortem if you really want.Safari is a notable exception. There is no stack property, but the throw keyword sets sourceURL and line properties of the object that is being thrown. Those things are guaranteed to be correct.Test cases I used can be found here: JavaScript self-made Error object comparison.In ES6:sourceEdit: Please read comments. It turns out this only works well in V8 (Chrome / Node.JS) My intent was to provide a cross-browser solution, which would work in all browsers, and provide stack trace where support is there.Edit: I made this Community Wiki to allow for more editing.Solution for V8 (Chrome / Node.JS), works in Firefox, and can be modified to function mostly correctly in IE. (see end of post)Original post on "Show me the code !"Short version:I keep this.constructor.prototype.__proto__ = Error.prototype inside the function to keep all the code together. But you can also replace this.constructor with UserError and that allows you to move the code to outside the function, so it only gets called once.If you go that route, make sure you call that line before the first time you throw UserError.That caveat does not apply the function, because functions are created first, no matter the order. Thus, you can move the function to the end of the file, without a problem.Browser CompatibilityWorks in Firefox and Chrome (and Node.JS) and fills all promises.Internet Explorer fails in the followingErrors do not have err.stack to begin with, so "it\'s not my fault".Error.captureStackTrace(this, this.constructor) does not exist so you need to do something else liketoString ceases to exist when you subclass Error. So you also need to add.IE will not consider UserError to be an instanceof Error unless you run the following some time before you throw UserErrorTo avoid the boilerplate for every different type of error, I combined the wisdom of some of the solutions into a\xc2\xa0createErrorType function:Then you can define new error types easily as follows:Crescent Fresh\'s answer highly-voted answer is misleading.  Though his warnings are invalid, there are other limitations that he doesn\'t address.First, the reasoning in Crescent\'s "Caveats:" paragraph doesn\'t make sense.  The explanation implies that coding "a bunch of if (error instanceof MyError) else ..." is somehow burdensome or verbose compared to multiple catch statements.  Multiple instanceof statements in a single catch block are just as concise as multiple catch statements-- clean and concise code without any tricks.  This is a great way to emulate Java\'s great throwable-subtype-specific error handling.WRT "appears the message property of the subclass does not get set", that is not the case if you use a properly constructed Error subclass.  To make your own ErrorX Error subclass, just copy the code block beginning with "var MyError =", changing the one word "MyError" to "ErrorX".  (If you want to add custom methods to your subclass, follow the sample text).The real and significant limitation of JavaScript error subclassing is that for JavaScript implementations or debuggers that track and report on stack trace and location-of-instantiation, like FireFox, a location in your own Error subclass implementation will be recorded as the instantiation point of the class, whereas if you used a direct Error, it would be the location where you ran "new Error(...)").  IE users would probably never notice, but users of Fire Bug on FF will see useless file name and line number values reported alongside these Errors, and will have to drill down on the stack trace to element #1 to find the real instantiation location.In 2017, I think this is the best way; that supports IE9+ and modern browsers.Also beware that __proto__ property is deprecated which is widely used in other answers.Note: See discussion in the comments and @MattBrowne\'s gist.UPDATE: Added constructor assignment.\nSee this test for comparison on different implementations. Test module here.For the sake of completeness -- just because none of the previous answers mentioned this method -- if you are working with Node.js and don\'t have to care about browser compatibility, the desired effect is pretty easy to achieve with the built in inherits of the util module (official docs here).For example, let\'s suppose you want to create a custom error class that takes an error code as the first argument and the error message as the second argument:file custom-error.js:Now you can instantiate and pass/throw your CustomError:Note that, with this snippet, the stack trace will have the correct file name and line, and the error instance will have the correct name!This happens due to the usage of the captureStackTrace method, which creates a stack property on the target object (in this case, the CustomError being instantiated). For more details about how it works, check the documentation here. How about this solution?Instead of throwing your custom Error using:You would wrap the Error object (kind of like a Decorator):This makes sure all of the attributes are correct, such as the stack, fileName lineNumber, et cetera.All you have to do then is either copy over the attributes, or define getters for them.\nHere is an example using getters (IE9):My solution is more simple than the other answers provided and doesn\'t have the downsides.It preserves the Error prototype chain and all properties on Error without needing specific knowledge of them. It\'s been tested in Chrome, Firefox, Node, and IE11.The only limitation is an extra entry at the top of the call stack. But that is easily ignored.Here\'s an example with two custom parameters:Example Usage:For environments that require a polyfil of setPrototypeOf:In the above example Error.apply (also Error.call) doesn\'t do anything for me (Firefox 3.6/Chrome 5). A workaround I use is:I just want to add to what others have already stated:To make sure that the custom error class shows up properly in the stack trace, you need to set the custom error class\'s prototype\'s name property to the custom error class\'s name property.\nThis is what I mean:So the full example would be:When all is said and done, you throw your new exception and it looks like this (I lazily tried this in the chrome dev tools):My 2 cents:a) Because accessing the Error.stack property (as in some answers) have a large performance penalty. b) Because it is only one line.c) Because the solution at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error does not seems to preserve stack info.usage examplehttp://jsfiddle.net/luciotato/xXyeB/this.__proto__.__proto__ is MyError.prototype.__proto__, so it is setting the __proto__ FOR ALL INSTANCES\nof MyError to a specific newly created Error. It keeps MyError class properties and methods and also puts the new Error properties (including .stack) in the __proto__ chain.You can not have more than one instance of MyError with useful stack info.Do not use this solution if you do not fully understand what this.__proto__.__proto__= does.In short:If you are using ES6 without transpilers:If you are using Babel transpiler:Option 1: use babel-plugin-transform-builtin-extendOption 2: do it yourself (inspired from that same library)If you are using pure ES5:Alternative: use Classtrophobic frameworkExplanation:Why extending the Error class using ES6 and Babel is a problem?Because an instance of CustomError is not anymore recognized as such.In fact, from the official documentation of Babel, you cannot extend any built-in JavaScript classes such as Date, Array, DOM or Error.The issue is described here:What about the other SO answers?All the given answers fix the instanceof issue but you lose the regular error console.log:Whereas using the method mentioned above, not only you fix the instanceof issue but you also keep the regular error console.log:Since JavaScript Exceptions are difficult to sub-class, I don\'t sub-class. I just create a new Exception class and use an Error inside of it. I change the Error.name property so that it looks like my custom exception on the console:The above new exception can be thrown just like a regular Error and it will work as expected, for example:Caveat: the stack trace is not perfect, as it will bring you to where the new Error is created and not where you throw. This is not a big deal on Chrome because it provides you with a full stack trace directly in the console. But it\'s more problematic on Firefox, for example.The way to do this right is to return the result of the apply from the constructor, as well as setting the prototype in the usual complicated javascripty way:The only problems with this way of doing it at this point (i\'ve iterated it a bit) are that The first problem could be fixed by iterating through all the non-enumerable properties of error using the trick in this answer: Is it possible to get the non-enumerable inherited property names of an object?, but this isn\'t supported by ie<9. The second problem could be solved by tearing out that line in the stack trace, but I\'m not sure how to safely do that (maybe just removing the second line of e.stack.toString() ??).I would take a step back and consider why you want to do that? I think the point is to deal with different errors differently.For example, in Python, you can restrict the catch statement to only catch MyValidationError, and perhaps you want to be able to do something similar in javascript.You can\'t do this in javascript. There\'s only going to be one catch block. You\'re supposed to use an if statement on the error to determine its type.\ncatch(e) {\n    if(isMyValidationError(e)) {\n        ...\n    } else {\n        // maybe rethrow?\n        throw e;\n    }\n}\nI think I would instead throw a raw object with a type, message, and any other properties you see fit.And when you catch the error:This is based on George Bailey\'s answer, but extends and simplifies the original idea. It is written in CoffeeScript, but is easy to convert to JavaScript. The idea is extend Bailey\'s custom error with a decorator that wraps it, allowing you to create new custom errors easily.Note: This will only work in V8. There is no support for Error.captureStackTrace in other environments.The decorator takes a name for the error type, and returns a function that takes an error message, and encloses the error name.Now it is simple to create new error types.For fun, you could now define a function that throws a SignatureError if it is called with too many args.This has been tested pretty well and seems to work perfectly on V8, maintaing the traceback, position etc.Note: Using new is optional when constructing a custom error.As pointed out in Mohsen\'s answer, in ES6 it\'s possible to extend errors using classes. It\'s a lot easier and their behavior is more consistent with native errors...but unfortunately it\'s not a simple matter to use this in the browser if you need to support pre-ES6 browsers. See below for some notes on how that might be implemented, but in the meantime I suggest a relatively simple approach that incorporates some of the best suggestions from other answers:In ES6 it\'s as simple as:...and you can detect support for ES6 classes with try {eval(\'class X{}\'), but you\'ll get a syntax error if you attempt to include the ES6 version in a script that\'s loaded by older browsers. So the only way to support all browsers would be to load a separate script dynamically (e.g. via AJAX or eval()) for browsers that support ES6. A further complication is that eval() isn\'t supported in all environments (due to Content Security Policies), which may or may not be a consideration for your project.So for now, either the first approach above or simply using Error directly without trying to extend it seems to be the best that can practically be done for code that needs to support non-ES6 browsers.There is one other approach that some people might want to consider, which is to use Object.setPrototypeOf() where available to create an error object that\'s an instance of your custom error type but which looks and behaves more like a native error in the console (thanks to Ben\'s answer for the recommendation). Here\'s my take on that approach: https://gist.github.com/mbrowne/fe45db61cea7858d11be933a998926a8. But given that one day we\'ll be able to just use ES6, personally I\'m not sure the complexity of that approach is worth it.