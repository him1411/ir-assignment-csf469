I know a list comprehension will do this, but I was wondering if there is an even shorter (and more Pythonic?) approach.I want to create a series of lists, all of varying length. Each list will contain the same element e, repeated n times (where n = length of the list). How do I create the lists, without doingfor each list?You can also write:You should note that if e is for example an empty list you get a list with n references to the same list, not n independent empty lists. Performance testingAt first glance it seems that repeat is the fastest way to create a list with n identical elements:But wait - it\'s not a fair test...The function itertools.repeat doesn\'t actually create the list, it just creates an object that can be used to create a list if you wish! Let\'s try that again, but converting to a list:So if you want a list, use [e] * n. If you want to generate the elements lazily, use repeat.Be careful when the item being repeated is a list. The list will not be cloned: all the elements will refer to the same list!For immutable items, like None, strings, tuples, or frozensets, you can do it like this:Note that this is best only used with immutable items (strings, tuples, frozensets, ) in the list, because they all point to the same item in the same place in memory. I use this frequently when I have to build a table with a schema of all strings, so that I don\'t have to give a one to one mapping.I\'ve used Python for a long time now, and I have never seen a use-case where I would do the above with a mutable instance. Instead, to get, say, a mutable empty list, set, or dict, you should do something like this:The underscore is simply a throwaway variable name in this context. (Use xrange for Python 2.)Beware doing this with mutable objects, when you change one of them, they all change because they\'re all the same object:foo now returns:But with immutable objects, you can make it work because you change the reference, not the object:But again, mutable objects are no good for this, because in-place operations change the object, not the reference:Itertools has a function just for that:Of course itertools gives you a iterator instead of a list. [e] * n gives you a list, but, depending on what you will do with those sequences, the itertools variant can be much more efficient.As others have pointed out, using the * operator for a mutable object duplicates references, so if you change one you change them all. If you want to create independent instances of a mutable object, your xrange syntax is the most Pythonic way to do this. If you are bothered by having a named variable that is never used, you can use the anonymous underscore variable.should work