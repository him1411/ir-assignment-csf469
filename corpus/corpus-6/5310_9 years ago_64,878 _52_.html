I know about the "cooperative" threading of ruby using green threads. How can I create real "OS-level" threads in my application in order to make use of multiple cpu cores for processing?Updated with J\xc3\xb6rg\'s Sept 2011 commentYou seem to be confusing two very different things here: the \nRuby Programming Language and the specific threading model of one \nspecific implementation of the Ruby Programming Language. There \nare currently around 11 different implementations of the Ruby \nProgramming Language, with very different and unique threading \nmodels.(Unfortunately, only two of those 11 implementations are actually \nready for production use, but by the end of the year that number \nwill probably go up to four or five.) (Update: it\'s now 5: MRI, JRuby, YARV (the interpreter for Ruby 1.9), Rubinius and IronRuby).The first implementation doesn\'t actually have a name, which \nmakes it quite awkward to refer to it and is really annoying and \nconfusing. It is most often referred to as "Ruby", which is even \nmore annoying and confusing than having no name, because it \nleads to endless confusion between the features of the Ruby \nProgramming Language and a particular Ruby Implementation.It is also sometimes called "MRI" (for "Matz\'s Ruby \nImplementation"), CRuby or MatzRuby.MRI implements Ruby Threads as Green Threads within its \ninterpreter. Unfortunately, it doesn\'t allow those threads \nto be scheduled in parallel, they can only run one thread at a \ntime.However, any number of C Threads (POSIX Threads etc.) can run \nin parallel to the Ruby Thread, so external C Libraries, or MRI \nC Extensions that create threads of their own can still run in \nparallel.The second implementation is YARV (short for "Yet \nAnother Ruby VM"). YARV implements Ruby Threads as POSIX or \nWindows NT Threads, however, it uses a Global Interpreter \nLock (GIL) to ensure that only one Ruby Thread can actually be \nscheduled at any one time.Like MRI, C Threads can actually run parallel to Ruby Threads.In the future, it is possible, that the GIL might get broken \ndown into more fine-grained locks, thus allowing more and more \ncode to actually run in parallel, but that\'s so far away, it is \nnot even planned yet.JRuby implements Ruby Threads as Native Threads, \nwhere "Native Threads" in case of the JVM obviously means "JVM \nThreads". JRuby imposes no additional locking on them. So, \nwhether those threads can actually run in parallel depends on \nthe JVM: some JVMs implement JVM Threads as OS Threads and some \nas Green Threads. (The mainstream JVMs from Sun/Oracle use exclusively OS threads since JDK 1.3)XRuby also implements Ruby Threads as JVM Threads. Update: XRuby is dead.IronRuby implements Ruby Threads as Native Threads, \nwhere "Native Threads" in case of the CLR obviously means \n"CLR Threads". IronRuby imposes no additional locking on them, \nso, they should run in parallel, as long as your CLR supports \nthat.Ruby.NET also implements Ruby Threads as CLR \nThreads. Update: Ruby.NET is dead.Rubinius implements Ruby Threads as Green Threads \nwithin its Virtual Machine. More precisely: the Rubinius \nVM exports a very lightweight, very flexible \nconcurrency/parallelism/non-local control-flow construct, called \na "Task", and all other concurrency constructs (Threads in \nthis discussion, but also Continuations, Actors and \nother stuff) are implemented in pure Ruby, using Tasks.Rubinius can not (currently) schedule Threads in parallel, \nhowever, adding that isn\'t too much of a problem: Rubinius can \nalready run several VM instances in several POSIX Threads in \nparallel, within one Rubinius process. Since Threads are \nactually implemented in Ruby, they can, like any other Ruby \nobject, be serialized and sent to a different VM in a different \nPOSIX Thread. (That\'s the same model the BEAM Erlang VM \nuses for SMP concurrency. It is already implemented for \nRubinius Actors.)Update: The information about Rubinius in this answer is about the Shotgun VM, which doesn\'t exist anymore. The "new" C++ VM does not use green threads scheduled across multiple VMs (i.e. Erlang/BEAM style), it uses a more traditional single VM with multiple native OS threads model, just like the one employed by, say, the CLR, Mono, and pretty much every JVM.MacRuby started out as a port of YARV on top of the \nObjective-C Runtime and CoreFoundation and Cocoa Frameworks. It \nhas now significantly diverged from YARV, but AFAIK it currently \nstill shares the same Threading Model with YARV.\nUpdate: MacRuby depends on apples garbage collector which is declared deprecated and will be removed in later versions of MacOSX, MacRuby is undead.Cardinal is a Ruby Implementation for the Parrot \nVirtual Machine. It doesn\'t implement threads yet, however, \nwhen it does, it will probably implement them as Parrot \nThreads. Update: Cardinal seems very inactive/dead.MagLev is a Ruby Implementation for the GemStone/S \nSmalltalk VM. I have no information what threading model \nGemStone/S uses, what threading model MagLev uses or even if \nthreads are even implemented yet (probably not).HotRuby is not a full Ruby Implementation of its \nown. It is an implementation of a YARV bytecode VM in \nJavaScript. HotRuby doesn\'t support threads (yet?) and when it \ndoes, they won\'t be able to run in parallel, because JavaScript \nhas no support for true parallelism. There is an ActionScript \nversion of HotRuby, however, and ActionScript might actually \nsupport parallelism. Update: HotRuby is dead.Unfortunately, only two of these 11 Ruby Implementations are \nactually production-ready: MRI and JRuby.So, if you want true parallel threads, JRuby is currently your \nonly choice\xc2\xa0\xe2\x80\x93 not that that\'s a bad one: JRuby is actually faster \nthan MRI, and arguably more stable.Otherwise, the "classical" Ruby solution is to use processes \ninstead of threads for parallelism. The Ruby Core Library \ncontains the Process module with the Process.fork \nmethod which makes it dead easy to fork off another Ruby \nprocess. Also, the Ruby Standard Library contains the \nDistributed Ruby (dRuby / dRb) library, which allows Ruby \ncode to be trivially distributed across multiple processes, not \nonly on the same machine but also across the network.Ruby 1.8 only has green threads, there is no way to create a real "OS-level" thread.  But, ruby 1.9 will have a new feature called fibers, which will allow you to create actual OS-level threads.  Unfortunately, Ruby 1.9 is still in beta, it is scheduled to be stable in a couple of months.Another alternative is to use JRuby.  JRuby implements threads as OS-level theads, there are no "green threads" in it.  The latest version of JRuby is 1.1.4 and is equivalent to Ruby 1.8It depends on the implementation:  \nRuby has closures as Blocks, lambdas and Procs. To take full advantage of closures and multiple cores in JRuby, Java\'s executors come in handy; for MacRuby I like GCD\'s queues.\n\nNote that, being able to create real "OS-level" threads doesn\'t imply that you can use multiple cpu cores for parallel processing. Look at the examples below.This is the output of a simple Ruby program which uses 3 threads using Ruby 2.1.0:As you can see here, there are four OS threads, however only the one with state R is running. This is due to a limitation in how Ruby\'s threads are implemented.\nSame program, now with JRuby. You can see three threads with state R, which means they are running in parallel.\nThe same program, now with MacRuby. There are also three threads running in parallel. This is because MacRuby threads are POSIX threads (real "OS-level" threads) and there is no GVL\nOnce again, the same program but now with the good old RMI. Due to the fact that this implementation uses green-threads, only one thread shows up\nIf you are interested in Ruby multi-threading you might find my report Debugging parallel programs using fork handlers interesting.\nFor a more general overview of the Ruby internals Ruby Under a Microscope is a good read. \nAlso, Ruby Threads and the Global Interpreter Lock in C in Omniref explains in the source code why Ruby threads don\'t run in parallel.How about using drb? It\'s not real multi-threading but communication between several processes, but you can use it now in 1.8 and it\'s fairly low friction.I\'ll let the "System Monitor" answer this question.  I\'m executing the same code (below, which calculates prime numbers) with 8 Ruby threads running on an i7 (4 hyperthreaded-core) machine in both cases... the first run is with:jruby 1.5.6 (ruby 1.8.7 patchlevel 249) (2014-02-03 6586)\n(OpenJDK 64-Bit Server VM 1.7.0_75) [amd64-java] The second is with:ruby 2.1.2p95 (2014-05-08) [x86_64-linux-gnu]Interestingly, the CPU is higher for JRuby threads, but the time to completion is slightly shorter for the interpreted Ruby.  It\'s kind of difficult to tell from the graph, but the second (interpreted Ruby) run uses about 1/2 the CPUs (no hyperthreading?)If you are using MRI, then you can write the threaded code in C either as an extension or using the ruby-inline gem. If you really need parallelism in Ruby for a Production level system (where you cannot employ a beta) processes are probably a better alternative. \nBut, it is most definitely worth trying threads under JRuby first.Also if you are interested in future of threading under Ruby, you might find this article useful.Here is some info on Rinda which is Ruby implementation of Linda (parallel processing and distributed computing paradigm) http://charmalloc.blogspot.com/2009/12/linda-tuples-rinda-drb-parallel.htmlBecause could not edit that answer, so add a new reply here.Update(2017-05-08)This article is very old, and information is not follow current\n(2017) tread, Following is some supplement:Opal is a Ruby to JavaScript source-to-source compiler. It also has an implementation of the Ruby corelib, It current very active develompent, and exist a great deal of (frontend) framework worked on it.\nand production ready. Because base on javascript, it not support parallel threads.truffleruby is a high performance implementation of the Ruby programming language. Built on the GraalVM by Oracle Labs,TruffleRuby is a fork of JRuby, combining it with code from the Rubinius project, and also containing code from the standard implementation of Ruby, MRI, still live development, not production ready.\nThis version ruby seem like born for performance, I don\'t know if support parallel threads, but I think it should.