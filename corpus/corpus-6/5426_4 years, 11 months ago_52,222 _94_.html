I am writing a project in Django and I see that 80% of the code is in the file models.py. This code is confusing and, after a certain time, I cease to understand what is really happening.Here is what bothers me:Here is a simple example. At first, the User model was like this:Over time, it turned into this:What I want is to separate entities in my code:What are the good practices to implement such an approach that can be applied in Django?It seems like you are asking about the difference between the data model and the domain model \xe2\x80\x93\xc2\xa0the latter is where you can find the business logic and entities as perceived by your end user, the former is where you actually store your data. Furthermore, I\'ve interpreted the 3rd part of your question as: how to notice failure to keep these models separate. These are two very different concepts and it\'s always hard to keep them separate. However, there are some common patterns and tools that can be used for this purpose. The first thing you need to recognize is that your domain model is not really about data; it is about actions and questions such as "activate this user", "deactivate this user", "which users are currently activated?", and "what is this user\'s name?". In classical terms: it\'s about queries and commands. Let\'s start by looking at the commands in your example: "activate this user" and "deactivate this user". The nice thing about commands is that they can easily be expressed by small given-when-then scenario\'s: given an inactive user \n  when the admin activates this user \n  then the user becomes active \n  and a confirmation e-mail is sent to the user \n  and an entry is added to the system log\n   (etc. etc.)Such scenario\'s are useful to see how different parts of your infrastructure can be affected by a single command \xe2\x80\x93\xc2\xa0in this case your database (some kind of \'active\' flag), your mail server, your system log, etc. Such scenario\'s also really help you in setting up a Test Driven Development environment. And finally, thinking in commands really helps you create a task-oriented application. Your users will appreciate this :-)Django provides two easy ways of expressing commands; they are both valid options and it is not unusual to mix the two approaches. The service module has already been described by @Hedde. Here you define a separate module and each command is represented as a function. services.pyThe other way is to use a Django Form for each command. I prefer this approach, because it combines multiple closely related aspects:forms.pyYou example did not contain any queries, so I took the liberty of making up a few useful queries. I prefer to use the term "question", but queries is the classical terminology. Interesting queries are: "What is the name of this user?", "Can this user log in?", "Show me a list of deactivated users", and "What is the geographical distribution of deactivated users?" Before embarking on answering these queries, you should always ask yourself two questions: is this a presentational query just for my templates, and/or a business logic query tied to executing my commands, and/or a reporting query. Presentational queries are merely made to improve the user interface. The answers to business logic queries directly affect the execution of your commands. Reporting queries are merely for analytical purposes and have looser time constraints. These categories are not mutually exclusive. The other question is: "do I have complete control over the answers?" For example, when querying the user\'s name (in this context)  we do not have any control over the outcome, because we rely on an external API. The most basic query in Django is the use of the Manager object: Of course, this only works if the data is actually represented in your data model. This is not always the case. In those cases, you can consider the options below. The first alternative is useful for queries that are merely presentational: custom tags and template filters. template.htmltemplate_tags.pyIf your query is not merely presentational, you could add queries to your services.py (if you are using that), or introduce a queries.py module: queries.pyProxy models are very useful in the context of business logic and reporting. You basically define an enhanced subset of your model. models.pyFor queries that are inherently complex, but are executed quite often, there is the possibility of query models. A query model is a form of denormalization where relevant data for a single query is stored in a separate model. The trick of course is to keep the denormalized model in sync with the primary model. Query models can only be used if changes are entirely under your control. models.pyThe first option is to update these models in your commands. This is very useful if these models are only changed by one or two commands. forms.pyA better option would be to use custom signals. These signals are of course emitted by your commands. Signals have the advantage that you can keep multiple query models in sync with your original model. Furthermore, signal processing can be offloaded to background tasks, using Celery or similar frameworks. signals.pyforms.pymodels.pyWhen using this approach, it becomes ridiculously easy to determine if your code stays clean. Just follow these guidelines:The same goes for views (because views often suffer from the same problem). Django documentation: proxy modelsDjango documentation: signalsArchitecture: Domain Driven DesignI usually implement a service layer in between views and models. This acts like your project\'s API and gives you a good helicopter view of what is going on. I inherited this practice from a colleague of mine that uses this layering technique a lot with Java projects (JSF), e.g:models.py services.pyviews.pyMind you, I usually take models, views and services to module level and\n  separate even further depending on the project\'s sizeFirst of all, Don\'t repeat yourself.Then, please be careful not to overengineer, sometimes it is just a waste of time, and makes someone lose focus on what is important. Review the zen of python from time to time.Take a look at active projectsthe fabric repository is also a good one to look at.More about MVCTake advantage of middleware / templatetagsTake advantage of model managersExample:Make use of forms where possibleA lot of boilerplate code can be eliminated if you have forms that map to a model. The ModelForm documentation is pretty good. Separating code for forms from model code can be good if you have a lot of customization (or sometimes avoid cyclic import errors for more advanced uses).Use management commands when possibleif you have business logic, you can separate it outbackend example:could become:more about design patternsmore about interface boundariesIn short, you could haveor anything else that helps you; finding the interfaces you need and the boundaries will help you.Django employs a slightly modified kind of MVC. There\'s no concept of a "controller" in Django. The closest proxy is a "view", which tends to cause confusion with MVC converts because in MVC a view is more like Django\'s "template".In Django, a "model" is not merely a database abstraction. In some respects, it shares duty with the Django\'s "view" as the controller of MVC. It holds the entirety of behavior associated with an instance. If that instance needs to interact with an external API as part of it\'s behavior, then that\'s still model code. In fact, models aren\'t required to interact with the database at all, so you could conceivable have models that entirely exist as an interactive layer to an external API. It\'s a much more free concept of a "model".In Django, MVC structure is as Chris Pratt said, different from classical MVC model used in other frameworks, I think the main reason for doing this is avoiding a too strict application structure, like happens in others MVC frameworks like CakePHP.In Django, MVC was implemented in the following way:View layer is splitted in two. The views should be used only to manage HTTP requests, they are called and respond to them. Views communicate with the rest of your application (forms, modelforms, custom classes, of in simple cases directly with models).\nTo create the interface we use Templates. Templates are string-like to Django, it maps a context into them, and this context was communicated to the view by the application (when view asks).Model layer gives encapsulation, abstraction, validation, intelligence and makes your data object-oriented (they say someday DBMS will also). This doesn\'t means that you should make huge models.py files (in fact a very good advice is to split your models in different files, put them into a folder called \'models\', make an \'__init__.py\' file into this folder where you import all your models and finally use the attribute \'app_label\' of models.Model class). Model should abstract you from operating with data, it will make your application simpler. You should also, if required, create external classes, like "tools" for your models.You can also use heritage in models, setting the \'abstract\' attribute of your model\'s Meta class to \'True\'.Where is the rest? Well, small web applications generally are a sort of an interface to data, in some small program cases using views to query or insert data would be enough. More common cases will use Forms or ModelForms, which are actually "controllers". This is not other than a practical solution to a common problem, and a very fast one. It\'s what a website use to do.If Forms are not enogh for you, then you should create your own classes to do the magic, a very good example of this is admin application: you can read ModelAmin code, this actually works as a controller. There is not a standard structure, I suggest you to examine existing Django apps, it depends on each case. This is what Django developers intended, you can add xml parser class, an API connector class, add Celery for performing tasks, twisted for a reactor-based application, use only the ORM, make a web service, modify the admin application and more... It\'s your responsability to make good quality code, respect MVC philosophy or not, make it module based and creating your own abstraction layers. It\'s very flexible.My advice: read as much code as you can, there are lots of django applications around, but don\'t take them so seriously. Each case is different, patterns and theory helps, but not always, this is an imprecise cience, django just provide you good tools that you can use to aliviate some pains (like admin interface, web form validation, i18n, observer pattern implementation, all the previously mentioned and others), but good designs come from experienced designers.PS.: use \'User\' class from auth application (from standard django), you can make for example user profiles, or at least read its code, it will be useful for your case.I\'m mostly agree with chosen answer (https://stackoverflow.com/a/12857584/871392), but want to add option in Making Queries section.One can define QuerySet classes for models for make filter queries and son on. After that you can proxy this queryset class for model\'s manager, like build-in Manager and QuerySet classes do. Although, if you had to query several data models to get one domain model, it seems more reasonable to me to put this in separate module like suggested before.An old question, but I\'d like to offer my solution anyway. It\'s based on acceptance that model objects too require some additional functionality while it\'s awkward to place it within the models.py. Heavy business logic may be written separately depending on personal taste, but I at least like the model to do everything related to itself. This solution also supports those who like to have all the logic placed within models themselves.As such, I devised a hack that allows me to separate logic from model definitions and still get all the hinting from my IDE.The advantages should be obvious, but this lists a few that I have observed:I have been using this with Python 3.4 and greater and Django 1.8 and greater.app/models.pyapp/logic/user.pyThe only thing I can\'t figure out is how to make my IDE (PyCharm in this case) recognise that UserLogic is actually User model. But since this is obviously a hack, I\'m quite happy to accept the little nuisance of always specifying type for self parameter.Django is designed to be easely used to deliver web pages. If you are not confortable with this perhaps you should use another solution.I\'m writting the root or common operations on the model (to have the same interface) and the others on the controller of the model. If I need an operation from other model I import its controller.This approach it\'s enough for me and the complexity of my applications.Hedde\'s response is an example that shows the flexibility of django and python itself.  Very interesting question anyway!