So far I\'ve been using the built-in unittest module (pyUnit) for unit-testing Python code. However, for simple cases it seems like overkill. Being a derivative of xUnit, it appears a bit heavy for the dynamic nature of Python, where I would expect to write less to achieve the same effects. On the other hand, it is built-in, it makes you write your tests in an organized way, and it is tested by time.The major alternatives I\'ve seen online are:Which of the frameworks do you prefer, and why? Update 10.12.2011: with the recent addition of test auto-discovery and many new features in unittest (in Python 2.7 and 3.2), IMHO it makes less sense to use an external library.Regarding doctest:\nI don\'t consider it a unit-testing framework per-se. I definitely wouldn\'t use it to write a large suite of tests for a sizable application. doctest is more suitable for making sure that the examples you provide in the documentation work. It has its place for this need, but it isn\'t a competitor for unittest, py.test and other frameworks.nose isn\'t really a unit testing framework.  It\'s a test runner and a great one at that.  It can run tests created using unittest, py.test or doctest.My preference for unit testing framework is the standard unittest module (also known as pyUnit).  It\'s similar to other xUnit frameworks and is easy to relate to for people without python background.   There is also pretty good support for it in Eclipse/PyDevOn py.test, I find multiple levels of setup/teardowns very confusing. I also find that it leads to highly unstructured and hard to read unit tests.doctest is OK for simple things, but I find that it\'s very limiting and doesn\'t really scale for complex and highly interactive code.Interesting that no one yet has answered to defend py.test. On the testing-in-python mailing list it is quite popular, e.g. this recent thread "why do you use py.test?". Most common responses included:We initially started our automation framework using unittest and nosetest. We subclassed all our test classes from unittest since unittest offers great syntax for assertions. For the actual running of the tests, we used nose which was pretty good in terms of reporting and specifying which tests needed to be run. The test generation logic was also pretty good - using the yield method it was easy to use. The only problem with the nose test generation is that the test class cannot inherit from unittest - the test generation fails then. Only nose assertions can be used here.We ran into major problems with nose when we wanted to parallelize the test runs. Extremely screwed up reporting resulted when the tests were run in parallel. Also, if you are creating certain resources in the setup methods then also the parallelization fails with weird errors. It seemed very complex to use nose to parallelize test runs - we tried almost everything. \nThen finally one of our team members hit upon py.test. Within a very short time he was able to make the necessary changes to a suite of 30 tests in order to run them in parallel. He began the run and to his surprise the run passed in a record of 15 minutes from the previous 75 minutes it used to take. He was able to run all 30 tests in parallel successfully with least amount of effort and hassle. THe syntax was also simple and the reporting was superb - far excelled the reporting of the nose framework. So I would say the winning combination is py.test with unittest.I just use the standard unittest. Not sure how you\'d write tests as effectively with another style -- perhaps each test in a function, but then how would you handle setup / teardown?nose2 has superseded nose and supports parameterized tests which means that you can run the same assertions with different parameters. This allows you to cover more scenarios with much less code.The unittest.TestCase is a class.  Feel free to subclass it with your own add-on features that allow you to "write less to achieve the same effects".I agree that one nicest features of nose is its plugin system. For example, I started learning Python when the Google App Engine launched and there was a Nose plug-in to support GAE almost immediately. So Nose with its plugins helped me to start doing test-driven development with a new platform like GAE from the start. The coverage plugin was there when I was ready for it as well. One of the nicest features of nose is its plugin system: for example the coverage plugin shows you how much of your code is covered by unittests. After writing lots of unittests it is often shocking to see how much of your code isn\'t covered ....There\'s always doctest if you want to keep your unit tests close to the code.HTHI think it\'s a matter of choice really. I have used all the major testing frameworks, it comes down to which one you think does the job with less coding. \nThat said, I prefer doctest as well.  