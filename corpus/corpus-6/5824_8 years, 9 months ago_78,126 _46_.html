According to the documentation of the == operator in MSDN, For predefined value types, the\n  equality operator (==) returns true if\n  the values of its operands are equal,\n  false otherwise. For reference types\n  other than string, == returns true if\n  its two operands refer to the same\n  object. For the string type, ==\n  compares the values of the strings.\n  User-defined value types can overload\n  the == operator (see operator). So can\n  user-defined reference types, although\n  by default == behaves as described\n  above for both predefined and\n  user-defined reference types.So why does this code snippet fail to compile?I get the error Operator \'==\' cannot be applied to operands of type \'T\' and \'T\'. I wonder why, since as far as I understand the == operator is predefined for all types?Edit: Thanks everybody. I didn\'t notice at first that the statement was about reference types only. I also thought that bit-by-bit comparison is provided for all value types, which I now know is not correct.But, in case I\'m using a reference type, would the the == operator use the predefined reference comparison, or would it use the overloaded version of the operator if a type defined one?Edit 2: Through trial and error, we learned that the == operator will use the predefined reference comparison when using an unrestricted generic type. Actually, the compiler will use the best method it can find for the restricted type argument, but will look no further. For example, the code below will always print true, even when Test.test<B>(new B(), new B()) is called:"...by default == behaves as described above for both predefined and user-defined reference types."Type T is not necessarily a reference type, so the compiler can\'t make that assumption.However, this will compile because it is more explicit:Follow up to additional question, "But, in case I\'m using a reference type, would the the == operator use the predefined reference comparison, or would it use the overloaded version of the operator if a type defined one?"I would have thought that == on the Generics would use the overloaded version, but the following test demonstrates otherwise.  Interesting... I\'d love to know why!  If someone knows please share.OutputInline:\nOverloaded == calledGeneric:Press any key to continue . . .Follow Up 2I do want to point out that changing my compare method to causes the overloaded == operator to be called.  I guess without specifying the type (as a where), the compiler can\'t infer that it should use the overloaded operator... though I\'d think that it would have enough information to make that decision even without specifying the type.As others have said, it will only work when T is constrained to be a reference type. Without any constraints, you can compare with null, but only null - and that comparison will always be false for non-nullable value types.Instead of calling Equals, it\'s better to use an IComparer<T> - and if you have no more information, EqualityComparer<T>.Default is a good choice:Aside from anything else, this avoids boxing/casting.In general, EqualityComparer<T>.Default.Equals should do the job with anything that implements IEquatable<T>, or that has a sensible Equals implementation.If, however, == and Equals are implemented differently for some reason, then my work on generic operators should be useful; it supports the operator versions of (among others):So many answers, and not a single one explains the WHY? (which Giovanni explicitly asked)....NET generics do not act like C++ templates.  In C++ templates, overload resolution occurs after the actual template parameters are known.In .NET generics (including C#), overload resolution occurs without knowing the actual generic parameters.  The only information the compiler can use to choose the function to call comes from type constraints on the generic parameters.The compile can\'t know T couldn\'t be a struct (value type). So you have to tell it it can only be of reference type i think:It\'s because if T could be a value type, there could be cases where x == y would be ill formed - in cases when a type doesn\'t have an operator == defined. The same will happen for this which is more obvious:That fails too, because you could pass a type T that wouldn\'t have a function foo. C# forces you to make sure all possible types always have a function foo. That\'s done by the where clause. It appears that without the class constraint:One should realize that while class constrained Equals in the == operator inherits from Object.Equals, while that of a struct overrides ValueType.Equals.Note that:also gives out the same compiler error.As yet I do not understand why having a value type equality operator comparison is rejected by the compiler. I do know for a fact though, that this works:There is an MSDN Connect entry for this hereAlex Turner\'s reply starts with:Unfortunately, this behavior is by\n  design and there is not an easy\n  solution to enable use of == with type\n  parameters that may contain value\n  types.If you want to make sure the operators of your custom type are called you can do so via reflection. Just get the type using your generic parameter and retrieve the MethodInfo for the desired operator (e.g. op_Equality, op_Inequality, op_LessThan...).Then execute the operator using the MethodInfo\'s Invoke method and pass in the objects as the parameters.This will invoke your overloaded operator and not the one defined by the constraints applied on the generic parameter. Might not be practical, but could come in handy for unit testing your operators when using a generic base class that contains a couple of tests.Well in my case I wanted to unit-test the equality operator. I needed call the code under the equality operators without explicitly setting the generic type. Advises for EqualityComparer were not helpful as EqualityComparer called Equals method but not the equality operator. Here is how I\'ve got this working with generic types by building a LINQ. It calls the right code for == and != operators:The above will work because == is taken care of in case of user-defined reference types.\nIn case of value types, == can be overridden. In which case, "!=" should also be defined.I think that could be the reason, it disallows generic comparison using "==".I wrote the following function looking at the latest msdn. It can easily compare two objects x and y: