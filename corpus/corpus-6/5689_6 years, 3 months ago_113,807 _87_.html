I have a data structure like this :And I would like to access the data using these variable :part1name should be filled with someObject.part1.name \'s value, which is "Part 1". Same thing with part2quantity which filled with 60.Is there anyway to achieve this with either pure javascript or JQuery?I just made this based on some similar code I already had, it appears to work:Usage::See a working demo at http://jsfiddle.net/alnitak/hEsys/EDIT some have noticed that this code will throw an error if passed a string where the left-most indexes don\'t correspond to a correctly  nested entry within the object.  This is a valid concern, but IMHO best addressed with a try / catch block when calling, rather than having this function silently return undefined for an invalid index.This is the solution I use:Example usage:Limitations:This is now supported by lodash using _.get(obj, property). See https://lodash.com/docs#getExample from the docs:You\'d have to parse the string yourself:This required that you also define array indexes with dot notation:It makes the parsing easier.DEMOWorks for arrays / arrays inside the object also.\nDefensive against invalid values.using eval:wrap to return undefined on errorhttp://jsfiddle.net/shanimal/b3xTw/Please use common sense and caution when wielding the power of eval. It\'s a bit like a light saber, if you turn it on there\'s a 90% chance you\'ll sever a limb. Its not for everybody.ES6: Only one line in Vanila JS (it return null if don\'t find instead of giving error):or exemple:For a ready to use function that also recognizes false, 0 and negative number and accept default values as parameter:Exemple to use:Bonus:To set a path (Requested by @rob-gordon) you can use:Example:Access array with []:exempleHere I offer more ways, which seem faster in many respects:Option 1: Split string on . or [ or ] or \' or ", reverse it, skip empty items.Option 2 (fastest of all, except eval): Low level character scan (no regex/split/etc, just a quick char scan).\nNote:  This one does not support quotes for indexes.Option 3: (new: option 2 expanded to support quotes - a bit slower, but still fast)JSPerf: http://jsperf.com/ways-to-dereference-a-delimited-property-string/3"eval(...)" is still king though (performance wise that is).  If you have property paths directly under your control, there shouldn\'t be any issues with using \'eval\' (especially if speed is desired).  If pulling property paths "over the wire" (on the line!? lol :P), then yes, use something else to be safe.  Only an idiot would say to never use "eval" at all, as there ARE good reasons when to use it.  Also, "It is used in Doug Crockford\'s JSON parser." If the input is safe, then no problems at all.  Use the right tool for the right job, that\'s it.You can manage to obtain value of a deep object member with dot notation without any external JavaScript library with the simple following trick:In your case to obtain value of part1.name from someObject just do:Here is a simple fiddle demo: https://jsfiddle.net/harishanchu/oq5esowf/I think you are asking for this:You could be asking for this:Both of which will workOr maybe you are asking for thisFinally you could be asking for thisSpeigg\'s approach is very neat and clean, though I found this reply while searching for the solution of accessing AngularJS $scope properties by string path and with a little modification it does the job:Just place this function in your root controller and use it any child scope like this:Here are performance tests for all 4, with @TheZver and @Shanimal being the winners:http://jsfiddle.net/Jw8XB/3/I haven\'t yet found a package to do all of the operations with a string path, so I ended up writing my own quick little package which supports insert(), get() (with default return), set() and remove() operations.You can use dot notation, brackets, number indices, string number properties, and keys with non-word characters. Simple usage below:https://www.npmjs.com/package/jsocrudhttps://github.com/vertical-knowledge/jsocrudThere is an npm module now for doing this: https://github.com/erictrinh/safe-accessExample usage:It\'s a one liner with lodash.PlunkrIf you need to access different nested key without knowing it at coding time (it will be trivial to address them) you can use the array notation accessor:They are equivalent to the dot notation accessor and may vary at runtime, for example:is equivalent to or I hope this address your question...EDITI won\'t use a string to mantain a sort of xpath query to access an object value.\nAs you have to call a function to parse the query and retrieve the value I would follow another path (not :or, if you are uneasy with the apply method The functions are shorter, clearer, the interpreter check them for you for syntax errors and so on.By the way, I feel that a simple assignment made at right time will be sufficent...Just had the same question recently and successfully used https://npmjs.org/package/tea-properties which also set nested object/arrays :get:set:What about this solution:And this one, for getting:Probably some will consider them unsafe, but they must be much faster then, parsing the string.Underscore has a function available called getNested(obj, chain, def, opts) seen here...https://github.com/dsc/underscore.nested/blob/master/underscore.nested.js#L182With coffeescript you can use the ? symbol to check if the object exist, and if so, follow the chain like this:If some property on the chain doesn\'t exists, the value will be undefined :-)The solutions here are just for accessing the deeply nested keys. I needed one for accessing, adding, modifying and deleting the keys. This is what I came up with:Works withSimple function, allowing for either a string or array path.ORBuilding off of Alnitak\'s answer:}This allows you to set a value as well!I\'ve created an npm package and github with this as wellUsing the streams api:      