I have always thought that functional programming can be done in Python. Thus, I was surprised that Python didn\'t get much of a mention in this question, and when it was mentioned, it normally wasn\'t very positive. However, not many reasons were given for this (lack of pattern matching and algebraic data types were mentioned). So my question is: why isn\'t Python very good for functional programming? Are there more reasons than its lack of pattern matching and algebraic data types? Or are these concepts so important to functional programming that a language that doesn\'t support them can only be classed as a second rate functional programming language? (Keep in mind that my experience with functional programming is quite limited.)The question you reference asks which languages promote both OO and functional programming. Python does not promote functional programming even though it works fairly well.The best argument against functional programming in Python is that imperative/OO use cases are carefully considered by Guido, while functional programming use cases are not. When I write imperative Python, it\'s one of the prettiest languages I know. When I write functional Python, it becomes as ugly and unpleasant as your average language that doesn\'t have a BDFL.Which is not to say that it\'s bad, just that you have to work harder than you would if you switched to a language that promotes functional programming or switched to writing OO Python.Here are the functional things I miss in Python:Guido has a good explanation of this here.  Here\'s the most relevant part:I have never considered Python to be\n  heavily influenced by functional\n  languages, no matter what people say\n  or think. I was much more familiar\n  with imperative languages such as C\n  and Algol 68 and although I had made\n  functions first-class objects, I\n  didn\'t view Python as a functional\n  programming language. However, earlier\n  on, it was clear that users wanted to\n  do much more with lists and functions....It is also worth noting that even\n  though I didn\'t envision Python as a\n  functional language, the introduction\n  of closures has been useful in the\n  development of many other advanced\n  programming features. For example,\n  certain aspects of new-style classes,\n  decorators, and other modern features\n  rely upon this capability.Lastly, even though a number of\n  functional programming features have\n  been introduced over the years, Python\n  still lacks certain features found in\n  \xe2\x80\x9creal\xe2\x80\x9d functional programming\n  languages. For instance, Python does\n  not perform certain kinds of\n  optimizations (e.g., tail recursion).\n  In general, because Python\'s extremely\n  dynamic nature, it is impossible to do\n  the kind of compile-time optimization\n  known from functional languages like\n  Haskell or ML. And that\'s fine.I pull two things out of this:Scheme doesn\'t have algebraic data types or pattern matching but it\'s certainly a functional language. Annoying things about Python from a functional programming perspective:Crippled Lambdas. Since Lambdas can only contain an expression, and you can\'t do everything as easily in an expression context, this means that the functions you can define "on the fly" are limited.Ifs are statements, not expressions. This means, among other things, you can\'t have a lambda with an If inside it. (This is fixed by ternaries in Python 2.5, but it looks ugly.)Guido threatens to remove map, filter, and reduce every once in awhileOn the other hand, python has lexical closures, Lambdas, and list comprehensions (which are really a "functional" concept whether or not Guido admits it). I do plenty of "functional-style" programming in Python, but I\'d hardly say it\'s ideal.I would never call Python \xe2\x80\x9cfunctional\xe2\x80\x9d but whenever I program in Python the code invariably ends up being almost purely functional.Admittedly, that\'s mainly due to the extremely nice list comprehension. So I wouldn\'t necessarily suggest Python as a functional programming language but I would suggest functional programming for anyone using Python.Let me demonstrate with a piece of code taken from an answer to a "functional" Python question on SOPython:Haskell:The main difference here is that Haskell\'s standard library has useful functions for functional programming: in this case iterate, concat, and (!!)Python is almost a functional language.  It\'s "functional lite".  It has extra features, so it isn\'t pure enough for some.  It also lacks some features, so it isn\'t complete enough for some.  The missing features are relatively easy to write.  Check out posts like this on FP in Python.One thing that is really important for this question (and the answers) is the following:\nWhat the hell is functional programming, and what are the most important properties of it.\nI\'ll try to give my view of it:Functional programming is a lot like writing math on a whiteboard. When you write equations\non a whiteboard, you do not think about an execution order. There is (typically) no mutation.\nYou don\'t come back the day after and look at it, and when you make the calculations again,\nyou get a different result (or you may, if you\'ve had some fresh coffee :)). Basically,\nwhat is on the board is there, and the answer was already there when you started writing\nthings down, you just haven\'t realized what it is yet.Functional programming is a lot like that; you don\'t change things, you just evaluate\nthe equation (or in this case, "program") and figure out what the answer is. The program\nis still there, unmodified. The same with the data.I would rank the following as the most important features of functional programming:\na) referential transparency - if you evaluate the same statement at some other time\n   and place, but with the same variable values, it will still mean the same.\nb) no side effect - no matter how long you stare at the whiteboard, the equation another\n   guy is looking at at another whiteboard won\'t accidentally change.\nc) functions are values too. which can be passed around and applied with, or to, other\n   variables.\nd) function composition, you can do h=g\xc2\xb7f and thus define a new function h(..) which is\n   equivalent to calling g(f(..)).This list is in my prioritized order, so referential transparency is the most important,\nfollowed by no side effects.Now, if you go through python and check how well the language and libraries supports,\nand guarantees, these aspects - then you are well on the way to answer your own question.Another reason not mentioned above is that many built-in functions and methods of built-in types modify and object but do not return the modified object. Functional code would be cleaner and more concise, for example, if some_list.append(some_object) returned some_list with some_object appended.In addition to other answers, one reason Python and most other multi-paradigm languages are not well suited for true functional programming is because their compilers / virtual machines / run-times do not support functional optimization.  This sort of optimization is achieved by the compiler understanding mathematical rules.  For example, many programming languages support a map function or method.  This is a fairly standard function that takes a function as one argument and a iterable as the second argument then applies that function to each element in the iterable.  Anyways it turns out that map( foo() , x ) * map( foo(), y ) is the same as map( foo(), x * y ).  The latter case is actually faster than the former because the former performs two copies where the latter performs one.Better functional languages recognize these mathematically based relationships and automatically perform the optimization.  Languages that aren\'t dedicated to the functional paradigm will likely not optimize.