For example, if I want to read the middle value from magic(5), I can do so like this:to get value == 13. I\'d like to be able to do something like one of these:to dispense with the intermediate variable. However, MATLAB complains about Unbalanced or unexpected parenthesis or bracket on the first parenthesis before the 3.Is it possible to read values from an array/matrix without first assigning it to a variable?It actually is possible to do what you want, but only if you use the functional form of the indexing operator. When you perform an indexing operation using (), you are actually making a call to the SUBSREF function. So, even though you can\'t do this:You can do this:Ugly, but possible, ;)In general, you just have to change the indexing step to a function call so you don\'t have two sets of parentheses immediately following one another. Another way to do this would be to define your own anonymous function to do the subscripted indexing:However, when all is said and done the temporary local variable solution is much more readable, and definitely what I would suggest.There was just good blog post on Loren on the Art of Matlab a couple days ago with a couple gems that might help. In particular, using helper functions like:where paren() can be used likewould returnI would also surmise that this will be faster than gnovice\'s answer, but I haven\'t checked (Use the profiler!!!). That being said, you also have to include these function definitions somewhere. I personally have made them independent functions in my path, because they are super useful.These functions and others are now available in the Functional Programming Constructs add-on which is available through the MATLAB Add-On Explorer or on the File Exchange.How do you feel about using undocumented features:or for cell arrays:Just like magic :)Bad news, the above hack doesn\'t work anymore in R2015b! That\'s fine, it was undocumented functionality and we cannot rely on it as a supported feature :)For those wondering where to find this type of thing, look in the folder fullfile(matlabroot,\'bin\',\'registry\'). There\'s a bunch of XML files there that list all kinds of goodies. Be warned that calling some of these functions directly can easily crash your MATLAB session.At least in MATLAB 2013a you can use getfield like:to get the element at (1,2) unfortunately syntax like magic(5)(3,3) is not supported by matlab. you need to use temporary intermediate variables. you can free up the memory after use, e.g.Note that if you compare running times with the standard way (asign the result and then access entries), they are exactly the same.To my opinion, the bottom line is : MATLAB does not have pointers, you have to live with it.CheersIt could be more simple if you make a new function: and then use it:Your initial notation is the most concise way to do this:If you are doing this in a loop you can just reassign M every time and ignore the clear statement as well.  To complement Amro\'s answer, you can use feval instead of builtin. There is no difference, really, unless you try to overload the operator function:BUILTIN(...) is the same as FEVAL(...) except that it will call the\n  original built-in version of the function even if an overloaded one\n  exists (for this to work, you must never overload\n  BUILTIN).What\'s interesting is that feval seems to be just a tiny bit quicker than builtin (by ~3.5%), at least in Matlab 2013b, which is weird given that feval needs to check if the function is overloaded, unlike builtin: