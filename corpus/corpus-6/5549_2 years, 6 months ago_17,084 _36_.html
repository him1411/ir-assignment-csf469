Also works for tuples with multiple elements, both versions seem to grow linearly:Based on this, I think I should totally start using in everywhere instead of ==!As I mentioned to David Wolever, there\'s more to this than meets the eye; both methods dispatch to is; you can prove this by doingThe first can only be so fast because it checks by identity.To find out why one would take longer than the other, let\'s trace through execution.They both start in ceval.c, from COMPARE_OP since that is the bytecode involvedThis pops the values from the stack (technically it only pops one)and runs the compare:cmp_outcome is this:This is where the paths split. The PyCmp_IN branch doesNote that a tuple is defined asSo the branchwill be taken and *sqm->sq_contains, which is the function (objobjproc)tuplecontains, will be taken.This does...Wait, wasn\'t that PyObject_RichCompareBool what the other branch took? Nope, that was PyObject_RichCompare.That code path was short so it likely just comes down to the speed of these two. Let\'s compare.The code path in PyObject_RichCompareBool pretty much immediately terminates. For PyObject_RichCompare, it doesThe Py_EnterRecursiveCall/Py_LeaveRecursiveCall combo are not taken in the previous path, but these are relatively quick macros that\'ll short-circuit after incrementing and decrementing some globals.do_richcompare does:This does some quick checks to call v->ob_type->tp_richcompare which iswhich doesNamely, this shortcuts on left == right... but only after doing All in all the paths then look something like this (manually recursively inlining, unrolling and pruning known branches)vsNow, PyUnicode_Check and PyUnicode_READY are pretty cheap since they only check a couple of fields, but it should be obvious that the top one is a smaller code path, it has fewer function calls, only one switch\nstatement and is just a bit thinner.Both dispatch to if (left_pointer == right_pointer); the difference is just how much work they do to get there. in just does less.There are three factors at play here which, combined, produce this surprising behavior.First: the in operator takes a shortcut and checks identity (x is y) before it checks equality (x == y):Second: because of Python\'s string interning, both "x"s in "x" in ("x", ) will be identical:(big warning: this is implementation-specific behavior! is should never be used to compare strings because it will give surprising answers sometimes; for example "x" * 100 is "x" * 100 ==> False)Third: as detailed in Veedrac\'s fantastic answer, tuple.__contains__ (x in (y, ) is roughly equivalent to (y, ).__contains__(x)) gets to the point of performing the identity check faster than str.__eq__ (again, x == y is roughly equivalent to x.__eq__(y)) does.You can see evidence for this because x in (y, ) is significantly slower than the logically equivalent, x == y:The x in (y, ) case is slower because, after the is comparison fails, the in operator falls back to normal equality checking (i.e., using ==), so the comparison takes about the same amount of time as ==, rendering the entire operation slower because of the overhead of creating the tuple, walking its members, etc.Note also that a in (b, ) is only faster when a is b:(why is a in (b, ) faster than a is b or a == b? My guess would be fewer virtual machine instructions \xe2\x80\x94\xc2\xa0a in (b, ) is only ~3 instructions, where a is b or a == b will be quite a few more VM instructions)Veedrac\'s answer \xe2\x80\x94 https://stackoverflow.com/a/28889838/71522 \xe2\x80\x94 goes into much more detail on specifically what happens during each of == and in and is well worth the read.