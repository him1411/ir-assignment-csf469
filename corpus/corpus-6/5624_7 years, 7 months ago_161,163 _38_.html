Exactly the same as this question, but there must be a way to do it without the Sites module. That\'s just silly... I shouldn\'t need to query my DB to snag the URL!I want to use it with reverse().Use handy request.build_absolute_uri() method on request, pass it the relative url and it\'ll give you full one.By default, the absolute URL for request.get_full_path() is returned, but you can pass it a relative URL as the first argument to convert it to an absolute URL.If you want to use it with reverse() you can do this : request.build_absolute_uri(reverse(\'view_name\', args=(obj.pk, )))You can also use get_current_site as part of the sites app (from django.contrib.sites.models import get_current_site). It takes a request object, and defaults to the site object you have configured with SITE_ID in settings.py if request is None. Read more in documentation for using the sites frameworke.g.It isn\'t as compact/neat as request.build_absolute_url(), but it is usable when request objects are unavailable, and you have a default site url.If you can\'t get access to request then you can\'t use get_current_site(request) as recommended in some solutions here. You can use a combination of the native Sites framework and get_absolute_url instead. Set up at least one Site in the admin, make sure your model has a get_absolute_url() method, then:https://docs.djangoproject.com/en/dev/ref/contrib/sites/#getting-the-current-domain-for-full-urlsIf you don\'t want to hit the database, you could do it with a setting.  Then, use a context processor to add it to every template:Examine Request.META dictionary that comes in. I think it has server name and server port.To create a complete link to another page from a template, you can use this:request.META.HTTP_HOST gives the host name, and url gives the relative name.  The template engine then concatenates them into a complete url.If you\'re trying to do this in a Django template, I\'ve released a tiny PyPI package django-fullurl to let you replace url and static template tags with fullurl and fullstatic, like this:These badges should hopefully stay up-to-date automatically:    In a view, you can of course use request.build_absolute_uri instead.Yet another way. You could use build_absolute_uri() in your view.py and pass it to the template.view.pyyour-template.htmlI know this is an old question. But I think people still run into this a lot.There are a couple of libraries out there that supplement the default Django functionality. I have tried a few. I like the following library when reverse referencing absolute urls:https://github.com/fusionbox/django-absoluteuriAnother one I like because you can easily put together a domain, protocol and path is:https://github.com/RRMoelker/django-full-urlThis library allows you to simply write what you want in your template, e.g.:In your view, just do this:Try the following code:If you\'re using django REST framework, you can use the reverse function from rest_framework.reverse. This has the same behavior as django.core.urlresolvers.reverse, except that it uses a request parameter to build a full URL.Edited to mention availability only in REST frameworkI got it:Get the full uri with schema, host, port path and query.request.get_host() will give you the domain.You can try "request.get_full_path()"You can also use:This is working fine for me, I\'m not entirely sure how it works. I believe this is a bit more low level and will return your server hostname, which might be different than the hostname used by your user to get to your page. 