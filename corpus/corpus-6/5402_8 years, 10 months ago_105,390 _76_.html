This could be the dumbest question ever asked but I think it is a total confusion for a newbie. A nice example (in Java) will be really appreciated.Immutable means that once the constructor for an object has completed execution that instance can\'t be altered.This is useful as it means you can pass references to the object around, without worrying that someone else is going to change its contents. Especially when dealing with concurrency, there are no locking issues with objects that never changee.g.Foo doesn\'t have to worry that the caller to getValue() might change the text in the string.If you imagine a similar class to Foo, but with a StringBuilder rather than a String as a member, you can see that a caller to getValue() would be able to alter the StringBuilder attribute of a Foo instance.Also beware of the different kinds of immutability you might find: Eric Lippert wrote a blog article about this. Basically you can have objects whose interface is immutable but behind the scenes actual mutables private state (and therefore can\'t be shared safely between threads).An immutable object is an object where the internal fields (or at least, all the internal fields that affect its external behavior) cannot be changed.There are a lot of advantages to immutable strings:Performance: Take the following operation:The underlying C for the substring() method is probably something like this:Note that none of the characters have to be copied!  If the String object were mutable (the characters could change later) then you would have to copy all the characters, otherwise changes to characters in the substring would be reflected in the other string later.Concurrency: If the internal structure of an immutable object is valid, it will always be valid.  There\'s no chance that different threads can create an invalid state within that object. Hence, immutable objects are Thread Safe.Garbage collection: It\'s much easier for the garbage collector to make logical decisions about immutable objects.However, there are also downsides to immutability:Performance: Wait, I thought you said performance was an upside of immutability!  Well, it is sometimes, but not always.  Take the following code:The two lines both replace the fourth character with the letter "a".  Not only is the second piece of code more readable, it\'s faster.  Look at how you would have to do the underlying code for foo.  The substrings are easy, but now because there\'s already a character at space five and something else might be referencing foo, you can\'t just change it; you have to copy the whole string (of course some of this functionality is abstracted into functions in the real underlying C, but the point here is to show the code that gets executed all in one place).Note that concatenate gets called twice meaning that the entire string has to be looped through!  Compare this to the C code for the bar operation:The mutable string operation is obviously much faster.In Conclusion: In most cases, you want an immutable string.  But if you need to do a lot of appending and inserting into a string, you need the mutability for speed.  If you want the concurrency safety and garbage collection benefits with it the key is to keep your mutable objects local to a method:Since the mutable object is a local reference, you don\'t have to worry about concurrency safety (only one thread ever touches it).  And since it isn\'t referenced anywhere else, it is only allocated on the stack, so it is deallocated as soon as the function call is finished (you don\'t have to worry about garbage collection).  And you get all the performance benefits of both mutability and immutability.Actually String is not immutable if you use the wikipedia definition suggested above. String\'s state does change post construction. Take a look at the hashcode() method.  String caches the hashcode value in a local field but does not calculate it until the first call of hashcode().  This lazy evaluation of hashcode places String in an interesting position as an immutable object whose state changes, but it cannot be observed to have changed without using reflection. So maybe the definition of immutable should be an object that cannot be observed to have changed. If the state changes in an immutable object after it has been created but no-one can see it (without reflection) is the object still immutable?Immutable objects are objects that can\'t be changed programmatically. They\'re especially good for multi-threaded environments or other environments where more than one process is able to alter (mutate) the values in an object.Just to clarify, however, StringBuilder is actually a mutable object, not an immutable one. A regular java String is immutable (meaning that once it\'s been created you cannot change the underlying string without changing the object).For example, let\'s say that I have a class called ColoredString that has a String value and a String color:In this example, the ColoredString is said to be mutable because you can change (mutate) one of its key properties without creating a new ColoredString class. The reason why this may be bad is, for example, let\'s say you have a GUI application which has multiple threads and you are using ColoredStrings to print data to the window. If you have an instance of ColoredString which was created asThen you would expect the string to always be "Blue". If another thread, however, got ahold of this instance and calledYou would suddenly, and probably unexpectedly, now have a "Red" string when you wanted a "Blue" one. Because of this, immutable objects are almost always preferred when passing instances of objects around. When you have a case where mutable objects are really necessary, then you would typically guard the objet by only passing copies out from your specific field of control.To recap, in Java, java.lang.String is an immutable object (it cannot be changed once it\'s created) and java.lang.StringBuilder is a mutable object because it can be changed without creating a new instance."immutable" means you cannot change value. If you have an instance of String class, any method you call which seems to modify the value, will actually create another String.To preserve changes you should do something like this\n    foo = foo.sustring(3);Immutable vs mutable can be funny when you work with collections. Think about what will happen if you use mutable object as a key for map and then change the value (tip: think about equals and hashCode).String s1 = "Old string"; String s2 = s1; s1 = "New String";The original string \'in memory\' didn\'t change, but the\n  reference variable was changed so that it refers to the new string.\n  And if we didn\'t have s2, "Old String" would still be in the memory but\n  we\'ll not be able to access it...I really like the explaination from SCJP Sun Certified Programmer for Java 5 Study Guide.To make Java more memory efficient, the JVM sets aside a special area of  memory called the "String constant pool." When the compiler encounters a String literal, it checks the pool to see if  an identical String already exists. If  a match is found, the reference to the new literal is directed to the existing String, and no new String literal object is created. Objects which are immutable can not have their state changed after they have been created.There are three main reasons to use immutable objects whenever you can, all of which will help to reduce the number of bugs you introduce in your code:There are also some other optimisations you might be able to make in code when you know that the state of an object is immutable - caching the calculated hash, for example - but these are optimisations and therefore not nearly so interesting.It might be a bit late but in order to understand what an immutable object is, consider the following example from the new Java 8 Date and Time API (java.time). As you probably know all date objects from Java 8 are immutable so in the following exampleOutput:2014-03-18This prints the same year as the initial date because the plusYears(2) returns a new object so the old date is still unchanged because it\'s an immutable object. Once created you cannot further modify it and the date variable still points to it.So, that code example should capture and use the new object instantiated and returned by that call to plusYears.date.toString()\xe2\x80\xa6 2014-03-18dateAfterTwoYears.toString()\xe2\x80\xa6 2016-03-18One meaning has to do with how the value is stored in the computer,  For a .Net string for example, it means that the string in memory cannot be changed,   When you think you\'re changing it, you are in fact creating a new string in memory and pointing the existing variable (which is just a pointer to the actual collection of characters somewhere else) to the new string. Once instanciated, cannot be altered. Consider a class that an instance of might be used as the key for a hashtable or similar. Check out Java best practices.Immutable means that once the object is created, non of its members will change. String is immutable since you can not change its content.\nFor example:In the code above, the string s1 did not change, another object (s2) was created using s1.s1="Hi" : an object s1 was created with "Hi" value in it.s2=s1   : an object s2 is created with reference to s1 object.s1="Bye" : the previous s1 object\'s value doesn\'t change because s1 has String type and String type is an immutable type, instead compiler create a new String object with "Bye" value and s1 referenced to it. here when we print s2 value, the result will be "Hi" not "Bye" because s2 referenced to previous s1 object which had "Hi" value.Immutable ObjectsAn object is considered immutable if its state cannot change after it is constructed. Maximum reliance on immutable objects is widely accepted as a sound strategy for creating simple, reliable code.Immutable objects are particularly useful in concurrent applications. Since they cannot change state, they cannot be corrupted by thread interference or observed in an inconsistent state.Programmers are often reluctant to employ immutable objects, because they worry about the cost of creating a new object as opposed to updating an object in place. The impact of object creation is often overestimated, and can be offset by some of the efficiencies associated with immutable objects. These include decreased overhead due to garbage collection, and the elimination of code needed to protect mutable objects from corruption.The following subsections take a class whose instances are mutable and derives a class with immutable instances from it. In so doing, they give general rules for this kind of conversion and demonstrate some of the advantages of immutable objects.SourceWhat is an Immutable Object ?As per the Java Reference Documentation,\n"An object is considered immutable if its state cannot change after it is constructed"\nSimply an immutable class is a class whose properties can not be modified after creation. That means at creation, all of the instance data is provided and remain unchanged till the destruction of the objects.Why Immutable Objects ?Immutable classes are great for concurrent applications. As per their immutable nature, they help to maintain the application in non-corrupted and consistent behavior as the state of the instances can not be changed.ConcernsImmutable classes are easy to design, develop and use as they are more error resistant and secure due to the immutability. However programmers reluctant to use them due to the re -usability limitation. Also it may have an performance impact on object creation than reusing. However with the latest sophisticated compilers, the cost of creation is a minimal. Also the provided capabilities and the advantage of immutability can be adopted beyond the re-usability as per the need. How does this String append is working ?New String object is created with the given value and the reference is updated to the new instance isolating the old object.Reference : http://www.devdummy.com/2017/09/immutable-objects-in-java.htmlAn immutable object is the one you cannot modify after you create it. A typical example are string literals.A D programming language, which becomes increasingly popular, has a notion of "immutability" through "invariant" keyword. Check this Dr.Dobb\'s article about it - http://dobbscodetalk.com/index.php?option=com_myblog&show=Invariant-Strings.html&Itemid=29 . It explains the problem perfectly.