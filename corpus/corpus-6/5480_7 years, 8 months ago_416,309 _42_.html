This question already has an answer here:I\'m relatively new in C#, & I\'m wondering when to use Delegates appropriately.\nthey are widely used in events declaration , but when should I use them in my own code and why are they useful? why not to use something else?I\'m also wondering when I have to use delegates and I have no other alternative.Thank you for the help!EDIT: I think I\'ve found a necessary use of Delegates hereI agree with everything that is said already, just trying to put some other words on it.A delegate can be seen as a placeholder for a/some method(s).By defining a delegate, you are saying to the user of your class, "Please feel free to assign, any method that matches this signature, to the delegate and it will be called each time my delegate is called".Typical use is of course events. All the OnEventX delegate to the methods the user defines.Delegates are useful to offer to the user of your objects some ability to customize their behavior.\nMost of the time, you can use other ways to achieve the same purpose and I do not believe you can ever be forced to create delegates. It is just the easiest way in some situations to get the thing done.A delegate is a reference to a method. Whereas objects can easily be sent as parameters into methods, constructor or whatever, methods are a bit more tricky. But every once in a while you might feel the need to send a method as a parameter to another method, and that\'s when you\'ll need delegates. Say you want to write a procedure to integrate some real-valued function f (x) over some interval [a, b]. Say we want to use the 3-Point Gaussian method to do this (any will do, of course).Ideally we want some function that looks like:So we can pass in any Integrand, f, and get its definite integral over the closed interval.Just what type should Integrand be? Well, without delegates, we\'d need some sort of interface with a single method, say eval declared as follows:Then we\'d need to create a whole bunch of classes implementing this interface, as follows:Then to use them in our Gauss3 method, we need to invoke it as follows:And Gauss3 needs to do the look like the following:So we need to do all that just to use our arbitrary functions in Guass3.Now we can define some static (or not) functions adhering to that prototype:No interfaces, no clunky .eval stuff, no object instantiation, just simple function-pointer like usage, for a simple task.Of course, delegates are more than just function pointers under the hood, but that\'s a separate issue (function chaining and events).Delegates are extremely useful when wanting to declare a block of code that you want to pass around. For example when using a generic retry mechanism.Pseudo:Or when you want to do late evaluation of code blocks, like a function where you have some Transform action, and want to have a BeforeTransform and an AfterTransform action that you can evaluate within your Transform function, without having to know whether the BeginTransform is filled, or what it has to transform.And of course when creating event handlers. You don\'t want to evaluate the code now, but only when needed, so you register a delegate that can be invoked when the event occurs.Delegates have the following properties:I\'ve just go my head around these, and so I\'ll share an example as you already have descriptions but at the moment one advantage I see is to get around the Circular Reference style warnings where you can\'t have 2 projects referencing each other.Let\'s assume an application downloads an XML, and then saves the XML to a database. I have 2 projects here which build my solution: FTP and a SaveDatabase.So, our application starts by looking for any downloads and downloading the file(s) then  it calls the SaveDatabase project.Now, our application needs to notify the FTP site when a file is saved to the database by uploading a file with Meta data (ignore why, it\'s a request from the owner of the FTP site). The issue is at what point and how? We need a new method called NotifyFtpComplete()  but in which of our projects should it be saved too - FTP or SaveDatabase? Logically, the code should live in our FTP project. But, this would mean our NotifyFtpComplete will have to be triggered or, it will have to wait until the save is complete, and then query the database to ensure it is in there. What we need to do is tell our SaveDatabase project to call the NotifyFtpComplete() method direct but we can\'t; we\'d get a ciruclar reference and the NotifyFtpComplete() is a private method. What a shame, this would have worked. Well, it can. During our application\'s code, we would have passed parameters between methods, but what if one of those parameters was the NotifyFtpComplete method. Yup, we pass the method, with all of the code inside as well. This would mean we could execute the method at any point, from any project. Well, this is what the delegate is. This means, we can pass the NotifyFtpComplete() method as a parameter to our SaveDatabase() class. At the point it saves, it simply executes the delegate. See if this crude example helps (pseudo code). We will also assume that the application starts with the Begin() method of the FTP class.So, with that explained, we can do it for real now with this Console Application using C#I suggest you step through the code and see when _notice is called and when the method (delegate) is called as this, I hope, will make things very clear.However, lastly, we can make it more useful by changing the delegate type to include a parameter.I consider delegates to be Anonymous Interfaces. In many cases you can use them whenever you need an interface with a single method, but you don\'t want the overhead of defining that interface.A delegate is a simple class that is used to point to methods with a specific signature, becoming essentially a type-safe function pointer. A delegate\'s purpose is to facilitate a call back to another method (or methods), after one has been completed, in a structured way.While it could be possible to create an extensive set of code to perform this functionality, you don\xe2\x80\x99t need too. You can use a delegate.Creating a delegate is easy to do. Identify the class as a delegate with the "delegate" keyword. Then specify the signature of the type.