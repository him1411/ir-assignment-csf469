In Java 8, what\'s the difference between Stream.map and Stream.flatMap methods?Both map and flatMap can be applied to a Stream<T> and they both return a Stream<R>. The difference is that the map operation produces one output value for each input value, whereas the flatMap operation produces an arbitrary number (zero or more) values for each input value.This is reflected in the arguments to each operation.The map operation takes a Function, which is called for each value in the input stream and produces one result value, which is sent to the output stream.The flatMap operation takes a function that conceptually wants to consume one value and produce an arbitrary number of values. However, in Java, it\'s cumbersome for a method to return an arbitrary number of values, since methods can return only zero or one value. One could imagine an API where the mapper function for flatMap takes a value and returns an array or a List of values, which are then sent to the output. Given that this is the streams library, a particularly apt way to represent an arbitrary number of return values is for the mapper function itself to return a stream! The values from the stream returned by the mapper are drained from the stream and are passed to the output stream. The "clumps" of values returned by each call to the mapper function are not distinguished at all in the output stream, thus the output is said to have been "flattened."Typical use is for the mapper function of flatMap to return Stream.empty() if it wants to send zero values, or something like Stream.of(a, b, c) if it wants to return several values. But of course any stream can be returned.Stream.flatMap, as it can be guessed by its name, is the combination of a map and a flat operation. That means that you first apply a function to your elements, and then flatten it. Stream.map only applies a function to the stream without flattening the stream.To understand what flattening a stream consists in, consider a structure like [ [1,2,3],[4,5,6],[7,8,9] ] which has "two levels". Flattening this means transforming it in a "one level" structure : [ 1,2,3,4,5,6,7,8,9 ].I would like to give 2 examples to get a more practical point of view:\n1st example making usage of map:Nothing Special into the 1st example, a Function is applied to return the String in uppercase.2nd example making usage of flatmap:In the second example, a Stream of List is passed. It is NOT a Stream of Integer!\nIf a tranformation Function has to be used (through map), then first the Stream has to be flattened to something else (a Stream of Integer).\nIf flatMap is removed then the following error is returned: The operator + is undefined for the argument type(s) List, int.\nIt is NOT possible to apply + 1 on a List of Integers!Please go through the post fully to get clear idea,\nmap vs flatMap:\nTo return a length  of each word from a list, we would do something like below..\nFor example:- Consider a list [\xe2\x80\x9cSTACK\xe2\x80\x9d,\xe2\x80\x9dOOOVVVER\xe2\x80\x9d] and we are trying to return a list like [\xe2\x80\x9cSTACKOVER\xe2\x80\x9d](returning only unique letters from that list)\nInitially we would do something like below to return a list  [\xe2\x80\x9cSTACKOVER\xe2\x80\x9d]  from  [\xe2\x80\x9cSTACK\xe2\x80\x9d,\xe2\x80\x9dOOOVVVER\xe2\x80\x9d]Here the issue is , Lambda passed to the map method returns a String array for each word, So the stream returned by the map method is actually of type Stream, But what we need is Stream to represent a stream of characters, below image illustrates the problem.Figure A:You might think that, We can resolve this problem using flatmap, OK, let us see how to solve this by using map and Arrays.stream\nFirst of all you gonna need a stream of characters instead of a stream of arrays. There is a method called Arrays.stream() that would take an array and produces a stream, for example:\nThe above still does not work, because we now end up with a list of streams (more precisely, Stream>), Instead, we must first convert each word in to an array of individual letters and then make each array into a separate streamBy using flatMap we should be able to fix this problem as below:flatMap would perform mapping each array not with stream but with the contents of that stream.All of the individual streams that would get generated while using map(Arrays::stream) get merged in to a single stream. Figure B illustrates the effect of using the flatMap method. Compare it with what map does in figure A.\nFigure B\nThe flatMap method lets you replace each value of a stream with another stream and then joins all the generated streams into a single stream.The function you pass to stream.map has to return one object. That means each object in the input stream results in exactly one object in the output stream.The function you pass to stream.flatMap returns a stream for each object. That means the function can return any number of objects for each input object (including none). The resulting streams are then concatenated to one output stream.Oracle\'s article on Optional highlights this difference between map and flatmap: Unfortunately, this code doesn\'t compile. Why? The variable computer\n  is of type Optional<Computer>, so it is perfectly correct to call the\n  map method. However, getSoundcard() returns an object of type\n  Optional. This means the result of the map operation is an\n  object of type Optional<Optional<Soundcard>>. As a result, the call to\n  getUSB() is invalid because the outermost Optional contains as its\n  value another Optional, which of course doesn\'t support the getUSB()\n  method.With streams, the flatMap method takes a function as an argument,\n  which returns another stream. This function is applied to each element\n  of a stream, which would result in a stream of streams. However,\n  flatMap has the effect of replacing each generated stream by the\n  contents of that stream. In other words, all the separate streams that\n  are generated by the function get amalgamated or "flattened" into one\n  single stream. What we want here is something similar, but we want to\n  "flatten" a two-level Optional into one.Optional also supports a flatMap method. Its purpose is to apply\n  the transformation function on the value of an Optional (just like the map\n  operation does) and then flatten the resulting two-level Optional into\n  a single one.So, to make our code correct, we need to rewrite it as follows using\n  flatMap:The first flatMap ensures that an Optional<Soundcard> is returned\n  instead of an Optional<Optional<Soundcard>>, and the second flatMap\n  achieves the same purpose to return an Optional<USB>. Note that the\n  third call just needs to be a map() because getVersion() returns a\n  String rather than an Optional object.http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.htmlMap :- \nThis method takes one Function as an argument and returns a new stream consisting of the results generated by applying the passed function to all the elements of the stream.Let\'s imagine, I have a list of integer values ( 1,2,3,4,5 ) and one function interface whose logic is square of passed integer. ( e -> e * e ). output :- As you can see, output is a new stream whose values are square of values of input stream.http://codedestine.com/java-8-stream-map-method/FlatMap :- \nThis method takes one Function as an argument, this function accepts one parameter T as an input argument and return one stream of parameter R as a return value. When this function is applied on each element of this stream, it produces a stream of new values. All the elements of these new streams generated by each element are then copied to a new stream, which will be a return value of this method. Let\'s image, I have a list of student objects, where each student can opt for multiple subjects.output :- As you can see, output is a new stream whose values are collection of all the elements of the streams return by each element of input stream.[ S1 , S2 , S3 ]  ->\n[ {"history","math","geography"}, {"economics","biology"}, {"science","math"} ] -> take unique subjects ->\n[economics, biology, geography, science, history, math]http://codedestine.com/java-8-stream-flatmap-method/I have a feeling that all answers here overengineer the problem. If you already understand how the map works that should be fairly simple to grasp.The flatmap() method is a special kind of map() which allows to flatten nested structures or avoid ending up with them.Examples:We can avoid having nested lists by using flatmap:where:Also good analogy can be with C# if you familiar with. Basically C# Select similar to java map and C# SelectMany java flatMap. Same applies to Kotlin for collections.