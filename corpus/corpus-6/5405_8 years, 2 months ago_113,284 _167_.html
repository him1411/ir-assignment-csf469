There is a lot of discussions of Python vs Ruby, and I all find them completely unhelpful, because they all turn around why feature X sucks in language Y, or that claim language Y doesn\'t have X, although in fact it does. I also know exactly why I prefer Python, but that\'s also subjective, and wouldn\'t help anybody choosing, as they might not have the same tastes in development as I do.It would therefore be interesting to list the differences, objectively. So no "Python\'s lambdas sucks". Instead explain what Ruby\'s lambdas can do that Python\'s can\'t. No subjectivity. Example code is good!Don\'t have several differences in one answer, please. And vote up the ones you know are correct, and down those you know are incorrect (or are subjective). Also, differences in syntax is not interesting. We know Python does with indentation what Ruby does with brackets and ends, and that @ is called self in Python.UPDATE: This is now a community wiki, so we can add the big differences here.In Ruby you have a reference to the class (self) already in the class body. In Python you don\'t have a reference to the class until after the class construction is finished.An example:self in this case is the class, and this code would print out "Kaka". There is no way to print out the class name or in other ways access the class from the class definition body in Python (outside method definitions).This lets you develop extensions to core classes.  Here\'s an example of a rails extension:Python (imagine there were no \'\'.startswith method):You could use it on any sequence (not just strings). In order to use it you should import it explicitly e.g., from some_module import starts_with.Ruby has first class regexps, $-variables, the awk/perl line by line input loop and other features that make it more suited to writing small shell scripts that munge text files or act as glue code for other programs.Thanks to the callcc statement. In Python you can create continuations by various techniques, but there is no support built in to the language.With the "do" statement you can create a multi-line anonymous function in Ruby, which will be passed in as an argument into the method in front of do, and called from there. In Python you would instead do this either by passing a method or with generators.Ruby:Python (Ruby blocks correspond to different constructs in Python):OrOrInterestingly, the convenience statement in Ruby for calling a block is called "yield", which in Python will create a generator.Ruby:Python:Although the principles are different, the result is strikingly similar.Python:Python has support for generators in the language. In Ruby 1.8 you can use the generator module which uses continuations to create a generator from a block. Or, you could just use a block/proc/lambda! Moreover, in Ruby 1.9 Fibers are, and can be used as, generators, and the Enumerator class is a built-in generator 4docs.python.org has this generator example:Contrast this with the above block examples.In Ruby, when you import a file with require, all the things defined in that file will end up in your global namespace. This causes namespace pollution. The solution to that is Rubys modules. But if you create a namespace with a module, then you have to use that namespace to access the contained classes.In Python, the file is a module, and you can import its contained names with from themodule import *, thereby polluting the namespace if you want. But you can also import just selected names with from themodule import aname, another or you can simply import themodule and then access the names with themodule.aname. If you want more levels in your namespace you can have packages, which are directories with modules and an __init__.py file.Docstrings are strings that are attached to modules, functions and methods and can be\nintrospected at runtime. This helps for creating such things as the help command and\nautomatic documentation.Ruby\'s equivalent are similar to javadocs, and located above the method instead of within it.  They can be retrieved at runtime from the files by using 1.9\'s Method#source_location example useRuby does not ("on purpose" -- see Ruby\'s website, see here how it\'s done in Ruby). It does reuse the module concept as a type of abstract classes.Python:Ruby:Python:Ruby:Python 2.7+:Ruby:Things similar to decorators can also be created in Ruby, and it can also be argued that they aren\'t as necessary as in Python.Ruby requires "end" or "}" to close all of its scopes, while Python uses white-space only.  There have been recent attempts in Ruby to allow for whitespace only indentation http://github.com/michaeledgar/seamlessRuby has the concepts of blocks, which are essentially syntactic sugar around a section of code; they are a way to create closures and pass them to another method which may or may not use the block. A block can be invoked later on through a yield statement.For example, a simple definition of an each method on Array might be something like:Then you can invoke this like so:Python has anonymous functions/closures/lambdas, but it doesn\'t quite have blocks since it\'s missing some of the useful syntactic sugar. However, there\'s at least one way to get it in an ad-hoc fashion. See, for example, here.Functions are first-class variables in Python.  You can declare a function, pass it around as an object, and overwrite it:This is a fundamental feature of modern scripting languages.  JavaScript and Lua do this, too.  Ruby doesn\'t treat functions this way; naming a function calls it.Of course, there are ways to do these things in Ruby, but they\'re not first-class operations.  For example, you can wrap a function with Proc.new to treat it as a variable--but then it\'s no longer a function; it\'s an object with a "call" method.Ruby functions aren\'t first-class objects.  Functions must be wrapped in an object to pass them around; the resulting object can\'t be treated like a function.  Functions can\'t be assigned in a first-class manner; instead, a function in its container object must be called to modify them.Ultimately all answers are going to be subjective at some level, and the answers posted so far pretty much prove that you can\'t point to any one feature that isn\'t doable in the other language in an equally nice (if not similar) way, since both languages are very concise and expressive.I like Python\'s syntax. However, you have to dig a bit deeper than syntax to find the true beauty of Ruby. There is zenlike beauty in Ruby\'s consistency. While no trivial example can possibly explain this completely, I\'ll try to come up with one here just to explain what I mean.Reverse the words in this string: When you think about how you would do it, you\'d do the following:In Ruby, you\'d do this:Exactly as you think about it, in the same sequence, one method call after another. In python, it would look more like this:It\'s not hard to understand, but it doesn\'t quite have the same flow. The subject (sentence) is buried in the middle. The operations are a mix of functions and object methods. This is a trivial example, but one discovers many different examples when really working with and understanding Ruby, especially on non-trivial tasks.Python has a "we\'re all adults here" mentality.  Thus, you\'ll find that Ruby has things like constants while Python doesn\'t (although Ruby\'s constants only raise a warning).  The Python way of thinking is that if you want to make something constant, you should put the variable names in all caps and not change it.For example, Ruby:Python:You can import only specific functions from a module in Python. In Ruby, you import the whole list of methods. You could "unimport" them in Ruby, but it\'s not what it\'s all about.EDIT:let\'s take this Ruby module :if you include it in your code :you\'ll see that both method1 and method2 have been added to your namespace. You can\'t import only method1. You either import them both or you don\'t import them at all. In Python you can import only the methods of your choosing. If this would have a name maybe it would be called selective importing?From Ruby\'s website:Similarities\nAs with Python, in Ruby,...Differences\nUnlike Python, in Ruby,...What Ruby has over Python are its scripting language capabilities. Scripting language in this context meaning to be used for "glue code" in shell scripts and general text manipulation.These are mostly shared with Perl. First-class built-in regular expressions, $-Variables, useful command line options like Perl (-a, -e) etc.Together with its terse yet epxressive syntax it is perfect for these kind of tasks.Python to me is more of a dynamically typed business language that is very easy to learn and has a neat syntax. Not as "cool" as Ruby but neat.\nWhat Python has over Ruby to me is the vast number of bindings for other libs. Bindings to Qt and other GUI libs, many game support libraries and and and. Ruby has much less. While much used bindings e.g. to Databases are of good quality I found niche libs to be better supported in Python even if for the same library there is also a Ruby binding.So, I\'d say both languages have its use and it is the task that defines which one to use. Both are easy enough to learn. I use them side-by-side. Ruby for scripting and Python for stand-alone apps.I don\'t think "Ruby has X and Python doesn\'t, while Python has Y and Ruby doesn\'t" is the most useful way to look at it. They\'re quite similar languages, with many shared abilities. To a large degree, the difference is what the language makes elegant and readable. To use an example you brought up, both do theoretically have lambdas, but Python programmers tend to avoid them, and constructs made using them do not look anywhere near as readable or idiomatic as in Ruby. So in Python, a good programmer will want to take a different route to solving the problem than he would in Ruby, just because it actually is the better way to do it.I\'d like to suggest a variant of the original question, "What does Ruby have that Python doesn\'t, and vice versa?" which admits the disappointing answer, "Well, what can you do with either Ruby or Python that can\'t be done in Intercal?" Nothing on that level, because Python and Ruby are both part of the vast royal family sitting on the throne of being Turing approximant.But what about this:What can be done gracefully and well in Python that can\'t be done in Ruby with such beauty and good engineering, or vice versa?That may be much more interesting than mere feature comparison.Python has an explicit, builtin syntax for list-comprehenions and generators whereas in Ruby you would use map and code blocks.Compareto"Variables that start with a capital letter becomes constants and can\'t be modified"Wrong. They can.You only get a warning if you do.Somewhat more on the infrastructure side:Python has much better integration with C++ (via things like Boost.Python, SIP, and Py++) than Ruby, where the options seem to be either write directly against the Ruby interpreter API (which you can do with Python as well, of course, but in both cases doing so is low level, tedious, and error prone) or use SWIG (which, while it works and definitely is great if you want to support many languages, isn\'t nearly as nice as Boost.Python or SIP if you are specifically looking to bind C++).Python has a number of web application environments (Django, Pylons/Turbogears, web.py, probably at least half a dozen others), whereas Ruby (effectively) has one: Rails. (Other Ruby web frameworks do exist, but seemingly have a hard time getting much traction against Rails). Is this aspect good or bad? Hard to say, and probably quite subjective; I can easily imagine arguments that the Python situation is better and that the Ruby situation is better.Culturally, the Python and Ruby communities seem somewhat different, but I can only hint at this as I don\'t have that much experience interacting with the Ruby community. I\'m adding this mostly in the hopes that someone who has a lot of experience with both can amplify (or reject) this statement.Shamelessly copy/pasted from: Alex Martelli answer on "What\'s better about Ruby than Python" thread from comp.lang.python mailing list. Aug 18 2003, 10:50 am Erik Max Francis\n  wrote:"Brandon J. Van Every" wrote:What\'s better about Ruby than Python?  I\'m sure there\'s something.\n      What is it?Wouldn\'t it make much more sense to ask Ruby people this, rather than\n    Python people?Might, or might not, depending on\n  one\'s purposes -- for example, if\n  one\'s purposes include a "sociological\n  study" of the Python community, then\n  putting questions to that community is\n  likely to prove more revealing of\n  information about it, than putting\n  them elsewhere:-).Personally, I gladly took the\n  opportunity to follow Dave Thomas\'\n  one-day Ruby tutorial at last OSCON. \n  Below a thin veneer of syntax\n  differences, I find Ruby and Python\n  amazingly similar -- if I was\n  computing the minimum spanning tree\n  among just about any set of languages,\n  I\'m pretty sure Python and Ruby would\n  be the first two leaves to coalesce\n  into an intermediate node:-).Sure, I do get weary, in Ruby, of\n  typing the silly "end" at the end of\n  each block (rather than just\n  unindenting) -- but then I do get to\n  avoid typing the equally-silly \':\'\n  which Python requires at the\n  start of each block, so that\'s almost a wash:-).  Other syntax\n  differences such as \'@foo\' versus\n  \'self.foo\', or the higher significance\n  of case in Ruby vs Python, are really\n  just about as irrelevant to me.Others no doubt base their choice of\n  programming languages on just such\n  issues, and they generate the hottest\n  debates -- but to me that\'s just an\n  example of one of Parkinson\'s Laws in\n  action (the amount on debate on an\n  issue is inversely proportional to the\n  issue\'s actual importance).Edit (by AM 6/19/2010 11:45): this is also known as "painting the\n  bikeshed" (or, for short,\n  "bikeshedding") -- the reference is,\n  again, to Northcote Parkinson, who\n  gave "debates on what color to paint\n  the bikeshed" as a typical example of\n  "hot debates on trivial topics".\n  (end-of-Edit).One syntax difference that I do find\n  important, and in Python\'s favor --\n  but other people will no doubt think\n  just the reverse -- is "how do you\n  call a function which takes no\n  parameters".  In Python (like in C),\n  to call a function you always apply\n  the "call operator" -- trailing\n  parentheses just after the object\n  you\'re calling (inside those trailing\n  parentheses go the args you\'re passing\n  in the call -- if you\'re passing no\n  args, then the parentheses are empty).\n  This leaves the mere mention of\n  any object, with no operator involved, as meaning just a reference\n  to the object -- in any context,\n  without special cases, exceptions,\n  ad-hoc rules, and the like.  In Ruby\n  (like in Pascal), to call a function\n  WITH arguments you pass the args\n  (normally in parentheses, though that\n  is not invariably the case) -- BUT if\n  the function takes no args then simply\n  mentioning the function implicitly\n  calls it.  This may meet the\n  expectations of many people (at least,\n  no doubt, those whose only previous\n  experience of programming was with\n  Pascal, or other languages with\n  similar "implicit calling", such as\n  Visual Basic) -- but to me, it means\n  the mere mention of an object may\n  EITHER mean a reference to the object,\n  OR a call to the object, depending on\n  the object\'s type -- and in those\n  cases where I can\'t get a reference to\n  the object by merely mentioning it I\n  will need to use explicit "give me a\n  reference to this, DON\'T call it!"\n  operators that aren\'t needed\n  otherwise. I feel this impacts the\n  "first-classness" of functions (or\n  methods, or other callable objects)\n  and the possibility of interchanging\n  objects smoothly.  Therefore, to me,\n  this specific syntax difference is a\n  serious black mark against Ruby -- but\n  I do understand why others would thing\n  otherwise, even though I could hardly\n  disagree more vehemently with them:-).Below the syntax, we get into some\n  important differences in elementary\n  semantics -- for example, strings in\n  Ruby are mutable objects (like in\n  C++), while in Python they are not\n  mutable (like in Java, or I believe\n  C#).  Again, people who judge\n  primarily by what they\'re already\n  familiar with may think this is a plus\n  for Ruby (unless they\'re familiar with\n  Java or C#, of course:-).  Me, I think\n  immutable strings are an excellent\n  idea (and I\'m not surprised that Java,\n  independently I think, reinvented that\n  idea which was already in Python),\n  though I wouldn\'t mind having a\n  "mutable string buffer" type as well\n  (and ideally one with better\n  ease-of-use than Java\'s own "string\n  buffers"); and I don\'t give this\n  judgment because of familiarity --\n  before studying Java, apart from\n  functional programming languages where\n  all data are immutable, all the languages I knew had mutable strings\n  -- yet when I first saw the immutable-string idea in Java (which I\n  learned well before I learned Python),\n  it immediately struck me as excellent,\n  a very good fit for the\n  reference-semantics of a higher level\n  programming language (as opposed to\n  the value-semantics that fit best with\n  languages closer to the machine and\n  farther from applications, such as C)\n  with strings as a first-class,\n  built-in (and pretty crucial) data\n  type.Ruby does have some advantages in\n  elementary semantics -- for example,\n  the removal of Python\'s "lists vs\n  tuples" exceedingly subtle\n  distinction.  But mostly the score (as\n  I keep it, with simplicity a big plus\n  and subtle, clever distinctions a\n  notable minus) is against Ruby (e.g.,\n  having both closed and half-open\n  intervals, with the notations a..b and\n  a...b [anybody wants to claim that\n  it\'s obvious which is which?-)], is\n  silly -- IMHO, of course!).  Again,\n  people who consider having a lot of\n  similar but subtly different things at\n  the core of a language a PLUS, rather\n  than a MINUS, will of course count\n  these "the other way around" from how\n  I count them:-).Don\'t be misled by these comparisons\n  into thinking the two languages are\n  very different, mind you.  They aren\'t.  But if I\'m asked to compare\n  "capelli d\'angelo" to "spaghettini",\n  after pointing out that these two\n  kinds of pasta are just about\n  undistinguishable to anybody and\n  interchangeable in any dish you might\n  want to prepare, I would then\n  inevitably have to move into\n  microscopic examination of how the\n  lengths and diameters imperceptibly\n  differ, how the ends of the strands\n  are tapered in one case and not in the\n  other, and so on -- to try and explain\n  why I, personally, would rather have\n  capelli d\'angelo as the pasta in any\n  kind of broth, but would prefer\n  spaghettini as the pastasciutta to go\n  with suitable sauces for such long\n  thin pasta forms (olive oil, minced\n  garlic, minced red peppers, and finely\n  ground anchovies, for example - but if\n  you sliced the garlic and peppers\n  instead of mincing them, then you\n  should choose the sounder body of\n  spaghetti rather than the thinner\n  evanescence of spaghettini, and would\n  be well advised to forego the achovies\n  and add instead some fresh spring\n  basil [or even -- I\'m a heretic...! --\n  light mint...] leaves -- at the very\n  last moment before serving the dish). \n  Ooops, sorry, it shows that I\'m\n  traveling abroad and haven\'t had pasta\n  for a while, I guess.  But the analogy\n  is still pretty good!-)So, back to Python and Ruby, we come\n  to the two biggies (in terms of\n  language proper -- leaving the\n  libraries, and other important\n  ancillaries such as tools and\n  environments, how to embed/extend each\n  language, etc, etc, out of it for now\n  -- they wouldn\'t apply to all IMPLEMENTATIONS of each language\n  anyway, e.g., Jython vs Classic Python\n  being two implementations of the\n  Python language!):Ruby\'s iterators and codeblocks vs Python\'s iterators    and generators;Ruby\'s TOTAL, unbridled "dynamicity", including the ability\n  to "reopen" any existing class,\n  including all built-in ones,    and\n  change its behavior at run-time -- vs\n  Python\'s vast but    bounded\n  dynamicity, which never changes the\n  behavior of    existing built-in\n  classes and their instances.Personally, I consider 1 a wash (the\n  differences are so deep that I could\n  easily see people hating either\n  approach and revering the other, but\n  on MY personal scales the pluses and\n  minuses just about even up); and 2 a\n  crucial issue -- one that makes Ruby\n  much more suitable for "tinkering",\n  BUT Python equally more suitable for\n  use in large production applications. \n  It\'s funny, in a way, because both\n  languages are so MUCH more dynamic\n  than most others, that in the end the\n  key difference between them from my\n  POV should hinge on that -- that Ruby\n  "goes to eleven" in this regard (the\n  reference here is to "Spinal Tap", of\n  course).  In Ruby, there are no limits\n  to my creativity -- if I decide that\n  all string comparisons must become\n  case-insensitive, I CAN DO THAT! \n  I.e., I can dynamically alter the\n  built-in string class so that\n      a = "Hello World"\n      b = "hello world"\n      if a == b\n          print "equal!\\n"\n      else\n          print "different!\\n"\n      end WILL print "equal".  In python, there is NO way I can do that.\n  For the purposes of metaprogramming,\n  implementing experimental frameworks,\n  and the like, this amazing dynamic\n  ability of Ruby is extremely\n  appealing.  BUT -- if we\'re talking\n  about large applications, developed by\n  many people and maintained by even\n  more, including all kinds of libraries\n  from diverse sources, and needing to\n  go into production in client sites...\n  well, I don\'t WANT a language that is\n  QUITE so dynamic, thank you very much.\n  I loathe the very idea of some library\n  unwittingly breaking other unrelated\n  ones that rely on those strings being\n  different -- that\'s the kind of deep\n  and deeply hidden "channel", between\n  pieces of code that LOOK separate and\n  SHOULD BE separate, that spells\n  d-e-a-t-h in large-scale programming. \n  By letting any module affect the\n  behavior of any other "covertly", the\n  ability to mutate the semantics of\n  built-in types is just a BAD idea for\n  production application programming,\n  just as it\'s cool for tinkering.If I had to use Ruby for such a large\n  application, I would try to rely on\n  coding-style restrictions, lots of\n  tests (to be rerun whenever ANYTHING\n  changes -- even what should be totally\n  unrelated...), and the like, to\n  prohibit use of this language feature.\n  But NOT having the feature in the\n  first place is even better, in my\n  opinion -- just as Python itself would\n  be an even better language for\n  application programming if a certain\n  number of built-ins could be "nailed\n  down", so I KNEW that, e.g.,\n  len("ciao") is 4 (rather than having\n  to worry subliminally about whether\n  somebody\'s changed the binding of name\n  \'len\' in the builtins module...). \n  I do hope that eventually Python does\n  "nail down" its built-ins.But the problem\'s minor, since\n  rebinding built-ins is quite a\n  deprecated as well as a rare practice\n  in Python.  In Ruby, it strikes me as\n  major -- just like the too powerful\n  macro facilities of other languages\n  (such as, say, Dylan) present similar\n  risks in my own opinion (I do hope\n  that Python never gets such a powerful\n  macro system, no matter the allure of\n  "letting people define their own\n  domain-specific little languages\n  embedded in the language itself" -- it\n  would, IMHO, impair Python\'s wonderful\n  usefulness for application\n  programming, by presenting an\n  "attractive nuisance" to the would-be\n  tinkerer who lurks in every\n  programmer\'s heart...).AlexSome others from:http://www.ruby-lang.org/en/documentation/ruby-from-other-languages/to-ruby-from-python/(If I have misintrepreted anything or any of these have changed on the Ruby side since that page was updated, someone feel free to edit...)Strings are mutable in Ruby, not in Python (where new strings are created by "changes").Ruby has some enforced case conventions, Python does not.Python has both lists and tuples (immutable lists). Ruby has arrays corresponding to Python lists, but no immutable variant of them.In Python, you can directly access object attributes.  In Ruby, it\'s always via methods.In Ruby, parentheses for method calls are usually optional, but not in Python.Ruby has public, private, and protected to enforce access, instead of Python\xe2\x80\x99s convention of using underscores and name mangling.Python has multiple inheritance.  Ruby has "mixins."And another very relevant link:http://c2.com/cgi/wiki?PythonVsRubyWhich, in particular, links to another good one by Alex Martelli, who\'s been also posting a lot of great stuff here on SO:http://groups.google.com/group/comp.lang.python/msg/028422d707512283I\'m unsure of this, so I add it as an answer first.That means you can call a method either like theobject.themethod() or by TheClass.themethod(anobject).Edit: Although the difference between methods and functions is small in Python, and non-existant in Python 3, it also doesn\'t exist in Ruby, simply because Ruby doesn\'t have functions. When you define functions, you are actually defining methods on Object.But you still can\'t take the method of one class and call it as a function, you would have to rebind it to the object you want to call on, which is much more obstuse.I would like to mention Python descriptor API that allows one customize object-to-attribute "communication". It is also noteworthy that, in Python, one is free to implement an alternative protocol via overriding the default given through the default implementation of the __getattribute__ method.\nLet me give more details about the aforementioned.\nDescriptors are regular classes with __get__, __set__ and/or __delete__ methods.\nWhen interpreter encounters something like anObj.anAttr, the following is performed:As was mentioned, this is the default behavior. One is free to change the protocol by re-implementing __getattribute__.This technique is lot more powerful than decorators.Ruby has builtin continuation support using callcc.Hence you can implement cool things like the amb-operatorAt this stage, Python still has better unicode supportPython has docstrings and ruby doesn\'t... Or if it doesn\'t, they are not accessible as easily as in python. Ps. If im wrong, pretty please, leave an example?  I have a workaround that i could monkeypatch into classes quite easily but i\'d like to have docstring kinda of a feature in "native way".Ruby has a line by line loop over input files (the \'-n\' flag) from the commandline so it can be used like AWK. This Ruby one-liner: will count lines like the AWK one-liner:Ruby gets feature this through Perl, which took it from AWK as a way of getting sysadmins on board with Perl without having to change the way they do things.Ruby has sigils and twigils, Python doesn\'t.Edit: And one very important thing that I forgot (after all, the previous was just to flame a little bit :-p):Python has a JIT compiler (Psyco), a sightly lower level language for writing faster code (Pyrex) and the ability to add inline C++ code (Weave).My python\'s rusty, so some of these may be in python and i just don\'t remember/never learned in the first place, but here are the first few that I thought of:Ruby handles whitespace completely different. For starters, you don\'t need to indent anything (which means it doesn\'t matter if you use 4 spaces or 1 tab). It also does smart line continuation, so the following is valid:Basically, if you end with an operator, it figures out what is going on.Ruby has mixins which can extend instances instead of full classes:I\'m not sure if this is the same as generators, but as of Ruby 1.9 ruby as enums, so Reference: http://blog.nuclearsquid.com/writings/ruby-1-9-what-s-new-what-s-changedBoth of the items listed there are supported in Ruby, although you can\'t skip default values like that.\nYou can either go in orderNote that c=5 actually assigns the variable c in the calling scope the value 5, and sets the parameter b the value 5.or you can do it with hashes, which address the second issueReference: The Pragmatic Progammer\'s Guide to RubyYou can have code in the class definition in both Ruby and Python. However, in Ruby you have a reference to the class (self). In Python you don\'t have a reference to the class, as the class isn\'t defined yet.An example:self in this case is the class, and this code would print out "Kaka". There is no way to print out the class name or in other ways access the class from the class definition body in Python.Syntax is not a minor thing, it has a direct impact on how we think.  It also has a direct effect on the rules we create for the systems we use.  As an example we have the order of operations because of the way we write mathematical equations or sentences.  The standard notation for mathematics allows people to read it more than one way and arrive at different answers given the same equation.  If we had used prefix or postfix notation we would have created rules to distinguish what the numbers to be manipulated were rather than only having rules for the order in which to compute values.The standard notation makes it plain what numbers we are talking about while making the order in which to compute them ambiguous.  Prefix and postfix notation make the order in which to compute plain while making the numbers ambiguous.  Python would already have multiline lambdas if it were not for the difficulties caused by the syntactic whitespace.  (Proposals do exist for pulling this kind of thing off without necessarily adding explicit block delimiters.)I find it easier to write conditions where I want something to occur if a condition is false much easier to write with the unless statement in Ruby than the semantically equivalent "if-not" construction in Ruby or other languages for example.  If most of the languages that people are using today are equal in power, how can the syntax of each language be considered a trivial thing?  After specific features like blocks and inheritance mechanisms etc.  syntax is the most important part of a language,hardly a superficial thing.What is superficial are the aesthetic qualities of beauty that we ascribe to syntax.  Aesthetics have nothing to do with how our cognition works, syntax does.Surprised to see nothing mentioned of ruby\'s "method missing" mechanism.  I\'d give examples of the find_by_... methods in Rails, as an example of the power of that language feature.  My guess is that something similar could be implemented in Python, but to my knowledge it isn\'t there natively.Another difference in lambdas between Python and Ruby is demonstrated by Paul Graham\'s Accumulator Generator problem.  Reprinted here:In Ruby, you can do this:In Python, you\'d create an object to hold the state of n:Some folks might prefer the explicit Python approach as being clearer conceptually, even if it\'s a bit more verbose.  You store state like you do for anything else.  You just need to wrap your head around the idea of callable objects.  But regardless of which approach one prefers aesthetically, it does show one respect in which Ruby lambdas are more powerful constructs than Python\'s.python has named optional argumentsAFAIK Ruby has only positioned arguments because b=2 in the function declaration is an affectation that always append.Ruby has embedded documentation:http://c2.com/cgi/wiki?PythonVsRuby\nhttp://c2.com/cgi/wiki?SwitchedFromPythonToRuby\nhttp://c2.com/cgi/wiki?SwitchedFromRubyToPython\nhttp://c2.com/cgi/wiki?UsingPythonDontNeedRuby\nhttp://c2.com/cgi/wiki?UsingRubyDontNeedPython In Ruby, when you import a file with\n  require, all the things defined in\n  that file will end up in your global\n  namespace.With Cargo you can "require libraries without cluttering your namespace".