The following query:yields:What I\'d like is only the top 5 results for each id:Is there a way to do this using some kind of LIMIT like modifier that works within the GROUP BY?You could use GROUP_CONCAT aggregated function to get all years into a single column, grouped by id and ordered by rate:Result:And then you could use FIND_IN_SET, that returns the position of the first argument inside the second one, eg.Using a combination of GROUP_CONCAT and FIND_IN_SET, and filtering by the position returned by find_in_set, you could then use this query that returns only the first 5 years for every id:Please see fiddle here.Please note that if more than one row can have the same rate, you should consider using GROUP_CONCAT(DISTINCT rate ORDER BY rate) on the rate column instead of the year column.The maximum length of the string returned by GROUP_CONCAT is limited, so this works well if you need to select a few records for every group.One trick is to number the rows in each group using user variables. Start with this query:This gives you the following result:Now wrap the query inside another query and filter the results where rank <= 5:And you have:For me something like works perfectly. No complicated query.for example: get top 1 for each groupNo, you can\'t LIMIT subqueries arbitrarily (you can do it to a limited extent in newer MySQLs, but not for 5 results per group).This is a groupwise-maximum type query, which is not trivial to do in SQL. There are various ways to tackle that which can be more efficient for some cases, but for top-n in general you\'ll want to look at Bill\'s answer to a similar previous question.As with most solutions to this problem, it can return more than five rows if there are multiple rows with the same rate value, so you may still need a quantity of post-processing to check for that.Try this: This requires a series of subqueries to rank the values, limit them, then perform the sum while groupingBuild the virtual columns\xef\xbc\x88like RowID in Oracle\xef\xbc\x89table:data:SQL like this:if delete the where clause in t3, it shows like this:GET "TOP N Record" --> add the "rownum <=3" in where clause(the where-clause of t3);CHOOSE "the year" --> add the "BETWEEN 2000 AND 2009" in where clause(the where-clause of t3);The following post: sql: selcting top N record per group describes the complicated way of achieving this without subqueries.It improves on other solutions offered here by:It is however not pretty. A good solution would be achievable were Window Functions (aka Analytic Functions) enabled in MySQL -- but they are not.\nThe trick used in said post utilizes GROUP_CONCAT, which is sometimes described as "poor man\'s Window Functions for MySQL".Took some working, but I thougth my solution would be something to share as it is seems elegant as well as quite fast.Note that this example is specified for the purpose of the question and can be modified quite easily for other similar purposes.The subquery is almost identical to your query. Only change is addingfor those like me that had queries time out. I made the below to use limits and anything else by a specific group.it loops through a list of domains and then inserts only a limit of 200 eachTry this:Please try below stored procedure. I have already verified. I am getting proper result but without using groupby.