I\'m trying to build a list of functions that can be used for arbitrary code execution. The purpose isn\'t to list functions that should be blacklisted or otherwise disallowed. Rather, I\'d like to have a grep-able list of red-flag keywords handy when searching a compromised server for back-doors.The idea is that if you want to build a multi-purpose malicious PHP script -- such as a "web shell" script like c99 or r57 -- you\'re going to have to use one or more of a relatively small set of functions somewhere in the file in order to allow the user to execute arbitrary code. Searching for those those functions helps you more quickly narrow down a haystack of tens-of-thousands of PHP files to a relatively small set of scripts that require closer examination.Clearly, for example, any of the following would be considered malicious (or terrible coding):and so forth. Searching through a compromised website the other day, I didn\'t notice a piece of malicious code because I didn\'t realize preg_replace could be made dangerous by the use of the /e flag (which, seriously? Why is that even there?). Are there any others that I missed?Here\'s my list so far:Shell Execute PHP ExecuteIt might also be useful to have a list of functions that are capable of modifying files, but I imagine 99% of the time exploit code will contain at least one of the functions above. But if you have a list of all the functions capable of editing or outputting files, post it and I\'ll include it here. (And I\'m not counting mysql_execute, since that\'s part of another class of exploit.)To build this list I used 2 sources.  A Study In Scarlet and RATS.   I have also added some of my own to the mix and people on this thread have helped out.Edit: After posting this list I contacted the founder of RIPS and as of now this tools searches PHP code for the use of every function in this list.Most of these function calls are classified as Sinks. When a tainted variable (like $_REQUEST) is passed to a sink function, then you have a vulnerability.  Programs like RATS and RIPS use grep like functionality to identify all sinks in an application.  This means that programmers should take extra care when using these functions,  but if they where all banned then you wouldn\'t be able to get much done.  "With great power comes great responsibility."--Stan Lee Apart from eval there are other ways to execute PHP code: include/require can be used for remote code execution in the form of Local File Include and Remote File Include vulnerabilities.These functions accept a string parameter which could be used to call a function of the attacker\'s choice.  Depending on the function the attacker may or may not have the ability to pass a parameter.  In that case an Information Disclosure function like phpinfo() could be used.Most of these function calls are not sinks.   But rather it maybe a vulnerability if any of the data returned is viewable to an attacker.  If an attacker can see phpinfo() it is definitely a vulnerability. According to RATS all filesystem functions in php are nasty. Some of these don\'t seem very useful to the attacker. Others are more useful than you might think. For instance if allow_url_fopen=On then a url can be used as a file path, so a call to copy($_GET[\'s\'], $_GET[\'d\']); can be used to upload a PHP script anywhere on the system. \nAlso if a site is vulnerable to a request send via GET everyone of those file system functions can be abused to channel and attack to another host through your server.You\'d have to scan for include($tmp) and require(HTTP_REFERER) and *_once as well. If an exploit script can write to a temporary file, it could just include that later. Basically  a two-step eval.  And it\'s even possible to hide remote code with workarounds like:Also, if your webserver has already been compromised you will not always see unencoded evil. Often the exploit shell is gzip-encoded. Think of include("zlib:script2.png.gz"); No eval here, still same effect.This is not an answer per se, but here\'s something interesting:In the same spirit, call_user_func_array() can be used to execute obfuscated functions.I\'m surprised no one has mentioned echo and print as points of security exploitation.Cross-Site Scripting (XSS) is a serious security exploit, because it\'s even more common than server-side code execution exploits.i\'d particularly want to add unserialize() to this list. It has had a long history of various vulnerabilities including arbitrary code execution, denial of service and memory information leakage. It should never be called on user-supplied data. Many of these vuls have been fixed in releases over the last dew years, but it still retains a couple of nasty vuls at the current time of writing.For other information about dodgy php functions/usage look around the Hardened PHP Project and its advisories. Also the recent Month of PHP Security and 2007\'s Month of PHP Bugs projects Also note that, by design, unserializing an object will cause the constructor and destructor functions to execute; another reason not to call it on user-supplied data.My VPS is set to disable the following functions:PHP has enough potentially destructible functions that your list might be too big to grep for. For example, PHP has chmod and chown, which could be used to simply deactivate a website.EDIT: Perhaps you may want to build a bash script that searches for a file for an array of functions grouped by danger (functions that are bad, functions that are worse, functions that should never be used), and then calculate the relativity of danger that the file imposes into a percentage. Then output this to a tree of the directory with the percentages tagged next to each file, if greater than a threshold of say, 30% danger.Also be aware of the class of "interruption vulnerabilities" that allow arbitrary memory locations to be read and written! These affect functions such as trim(), rtrim(), ltrim(), explode(), strchr(), strstr(), substr(), chunk_split(), strtok(), addcslashes(), str_repeat() and more. This is largely, but not exclusively, due to the call-time pass-by-reference feature of the language that has been deprecated for 10 years but not disabled.Fore more info, see Stefan Esser\xe2\x80\x99s talk about interruption vulnerabilities and other lower-level PHP issues at BlackHat USA 2009 Slides PaperThis paper/presentation also shows how dl() can be used to execute arbitrary system code.Plattform-specific, but also theoretical exec vectors:And there are many more disguising methods:Apart from the eval language construct there is another function which allows arbitrary code execution: assertOne source of interesting exploits has not been mentioned. PHP allows strings to have 0x00 bytes in them. Underlying (libc) functions treat this as the end of a string.This allows for situations where (poorly implemented) sanity-checking in PHP can be fooled, e.g. in a situation like:This might include any file - not just those ending in .php - by calling script.php?file=somefile%00.phpSo any function that will not obey PHP\'s string length may lead to some vulnerability.What about dangerous syntactic elements?The "variable variable" ($$var) will find a variable in the current scope by the name of $var. If used wrong, the remote user can modify or read any variable in the current scope. Basically a weaker eval.Ex: you write some code $$uservar = 1;, then the remote user sets $uservar to "admin", causing $admin to be set to 1 in the current scope.I guess you won\'t be able to really find all possible exploits by parsing your source files.also if there are really great lists provided in here, you can miss a function which can be exploitetthere still could be "hidden" evil code like this$myEvilRegex = base64_decode(\'Ly4qL2U=\');preg_replace($myEvilRegex, $_POST[\'code\']);you could now say, i simply extend my script to also match thisbut then you will have that mayn "possibly evil code" which additionally is out of it\'s contextso to be (pseudo-)secure, you should really write good code and read all existing code yourselfBacktick Operator Backtick on php manualI know move_uploaded_file has been mentioned, but file uploading in general is very dangerous. Just the presence of $_FILES should raise some concern.It\'s quite possible to embed PHP code into any type of file. Images can be especially vulnerable with text comments. The problem is particularly troublesome if the code accepts the extension found within the $_FILES data as-is.For example, a user could upload a valid PNG file with embedded PHP code as "foo.php". If the script is particularly naive, it may actually copy the file as "/uploads/foo.php". If the server is configured to allow script execution in user upload directories (often the case, and a terrible oversight), then you instantly can run any arbitrary PHP code. (Even if the image is saved as .png, it might be possible to get the code to execute via other security flaws.)A (non-exhaustive) list of things to check on uploads:Let\'s add pcntl_signal and pcntl_alarm to the list.With the help of those functions you can work around any set_time_limit restriction created int the php.ini or in the script.This script for example will run for 10 seconds despite of set_time_limit(1);(Credit goes to Sebastian Bergmanns tweet and gist: There are loads of PHP exploits which can be disabled by settings in the PHP.ini file. Obvious example is register_globals, but depending on settings it may also be possible to include or open files from remote machines via HTTP, which can be exploited if a program uses variable filenames for any of its include() or file handling functions.PHP also allows variable function calling by adding () to the end of a variable name -- eg $myvariable(); will call the function name specified by the variable. This is exploitable; eg if an attacker can get the variable to contain the word \'eval\', and can control the parameter, then he can do anything he wants, even though the program doesn\'t actually contain the eval() function.These functions can also have some nasty effects.The first two can exhaust all the available memory and the latter keep the exhaustion going...There was some discussion of this on security.stackexchange.com recentlyfunctions that can be used for arbitrary code executionWell that reduces the scope a little - but since \'print\' can be used to inject javascript (and therefore steal sessions etc) its still somewhat arbitrary.isn\'t to list functions that should be blacklisted or otherwise disallowed. Rather, I\'d like to have a grep-able listThat\'s a sensible approach.Do consider writing your own parser though - very soon you\'re going to find a grep based approach getting out of control (awk would be a bit better). Pretty soon you\'re also going to start wishing you\'d implemented a whitelist too!In addition to the obvious ones, I\'d recommend flagging up anything which does an include with an argument of anything other than a string literal. Watch out for __autoload() too.I fear my answer might be a bit too negative, but...IMHO, every single function and method out there can be used for nefarious purposes.  Think of it as a trickle-down effect of nefariousness: a variable gets assigned to a user or remote input, the variable is used in a function, the function return value used in a class property, the class property used in a file function, and so forth.  Remember: a forged IP address or a man-in-the-middle attack can exploit your entire website.Your best bet is to trace from beginning to end any possible user or remote input, starting with $_SERVER, $_GET, $_POST, $_FILE, $_COOKIE, include(some remote file) (if allow_url_fopen is on), all other functions/classes dealing with remote files, etc.  You programatically build a stack-trace profile of each user- or remote-supplied value.  This can be done programatically by getting all repeat instances of the assigned variable and functions or methods it\'s used in, then recursively compiling a list of all occurrences of those functions/methods, and so on.  Examine it to ensure it first goes through the proper filtering and validating functions relative to all other functions it touches.  This is of course a manual examination, otherwise you\'ll have a total number of case switches equal to the number of functions and methods in PHP (including user defined).Alternatively for handling only user input, have a static controller class initialized at the beginning of all scripts which 1) validates and stores all user-supplied input values against a white-list of allowed purposes; 2) wipes that input source (ie $_SERVER = null).  You can see where this gets a little Naziesque.Here is a list of functions my provider disables for security purposes:Most of attacks in the code use multiple access sources, or multiple steps to execute themselves. I would search not only for a code, or method having malicious code, but all methods, function executing or calling it. The best security would also include encoding and validating form data as it comes in and out.Watch also out from defining system variables, they can afterwards be called from any function or method in the code.Several buffer overflows were discovered using 4bit \ncharacters functions that interpret text. \nhtmlentities()\nhtmlspecialchars()were at the top, a good defence is to use\nmb_convert_encoding() to convert to single\nencoding prior to interpretation.You can find a continuously updated list of sensitive sinks (exploitable php functions) and their parameters in RIPS /config/sinks.php, a static source code analyser for vulnerabilities in PHP applications that also detects PHP backdoors.