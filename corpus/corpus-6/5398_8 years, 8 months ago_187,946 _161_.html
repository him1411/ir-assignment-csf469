We\'ve been using WiX for a while now, and despite the usual gripes about ease of use, it\'s going reasonably well. What I\'m looking for is useful advice regarding:Keep variables in a separate wxi include file. Enables re-use, variables are faster to find and (if needed) allows for easier manipulation by an external tool.Define Platform variables for x86 and x64 buildsStore the installation location in the registry, enabling upgrades to find the correct location. For example, if a user sets custom install directory. Note: WiX guru Rob Mensching has posted an excellent blog entry which goes into more detail and fixes an edge case when properties are set from the command line.Examples using 1. 2. and 3.andThe simplest approach is always do major upgrades, since it allows both new installs and upgrades in the single MSI. UpgradeCode is fixed to a unique Guid and will never change, unless we don\'t want to upgrade existing product.Note: In WiX 3.5 there is a new MajorUpgrade element which makes life even easier!Creating an icon in Add/Remove ProgramsOn release builds we version our installers, copying the msi file to a deployment directory. An example of this using a wixproj target called from AfterBuild target:Use heat to harvest files with wildcard (*) Guid. Useful if you want to reuse WXS files across multiple projects (see my answer on multiple versions of the same product). For example, this batch file automatically harvests RoboHelp output.There\'s a bit going on, robocopy is stripping out Subversion working copy metadata before harvesting; the -dr root directory reference is set to our installation location rather than default TARGETDIR; -var is used to create a variable to specify the source directory (web deployment output).Easy way to include the product version in the welcome dialog title by using Strings.wxl for localization. (Credit: saschabeaumont. Added as this great tip is hidden in a comment)Save yourself some pain and follow Wim Coehen\'s advice of one component per file. This also allows you to leave out (or wild-card *) the component GUID.Rob Mensching has a neat way to quickly track down problems in MSI log files by searching for value 3. Note the comments regarding internationalization.When adding conditional features, it\'s more intuitive to set the default feature level to 0 (disabled) and then set the condition level to your desired value. If you set the default feature level >= 1, the condition level has to be 0 to disable it, meaning the condition logic has to be the opposite to what you\'d expect, which can be confusing :)Checking if IIS is installed:Checking if IIS 6 Metabase Compatibility is installed on Vista+:Keep all IDs in separate namespacesI find this helps immensely in keeping track of all the various id\'s in all the various categories. Fantastic question.  I\'d love to see some best practices shown.I\'ve got a lot of files that I distribute, so I\'ve set up my project into several wxs source files.I have a top level source file which I call Product.wxs which basically contains the structure for the installation, but not the actual components.  This file has several sections:The rest of the .wix files are composed of Fragments that contain ComponentGroups which are referenced in the Feature tag in the Product.wxs.  My project contains a nice logical grouping of the files that I distributeThis isn\'t perfect, my OO spider sense tingles a bit because the fragments have to reference names in the Product.wxs file (e.g. the DirectoryRef) but I find it easier to maintain that a single large source file.I\'d love to hear comments on this, or if anyone has any good tips too!Add a checkbox to the exit dialog to launch the app, or the helpfile. ...If you do it this way, the "standard" appearance isn\'t quite right.  The checkbox is always a gray background, while the dialog is white: alt text http://www.dizzymonkeydesign.com/blog/misc/adding-and-customizing-dlgs-in-wix-3/images/exit_dlg_1.gifOne way around this is to specify your own custom ExitDialog, with a differently-located checkbox.  This works, but seems like a lot of work just to change the color of one control.  Another way to solve the same thing is to post-process the generated MSI to change the X,Y fields in the Control table for that particular CheckBox control.  The javascript code looks like this: Running this code as a command-line script (using cscript.exe) after the MSI is generated (from light.exe) will produce an ExitDialog that looks more professional:alt text http://www.dizzymonkeydesign.com/blog/misc/adding-and-customizing-dlgs-in-wix-3/images/exit_dlg_2.gifIn a nutshell: Create unique UpgradeCode for each installer and automagically define the first character of each Guid for each installer, leaving the remaining 31 unique.Example Config.wxiExample Config.Common.wxiExample Components.wxsNote: I would now suggest leaving the Guid attribute out of Component (equivalent of *), using one file per component and setting the file as the keypath. This removes the need for calling ModifyComponentsGuids and RevertComponentsGuids targets shown below. This might not be possible for all your components though.Example Setup.Live.wixprojFinal thoughtsUPDATE 1: Auto-generating component Guids removes the need for calling FileUpdate task if you create component with Guid="*" for each file, setting the file as the keypath.UPDATE 2: One of the issues we\'ve come up against is if you don\'t auto-generate your component Guid\'s and the build fails, then the temp files need to be manually deleted.UPDATE 3: Found a way to remove reliance on svn:externals and temporary file creation. This makes the build process more resilient (and is best option if you can\'t wildcard your Guids) and less brittle if there is a build failure in light or candle.UPDATE 4: Support for Multiple Instances using instance transforms is in WiX 3.0+, definitely also worth a look.Using the Msi Diagnostic logging to get detailed failure Information\n\nmsiexec /i Package.msi /l*v c:\\Package.log\n\n\nWhere Msi Error CodesWix Intro Video\nOh and Random Wix intro video featuring "Mr. WiX" Rob Mensching is "conceptual big picture" helpful.Use Javascript CustomActions because they\'re soooo easyPeople have said that Javascript is the wrong thing to use for MSI CustomActions.  Reasons given:  hard to debug, hard to make it reliable.  I don\'t agree.  It\'s not hard to debug, certainly no harder than C++.  Its just different.  I found writing CustomActions in Javascript to be super easy, much easier than using C++.  Much faster.  And just as reliable. There\'s just one drawback: Javascript CustomActions  can be extracted via Orca, whereas a C/C++ CA would require reverse-engineering.  If you consider your installer magic to be protected intellectual property, you will want to avoid script. If you use script, \nyou just need to start with some structure.  Here\'s some to get you started.Javascript "boilerplate" code for CustomAction: Then, register the custom action with something like this: You can, of course, insert as many Javascript functions as you like, for multiple custom actions.  One example: I used Javascript to do a WMI query on IIS, to get a list of existing websites, to which an ISAPI filter could be installed.  This list was then used to populate a listbox shown later in the UI sequence.  All very easy. On IIS7, there is no WMI provider for IIS, so I used the shell.Run() approach to invoke appcmd.exe to perform the work.  Easy.Related question: About Javascript CustomActionsPeter Tate has already shown how you can define reusable ComponentGroup definitions in separate wix fragments. Some additional tricks related to this:Directory AliasingThe component group fragments don\'t need to know about directories defined by the main product wxs. In your component group fragment you can talk about a folder like this:Then the main product can alias one of its directories (e.g. "productInstallFolder") like this:Dependency GraphComponentGroup elements can contain ComponentGroupRef child elements. This is great if you have a big pool of reusable components with a complex dependency graph between them. You just set up a ComponentGroup in its own fragment for each component and declare the dependencies like this: If you now reference component group "B" in your setup because it is a direct dependency of your application, it will automatically pull in component group "A" even if the application author never realized that it was a dependency of "B". It "just works" as long as you don\'t have any circular dependencies.Reusable wixlibThe above dependency graph idea works best if you compile the big-pool-o-reusable-components into a reusable wixlib with lit.exe. When creating an application setup, you can reference this wixlib much like a wixobj file. The candle.exe linker will automatically eliminate any fragments that are not "pulled in" by the main product wxs file(s).I\'m surprised no one has mentioned using T4 to generate the WXS file during build. I learned about this by way of Henry Lee @ New Age Solutions.Essentially, you create a custom MSBuild task to execute a T4 template, and that template outputs the WXS just before the Wix project is compiled. This allows you to (depending on how you implement it) automatically include all assemblies output from compiling another solution (meaning that you no longer have to edit the wxs ever time you add a new assembly).Using Heat.exe to smash face and inflict "Epic Pwnage" on painfully large installs\n\nExpanding on Si\'s and \nRobert-P\'s answers about heat.\n\nTranslation:\n(Using heat to avoid typing individual files into the project by hand and for automating builds for an overall easier process.)\n\n\nWiX 2.0 Heat Syntax detailed\nFor newer versions (not all that different from older versions but there are potentially annoying syntax changes....) go to the directory Heat is in from the cmd.exe and just type in heat but I have a example one right here for help with newer versions if needed.\nAdding the following to your Build Event in visual studio 2010.\n(Right Click Project->Properties ->Build Events-> Pre-Build Events)\n\n\n$(WIX)bin\\heat.exe" dir "$(EnviromentVariable)" -cg GroupVariable -gg -scom -sreg -sfrag -\nsrd -dr INSTALLLOCATION -var env.LogicPath -out "$(FragmentDir)\\FileName.wxs\n\nGenerates Guids when heat is run(as in when you execute the command above)Dont grab "COM files"Dont grab "Registry Files"Dont grab "Fragments"Dont grab the "root Dir"dir indicates you want Heat to look in a folder The name of the variable you would add to the Preprocessor variables in the (Right click project, Go to properties) project properties->Build section where it says Define preprocessor variables (assumes visual studio 2010)The ComponentGroup that will be referenced from the fragment created to the main wxs fileThe fragment directory where the output wxs fragment will be stored The the name of the fileFull tutorial here, So freakin helpfulPart 1\nPart 2Including COM Objects:heat generates all most (if not all) the registry entries and other configuration needed for them.  Rejoice!Including Managed COM Objects (aka, .NET or C# COM objects)Using heat on a managed COM object will give you an almost complete wix document.  If you don\'t need the library available in the GAC (ie, globally available: MOST of the time you do not need this with your .NET assemblies anyway - you\'ve probably done something wrong at this point if it\'s not intended to be a shared library) you will want to make sure to update the CodeBase registry key to be set to [#ComponentName].  If you ARE planning on installing it to the GAC (eg, you\'ve made some new awesome common library that everyone will want to use) you must remove this entry, and add two new attributes to the File element: Assembly and KeyPath.  Assembly should be set to ".net" and KeyPath should be set to "yes".However, some environments (especially anything with managed memory such as scripting languages) will need access to the Typelib as well.  Make sure to run heat on your typelib and include it.  heat will generate all the needed registry keys.  How cool is that?Installing to C:\\ProductNameSome applications need to be installed to C:\\ProductName or something similar, but 99.9% (if not 100%) of the examples in the net install to C:\\Program Files\\CompanyName\\ProductName.The following code can be used to set the TARGETDIR property to the root of the C: drive (taken from the WiX-users list):NOTE: By default, TARGETDIR does not point to C:\\! It rather points to ROOTDRIVE which in turn points to the root of the drive with the most free space (see here) - and this is not necessarily the C: drive. There might be another hard drive, partition, or USB drive!Then, somewhere below your <Product ...> tag, you need the following directory tags as usual:Environmental VariablesWhen compiling your Wxs documents to wixobj code, you can make use of environmental variables to determine various information.  For example, lets say you want to change which files get included in a project.  Lets say you have an environmental variable called RELEASE_MODE, that you set right before you build your MSI (either with a script or manually, it doesn\'t matter)  In your wix source, you can do something like:and then later in your code, use it in place to on the fly change your wxs document, eg:Using the RobM special "Remember Property" patternhttp://robmensching.com/blog/posts/2010/5/2/The-WiX-toolsets-Remember-Property-patternCreating Custom Action for WIX written in managed code (C#) without Votivehttp://www.codeproject.com/KB/install/wixcustomaction.aspxEditing DialogsOne good ability to edit dialogs is using SharpDevelop in a version 4.0.1.7090 (or higher). With help of this tool a standalone dialog (wxs files from WiX sources like e.g. InstallDirDlg.wxs) can be opened, previewed and edited in Design view.Setting the IIS enable32BitAppOnWin64 flag http://trycatchfail.com/blog/post/WiX-Snippet-change-enable32BitAppOnWin64.aspxModify the "Ready to install?" dialog (aka VerifyReadyDlg) to provide a summary of choices made.It looks like this:\nalt text http://i46.tinypic.com/s4th7t.jpgDo this with a Javascript CustomAction: Javascript code:Declare the Javascript CA: Attach the CA to a button.  In this example, the CA is fired when Next is clicked from the CustomizeDlg:Related SO Question: How can I set, at runtime, the text to be displayed in VerifyReadyDlg?Put Components which may be patched individually inside their own FragmentsIt goes for both making product installers and patches that if you include any component in a fragment, you must include all of the components in that fragment. In the case of building an installer, if you miss any component references, you\'ll get a linking error from light.exe. However, when you make a patch, if you include a single component reference in a fragment, then all changed components from that fragment will show up in your patch.like this:instead of this:Also, when patching using the "Using Purely WiX" topic from the WiX.chm help file, using this procedure to generate the patch:it\'s not enough to just have the 1.1 version of the product.wixpdb built using the components in separate fragments. So be sure to correctly fragment your product before shipping.1) When you compile your wix source code, the light.exe must reference the WixUIExtension.dll in command line. Use the command line switch -ext  for this.2) If when you add the reference to the WixUIExtension.dll, your project fails to compile, this is most likely because of clashes of Dialog IDs, i.e. your project was using the same IDs of dialogs as some standard dialogs in WixUIExtension.dll, give different IDs to your dialogs. This is quite common problem.3) Your license dialog must have ScrollableText control with the id "LicenseText". Wix searches for exactly this name of control when it prints.and a PushButton which refers to the custom action4) Define CustomAction with the Id="PrintEula" like this:Note: BinaryKey is different in Wix3.0 comparing to Wix2.0 and must be exactly "WixUIWixca" (case sensitive).When user presses the button he/she will be presented with the standard Select Printer Dialog and will be able to print from there.We display the product version somewhere (tiny) in the first screen of the GUI. Because people tend to make mistakes in picking the right version every time. (And keep us developers searching for ages..)We\'ve set up TFSBuild to also generate transforms (.mst files) with the configuration for our different environments. (We know about all environments we need to deploy to). Since the original weblog post by Grant Holliday is down, I copy pasted its contents here:MSBuild task to generate MSI Transform files from XMLMarch 11 2008In my previous post I described how you can use MSI Transform (*.mst) files to separate environment-specific configuration settings from a generic MSI package.Although this provides a level of flexibility in your configuration, there are two down-sides of Transform files:Fortunately we can use the Microsoft Windows Installer Object Library (c:windowssystem32msi.dll) to open MSI \xe2\x80\x9cdatabases\xe2\x80\x9d and create transform files.Credits go again to Alex Shevchuk \xe2\x80\x93 From MSI to WiX \xe2\x80\x93 Part 7 \xe2\x80\x93 Customising installation using Transforms for showing us how to achieve this with VbScript. Essentially all I\xe2\x80\x99ve done is taken Alex\xe2\x80\x99s example and using Interop.WindowsInstaller.dll I\xe2\x80\x99ve implemented an MSBuild task.\nThe  MSBuild TaskDownload the source code & example transforms.xml here (~7Kb Zipped VS2008 Solution)Before deploying an install package I always control the content of it.It\'s just a simple call at the command line (according to Terrences post) open command line and enterThis will extract package contents to an subdir \'Extract\' with the current path.Instead of ORCA use InstEd which is a good tool for viewing MSI tables. Also it has the ability to diff two packages by \nTransform -> Compare To...Additionally a Plus version with additional functionality is available. But also the free version offers a good alternative for Orca.NB This fragment is essentially the same as REGASM Assembly.dll /codebaseA couple of things are going on in this sample so here\'s the code and I\'ll explain it afterwards...If you were wondering, this is actually for an ASCOM Telescope Driver.First, I took advice from above and created some platforma variables in a seperate file, you can see those scattered through the XML.The if-then-else part near the top deals with x86 vs x64 compatibility. My assembly targets \'Any CPU\' so on an x64 system, I need to register it twice, once in the 64-bit registry and once in the 32-bit Wow6432Node areas. The if-then-else sets me up for this, the values are used in a foreach loop later on. This way, I only have to author the registry keys once (DRY principle).The file element specifies the actual assembly dll being installed and registered:Nothing revolutionary, but notice the Assembly=".net" - this attribute alone would cause the assembly to be put into the GAC, which is NOT what I wanted. Using the AssemblyApplication attribute to point back to itself is simply a way of stopping Wix putting the file into the GAC. Now that Wix knows it\'s a .net assembly, though, it lets me use certain binder variables within my XML, such as the !(bind.assemblyFullname.filDriverAssembly) to get the assembly full name.Set the DISABLEADVTSHORTCUTS property to force all advertised shortcuts in your installer to become regular shortcuts, and you don\'t need to include a dummy reg key to be used as the keypath.I think Windows Installer 4.0 or higher is a requirement.It\'s a nice structure but based on my experience I wonder how you address these conditions:A. Your installs all appear to land in the same destination. If a user needs to install all 3 versions at once will your process allow this.  Can they unambiguously tell which version of every executable they are triggering?B. How do you handle new files that exist in TEST and/or TRAINING but not yet in LIVE?Here\'s a way to help large web projects verify that the number of deployed files matches the number of files built into an MSI (or merge module). I\'ve just run the custom MSBuild task against our main application (still in development) and it picked up quite a few missing files, mostly images, but a few javascript files had slipped through to!  This approach (peeking into File table of MSI by hooking into AfterBuild target of WiX project) could work for other application types where you have access to a complete list of expected files.Performing a forced reinstall when an install doesn\'t allow uninstall or reinstall and doesn\'t roll back.\n\n\nVBscript script used for overriding an install that isn\'t uninstalling for whatever reason..Create a UI that has a custom action that will set a variable and the UI will disable/enable the next button (or similar) based upon the variable set in the custom action.Not as straight-forward as you would think, not too difficult just not documented anywhere!Wix Interactions with Conditions, Properties & Custom Actions