Also, does one imply the other?What is the difference between a strongly typed language and a statically typed language?A statically typed language has a type system that is checked at compile time by the implementation (a compiler or interpreter).  The type check rejects some programs, and programs that pass the check usually come with some guarantees; for example, the compiler guarantees not to use integer arithmetic instructions on floating-point numbers.There is no real agreement on what "strongly typed" means, although the most widely used definition in the professional literature is that in a "strongly typed" language, it is not possible for the programmer to work around the restrictions imposed by the type system.  This term is almost always used to describe statically typed languages.The opposite of statically typed is "dynamically typed", which means thatFor example, Lua, a dynamically typed language, has  a string type, a number type, and a Boolean type, among others.  In Lua every value belongs to exactly one type, but this is not a requirement for all dynamically typed languages.  In Lua, it is permissible to concatenate two strings, but it is not permissible to concatenate a string and a Boolean.The opposite of "strongly typed" is "weakly typed", which means you can work around the type system.  C is notoriously weakly typed because any pointer type is convertible to any other pointer type simply by casting.  Pascal was intended to be strongly typed, but an oversight in the design (untagged variant records) introduced a loophole into the type system, so technically it is weakly typed.\nExamples of truly strongly typed languages include CLU, Standard ML, and Haskell.  Standard ML has in fact undergone several revisions to remove loopholes in the type system that were discovered after the language was widely deployed.Overall, it turns out to be not that useful to talk about "strong" and "weak".  Whether a type system has a loophole is less important than the exact number and nature of the loopholes, how likely they are to come up in practice, and what are the consequences of exploiting a loophole.  In practice, it\'s best to avoid the terms "strong" and "weak" altogether, becauseAmateurs often conflate them with "static" and "dynamic".Apparently "weak typing" is used by some persons to talk about the relative prevalance or absence of implicit conversions.Professionals can\'t agree on exactly what the terms mean.Overall you are unlikely to inform or enlighten your audience.The sad truth is that when it comes to type systems, "strong" and "weak" don\'t have a universally agreed on technical meaning.   If you want to discuss the relative strength of type systems, it is better to discuss exactly what guarantees are and are not provided.\nFor example, a good question to ask is this: "is every value of a given type (or class) guaranteed to have been created by calling one of that type\'s constructors?"  In C the answer is no.  In CLU, F#, and Haskell it is yes.  For C++ I am not sure—I would like to know. By contrast, static typing means that programs are checked before being executed, and a program might be rejected before it starts.  Dynamic typing means that the types of values are checked during execution, and a poorly typed operation might cause the program to halt or otherwise signal an error at run time.  A primary reason for static typing is to rule out programs that might have such "dynamic type errors".  Does one imply the other?On a pedantic level, no, because the word "strong" doesn\'t really mean anything.  But in practice, people almost always do one of two things:They (incorrectly) use "strong" and "weak" to mean "static" and "dynamic", in which case they (incorrectly) are using "strongly typed" and "statically typed" interchangeably.They use "strong" and "weak" to compare properties of static type systems.  It is very rare to hear someone talk about a "strong" or "weak" dynamic type system.  Except for FORTH, which doesn\'t really have any sort of a type system, I can\'t think of a dynamically typed language where the type system can be subverted.  Sort of by definition, those checks are bulit into the execution engine, and every operation gets checked for sanity before being executed.  Either way, if a person calls a language "strongly typed", that person is very likely to be talking about a statically typed language.This is often misunderstood so let me clear it up.Static typing is where the type is bound to the variable.  Types are checked at compile time.Dynamic typing is where the type is bound to the value.  Types are checked at run time.So in Java for example:s will "forever" be a String. During its life it may point to different Strings (since s is a reference in Java). It may have a null value but it will never refer to an Integer or a List. That\'s static typing.In PHP:That\'s dynamic typing.(Edit alert!)Strong typing is a phrase with no widely agreed upon meaning.  Most programmers who use this term to mean something other than static typing use it to imply that there is a type discipline that is enforced by the compiler.  For example, CLU has a strong type system that does not allow client code to create a value of abstract type except by using the constructors provided by the type.  C has a somewhat strong type system, but it can be "subverted" to a degree because a program can always cast a value of one pointer type to a value of another pointer type.  So for example, in C you can take a value returned by malloc() and cheerfully cast it to FILE*, and the compiler won\'t try to stop you—or even warn you that you are doing anything dodgy.(The original answer said something about a value "not changing type at run time".  I have known many language designers and compiler writers and have not known one that talked about values changing type at run time, except possibly some very advanced research in type systems, where this is known as the "strong update problem".)Weak typing implies that the compiler does not enforce a typing discpline, or perhaps that enforcement can easily be subverted.The original of this answer conflated weak typing with implicit conversion (sometimes also called "implicit promotion"). For example, in Java:This is code is an example of implicit promotion: 123 is implicitly converted to a string before being concatenated with "abc". It can be argued the Java compiler rewrites that code as:Consider a classic PHP "starts with" problem:The error here is that strpos() returns the index of the match, being 0. 0 is coerced into boolean false and thus the condition is actually true. The solution is to use === instead of == to avoid implicit conversion.This example illustrates how a combination of implicit conversion and dynamic typing can lead programmers astray.Compare that to Ruby:which is a runtime error because in Ruby the object 123 is not implicitly converted just because it happens to be passed to a + method. In Ruby the programmer must make the conversion explicit:Comparing PHP and Ruby is a good illustration here. Both are dynamically typed languages but PHP has lots of implicit conversions and Ruby (perhaps surprisingly if you\'re unfamiliar with it) doesn\'t.The point here is that the static/dynamic axis is independent of the strong/weak axis. People confuse them probably in part because strong vs weak typing is not only less clearly defined, there is no real consensus on exactly what is meant by strong and weak. For this reason strong/weak typing is far more of a shade of grey rather than black or white.So to answer your question: another way to look at this that\'s mostly correct is to say that static typing is compile-time type safety and strong typing is runtime type safety.The reason for this is that variables in a statically typed language have a type that must be declared and can be checked at compile time. A strongly-typed language has values that have a type at run time, and it\'s difficult for the programmer to subvert the type system without a dynamic check.But it\'s important to understand that a language can be Static/Strong, Static/Weak, Dynamic/Strong or Dynamic/Weak.Strongly typed means that there are restrictions between conversions between types. Statically typed means that the types are not dynamic - you can not change the type of a variable once it has been created. Data Coercion does not necessarily mean weakly typed because sometimes its syntacical sugar:The example above of Java being weakly typed because ofIs not weakly typed example because its really doing:Data coercion is also not weakly typed if you are constructing a new object.\nJava is a very bad example of weakly typed (and any language that has good reflection will most likely not be weakly typed). Because the runtime of the language always knows what the type is (the exception might be native types).This is unlike C. C is the one of the best examples of weakly typed. The runtime has no idea if 4 bytes is an integer, a struct, a pointer or a 4 characters.The runtime of the language really defines whether or not its weakly typed otherwise its really just opinion.EDIT:\nAfter further thought this is not necessarily true as the runtime does not have to have all the types reified in the runtime system to be a Strongly Typed system.\nHaskell and ML have such complete static analysis that they can potential ommit type information from the runtime. Both are poles on two different axis:Strongly typed means, a will not be automatically converted from one type to another. Weakly typed is the opposite: Perl can use a string like "123" in a numeric context, by automatically converting it into the int 123. A strongly typed language like python will not do this.Statically typed means, the compiler figures out the type of each variable at compile time. Dynamically typed languages only figure out the types of variables at runtime.Strong typing probably means that variables have a well-defined type and that there are strict rules about combining variables of different types in expressions.  For example, if A is an integer and B is a float, then the strict rule about A+B might be that A is cast to a float and the result returned as a float.  If A is an integer and B is a string, then the strict rule might be that A+B is not valid.Static typing probably means that types are assigned at compile time (or its equivalent for non-compiled languages) and cannot change during program execution.Note that these classifications are not mutually exclusive, indeed I would expect them to occur together frequently.  Many strongly-typed languages are also statically-typed.And note that when I use the word \'probably\' it is because there are no universally accepted definitions of these terms.  As you will already have seen from the answers so far.One does not imply the other. For a language to be statically typed it means that the types of all variables are known or inferred at compile time. A strongly typed language does not allow you to use one type as another. C is a weakly typed language and is a good example of what strongly typed languages don\'t allow. In C you can pass a data element of the wrong type and it will not complain. In strongly typed languages you cannot.In computer programming, programming languages are often colloquially referred to as strongly typed or weakly typed. These terms do not have a precise definition, but in general a strongly typed language is more likely to generate an error or refuse to compile if the argument passed to a function does not closely match the expected type. On the other hand, a very weakly typed language may produce unpredictable results or may perform implicit type conversion