I have a Git repository with few branches and dangling commits. I would like to search all such commits in repository for a specific string.I know how to get a log of all commits in history, but these don\'t include branches or dangling blobs, just HEAD\'s history. I want to get them all, to find a specific commit that got misplaced.I would also like to know how to do this in Mercurial, as I\'m considering the switch.You can see dangling commits with git log -g.So you could do this to find a particular string in a commit message that is dangling:Alternatively, if you want to search the changes for a particular string, you could use the pickaxe search option, "-S":Git 1.7.4 will add the -G option, allowing you to pass -G<regexp> to find when a line containing <regexp> was moved, which -S cannot do. -S will only tell you when the total number of lines containing the string changed (i.e. adding/removing the string).Finally, you could use gitk to visualise the dangling commits with:And then use its search features to look for the misplaced file. All these work assuming the missing commit has not "expired" and been garbage collected, which may happen if it is dangling for 30 days and you expire reflogs or run a command that expires them.In Mercurial you use hg log --keyword to search for keywords in the commit messages and hg log --user to search for a particular user. See hg help log for other ways to limit the log.In addition to richq answer of using git log -g --grep=<regexp> or git grep -e <regexp> $(git log -g --pretty=format:%h): take a look at the following blog posts by Junio C Hamano, current git maintainerBoth git grep and git log --grep are line oriented, in that they look for lines that match specified pattern. You can use git log --grep=<foo> --grep=<bar> (or git log --author=<foo> --grep=<bar> that internally translates to two --grep) to find commits that match either of patterns (implicit OR semantic).Because of being line-oriented, the useful AND semantic is to use git log --all-match --grep=<foo> --grep=<bar> to find commit that has both line matching first and line matching second somewhere.With git grep you can combine multiple patterns (all which must use the -e <regexp> form) with --or (which is the default), --and, --not, ( and ).  For grep --all-match means that file must have lines that match each of alternatives.Building on rq\'s answer, I found this line does what I want:Which will report the commit ID, filename, and display the matching line, like this:... Does anyone agree that this would be a nice option to be included in the standard git grep command?Any command that takes references as arguments will accept the --all option documented in the man page for git rev-list as follows:So for instance git log -Sstring --all will display all commits that mention string and that are accessible from a branch or from a tag (I\'m assuming that your dangling commits are at least named with a tag).With Mercurial you do aThere are other options that narrow down the range of revisions that are searched.Don\'t know about git, but in Mercurial I\'d just pipe the output of hg log to some sed/perl/whatever script to search for whatever it is you\'re looking for. You can customize the output of hg log using a template or a style to make it easier to search on, if you wish.This will include all named branches in the repo. Mercurial does not have something like dangling blobs afaik.if you are a vim user, you can install tig (apt-get install tig), and use /, same command to search on vimhttps://blogs.atlassian.com/2013/05/git-tig/To add just one more solution not yet mentioned, I had to say that using gitg\'s graphical search box was the simplest solution for me. It will select the first occurrence and you can find the next with Ctrl-G.One command in git that I think it\'s much easier to find a string:works in Git 2.0.4