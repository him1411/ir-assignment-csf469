I would like to catch every undefined function error thrown. Is there a global error handling facility in Javascript? The use case is catching function calls from flash that are not defined.Does this help you:I\'m not sure how it handles Flash errors though...Update: it doesn\'t work in Opera, but I\'m hacking Dragonfly right now to see what it gets. Suggestion about hacking Dragonfly came from this question:Mimic Window. onerror in Opera using javascriptAssign the window.onerror event to an event handler like:As commented in the code, if the return value of window.onerror is true then the browser should suppress showing an alert dialog.In a nutshell, the event is raised when either 1.) there is an uncaught exception or 2.) a compile time error occurs.uncaught exceptionscompile errorExample of the onerror code above in action after adding this to a test page:https://jsfiddle.net/nzfvm44d/If your error handling is very sophisticated and therefore might throw an error itself, it is useful to add a flag indicating if you are already in "errorHandling-Mode". Like so:Otherwise you could find yourself in an infinite loop.Try Atatus which provides Advanced Error Tracking and Real User Monitoring for modern web apps.https://www.atatus.com/Let me explain how to get stacktraces that are reasonably complete in all browsers. Modern Chrome and Opera fully support the HTML 5 draft spec for ErrorEvent and window.onerror. In both of these browsers you can either use window.onerror, or bind to the \'error\' event properly:Unfortunately Firefox, Safari and IE are still around and we have to support them too. As the stacktrace is not available in window.onerror we have to do a little bit more work.It turns out that the only thing we can do to get stacktraces from errors is to wrap all of our code in a try{ }catch(e){ } block and then look at e.stack. We can make the process somewhat easier with a function called wrap that takes a function and returns a new function with good error handling.This works. Any function that you wrap manually will have good error handling, but it turns out that we can actually do it for you automatically in most cases.By changing the global definition of addEventListener so that it automatically wraps the callback we can automatically insert try{ }catch(e){ } around most code. This lets existing code continue to work, but adds high-quality exception tracking.We also need to make sure that removeEventListener keeps working. At the moment it won\'t because the argument to addEventListener is changed. Again we only need to fix this on the prototype object:You can send error data using image tag as followsDisclaimer: I am a web developer at https://www.atatus.com/.It seems that window.onerror doesn\'t provide access to all possible errors. Specifically it ignores:Here is the start of a script that catches many of these errors, so that you may add more robust debugging to your app during development.It could be used like this:The full script has a default implementation that tries to print out a semi-readable "display" version of the entity/error that it receives. Can be used for inspiration for an app-specific error handler. The default implementation also keeps a reference to the last 100 error entities, so you can inspect them in the web console after they occur like:Note: This works by overriding methods on several browser/native constructors. This can have unintended side-effects. However, it has been useful to use during development, to figure out where errors are occurring, to send logs to services like NewRelic or Sentry during development so we can measure errors during development, and on staging so we can debug what is going on at a deeper level. It can then be turned off in production.Hope this helps.I would recommend giving Trackjs a try.It\'s error logging as a service.It\'s amazingly simple to set up. Just add one <script> line to each page and that\'s it. This also means it will be amazingly simple to remove if you decide you don\'t like it.There are other services like Sentry (which is open-source if you can host your own server), but it doesn\'t do what Trackjs does. Trackjs records the user\'s interaction between their browser and your webserver so that you can actually trace the user steps that led to the error, as opposed to just a file and line number reference (and maybe stack trace).One should preserve the previously associated onerror callback as wellIf you want unified way to handle both uncaught errors and unhandled promise rejections you may have a look on uncaught library.EDITIt listens window.unhandledrejection in addition to window.onerror.You listen to the onerror event by assigning a function to window.onerror: