This question already has an answer here:I\'m a newbie to Java programming, trying to get the hang of OOP.So I built this abstract class:and 2 subclasses:Car and Boat also hold some unique fields and methods that aren\'t common (don\'t have the same name, so I can\'t define an abstract method for them in Vehicle).Now in mainClass I have setup my new Garage:I was very happy with polymorphism until I tried to access one of the fields that are unique to Car, such as:The compiler doesn\'t accept that. I worked around this issue using casting:That works... but it doesn\'t help with methods, just fields. Meaning I can\'t doSo my question is - what do I really have in my garage? I\'m trying to get the intuition as well as understand what\'s going on "behind the scenes".for the sake of future readers, a short summary of the answers below:If you need to make the difference between Car and Boat in your garage, then you should store them in distinct structures.For instance:Then you can define methods that are specific on boats or specific on cars.Let\'s say Vehicle is like:Every Vehicle has a price so it can be put inside the Vehicle abstract class.Yet, the formula determining the price after n years depends on the vehicle, so it left to the implementing class to define it. For instance:The Boat class may have an other definition for getPriceAfterYears and specific attributes and methods.So now back in the Garage class, you can define:The interest of polymorphism is to be able to call getPriceAfterYears on a Vehicle without caring about the implementation.Usually, downcasting is a sign of a flawed design: do not store your vehicles all together if you need to differenciate their actual type.Note: of course the design here can be easily improved. It is just an example to demonstrate the points.To answer your question you can find out what exactly is in your garage you do the following:UPDATE: As you can read from the comments below, this method is okay for simple solutions but it is not good practice, particularly if you have a huge number of vehicles in your garage. So use it only if you know the garage will stay small. If that\'s not the case, search for "Avoiding instanceof" on stack overflow, there are multiple ways to do it.If you operate on the base type, you can only access public methods and fields of it.If you want to access the extended type, but have a field of the base type where it\'s stored (as in your case), you first have to cast it and then you can access it:Or shorter without temp field:Since you are using Vehicle objects, you can only call methods from the base class on them without casting. So for your garage it may be advisable to distinguish the objects in different arrays - or better lists - an array is often not a good idea, since it\'s far less flexible in handling than a Collection-based class.You defined that your garage will store vehicles, so you do not care what type of vehicles you have. The vehicles have common features like engine, wheel, behavior like moving. \nThe actual representation of these features might be different, but at abstract layer are the same. \nYou used abstract class which means that some attributes, behaviors are exactly the same by both vehicle. If you want to express that your vehicles have common abstract features then use interface like moving might mean different by car and boat. Both can get from point A to point B, but in a different way (on wheel or on water - so the implementation will be different)\nSo you have vehicles in the garage which behave the same way and you do not car about the specific features of them.To answer the comment:Interface means a contract which describes how to communicate with the outer world. In the contract you define that your vehicle can move, can be steered, but you do not describe how it will actually work, it is described in the implementation.By abstract class you might have functions where you share some implementation, but you also have function which you do not know how it will be implemented.One example of using abstract class:You will use the same steps by each vehicle, but the implementation of the steps will differ by vehicle type. Car might use GPS, boat might use sonar to identify where it is.I\'m a newbie to Java programming, trying to get the hang of OOP.Just my 2 cents \xe2\x80\x94 I will try to make it short as many interesting things have already been said. But, in fact, there is two questions here. One about "OOP" and one about how it is implemented in Java.First of all, yes, you have a car in your garage. So your assumptions are right. But, Java is a statically typed language. And the type system in the compiler can only "know" the type of your various object by their corresponding declaration. Not by their usage. If you have an array of Vehicle, the compiler only knows that. So it will check that you only perform operation allowed on any Vehicle. (In other words, methods and attributes visible in the Vehicle declaration).You can explain to the compiler that "you in fact know this Vehicle is a Car", by using an explicit cast (Car). the compiler will believe you -- even if in Java there is a check at run-time, that might lead to a ClassCastException that prevent further damages if you lied (other language like C++ won\'t check at run-time - you have to know what you do)Finally, if you really need, you might rely of run-time type identification (i.e.: instanceof) to check the "real" type of an object before attempting to cast it. But this is mostly considered as a bad practice in Java.As I said, this is the Java way of implementing OOP. There is whole different class family of languages broadly known as "dynamic languages", that only check at run-time if an operation is allowed on an object or not. With those languages, you don\'t need to "move up" all the common methods to some (possibly abstract) base class to satisfy the type system. This is called duck typing.You asked your butler:Jeeves, remember my garage on the Isle of Java? Go check whether the first vehicle parked there is automatic.and lazy Jeeves said:but sir, what if it\'s a vehicle that can\'t be automatic or non-automatic?That\'s all.Ok, that\'s not really all since reality is more duck-typed than statically typed. That\'s why I said Jeeves is lazy.Your problem here is at a more fundamental level: you built Vehicle in such a way that Garage needs to know more about its objects than the Vehicle interface gives away. You should try and build the Vehicle class from the Garage perspective (and in general from the perspective of everything that\'s going to use Vehicle): what kind of things do they need to do with their vehicles? How can I make those things possible with my methods?For example, from your example:Your garage want to know about a vehicle\'s engine for... reasons? Anyway, there is no need for this to be just exposed by Car. You can still expose an unimplemented isAutomatic() method in Vehicle, then implement it as return True in Boat and return this.auto in Car.It would be even better to have a three-valued EngineType enum (HAS_NO_GEARS, HAS_GEARS_AUTO_SHIFT, HAS_GEARS_MANUAL_SHIFT), which would let your code reason on the actual characteristics of a generic Vehicle cleanly and accurately. (You\'d need this distinction to handle motorbikes, anyway.)You garage contains Vehicles, so the compiler static control view that you have a Vehicle and as .auto is a Car field you can\'t access it, dynamically it is a Car so the cast don\'t create some problem, if it will be a Boat and you try to make cast to Car will rise an exception on runtime.This is a good place for application of the Visitor design pattern.The beauty of this pattern is you can call unrelated code on different subclasses of a superclass without having to do weird casts everywhere or putting tons of unrelated methods into the superclass.This works by creating a Visitor object and allowing our Vehicle class to accept() the visitor.You can also create many types of Visitor and call unrelated code using the same methods, just a different Visitor implementation, which makes this design pattern very powerful when creating clean classes.A demo for example:As you can see, StuffVisitor allows you to call different code on Boat or Car depending on which implementation of visit is called. You can also create other implementations of the Visitor to call different code with the same .visit() pattern.Also notice that using this method, there is no use of instanceof or any hacky class checking. The only duplicated code between classes is the method void accept(Visitor).If you want to support 3 types of concrete subclasses for example, you can just add that implementation into the Visitor interface too.I\'m really just pooling the ideas of the others here (and I\'m not a Java guy, so this is pseudo rather than actual) but, in this contrived example, I would abstract my car checking approach into a dedicated class, that only knows about cars and only cares about cars when looking at garages:Point is, you\'ve already decided you only care about cars when you ask about the car\'s transmission.  So just ask the CarInspector.  Thanks to the tri-state Enum, you can now know whether it is automatic or even if it is not a car.Of course, you\'ll need different VehicleInspectors for each vehicle you care about.  And you have just pushed the problem of which VehicleInspector to instantiate up the chain.So instead, you might want to look at interfaces.Abstract getTransmission out to an interface (e.g. HasTransmission).  That way, you can check if a vehicle has a transmission, or write an TransmissionInspector:Now you are saying, you only about transmission, regardless of Vehicle, so can ask the TransmissionInspector.  Both the bus and the car can be inspected by the TransmissionInspector, but it can only ask about the transmission.Now, you might decide that boolean values are not all you care about.  At that point, you might prefer to use a generic Supported type, that exposes both the supported state and the value:Now your Inspector might be defined as:As I\'ve said, I\'m not a Java guy, so some of the syntax above may be wrong, but the concepts should hold.  Nevertheless, don\'t run the above anywhere important without testing it first.If you are on Java, could use reflections to check if a function is available and execute it, tooCreate Vehicle level fields that will help make each individual Vehicle more distinct.Set the Vehicle level fields in the inheriting class to the appropriate value.Implement using the Vehicle level fields to properly decipher the vehicle type.Since your telling your compiler that everything in your garage is a Vehicle, your stuck with the Vehicle class level methods and fields. If you want to properly decipher the Vehicle type, then you should set some class level fields e.g. isCar and isBoat that will give you the programmer a better understanding of what type of Vehicle you are using. Java is a type safe language so its best to always type check before handling data that has been casted like your Boats and Cars.Modeling objects you want to present in a program (in order to solve some problem) is one thing, coding is another story. In your code, I think essentially it\'s inappropriate to model a garage using array. Arrays shouldn\'t be often considered as objects, although they do appear to be, usually for the sake of self-contained-ness sort of integrity of a language and providing some familiarity, but array as a type is really just a computer-specific thing, IMHO, especially in Java, where you can\'t extend arrays.I understand that correctly modeling a class to represent a garage won\'t help answer your "cars in a garage" question; just a piece of advice.Head back to the code. Other than getting some hang to OOP, a few questions would be helpful creating a scene hence to better understand the problem you want to resolve (assuming there is one, not just "getting some hang"):It might be some inspector, or someone who knows only how to drive auto-transmission cars, etc., but from the garage\'s perspective, all it knows is it holds some vehicle, therefore (in this model) it is the responsibility of this inspector or driver to tell if it\'s a car or a boat; at this moment, you may want to start creating another bunch of classes to represent similar types of *actor*s in the scene. Depends on the problem to be resolved, if you really have to, you can model the garage to be a super intelligent system so it behaves like a vending machine, instead of a regular garage, that has a button says "Car" and another says "Boat", so that people can push the button to get a car or a boat as they want, which in turn makes this super intelligent garage responsible for telling what (a car or a boat) should be presented to its users; to follow this improvisation, the garage may require some bookkeeping when it accepts a vehicle, someone may have to provide the information, etc., all these responsibilities go beyond a simple Main class.Having said this much, certainly I understand all the troubles, along with the boilerplates, to code an OO program, especially when the problem it tries to resolve is very simple, but OO is indeed a feasible way to resolve many other problems. From my experience, with some input providing use cases, people start to design scenes how objects would interact with each other, categorize them into classes (as well as interfaces in Java), then use something like your Main class to bootstrap the world.