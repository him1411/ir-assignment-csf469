People including me know there is something in Python called __future__ and it appears in quite a few modules I read. And the dull people like me don\'t know why it\'s there, and how/when to use it , even after reading the Python\'s __future__ doc. So any explains with examples to demonstrate it?I have got a few answers quickly, which look all correct, in terms of the basic usage.However and also for further understanding how __future__ works:I just realized one key thing that was confusing me when I tried to understand it, that is, how a current python release include something that will be released in future release?\nand how can a program using a new feature in a future python release be compiled successfully by the current python release?So, I guess now that, the current release has already packaged some potential features that will be included in future releases - is this right? but the features are available only by __future__, that is because it doesn\'t become standard yet - am I right?With __future__ module\'s inclusion, you can slowly be accustomed to incompatible changes or to such ones introducing new keywords.E.g., for using context managers, you had to do from __future__ import with_statement in 2.5, as the with keyword was new and shouldn\'t be used as variable names any longer. In order to be able to use a program which uses variables named with, the above import statement is needed.Another example isWithout the __future__ stuff, both print statements would print 1.The internal difference is that without that import, / is mapped to the __div__() method, while with it, __truediv__() is used. (In any case, // calls __floordiv__().)A propos print: print becomes a function in 3.x, losing its special property as a keyword. So it is the other way round.When you doYou\'re not actually using an import statement, but a future statement. You\'re reading the wrong docs, as you\'re not actually importing that module.Future statements are special -- they change how your Python module is parsed, which is why the must be at the top of the file. They give new -- or different -- meaning to words or symbols in your file. From the docs:A future statement is a directive to the compiler that a particular module should be compiled using syntax or semantics that will be available in a specified future release of Python. The future statement is intended to ease migration to future versions of Python that introduce incompatible changes to the language. It allows use of the new features on a per-module basis before the release in which the feature becomes standard.If you actually want to import the __future__ module, just doand then access it as usual.__future__ is a pseudo-module which programmers can use to enable new language features which are not compatible with the current interpreter. For example, the expression 11/4 currently evaluates to 2. If the module in which it is executed had enabled true division by executing:from __future__ import divisionthe expression 11/4 would evaluate to 2.75. By importing the __future__ module and evaluating its variables, you can see when a new feature was first added to the language and when it will become the default:It can be used to use features which will appear in newer versions while having an older release of Python.For examplewill allow you to use print as a function:Or is it like saying "Since this is python v2.7, use that different \'print\' function that has also been added to python v2.7, after it was added in python 3. So my \'print\' will no longer be statements (eg print "message" ) but functions (eg, print("message", options). That way when my code is run in python 3, \'print\' will not break."In print_statement is the module containing the new implementation of \'print\' as per how it is behaving in python v3.This has more explanation: http://python3porting.com/noconv.htmlOne of the uses which I found to be very useful is the print_function from future module.In python 2.7, I wanted chars from different print statements to be printed on same line without spaces.It can be done using a comma(",") at the end, but it also appends an extra space.\nThe above statement when used as : from future import print_function\n...\nprint (v_num,end="")\n...will print the value of v_num from each iteration in a single line without spaces.After Python 3.0 onward, print is no longer just a statement, its a function instead. and is included in PEP 3105. Also I think the Python 3.0 package has still these special functionality. Lets see its usability through a traditional "Pyramid program" in Python:If we use normal print function, we won\'t be able to achieve the same output, since print() comes with a extra newline. So every time the inner for loop execute, it will print * onto the next line.