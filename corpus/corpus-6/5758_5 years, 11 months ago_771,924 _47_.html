This question already has an answer here:Just have a quick question. I\'ve looked around the internet quite a bit  and I\'ve found a few solutions but none of them have worked yet. Looking at converting a string to an int and I don\'t mean ASCII codes.For a quick run-down, we are passed in an equation as a string. We are to break it down, format it correctly and solve the linear equations. Now, in saying that, I\'m not able to convert a string to an int.I know that the string will be in either the format (-5) or (25) etc. so it\'s definitely an int. But how do we extract that from a string?One way I was thinking is running a for/while loop through the string, check for a digit, extract all the digits after that and then look to see if there was a leading \'-\', if there is, multiply the int by -1.It seems a bit over complicated for such a small problem though. Any ideas?In C++11 there are some nice new convert functions from std::string to a number type.So instead of you can usewhere str is your number as std::string.There are version for all flavours of numbers:\nlong stol(string), float stof(string), double stod(string),...\nsee http://en.cppreference.com/w/cpp/string/basic_string/stolTo be fully correct you\'ll want to check the error flags.use the atoi function to convert the string to an integer:http://www.cplusplus.com/reference/clibrary/cstdlib/atoi/How about Boost.Lexical_cast?Here is their example:The following example treats command line arguments as a sequence of numeric data:Admittedly, my solution wouldn\'t work for negative integers, but it will extract all positive integers from input text containing integers. It makes use of numeric_only locale:Input text:Output integers:The class numeric_only is defined as:Complete online demo : http://ideone.com/dRWSjThe possible options are described below:1. First option: sscanf()This is an error (also shown by cppcheck) because "scanf without field width limits can crash with huge input data on some versions of libc" (see here, and here).2. Second option: std::sto*()This solution is short and elegant, but it is available only on on C++11 compliants compilers.3. Third option: sstreamsHowever, with this solution is hard to distinguish between bad input (see here).4. Fourth option: Boost\'s lexical_castHowever, this is just a wrapper of sstream, and the documentation suggests to use sstrem for better error management (see here).5. Fifth option: strto*()This solution is very long, due to error management, and it is described here. Since no function returns a plain int, a conversion is needed in case of integer (see here for how this conversion can be achieved).6. Sixth option: QtConclusionsSumming up, the best solution is C++11 std::stoi() or, as a second option, the use of Qt libraries.\nAll other solutions are discouraged or buggy.atoi is a built-in function that converts a string to an integer, assuming that the string begins with an integer representation.http://www.cplusplus.com/reference/clibrary/cstdlib/atoi/It\'s probably a bit of overkill, but \nboost::lexical_cast<int>( theString ) should to the job\nquite well. In Windows, you could use:strtol,stringstream need to specify the base if you need to interpret hexdecimal.there is another easy way : suppose you have a character like c=\'4\' therefore you can do one of these steps :1st : int q q=(int) c ; (q is now 52 in ascii table ) .\nq=q-48; remember that adding 48 to digits is their ascii code .the second way : q=c-\'0\'; the same , character \'0\' means 48This normally works when I use it: