I have an IEnumerable<T> method that I\'m using to find controls in a WebForms page.The method is recursive and I\'m having some problems returning the type I want when the yield return is returnig the value of the recursive call.My code looks as follows:This currently throws a "Cannot convert expression type" error. If however this method returns type IEnumerable<Object>, the code builds, but the wrong type is returned in the output.Is there a way of using yield return whilst also using recursion?Inside a method that returns IEnumerable<T>, yield return has to return T, not an IEnumerable<T>.Replacewith:You need to yield each of the items yielded by the recursive call:Note that there\'s a cost to recursing in this way - you\'ll end up creating a lot of iterators, which can create a performance issue if you have a really deep control tree. If you want to avoid that, you basically need to do the recursion yourself within the method, to make sure there\'s only one iterator (state machine) created. See this question for more details and a sample implementation - but this obviously adds a certain amount of complexity too.You need to return the items from the enumerator, not the enumerator itself, in your second yield returnOthers provided you with the correct answer, but I don\'t think your case benefits from yielding. Here\'s a snippet which achieves the same without yielding. As Jon Skeet and Colonel Panic note in their answers, using yield return in recursive methods may cause performance problems if the tree is very deep.Here\'s a generic non-recursive extension method that performs a depth-first traversal of a sequence of trees:Unlike Eric Lippert\'s solution, RecursiveSelect works directly with enumerators so that it doesn\'t need to call Reverse (which buffers the entire sequence in memory).Using RecursiveSelect, the OP\'s original method can be rewritten simply like this:I think you have to yield return each of the controls in the enumerables.Seredynski\'s syntax is correct, but you should be careful to avoid yield return in recursive functions because it\'s a disaster for memory usage. See https://stackoverflow.com/a/3970171/284795 it scales explosively with depth (a similar function was using 10% of memory in my app).A simple solution is to use one list and pass it with the recursion https://codereview.stackexchange.com/a/5651/754Alternatively you could use a stack and a while loop to eliminate recursive calls  https://codereview.stackexchange.com/a/5661/754While there are many good answers out there, I would still add that it is possible to use LINQ methods to accomplish the same thing, .For instance, the original code of the OP could be rewritten as: