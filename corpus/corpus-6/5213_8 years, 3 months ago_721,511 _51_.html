Is there a cross-platform way to get the current date and time in C++?std C libraries provide time().\nThis is seconds from the epoch and can be converted to date and H:M:S using standard C functions. Boost also has a time/date library that you can check.C++ shares its date/time functions with C. The tm structure is probably the easiest for a C++ programmer to work with - the following prints today\'s date:In C++ 11 you can use std::chrono::system_clock::now()You can try the following cross-platform code to get current date/time:Output:Please visit here for more information about date/time formatthe C++ standard library does not provide a proper date type. C++ inherits the structs and functions for date and time manipulation from C, along with a couple of date/time input and output functions that take into account localization.(For fellow googlers)There is also Boost::date_time :New answer for an old question:The question does not specify in what timezone.  There are two reasonable possibilities:For 1, you can use this date library and the following program:Which just output for me:The date library essentially just adds a streaming operator for std::chrono::system_clock::time_point.  It also adds a lot of other nice functionality, but that is not used in this simple program.If you prefer 2 (the local time), there is a timezone library that builds on top of the date library.  Both of these libraries are open source and cross platform, assuming the compiler supports C++11 or C++14.Which for me just output:The result type from make_zoned is a date::zoned_time which is a pairing of a date::time_zone and a std::chrono::system_clock::time_point.  This pair represents a local time, but can also represent UTC, depending on how you query it.With the above output, you can see that my computer is currently in a timezone with a UTC offset of -4h, and an abbreviation of EDT.If some other timezone is desired, that can also be accomplished.  For example to find the current time in Sydney , Australia just change the construction of the variable local to:And the output changes to:Yes and you can do so with formatting rules specified by the currently-imbued locale:Output: Fri Sep  6 20:33:31 2013There\'s always the __TIMESTAMP__ preprocessor macro.example: Sun Apr 13 11:28:08 2014You can also directly use ctime(): I found this link pretty useful for my implementation:\nC++ Date and TimeHere\'s the code I use in my implementation, to get a clear "YYYYMMDD HHMMSS" output format. The param in is for switching between UTC and local time. You can easily modify my code to suite your need. Output (UTC, EST):This compiled for me on Linux (RHEL) and Windows (x64) targeting g++ and OpenMP:http://www.cplusplus.com/reference/ctime/strftime/This built-in seems to offer a reasonable set of options.This works with G++ I\'m not sure if this helps you. \nProgram output: Code :The ffead-cpp provides multiple utility classes for various tasks, one such class is the Date class which provides a lot of features right from Date operations to date arithmetic, there\'s also a Timer class provided for timing operations. You can have a look at the same.you could use C++ 11 time class:out put:Get the current time either using std::time() or std::chrono::system_clock::now() (or another clock type).std::put_time() (C++11) and strftime() (C) offer a lot of formatters to output those times.The sequence of the formatters matters:The formatters of strftime() are similar:Often, the capital formatter means "full version" and lowercase means abbreviation (e.g. Y: 2017, y: 17).Locale settings alter the output:Possible output (Coliru, Compiler Explorer):I\'ve used std::gmtime() for conversion to UTC. std::localtime() is provided to convert to local time.Heed that asctime()/ctime() which were mentioned in other answers are marked as deprecated now and strftime() should be preferred.You could use boost:localtime_s() version:If you want millisecond precision:Then useYou should get something like