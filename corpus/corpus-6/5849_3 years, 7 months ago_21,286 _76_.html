I was reading about order of evaluation violations, and they give an example that puzzles me.1) If a side effect on a scalar object is un-sequenced relative to another side effect on the same scalar object, the behavior is undefined. In this context, i is a scalar object, which apparently meansArithmetic types (3.9.1), enumeration types, pointer types, pointer to member types (3.9.2), std::nullptr_t, and cv-qualified versions of these types (3.9.3) are collectively called scalar types.I don\xe2\x80\x99t see how the statement is ambiguous in that case. It seems to me that regardless of if the first or second argument is evaluated first, i ends up as -1, and both arguments are also -1.Can someone please clarify?I really appreciate all the discussion. So far, I like @harmic\xe2\x80\x99s answer a lot since it exposes the pitfalls and intricacies of defining this statement in spite of how straight forward it looks at first glance. @acheong87 points out some issues that come up when using references, but I think that\'s orthogonal to the unsequenced side effects aspect of this question.Since this question got a ton of attention, I will summarize the main points/answers. First, allow me a small digression to point out that "why" can have closely related yet subtly different meanings, namely "for what cause", "for what reason", and "for what purpose". I will group the answers by which of those meanings of "why" they addressed.The main answer here comes from Paul Draper, with Martin J contributing a similar but not as extensive answer. Paul Draper\'s answer boils down toIt is undefined behavior because it is not defined what the behavior is.The answer is overall very good in terms of explaining what the C++ standard says. It also addresses some related cases of UB such as f(++i, ++i); and f(i=1, i=-1);. In the first of the related cases, it\'s not clear if the first argument should be i+1 and the second i+2 or vice versa; in the second, it\'s not clear if i should be 1 or -1 after the function call. Both of these cases are UB because they fall under the following rule:If a side effect on a scalar object is unsequenced relative to another side effect on the same scalar object, the behavior is undefined.Therefore, f(i=-1, i=-1) is also UB since it falls under the same rule, despite that the intention of the programmer is (IMHO) obvious and unambiguous.Paul Draper also makes it explicit in his conclusion thatCould it have been defined behavior? Yes. Was it defined? No.which brings us to the question of "for what reason/purpose was f(i=-1, i=-1) left as undefined behavior?"Although there are some oversights (maybe careless) in the C++ standard, many omissions are well-reasoned and serve a specific purpose. Although I am aware that the purpose is often either "make the compiler-writer\'s job easier", or "faster code", I was mainly interested to know if there is a good reason leave f(i=-1, i=-1) as UB.harmic and supercat provide the main answers that provide a reason for the UB. Harmic points out that an optimizing compiler that might break up the ostensibly atomic assignment operations into multiple machine instructions, and that it might further interleave those instructions for optimal speed. This could lead to some very surprising results: i ends up as -2 in his scenario! Thus, harmic demonstrates how assigning the same value to a variable more than once can have ill effects if the operations are unsequenced.supercat provides a related exposition of the pitfalls of trying to get f(i=-1, i=-1) to do what it looks like it ought to do. He points out that on some architectures, there are hard restrictions against multiple simultaneous writes to the same memory address. A compiler could have a hard time catching this if we were dealing with something less trivial than f(i=-1, i=-1).davidf also provides an example of interleaving instructions very similar to harmic\'s.Although each of harmic\'s, supercat\'s and davidf\' examples are somewhat contrived, taken together they still serve to provide a tangible reason why f(i=-1, i=-1) should be undefined behavior.I accepted harmic\'s answer because it did the best job of addressing all meanings of why, even though Paul Draper\'s answer addressed the "for what cause" portion better.JohnB points out that if we consider overloaded assignment operators (instead of just plain scalars), then we can run into trouble as well.Since the operations are unsequenced, there is nothing to say that the instructions performing the assignment cannot be interleaved. It might be optimal to do so, depending on CPU architecture. The referenced page states this:If A is not sequenced before B and B is not sequenced before A, then\n  two possibilities exist: evaluations of A and B are unsequenced: they may be performed in any order and may overlap (within a single thread of execution, the\n  compiler may interleave the CPU instructions that comprise A and B) evaluations of A and B are indeterminately-sequenced: they may be performed in any order but may not overlap: either A will be complete\n  before B, or B will be complete before A. The order may be the\n  opposite the next time the same expression is evaluated.That by itself doesn\'t seem like it would cause a problem - assuming that the operation being performed is storing the value -1 into a memory location. But there is also nothing to say that the compiler cannot optimize that into a separate set of instructions that has the same effect, but which could fail if the operation was interleaved with another operation on the same memory location.For example, imagine that it was more efficient to zero the memory, then decrement it, compared with loading the value -1 in. Then this:might become:Now i is -2.It is probably a bogus example, but it is possible.First, "scalar object" means a type like a int, float, or a pointer (see What is a scalar Object in C++?).Second, it may seem more obvious that would have undefined behavior. Butis less obvious.A slightly different example:What assignment happened "last", i = 1, or i = -1? It\'s not defined in the standard. Really, that means i could be 5 (see harmic\'s answer for a completely plausible explanation for how this chould be the case). Or you program could segfault. Or reformat your hard drive.But now you ask: "What about my example? I used the same value (-1) for both assignments. What could possibly be unclear about that?"You are correct...except in the way the C++ standards committee described this.If a side effect on a scalar object is unsequenced relative to another side effect on the same scalar object, the behavior is undefined.They could have made a special exception for your special case, but they didn\'t. (And why should they? What use would that ever possibly have?) So, i could still be 5. Or your hard drive could be empty. Thus the answer to your question is:It is undefined behavior because it is not defined what the behavior is.(This deserves emphasis because many programmers think "undefined" means "random", or "unpredictable". It doesn\'t; it means not defined by the standard. The behavior could be 100% consistent, and still be undefined.)Could it have been defined behavior? Yes. Was it defined? No. Hence, it is "undefined".That said, "undefined" doesn\'t mean that a compiler will format your hard drive...it means that it could and it would still be a standards-compliant compiler. Realistically, I\'m sure g++, Clang, and MSVC will all do what you expected. They just wouldn\'t "have to".A different question might be Why did the C++ standards committee choose to make this side-effect unsequenced?. That answer will involve history and opinions of the committee. Or What is good about having this side-effect unsequenced in C++?, which permits any justification, whether or not it was the actual reasoning of the standards committee. You could ask those questions here, or at programmers.stackexchange.com.A practical reason to not make an exception from the rules just because the two values are the same:Consider the case this was allowed.Now, some months later, the need arises to changeSeemingly harmless, isn\'t it? And yet suddenly prog.cpp wouldn\'t compile anymore.\nYet, we feel that compilation should not depend on the value of a literal.Bottom line: there is no exception to the rule because it would make successful compilation depend on the value (rather the type) of a constant.@HeartWare pointed out that constant expressions of the form A DIV B are not allowed in some languages, when B is 0, and cause compilation to fail. Hence changing of a constant could cause compilation errors in some other place. Which is, IMHO, unfortunate. But it is certainly good to restrict such things to the unavoidable.Behavior is commonly specified as undefined if there is some conceivable reason why a compiler which was trying to be "helpful" might do something which would cause totally unexpected behavior.In the case where a variable is written multiple times with nothing to ensure that the writes happen at distinct times, some kinds of hardware might allow multiple "store" operations to be performed simultaneously to different addresses using a dual-port memory. However, some dual-port memories expressly forbid the scenario where two stores hit the same address simultaneously, regardless of whether or not the values written match.  If a compiler for such a machine notices two unsequenced attempts to write the same variable, it might either refuse to compile or ensure that the two writes cannot get scheduled simultaneously. But if one or both of the accesses is via a pointer or reference, the compiler might not always be able to tell whether both writes might hit the same storage location.  In that case, it might schedule the writes simultaneously, causing a hardware trap on the access attempt.Of course, the fact that someone might implement a C compiler on such a platform does not suggest that such behavior shouldn\'t be defined on hardware platforms when using stores of types small enough to be processed atomically.  Trying to store two different values in unsequenced fashion could cause weirdness if a compiler isn\'t aware of it; for example, given:if the compiler in-lines the call to "moo" and can tell it doesn\'t modify\n"v", it might store a 5 to v, then store a 6 to *p, then pass 5 to "zoo",\nand then pass the contents of v to "zoo".  If "zoo" doesn\'t modify "v",\nthere should be no way the two calls should be passed different values,\nbut that could easily happen anyway.  On the other hand, in cases where\nboth stores would write the same value, such weirdness could not occur and\nthere would on most platforms be no sensible reason for an implementation\nto do anything weird.  Unfortunately, some compiler writers don\'t need any\nexcuse for silly behaviors beyond "because the Standard allows it", so even\nthose cases aren\'t safe.The fact that the result would be the same in most implementations in this case is incidental; the order of evaluation is still undefined. Consider f(i = -1, i = -2): here, order matters. The only reason it doesn\'t matter in your example is the accident that both values are -1.Given that the expression is specified as one with an undefined behaviour, a maliciously compliant compiler might display an inappropriate image when you evaluate f(i = -1, i = -1) and abort the execution - and still be considered completely correct. Luckily, no compilers I am aware of do so.The confusion is that storing a constant value into a local variable is not one atomic instruction on every architecture the C is designed to be run on. The processor the code runs on matters more than the compiler in this case. For example, on ARM where each instruction can not carry a complete 32 bits constant, storing an int in a variable needs more that one instruction. Example with this pseudo code where you can only store 8 bits at a time and must work in a 32 bits register, i is a int32:You can imagine that if the compiler wants to optimize it may interleave the same sequence twice, and you don\'t know what value will get written to i; and let\'s say that he is not very smart:However in my tests gcc is kind enough to recognize that the same value is used twice and generates it once and does nothing weird. I get -1, -1\nBut my example is still valid as it is important to consider that even a constant may not be as obvious as it seems to be.It looks to me like the only rule pertaining to sequencing of function argument expression is here:3) When calling a function (whether or not the function is inline, and whether or not explicit function call syntax is used), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function.This does not define sequencing between argument expressions, so we end up in this case:1) If a side effect on a scalar object is unsequenced relative to another side effect on the same scalar object, the behavior is undefined.In practice, on most compilers, the example you quoted will run fine (as opposed to "erasing your hard disk" and other theoretical undefined behavior consequences).\nIt is, however, a liability, as it depends on specific compiler behaviour, even if the two assigned values are the same. Also, obviously, if you tried to assign different values, the results would be "truly" undefined:The assignment operator could be overloaded, in which case the order could matter:This is just answering the "I\'m not sure what "scalar object" could mean besides something like an int or a float".I would interpret the "scalar object" as a abbreviation of "scalar type object", or just "scalar type variable". Then, pointer, enum (constant) are of scalar type.This is a MSDN article of Scalar Types.Actually, there\'s a reason not to depend on the fact that compiler will check that i is assigned with the same value twice, so that it\'s possible to replace it with single assignment. What if we have some expressions?C++17 defines stricter evaluation rules. In particular, it sequences function arguments (although in unspecified order).N5659 \xc2\xa74.6:15\n  Evaluations A and B are indeterminately sequenced when either A is sequenced before B or B is sequenced before A,\n  but it is unspecified which. [ Note: Indeterminately sequenced evaluations cannot overlap, but either could\n  be executed first. \xe2\x80\x94end note ]N5659 \xc2\xa7 8.2.2:5\n  The\n  initialization of a parameter, including every associated value computation and side effect, is indeterminately\n  sequenced with respect to that of any other parameter.It allows some cases which would be UB before: