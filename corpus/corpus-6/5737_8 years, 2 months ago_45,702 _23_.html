We\'re often told we should protect encapsulation by making getter and setter methods (properties in C#) for class fields, instead of exposing the fields to the outside world.But there are many times when a field is just there to hold a value and doesn\'t require any computation to get or set. For these we would all do this number:Well, I have a confession, I couldn\'t bear writing all that (really, it wasn\'t having to write it, it was having to look at it), so I went rogue and used public fields.Then along comes C# 3.0 and I see they added automatic properties:which is tidier, and I\'m thankful for it, but really, what\'s so different than just making a public field?In a related question I had some time ago, there was a link to a posting on Jeff\'s blog, explaining some differences.Properties vs. Public VariablesChanging a variable to a property is a breaking change. For example:  Ignoring the API issues, the thing I find most valuable about using a property is debugging.  The CLR debugger does not support data break points (most native debuggers do).  Hence it\'s not possible to set a break point on the read or write of a particular field on a class.  This is very limiting in certain debugging scenarios.Because properties are implemented as very thin methods, it is possible to set breakpoints on the read and write of their values.  This gives them a big leg up over fields.  Just because no one mentioned it: You can\'t define fields on Interfaces. So, if you have to implement a specific interface which defines properties, auto-properties sometimes are a really nice feature.Changing from a field to a property breaks the contract (e.g. requires all referencing code to be recompiled). So when you have an interaction point with other classes - any public (and generally protected) member, you want to plan for future growth. Do so by always using properties.It\'s nothing to make it an auto-property today, and 3 months down the line realize you want to make it lazy-loaded, and put a null check in the getter. If you had used a field, this is a recompile change at best and impossible at worst, depending on who & what else relies on your assemblies.A huge difference that is often overlooked and is not mentioned in any other answer: overriding. You can declare properties virtual and override them whereas you cannot do the same for public member fields.Another advantage of auto-implemented properties over public fields is that you can make set accessors private or protected, providing the class of objects where it was defined better control than that of public fields.It\'s all about versioning and API stability.  There is no difference, in version 1 - but later, if you decide you need to make this a property with some type of error checking in version 2, you don\'t have to change your API- no code changes, anywhere, other than the definition of the property.There is nothing wrong in making a field public. But remember creating getter/setter with private fields is no encapsulation. IMO, If you do not care about other features of a Property, you might as well make it public.If you decide later to check that the title is unique, by comparing to a collection or a database, you can do that in the property without changing any code that depends on it.If you go with just a public attribute then you will have less flexibility.  The extra flexibility without breaking the contract is what is most important to me about using properties, and, until I actually need the flexibility, auto-generation makes the most sense.One thing I find very useful as well as all the code and testing reasons is that if it is a property vs a field is that the Visual Studio IDE shows you the references for a property but not a field.One aspect is also performance. I have found out interesting thing - in debug version access to the property is nearly double slower(if not more) than to the field, BUT in release version access to the property is marginally faster than to the field!