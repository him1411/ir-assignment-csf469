I asked a question about Currying and closures were mentioned.\nWhat is a closure? How does it relate to currying?When you declare a local variable, that variable has a scope. Generally local variables exist only within the block or function in which you declare them. If I try to access a local variable, most languages will look for it in the current scope, then up through the parent scopes until they reach the root scope.When a block or function is done with, its local variables are no longer needed and are usually blown out of memory.This is how we normally expect things to work.A closure is a persistent scope which holds on to local variables even after the code execution has moved out of that block. Languages which support closure (such as JavaScript, Swift and Ruby) will allow you to keep a reference to a scope (including its parent scopes), even after the block in which those variables were declared has finished executing, provided you keep a reference to that block or function somewhere.The scope object, and all its local variables, are tied to the function, and will persist as long as that function persists.This gives us function portability. We can expect any variables that were in scope when the function was first defined to still be in scope when we later call the function, even if we call the function in a completely different context.Here\'s a really simple example in JavaScript that illustrates the point:Here I have defined a function within a function. The inner function gains access to all the outer function\'s local variables, including a. The variable a is in scope for the inner function.Normally when a function exits, all its local variables are blown away. However, if we return the inner function and assign it to a variable fnc, so that it persists after outer has exited, all of the variables that were in scope when inner was defined also persist. The variable a has been closed over -- it is within a closure.Note that the variable a is totally private to fnc. This is a way of creating private variables in a functional programming language such as JavaScript.As you might be able to guess, when I call fnc() it prints the value of a, which is "1". In a language without closure, the variable a would have been garbage collected and thrown away when the function outer exited. Calling fnc would have thrown an error because a no longer exists.In JavaScript, the variable a persists because variable scope is created when the function is first declared, and persists for as long as the function continues to exist.a belongs to the scope of outer. The scope of inner has a parent pointer to the scope of outer. fnc is a variable which points to inner. a persists as long as fnc persists. a is within the closure.I\'ll give an example (in JavaScript):What this function, makeCounter, does is it returns a function, which we\'ve called x, that will count up by one each time its called. Since we\'re not providing any parameters to x it must somehow remember the count. It knows where to find it based on what\'s called lexical scoping - it must look to the spot where it\'s defined to find the value. This "hidden" value is what is called a closure.Here is my currying example again:What you can see is that when you call add with the parameter a (which is 3), that value is contained in the closure of the returned function that we\'re defining to be add3. That way, when we call add3 it knows where to find the a value to perform the addition.Kyle\'s answer is pretty good. I think the only additional clarification is that the closure is basically a snapshot of the stack at the point that the lambda function is created. Then when the function is re-executed the stack is restored to that state before executing the function. Thus as Kyle mentions, that hidden value (count) is available when the lambda function executes.A closure is a function that can reference state in another function. For example, in Python, this uses the closure "inner":To help facilitate understanding of closures it might be useful to examine how they might be implemented in a procedural language. This explanation will follow a simplistic implementation of closures in Scheme.To start, I must introduce the concept of a namespace. When you enter a command into a Scheme interpreter, it must evaluate the various symbols in the expression and obtain their value. Example:The define expressions store the value 3 in the spot for x and the value 4 in the spot for y. Then when we call (+ x y), the interpreter looks up the values in the namespace and is able to perform the operation and return 7.However, in Scheme there are expressions that allow you to temporarily override the value of a symbol. Here\'s an example:What the let keyword does is introduces a new namespace with x as the value 5. You will notice that it\'s still able to see that y is 4, making the sum returned to be 9. You can also see that once the expression has ended x is back to being 3. In this sense, x has been temporarily masked by the local value.Procedural and object-oriented languages have a similar concept. Whenever you declare a variable in a function that has the same name as a global variable you get the same effect.How would we implement this? A simple way is with a linked list - the head contains the new value and the tail contains the old namespace. When you need to look up a symbol, you start at the head and work your way down the tail.Now let\'s skip to the implementation of first-class functions for the moment. More or less, a function is a set of instructions to execute when the function is called culminating in the return value. When we read in a function, we can store these instructions behind the scenes and run them when the function is called.We define x to be 3 and plus-x to be its parameter, y, plus the value of x. Finally we call plus-x in an environment where x has been masked by a new x, this one valued 5. If we merely store the operation, (+ x y), for the function plus-x, since we\'re in the context of x being 5 the result returned would be 9. This is what\'s called dynamic scoping.However, Scheme, Common Lisp, and many other languages have what\'s called lexical scoping - in addition to storing the operation (+ x y) we also store the namespace at that particular point. That way, when we\'re looking up the values we can see that x, in this context, is really 3. This is a closure.In summary, we can use a linked list to store the state of the namespace at the time of function definition, allowing us to access variables from enclosing scopes, as well as providing us the ability to locally mask a variable without affecting the rest of the program.First of all, contrary to what most of the people here tell you, closure is not a function! So what is it?\nIt is a set of symbols defined in a function\'s "surrounding context" (known as its environment) which make it a CLOSED expression (that is, an expression in which every symbol is defined and has a value, so it can be evaluated).For example, when you have a JavaScript function:it is a closed expression because all the symbols occurring in it are defined in it (their meanings are clear), so you can evaluate it. In other words, it is self-contained.But if you have a function like this:it is an open expression because there are symbols in it which has not been defined in it. Namely, y. When looking at this function, we can\'t tell what y is and what does it mean, we don\'t know its value, so we cannot evaluate this expression. I.e. we cannot call this function until we tell what y is supposed to mean in it. This y is called a free variable.This y begs for a definition, but this definition is not part of the function \xe2\x80\x93 it is defined somewhere else, in its "surrounding context" (also known as the environment). At least that\'s what we hope for :PFor example, it could be defined globally:Or it could be defined in a function which wraps it:The part of the environment which gives the free variables in an expression their meanings, is the closure. It is called this way, because it turns an open expression into a closed one, by supplying these missing definitions for all of its free variables, so that we could evaluate it.In the example above, the inner function (which we didn\'t give a name because we didn\'t need it) is an open expression because the variable y in it is free \xe2\x80\x93 its definition is outside the function, in the function which wraps it. The environment for that anonymous function is the set of variables:Now, the closure is that part of this environment which closes the inner function by supplying the definitions for all its free variables. In our case, the only free variable in the inner function was y, so the closure of that function is this subset of its environment:The other two symbols defined in the environment are not part of the closure of that function, because it doesn\'t require them to run. They are not needed to close it.More on the theory behind that here:\nhttps://stackoverflow.com/a/36878651/434562It\'s worth to note that in the example above, the wrapper function returns its inner function as a value. The moment we call this function can be remote in time from the moment the function has been defined (or created). In particular, its wrapping function is no longer running, and its parameters which has been on the call stack are no longer there :P This makes a problem, because the inner function needs y to be there when it is called! In other words, it requires the variables from its closure to somehow outlive the wrapper function and be there when needed. Therefore, the inner function has to make a snapshot of these variables which make its closure and store them somewhere safe for later use. (Somewhere outside the call stack.)And this is why people often confuse the term closure to be that special type of function which can do such snapshots of the external variables they use, or the data structure used to store these variables for later. But I hope you understand now that they are not the closure itself \xe2\x80\x93 they\'re just ways to implement closures in a programming language, or language mechanisms which allows the variables from the function\'s closure to be there when needed. There\'s a lot of misconceptions around closures which (unnecessarily) make this subject much more confusing and complicated that it actually is.Here\'s a real world example of why Closures kick ass... This is straight out of my Javascript code. Let me illustrate.And here\'s how you would use it:Now imagine you want the playback to start delayed, like for example 5 seconds later after this code snippet runs. Well that\'s easy with delay and it\'s closure:When you call delay with 5000ms, the first snippet runs, and stores the passed in arguments in it\'s closure. Then 5 seconds later, when the setTimeout callback happens, the closure still maintains those variables, so it can call the original function with the original parameters.\nThis is a type of currying, or function decoration.Without closures, you would have to somehow maintain those variables state outside the function, thus littering code outside the function with something that logically belongs inside it. Using closures can greatly improve the quality and readiblity of your code.In a normal situation, variables are bound by scoping rule: Local variables work only within the defined function. Closure is a way of breaking this rule temporarily for convenience.in the above code, lambda(|n| a_thing * n} is the closure because a_thing is referred by the lambda (an anonymous function creator).Now, if you put the resulting anonymous function in a function variable.foo will break the normal scoping rule and start using 4 internally.returns 12.src: https://leanpub.com/javascriptallongesix/read#leanpub-auto-if-functions-without-free-variables-are-pure-are-closures-impureIn short, function pointer is just a pointer to a location in the program code base (like program counter). Whereas Closure = Function pointer + Stack frame..A closure is a function and its scope assigned to (or used as) a variable. Thus, the name closure: the scope and the function is enclosed and used just like any other entity. According to Wikipedia, a closure is: Techniques for implementing lexically scoped name binding in languages with first-class functions.What does that mean? Lets look into some definitions.I will explain closures and other related definitions by using this example:Basically that means we can use functions just like any other entity. We can modify them, pass them as arguments, return them from functions or assign them for variables. Technically speaking, they are first-class citizens, hence the name: first-class functions.In the example above, startAt returns an (anonymous) function which function get assigned to closure1 and closure2. So as you see JavaScript treats functions just like any other entities (first-class citizens).Name binding is about finding out what data a variable (identifier) references. The scope is really important here, as that is the thing that will determine how a binding is resolved. In the example above:Inside the anonymous function\'s scope, x is not bound to any value, so it needs to be resolved in an upper (startAt\'s) scope.As Wikipedia says, the scope:Is the region of a computer program where the binding is valid: where the name can be used to refer to the entity.There are two techniques:For more explanation, check out this question and take a look at Wikipedia.In the example above, we can see that JavaScript is lexically scoped, because when x is resolved, the binding is searched in the upper (startAt\'s) scope, based on the source code (the anonymous function that looks for x is defined inside startAt) and not based on the call stack, the way (the scope where) the function was called.In our example, when we call startAt, it will return a (first-class) function that will be assigned to closure1 and closure2 thus a closure is created, because the passed variables 1 and 5 will be saved within startAt\'s scope, that will be enclosed with the returned anonymous function. When we call this anonymous function via closure1 and closure2 with the same argument (3), the value of y will be found immediately (as that is the parameter of that function), but x is not bound in the scope of the anonymous function, so the resolution continues in the (lexically) upper function scope (that was saved in the closure) where x is found to be bound to either 1 or 5. Now we know everything for the summation so the result can be returned, then printed.Now you should understand closures and how they behave, which is a fundamental part of JavaScript.Oh, and you also learned what currying is about: you use functions (closures) to pass each argument of an operation instead of using one functions with multiple parameters.Here is another real life example, and using a scripting language popular in games - Lua.  I needed to slightly change the way a library function worked to avoid a problem with stdin not being available.The value of old_dofile disappears when this block of code finishes it\'s scope (because it\'s local), however the value has been enclosed in a closure, so the new redefined dofile function CAN access it, or rather a copy stored along with the function as an \'upvalue\'.From Lua.org:When a function is written enclosed in another function, it has full access to local variables from the enclosing function; this feature is called lexical scoping. Although that may sound obvious, it is not. Lexical scoping, plus first-class functions, is a powerful concept in a programming language, but few languages support that concept.If you are from the Java world, you can compare a closure with a member function of a class. Look at this exampleThe function g is a closure: g closes a in. So g can be compared with a member function, a can be compared with a class field, and the function f with a class.Closures\nWhenever we have a function defined inside another function, the inner function has access to the variables declared\nin the outer function. Closures are best explained with examples.\nIn Listing 2-18, you can see that the inner function has access to a variable (variableInOuterFunction) from the\nouter scope. The variables in the outer function have been closed by (or bound in) the inner function. Hence the term\nclosure. The concept in itself is simple enough and fairly intuitive.source: http://index-of.es/Varios/Basarat%20Ali%20Syed%20(auth.)-Beginning%20Node.js-Apress%20(2014).pdf