How do you squash your entire repository down to the first commit?I can rebase to the first commit, but that would leave me with 2 commits.\nIs there a way to reference the commit before the first one?Perhaps the easiest way is to just create a new repository with current state of the working copy.  If you want to keep all the commit messages you could first do git log > original.log and then edit that for your initial commit message in the new repository:orIn recent versions of git, you can use git rebase --root -i.For each commit except the first, change pick to squash.I\'ve create an alias git squash-all. Example usage: git squash-all "a brand new start".Caveat: remember to provide a comment, otherwise the default commit message "A new start" would be used.Or you can create the alias with the following command:Note: here "A new start" is just an example, feel free to use your own language.No need to squash, use git commit-tree to create an orphan commit and go with it.create a single commit via git commit-treeWhat git commit-tree HEAD^{tree} -m "A new start" does is:Creates a new commit object based on the provided tree object\n  and emits the new commit object id on stdout. The log message is\n  read from the standard input, unless -m or -F options are given.The expression HEAD^{tree} means the tree object corresponding to HEAD, namely the tip of your current branch. see Tree-Objects and Commit-Objects.reset the current branch to the new commitThen git reset simply reset the current branch to the newly created \ncommit object. This way, nothing in the workspace is touched, nor there\'s \n  need for rebase/squash, which makes it really fast. And the time needed is irrelevant to the repository size or history depth.This is useful to create the "initial commit" in a new project using another repository as the template/archetype/seed/skeleton. For example:This avoids adding the template repo as a remote (origin or otherwise) and collapses the template repo\'s history into your initial commit.If all you want to do is squash all of your commits down to the root commit, then whilecan work, it\'s impractical for a large number of commits (for example, hundreds of commits), because the rebase operation will probably run very slowly to generate the interactive rebase editor commit list, as well as run the rebase itself.Here are two quicker and more efficient solutions when you\'re squashing a large number of commits:You can simply create a new orphan branch at the tip (i.e. the most recent commit) of your current branch. This orphan branch forms the initial root commit of an entirely new and separate commit history tree, which is effectively equivalent to squashing all of your commits:Documentation:Another efficient solution is to simply use a mixed or soft reset to the root commit <root>:Documentation:This will create an orphaned commit with the tree of HEAD, and output it\'s name (SHA-1) on stdout. Then just reset your branch there.The easiest way is to use the \'plumbing\' command update-ref to delete the current branch. You can\'t use git branch -D as it has a safety valve to stop you deleting the current branch.This puts you back into the \'initial commit\' state where you can start with a fresh initial commit.Here\'s how I ended up doing this, just in case it works for someone else:Remember that there\'s always risk in doing things like this, and its never a bad idea to create a save branch before starting.Start by loggingScroll to first commit, copy SHAReplace <#sha#> w/ the SHA copied from the logMake sure everything\'s green, otherwise run git add -AAmend all current changes to current first commitNow force push this branch and it will overwrite what\'s there.First, squash all your commits into a single commit using git rebase --interactive. Now you\'re left with two commits to squash. To do so, read any ofI read something about using grafts but never investigated it much.Anyway, you can squash those last 2 commits manually with something like this:This answer improves on a couple above (please vote them up), assuming that in addition to creating the one commit (no-parents no-history), you also want to retain all of the commit-data of that commit:Of course the commit-SHA of the new/single commit will change, because it represents a new (non-)history, becoming a parentless/root-commit.This can be done by reading git log and setting some variables for git commit-tree.  Assuming that you want to create a single commit from master in a new branch one-commit, retaining the commit-data above:Add a file .git/info/grafts, put there the commit hash you want to become your rootgit log will now start from that commitTo make it \'real\' run git filter-branch