On IE I can do this with the (terribly non-standard, but working) jQueryBut is it possible to do in a way which works on Firefox, or in a cross-browser way for a bonus?For the record:does nothing.solves the problem, but renders the backspace key unusable on the page, which is even worse than the original behaviour.EDIT:\nThe reason I do this is that I\'m not creating a simple web page but a large application. It is incredibly annoying to lose 10 minutes of work just because you pressed backspace in the wrong place. The ratio of preventing mistakes vs. annoying users should be way above 1000/1 by preventing the backspace key from navigating back.EDIT2: I\'m not trying to prevent history navigation, just accidents.EDIT3: @brentonstrines comment (moved here since the question is so popular): This is a long-term \'fix\', but you could throw your support behind the Chromium bug to change this behavior in webkitThis code solves the problem, at least in IE and Firefox (haven\'t tested any other, but I give it a reasonable chance of working if the problem even exists in other browsers).This code works on all browsers and swallows the backspace key when not on a form element, or if the form element is disabled|readOnly.  It is also efficient, which is important when it is executing on every key typed in.The other answers here have established that this cannot be done without whitelisting elements in which Backspace is allowed. This solution is not ideal because the whitelist is not as straightforward as merely textareas and text/password inputs, but is repeatedly found to be incomplete and needing to be updated. However, since the purpose of suppressing the backspace functionality is merely to prevent users from accidentally losing data, the beforeunload solution is a good one because the modal popup is surprising--modal popups are bad when they are triggered as part of a standard workflow, because the user gets used to dismissing them without reading them, and they are annoying. In this case, the modal popup would only appear as an alternative to a rare and surprising action, and is therefore acceptable. The problem is that an onbeforeunload modal must not pop up whenever the user navigates away from the page (such as when clicking a link or submitting a form), and we don\'t want to start whitelisting or blacklisting specific onbeforeunload conditions. The ideal combination of tradeoffs for a generalized solution is as follows: keep track of whether backspace is pressed, and only pop up the onbeforeunload modal if it is. In other words:This has been tested to work in IE7+, FireFox, Chrome, Safari, and Opera. Just drop this function into your global.js and call it from any page where you don\'t want users to accidentally lose their data.A more elegant/concise solution:Modification of erikkallen\'s Answer to address different input typesI\'ve found that an enterprising user might press backspace on a checkbox or a radio button in a vain attempt to clear it and instead they would navigate backwards and lose all of their data.This change should address that issue.New Edit to address content editable divsExample\nTo test make 2 files.starthere.htm - open this first so you have a place to go back totest.htm - This will navigate backwards when backspace is pressed while the checkbox or submit has focus (achieved by tabbing). Replace with my code to fix.Based on the comments it appears you want to stop people losing information in forms, if they press backspace to delete but the field is not focused.In which case, you want to look at the onunload event handler. Stack Overflow uses it - if you try to leave a page when you\'ve started writing an answer, it pops up a warning.Not sure why no-one\'s just answered this - seems like a perfectly reasonable technical question to ask whether it\'s possible.No, I don\'t think there\'s a cross-browser way to disable the backspace button. I know it\'s not enabled by default in FF these days though.Stop from navigating this code works!But for not to restricting text fields but othersTo prevent it for specific field simply useReferring to this one below!Prevent BACKSPACE from navigating back with jQuery (Like Google's Homepage)Combining solutions given by "thetoolman" && "Biff MaGriff"following code seems to work correctly in IE 8/Mozilla/ChromeThis solution is similar to others that have been posted, but it uses a simple whitelist making it easily customizable to allow the backspace in specified elements just by setting the selector in the .is() function.I use it in this form to prevent the backspace on pages from navigating back:To elaborate slightly on @erikkallen\'s excellent answer, here is a function that allows all keyboard-based input types, including those introduced in HTML5:JavaScript - jQuery way:Javascript - the native way, that works for me:I had a hard time finding a non-JQUERY answer. Thanks to Stas for putting me on the track.Chrome:  If you don\'t need cross browser support, you can just use a blacklist, rather than whitelisting. This pure JS version works in Chrome, but not in IE. Not sure about FF. In Chrome (ver. 36, mid 2014), keypresses not on an input or contenteditable element seem to be targeted to <BODY>. This makes it possible use a blacklist, which I prefer to whitelisting. IE uses the last click target - so it might be a div or anything else. That makes this useless in IE.Cross Browser:  For pure javascript, I found Stas\' answer to be the best. Adding one more condition check for contenteditable made it work for me*:*Note that IEs [edit: and Spartan/TechPreview] have a "feature" that makes  table-related elements uneditable. If you click one of those and THEN press backspace, it WILL navigate back. If you don\'t have editable <td>s, this is not an issue.I had some problems with the accepted solution and the Select2.js plugin; I was not able to delete characters in the editable box as the delete action was being prevented. This was my solution:Select2 creates a Span with an attribute of "contentEditable" which is set to true for the editable combo box in it. I added code to account for the spans tagName and the different attribute. This solved all my problems.Edit: If you are not using the Select2 combobox plugin for jquery, then this solution may not be needed by you, and the accepted solution might be better.Most of the answers are in jquery. You can do this perfectly  in pure Javascript, simple and no library required. This article was a good starting point for me but since keyIdentifier is deprecated, I wanted this code to be more secure so I added ||e.keyCode==8 to the if statement. Also, the code wasn\'t working well on Firefox so I added return false; and now it works perfectly well. Here it is:This code works great because,You can add console.log(e); for your your test purposes, and hit F12 in chrome, go to "console" tab and hit "backspace" on the page and look inside it to see what values are returned, then you can target all of those parameters to further enhance the code above to suit your needs.This code solves the problem in all browsers:Simplest way to prevent navigation on pressing backspaceUsing Dojo toolkit 1.7, this works in IE 8:Have you tried the very simple solution of just adding the following attribute to your read only text field:onkeydown="return false;" This will keep the browser from going back in history when the Backspace key is pressed in a read only text field.  Maybe I am missing your true intent, but seems like this would be the simplest solution to your issue.A much neater solution -Alternately, you could only check ifPure javascript version, which works in all browsers:Of course you can use "INPUT, TEXTAREA" and use "if (!regex.test(elements))" then. The first worked fine for me.Performance?I was worried about performance and made a fiddle: http://jsfiddle.net/felvhage/k2rT6/9/embedded/result/I have analyzed the most promising methods i found in this thread. It turns out, they were all very fast and most probably do not cause a problem in terms of "sluggishness" when typing.\nThe slowest Method i looked at was about 125 ms for 10.000 Calls in IE8. Which is 0.0125ms per Stroke.I found the methods posted by Codenepal and Robin Maben to be fastest ~ 0.001ms (IE8) but beware of the different semantics.Perhaps this is a relief to someone introducing this kind of functionality to his code.Modified erikkallen answer:This solution worked very well when tested.I did add some code to handle some input fields not tagged with input, and to integrate in an Oracle PL/SQL application that generates an input form for my job.My "two cents":I created a NPM project with a clean version of the currently accepted (of erikkallen) https://github.com/slorber/backspace-disablerIt uses basically the same principles but:Here is my rewrite of the top-voted answer. I tried to check element.value!==undefined (since some elements like  may have no html attribute but may have a javascript value property somewhere on the prototype chain), however that didn\'t work very well and had lots of edge cases. There doesn\'t seem to be a good way to future-proof this, so a whitelist seems the best option.This registers the element at the end of the event bubble phase, so if you want to handle Backspace in any custom way, you can do so in other handlers.This also checks instanceof HTMLTextAreElement since one could theoretically have a web component which inherits from that.This does not check contentEditable (combine with other answers).https://jsfiddle.net/af2cfjc5/15/Sitepoint: Disable back for Javascriptevent.stopPropagation() and event.preventDefault() do nothing in IE.  I had to send return event.keyCode == 11 (I just picked something) instead of just saying "if not = 8, run the event" to make it work, though.  event.returnValue = false also works.Another method using jqueryI\'ve been using this in my code for some time now.  I write online tests for students and ran into the problem when students were pressing backspace during their test and it would take them back to the login screen.  Frustrating!  It works on FF for sure.  