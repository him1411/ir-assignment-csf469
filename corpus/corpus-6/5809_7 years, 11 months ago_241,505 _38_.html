Given this array:I would like to sort $inventory\'s elements by price to get:How can I do this?You are right, the function you\'re looking for is array_multisort().Here\'s an example taken straight from the manual and adapted to your case:As of PHP 7, this can be done concisely using usort with an anonymous function that uses the spaceship operator to compare elements.You can do an ascending sort like this:Or a descending sort like this:To understand how this works, note that usort takes a user-provided comparison function that must behave as follows (from the docs):The comparison function must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second.And note also that <=>, the spaceship operator,returns 0 if both operands are equal, 1 if the left is greater, and -1 if the right is greaterwhich is exactly what usort needs. In fact, almost the entire justification given for adding <=> to the language in https://wiki.php.net/rfc/combined-comparison-operator is that itmakes writing ordering callbacks for use with usort() easierPHP 5.3 introduced anonymous functions, but doesn\'t yet have the spaceship operator. We can still use usort to sort our array, but it\'s a little more verbose and harder to understand:Note that although it\'s fairly common for comparators dealing with integer values to just return the difference of the values, like $item2[\'price\'] - $item1[\'price\'], we can\'t safely do that in this case. This is because the prices are floating point numbers in the question asker\'s example, but the comparison function we pass to usort has to return integers for usort to work properly:Returning non-integer values from the comparison function, such as float, will result in an internal cast to integer of the callback\'s return value. So values such as 0.99 and 0.1 will both be cast to an integer value of 0, which will compare such values as equal.This is an important trap to bear in mind when using usort in PHP 5.x! My original version of this answer made this mistake and yet I accrued ten upvotes over thousands of views apparently without anybody noticing the serious bug. The ease with which lackwits like me can screw up comparator functions is precisely the reason that the easier-to-use spaceship operator was added to the language in PHP 7.Since your array elements are arrays themselves with string keys, your best bet is to define a custom comparison function.  It\'s pretty quick and easy to do.  Try this:Produces the following:I ended on this:Just call the function, passing the array and the name of the field of the second level array.\nLike:You can use usort with anonymous function, e.g.While others have correctly suggested the use of array_multisort(), for some reason no answer seems to acknowledge the existence of array_column(), which can greatly simplify the solution. So my suggestion would be:outputs:Was tested on 100 000 records:\nTime in seconds(calculated by funciton microtime).\nOnly for unique values on sorting key positions.Solution of function of @Josh Davis:\nSpended time: 1.5768740177155Mine solution:\nSpended time: 0.094044923782349Solution:You might try to define your own comparison function and then use usort.This function is re-usable:It works well on string values by default, but you\'ll have to sub the callback for a number comparison function if all your values are numbers.try this:for reference see this:\nhttp://php.net/manual/en/function.asort.phpsee various sort flags here:\nhttp://www.php.net/manual/en/function.sort.phpthe simple solution :)the output is,From Sort an array of associative arrays by value of given key in php: