I would like to join the result of ls -1 into one line and delimit it with whatever i want.Are there any standard Linux commands I can use to achieve this?Similar to the very first option but omits the trailing delimiter EDIT: Simply "ls -m" If you want your delimiter to be a commaAh, the power and simplicity !Change the comma "," to whatever you want.  Note that this includes a "trailing comma"This replaces the last comma with a newline:ls -m includes newlines at the screen-width character (80th for example).Mostly Bash (only ls is external):Using readarray (aka mapfile) in Bash 4:Thanks to gniourf_gniourf for the suggestions.The combination of setting IFS and use of "$*" can do what you want. I\'m using a subshell so I don\'t interfere with this shell\'s $IFSTo capture the output,I think this one is awesomeParsing ls in general is not advised, so alternative better way is to use find, for example:Or by using find and paste:For general joining multiple lines (not related to file system), check: Concise and portable \xe2\x80\x9cjoin\xe2\x80\x9d on the Unix command-line.Don\'t reinvent the wheel.It does exactly that.just bashTo avoid potential newline confusion for tr we could add the -b flag to ls:This command is for the PERL fans :Here 40 is the octal ascii code for space.-p will process line by line and print -l will take care of replacing the trailing \\n with the ascii character we provide.-e is to inform PERL we are doing command line execution.0 means that there is actually no command to execute.perl -e0 is same as perl -e \' \'You can use:Explanation:-e - denotes a command to be executed\n   :a - is a label\n   /$/N - defines the scope of the match for the current and the (N)ext line\n   s/\\n/\\\\n/; - replaces all EOL with \\n\n   ta; - goto label a if the match is successfulTaken from my blog.If you version of xargs supports the -d flag then this should work-d is the delimiter flagIf you do not have -d, then you can try the followingThe first xargs allows you to specify your delimiter which is a comma in this example.ls produces one column output when connected to a pipe, so the -1 is redundant.Here\'s another perl answer using the builtin join function which doesn\'t leave a trailing delimiter:The obscure -0777 makes perl read all the input before running the program.sed alternative that doesn\'t leave a trailing delimiterIt looks like the answers already exist.If you want\na, b, c format, use ls -m ( Tulains C\xc3\xb3rdova\xe2\x80\x99s answer)Or if you want a b c format, use ls | xargs (simpified version of Chris J\xe2\x80\x99s answer)Or if you want any other delimiter like |, use ls | paste -sd\'|\' (application of Artem\xe2\x80\x99s answer)ls has the option -m to delimit the output with ", " a comma and a space.piping this result to tr to remove either the space or the comma will allow you to pipe the result again to tr to replace the delimiter.in my example i replace the delimiter , with the delimiter ;replace ; with whatever one character delimiter you prefer since tr only accounts for the first character in the strings you pass in as arguments.You can use chomp to merge multiple line in single line:perl -e \'while (<>) { if (/\\$/ ) { chomp; } print ;}\' bad0 >testput line break condition in if statement.It can be special character or any delimiter.Adding on top of majkinetor\'s answer, here is the way of removing trailing delimiter(since I cannot just comment under his answer yet):Just remove as many trailing bytes as your delimiter counts for.I like this approach because I can use multi character delimiters + other benefits of awk: