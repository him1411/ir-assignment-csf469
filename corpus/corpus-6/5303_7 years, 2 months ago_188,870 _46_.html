I understand the basics of how ports work. However, what I don\'t get is how multiple clients can simultaneously connect to say port 80. I know each client has a unique (for their machine) port. Does the server reply back from an available port to the client, and simply state the reply came from 80? How does this work?First off, a "port" is just a number.  All a "connection to a port" really represents is a packet which has that number specified in its "destination port" header field.Now, there are two answers to your question, one for stateful protocols and one for stateless protocols.For a stateless protocol (ie UDP), there is no problem because "connections" don\'t exist - multiple people can send packets to the same port, and their packets will arrive in whatever sequence.  Nobody is ever in the "connected" state.For a stateful protocol (like TCP), a connection is identified by a 4-tuple consisting of source and destination ports and source and destination IP addresses.  So, if two different machines connect to the same port on a third machine, there are two distinct connections because the source IPs differ.  If the same machine (or two behind NAT or otherwise sharing the same IP address) connects twice to a single remote end, the connections are differentiated by source port (which is generally a random high-numbered port).Simply, if I connect to the same web server twice from my client, the two connections will have different source ports from my perspective and destination ports from the web server\'s.  So there is no ambiguity, even though both connections have the same source and destination IP addresses.Ports are a way to multiplex IP addresses so that different applications can listen on the same IP address/protocol pair.  Unless an application defines its own higher-level protocol, there is no way to multiplex a port.  If two connections using the same protocol have identical source and destination IPs and identical source and destination ports, they must be the same connection.Important:I\'m sorry to say that the response from "Borealid" is imprecise and somewhat incorrect - firstly there is no relation to statefulness or statelessness to answer this question, and most importantly the definition of the tuple for a socket is incorrect.  First remember below two rules:Primary key of a socket: A socket is identified by {SRC-IP, SRC-PORT, DEST-IP, DEST-PORT, PROTOCOL} not by {SRC-IP, SRC-PORT, DEST-IP, DEST-PORT} - Protocol is an important part of a socket\'s definition.OS Process & Socket mapping: A process can be associated with (can open/can listen to) multiple sockets which might be obvious to many readers.Example 1: Two clients connecting to same server port means: socket1 {SRC-A, 100, DEST-X,80, TCP} and socket2{SRC-B, 100, DEST-X,80, TCP}. This means host A connects to server X\'s port 80 and another host B also connects to same server X to the same port 80. Now, how the server handles these two sockets depends on if the server is single threaded or multiple threaded (I\'ll explain this later). What is important is that one server can listen to multiple sockets simultaneously.To answer the original question of the post:Irrespective of stateful or stateless protocols, two clients can connect to same server port because for each client we can assign a different socket (as client IP will definitely differ). Same client can also have two sockets connecting to same server port - since such sockets differ by SRC-PORT. With all fairness, "Borealid" essentially mentioned the same correct answer but the reference to state-less/full was kind of unnecessary/confusing.To answer the second part of the question on how a server knows which socket to answer. First understand that for a single server process that is listening to same port, there could be more than one sockets (may be from same client or from different clients). Now as long as a server knows which request is associated with which socket, it can always respond to appropriate client using the same socket. Thus a server never needs to open another port in its own node than the original one on which client initially tried to bind connect. If any server allocates different server-ports after a socket is bound, then in my opinion the server is wasting its resource and it must be needing the client to bind connect again to the new port assigned.A bit more for completeness:Example 2: It\'s very interesting question that can a server\'s two different processes listen to same port. If you do not consider protocol as one of parameter defining socket then the answer is no. Initiatively this is so because we can say that in such case for a single client trying to connect to a server-port will not have any mechanism to mention which of the two listening process the client intends to. This is the same theme asserted by rule (2). However this is WRONG answer because \'protocol\' is also a part of the socket definition. Thus two processes in same node can listen to same port only if they are using different protocol. For example two unrelated clients (say one is using TCP and another is using UDP) can bind connect and communicate to the same server node and to the same port but they must be served by two different server-processes. Server Types - single & multiple:When a server\'s processes listening to a port that means multiple sockets can simultaneously connect and communicate with the same server-process. If a server uses only a single child-process to serve all the sockets then the server is called single-process/threaded and if the server uses many sub-processes to serve each socket by one sub-process then the server is called multi-process/threaded server. Note that irrespective of the server\'s type a server can/should always uses the same initial socket to respond back (no need to allocate another server-port).Suggested Books and rest of the two volumes if you can.A Note on Parent/Child Process (in response to query/comment of \'Ioan Alexandru Cucu\')Wherever I mentioned any concept in relation to two processes say A and B, consider that they are not related by parent child relationship. OS\'s (especially UNIX) by design allow a child process to inherit all File-descriptors (FD) from parents. Thus all the sockets (in UNIX like OS are also part of FD) that a process A listening to, can be listened by many more processes A1, A2, .. as long as they are related by parent-child relation to A. But an independent process B (i.e. having no parent-child relation to A) cannot listen to same socket. In addition, also note that this rule of disallowing two independent processes to listen to same socket lies on an OS (or its network libraries) and by far it\'s obeyed by most OS\'s. However, one can create own OS which can very well violate this restrictions.So, what happens when a server listen for incoming connections on a TCP port? For example, let\'s say you have a web-server on port 80. Let\'s assume that your computer has the public IP address of 24.14.181.229 and the person that tries to connect to you has IP address 10.1.2.3. This person can connect to you by opening a TCP socket to 24.14.181.229:80. Simple enough.Intuitively (and wrongly), most people assume that it looks something like this:This is intuitive, because from the standpoint of the client, he has an IP address, and connects to a server at IP:PORT. Since the client connects to port 80, then his port must be 80 too? This is a sensible thing to think, but actually not what happens. If that were to be correct, we could only serve one user per foreign IP address. Once a remote computer connects, then he would hog the port 80 to port 80 connection, and no one else could connect. Three things must be understood:1.) On a server, a process is listening on a port. Once it gets a connection, it hands it off to another thread. The communication never hogs the listening port. 2.) Connections are uniquely identified by the OS by the following 5-tuple: (local-IP, local-port, remote-IP, remote-port, protocol). If any element in the tuple is different, then this is a completely independent connection.3.) When a client connects to a server, it picks a random, unused high-order source port. This way, a single client can have up to ~64k connections to the server for the same destination port.So, this is really what gets created when a client connects to a server:First, let\'s use netstat to see what is happening on this computer. We will use port 500 instead of 80 (because a whole bunch of stuff is happening on port 80 as it is a common port, but functionally it does not make a difference).As expected, the output is blank. Now let\'s start a web server:Now, here is the output of running netstat again:So now there is one process that is actively listening (State: LISTEN) on port 500. The local address is 0.0.0.0, which is code for "listening for all". An easy mistake to make is to listen on address 127.0.0.1, which will only accept connections from the current computer. So this is not a connection, this just means that a process requested to bind() to port IP, and that process is responsible for handling all connections to that port. This hints to the limitation that there can only be one process per computer listening on a port (there are ways to get around that using multiplexing, but this is a much more complicated topic). If a web-server is listening on port 80, it cannot share that port with other web-servers.So now, let\'s connect a user to our machine:This is a simple script (https://github.com/grokit/dcore/tree/master/apps/quicknet) that opens a TCP socket, sends the payload ("Test payload." in this case), waits a few seconds and disconnects. Doing netstat again while this is happening displays the following:If you connect with another client and do netstat again, you will see the following:... that is, the client used another random port for the connection. So there is never confusion between the IP addresses.Normally, for every connecting client the server forks a child process that communicates with the client (TCP). The parent server hands off to the child process an established socket that communicates back to the client.When you send the data to a socket from your child server, the TCP stack in the OS creates a packet going back to the client and sets the "from port" to 80.Multiple clients can connect to the same port (say 80) on the server because on the server side, after creating a socket and binding (setting local IP and port) listen is called on the socket which tells the OS to accept incoming connections.When a client tries to connect to server on port 80, the accept call is invoked on the server socket. This creates a new socket for the client trying to connect and similarly new sockets will be created for subsequent clients using same port 80.Words in italics are system calls.Refhttp://www.scs.stanford.edu/07wi-cs244b/refs/net2.pdf