When I executed the following command:I got this error message:Information about column1 and column2:I think varchar(20) only requires 21 bytes while varchar(500) only requires 501 bytes. So the total bytes are 522, less than 767. So why did I get the error message?767 bytes is the stated prefix limitation for InnoDB tables - its 1,000 bytes long for MyISAM tables.According to the response to this issue, you can get the key to apply by specifying a subset of the column rather than the entire amount. IE:Tweak as you need to get the key to apply, but I wonder if it would be worth it to review your data model regarding this entity to see if there\'s improvements that would allow you to implement the intended business rules without hitting the MySQL limitation.If anyone is having issues with INNODB / Utf-8 trying to put an UNIQUE index on a VARCHAR(256) field, switch it to VARCHAR(255). It seems 255 is the limitation.MySQL assumes worst case for the number of bytes per character in the string. For the MySQL \'utf8\' encoding, that\'s 3 bytes per character since that encoding doesn\'t allow characters beyond U+FFFF. For the MySQL \'utf8mb4\' encoding, it\'s 4 bytes per character, since that\'s what MySQL calls actual UTF-8.So assuming you\'re using \'utf8\', your first column will take 60 bytes of the index, and your second another 1500.When you hit the limit. Set the following.What character encoding are you using? Some character sets (like UTF-16, et cetera) use more than one byte per character.run this query before your query:this will increase limit to 3072 bytes.you could add an column of the md5 of long columnsYou got that message because 1 byte equals 1 character only if you use the latin-1 character set. If you use utf8, each character will be considered 3 bytes when defining your key column. If you use utf8mb4, each character will be considered to be 4 bytes when defining your key column. Thus, you need to multiply your key field\'s character limit by, 1, 3, or 4 (in my example) to determine the number of bytes the key field is trying to allow. If you are using uft8mb4, you can only define 191 characters for a native, InnoDB, primary key field. Just don\'t breach 767 bytes.We encountered this issue when trying to add a UNIQUE index to a VARCHAR(255) field using utf8mb4. While the problem is outlined well here already, I wanted to add some practical advice for how we figured this out and solved it.When using utf8mb4, characters count as 4 bytes, whereas under utf8, they could as 3 bytes. InnoDB databases have a limit that indexes can only contain 767 bytes. So when using utf8, you can store 255 characters (767/3 = 255), but using utf8mb4, you can only store 191 characters (767/4 = 191).You\'re absolutely able to add regular indexes for VARCHAR(255) fields using utf8mb4, but what happens is the index size is truncated at 191 characters automatically - like unique_key here:This is fine, because regular indexes are just used to help MySQL search through your data more quickly. The whole field doesn\'t need to be indexed.So, why does MySQL truncate the index automatically for regular indexes, but throw an explicit error when trying to do it for unique indexes? Well, for MySQL to be able to figure out if the value being inserted or updated already exists, it needs to actually index the whole value and not just part of it.At the end of the day, if you want to have a unique index on a field, the entire contents of the field must fit into the index. For utf8mb4, this means reducing your VARCHAR field lengths to 191 characters or less. If you don\'t need utf8mb4 for that table or field, you can drop it back to utf8 and be able to keep your 255 length fields.I think varchar(20) only requires 21 bytes while varchar(500) only\n  requires 501 bytes. So the total bytes are 522, less than 767. So why\n  did I get the error message?UTF8 requires 3 bytes per character to store the string, so in your case 20 + 500 characters = 20*3+500*3 = 1560 bytes which is more than allowed 767 bytes.The limit for UTF8 is 767/3 = 255 characters, for UTF8mb4 which uses 4 bytes per character it is 767/4 = 191 characters.The answer about why you get error message was already answered by many users here. My answer is about how to fix and use it as it be.Refer from this link.Database changedQuery OK, 0 rows affected (0.00 sec)Query OK, 0 rows affected (0.02 sec)The problem of this fix is if you export db to another server (for example from localhost to real host) and you cannot use MySQL command line in that server. You cannot make it work there.As per Lravel 5.4.* documentation; You have to set the default string length inside the bootmethod of app/Providers/AppServiceProvider.phpfile as follows:change your collation. You can use utf8_general_ci that supports almost allBased on the column given below, those 2 variable string columns are using utf8_general_ci collation (utf8 charset is implied). In MySQL, utf8 charset uses a maximum of 3 bytes for each character. Thus, it would need to allocate 500*3=1500 bytes, which is much greater than the 767 bytes MySQL allows. That\'s why you are getting this 1071 error.In other words, you need to calculate the character count based on the charset\'s byte representation as not every charset is a single byte representation (as you presumed.) I.E. utf8 in MySQL is uses at most 3-byte per character, 767/3\xe2\x89\x88255 characters, and for utf8mb4, an at most 4-byte representation, 767/4\xe2\x89\x88191 characters.It\'s also known that MySQLI did some search on this topic finally got some custom changeFor MySQL workbench 6.3.7 Version Graphical inter phase is availableFor Versions below 6.3.7 direct options are not available so need to go with command promptChange CHARSET of the complaining index field to "latin1"\ni.e. ALTER TABLE tbl CHANGE myfield myfield varchar(600) CHARACTER SET latin1 DEFAULT NULL;\nlatin1 takes one byte for one character instead of fourPlease check if sql_mode is like -\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLESif it is, change-\nsql_mode=NO_ENGINE_SUBSTITUTIONORrestart your server changing your my.cnf file (putting following)-innodb_large_prefix=onIf you\'re creating something like:it should be something likebut you need to check uniqueness of that column from code or adding a new column as an MD5 or SHA1 of the varchar columnIf you have changed innodb_log_file_size recently, try to restore the previous value which worked.For me, the issue of "#1071 - Specified key was too long; max key length is 767 bytes" got resolved after changing the primarykey / uniquekey combination by limiting the column size by 200.I just drop database and recreate like this, and the error is gone:\ndrop database if exists rhodes;\ncreate database rhodes default CHARACTER set utf8\n  default COLLATE utf8_general_ci;\n