I need to write JUnit tests for an old application that\'s poorly designed and is writing a lot of error messages to standard output. When the getResponse(String request) method behaves correctly it returns a XML response:But when it gets malformed XML or does not understand the request it returns null and writes some  stuff to standard output.Is there any way to assert console output in JUnit? To catch cases like:using ByteArrayOutputStream and System.setXXX is simple:sample test cases:I used this code to test the command line option (asserting that -version outputs the version string, etc etc) I know this is an old thread, but there is a nice library to do this:System RulesExample from the docs:It will also allow you to trap System.exit(-1) and other things that a command line tool would need to be tested for.You can set the System.out print stream via setOut() (and for in and err). Can you redirect this to a print stream that records to a string, and then inspect that ? That would appear to be the simplest mechanism.(I would advocate, at some stage, convert the app to some logging framework - but I suspect you already are aware of this!)Instead of redirecting System.out, I would refactor the class that uses System.out.println() by passing a PrintStream as a collaborator and then using System.out in production and a Test Spy in the test. In ProductionIn the TestDiscussionThis way the class under test becomes testable by a simple refactoring, without having the need for indirect redirection of the standard output or obscure interception with a system rule.Slightly off topic, but in case some people (like me, when I first found this thread) might be interested in capturing log output via SLF4J, commons-testing\'s JUnit @Rule might help:Disclaimer: @dfa answer is great, so I took it a step farther to make it possible to test blocks of ouput. First I created TestHelper with a method captureOutput that accepts the annoymous class CaptureTest. The captureOutput method does the work of setting and tearing down the output streams. When the implementation of CaptureOutput\'s test method is called, it has access to the output generate for the test block.Source for TestHelper:Note that TestHelper and CaptureTest are defined in the same file.Then in your test, you can import the static captureOutput. Here is an example using JUnit:If you were using Spring Boot (you mentioned that you\'re working with an old application, so you probably aren\'t but it might be of use to others), then you could use org.springframework.boot.test.rule.OutputCapture in the following manner:You don\'t want to redirect the system.out stream because that redirects for the ENTIRE JVM. Anything else running on the JVM can get messed up. There are better ways to test input/output. Look into stubs/mocks.You cannot directly print by using system.out.println or using logger api while using JUnit. But if you want to check any values then you simply can use It will throw below assertion error:Your value should be 21.92, Now if you will test using this value like below your test case will pass.for outfor err 