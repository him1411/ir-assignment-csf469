PHP, for all its warts, is pretty good on this count. There\'s no difference between an array and a hash (maybe I\'m naive, but this seems obviously right to me), and to iterate through either you just doIn Ruby there are a bunch of ways to do this sort of thing:Hashes make more sense, since I just always useWhy can\'t I do this for arrays? If I want to remember just one method, I guess I can use each_index (since it makes both the index and value available), but it\'s annoying to have to do array[index] instead of just value.Oh right, I forgot about array.each_with_index. However, this one sucks because it goes |value, key| and hash.each goes |key, value|! Is this not insane?This will iterate through all the elements:Prints:This will iterate through all the elements giving you the value and the index:Prints:I\'m not quite sure from your question which one you are looking for.I think there is no one right way.  There are a lot of different ways to iterate, and each has its own niche.It may seem like a lot to remember, but don\'t worry, you can get by without knowing all of them.  But as you start to learn and use the different methods, your code will become cleaner and clearer, and you\'ll be on your way to Ruby mastery.I\'m not saying that Array -> |value,index| and Hash -> |key,value| is not insane (see Horace Loeb\'s comment), but I am saying that there is a sane way to expect this arrangement.When I am dealing with arrays, I am focused on the elements in the array (not the index because the index is transitory).  The method is each with index, i.e. each+index, or |each,index|, or |value,index|.  This is also consistent with the index being viewed as an optional argument, e.g. |value| is equivalent to |value,index=nil| which is consistent with |value,index|.When I am dealing with hashes, I am often more focused on the keys than the values, and I am usually dealing with keys and values in that order, either key => value or hash[key] = value.If you want duck-typing, then either explicitly use a defined method as Brent Longborough showed, or an implicit method as maxhawkins showed.Ruby is all about accommodating the language to suit the programmer, not about the programmer accommodating to suit the language.  This is why there are so many ways.  There are so many ways to think about something.  In Ruby, you choose the closest and the rest of the code usually falls out extremely neatly and concisely.As for the original question, "What is the \xe2\x80\x9cright\xe2\x80\x9d way to iterate through an array in Ruby?", well, I think the core way (i.e. without powerful syntactic sugar or object oriented power) is to do:But Ruby is all about powerful syntactic sugar and object oriented power, but anyway here is the equivalent for hashes, and the keys can be ordered or not:So, my answer is, "The \xe2\x80\x9cright\xe2\x80\x9d way to iterate through an array in Ruby depends on you (i.e. the programmer or the programming team) and the project.".  The better Ruby programmer makes the better choice (of which syntactic power and/or which object oriented approach).  The better Ruby programmer continues to look for more ways.Now, I want to ask another question, "What is the \xe2\x80\x9cright\xe2\x80\x9d way to iterate through a Range in Ruby backwards?"!  (This question is how I came to this page.)It is nice to do (for the forwards):but I don\'t like to do (for the backwards):Well, I don\'t actually mind doing that too much, but when I am teaching going backwards, I want to show my students a nice symmetry (i.e. with minimal difference, e.g. only adding a reverse, or a step -1, but without modifying anything else).\nYou can do (for symmetry):andwhich I don\'t like much, but you can\'t doYou could ultimately dobut I want to teach pure Ruby rather than object oriented approaches (just yet).  I would like to iterate backwards:I believe this is impossible without defining a pred method, which means modifying the Range class to use it.  If you can do this please let me know, otherwise confirmation of impossibility would be appreciated though it would be disappointing.  Perhaps Ruby 1.9 addresses this.(Thanks for your time in reading this.)Use each_with_index when you need both.The other answers are just fine, but I wanted to point out one other peripheral thing: Arrays are ordered, whereas Hashes are not in 1.8.  (In Ruby 1.9, Hashes are ordered by insertion order of keys.)  So it wouldn\'t make sense prior to 1.9 to iterate over a Hash in the same way/sequence as Arrays, which have always had a definite ordering.  I don\'t know what the default order is for PHP associative arrays (apparently my google fu isn\'t strong enough to figure that out, either), but I don\'t know how you can consider regular PHP arrays and PHP associative arrays to be "the same" in this context, since the order for associative arrays seems undefined.As such, the Ruby way seems more clear and intuitive to me.  :)Trying to do the same thing consistently with arrays and hashes might just be a code smell, but, at the risk of my being branded as a codorous half-monkey-patcher, if you\'re looking for consistent behaviour, would this do the trick?:I\'d been trying to build a menu (in Camping and Markaby) using a hash.Each item has 2 elements: a menu label and a URL, so a hash seemed right, but the \'/\' URL for \'Home\' always appeared last (as you\'d expect for a hash), so menu items appeared in the wrong order.Using an array with each_slice does the job:Adding extra values for each menu item (e.g. like a CSS ID name) just means increasing the slice value. So, like a hash but with groups consisting of any number of items. Perfect.So this is just to say thanks for inadvertently hinting at a solution!Obvious, but worth stating: I suggest checking if the length of the array is divisible by the slice value.Here are the four options listed in your question, arranged by freedom of control. You might want to use a different one depending on what you need.Simply go through values:Simply go through indices:Go through indices + index variable:Control loop count + index variable:If you use the enumerable mixin (as Rails does) you can do something similar to the php snippet listed. Just use the each_slice method and flatten the hash.Less monkey-patching required.However, this does cause problems when you have a recursive array or a hash with array values. In ruby 1.9 this problem is solved with a parameter to the flatten method that specifies how deep to recurse.As for the question of whether this is a code smell, I\'m not sure. Usually when I have to bend over backwards to iterate over something I step back and realize I\'m attacking the problem wrong.The right way is the one you feel most comfortable with and which does what you want it to do. In programming there is rarely one \'correct\' way to do things, more often there are multiple ways to choose. If you are comfortable with certain way of doings things, do just it, unless it doesn\'t work - then it is time to find better way.In Ruby 2.1, each_with_index method is removed.\nInstead you can use each_indexExample:produces: