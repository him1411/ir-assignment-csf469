Try executing the following in JavaScript:I just learned the hard way that JavaScript thinks the leading zero indicates an octal integer, and since there is no "8" or "9" in base-8, the function returns zero. Like it or not, this is by design.What are the workarounds?Note: For sake of completeness, I\'m about to post a solution, but it\'s a solution that I hate, so please post other/better answers.Update: The 5th Edition of the JavaScript standard (ECMA-262) introduces a breaking change that eliminates this behavior. Mozilla has a good write-up. This is a common Javascript gotcha with a simple solution:Just specify the base, or \'radix\', like so:You could also use Number:First of all, you really don\'t need parseInt() in most cases. It\'s algorithm is full of various quirks, the 0 prefix is even forbidden by the specification ("the specification of the function parseInt no longer allows implementations to treat Strings beginning with a 0 character as octal values."), but it will take a while to change browser behaviors (even if I\'m sure that nobody does use octals intentionally in parseInt()). And Internet Explorer 6 will never change (the Internet Explorer 9 however removed support for octals in parseInt()). The algorithm used by it usually does more than you want from it. In certain cases, it\'s bad idea.Convert number to decimal until the first character which is not in range.For example, parseInt(\'012z\', 27) gives 0 * Math.pow(27, 2) + 1 * Math.pow(27, 1) + 2 * Math.pow(27, 0).The algorithm itself is not really quick, but performance varies (optimizations make wonders). I\'ve put test on JSPerf and the results are interesting. + and ~~ are fastest with exception for Chrome where parseFloat() is somehow way faster than other options (2 to 5 times faster than other options, where + is actually 5 times slower). In Firefox, ~~ test is very fast - in certain cases, I\'ve got Infinity cycles.The other thing is correctness. parseInt(), ~~ and parseFloat() make errors silent. In case of parseInt() and parseFloat() characters are ignored after invalid character - you can call it a feature (in most cases it\'s anti-feature for me, just like switch statements fallthrough) and if you need it, use one of those. In case of ~~ it means returning 0, so be careful.In certain cases, parseInt() might hurt you. Badly. For example, if number is so big that it is written in exponential notation. Use Math methods then.Anyways, at end I want to make a list when of methods to convert strings to numbers (both integers and floats). They have various usages and you may be interested what method to use. In most cases, the simplest one is +number method, use it if you can. Whatever you do (except for first method), all should give correct result.Don\'t use. Simple as that. Either use parseInt(number, 10) or this workaround which will magically fix parseInt function. Please note that this workaround will not work in JSLint. Please don\'t complain about it.parseInt converts argument to numbers using mentioned above algorithm. Avoid using it on large integers as it can do incorrect results in cases like parseInt(2e30). Also, never ever give it as argument to Array.prototype.map or Underscore.js variation of it as you may get weird results (try [\'1\', \'2\', \'3\'].map(parseInt) if you want (for explanation, replace parseInt with console.log)).Use it when either:Otherwise use other more safe methods (if you need integer, use Math.floor instead).+ prefix (+number) converts number to float. In case of error it returns NaN which you can compare by either isNaN() or just by number !== number (it should return true only for NaN). It\'s very fast in Opera.Use it unless you want specific features of other types.~~ is a hack which uses ~ two times on the integer. As ~ bitwise operation can be only done for integers, the number is automatically converted. Most browsers have optimizations for this case. As bitwise operations only work below Math.pow(2, 32) never use this method with big numbers. It\'s blazingly fast on SpiderMonkey engine.Use it when either:parseFloat() works like + with the one exception - it processes number until first invalid character instead of returning NaN. It\'s very fast (but not as fast as ~~ on Firefox) in V8. Unlike parseInt variation, it should be safe with Array.prototype.map.Use it when either:Avoid it. It works just like + prefix and is usually slower. The only usage where it could be useful is callback for Array.prototype.map - you cannot use + as callback.Use it when you need to confuse everybody with 0 being truthy value and having typeof of \'number\'. Seriously, don\'t.Use them when you need integer as it\'s more safe than parseInt() by not ignoring unexpected characters. Please note that technically it involves long conversion - string \xe2\x86\x92 float \xe2\x86\x92 integer \xe2\x86\x92 float (numbers in JavaScript are floats) - but most browser have optimizations for it, so usually it\'s not that noticeable. It\'s also safe with Array.prototype.map.If you know your value will be in the signed 32 bit integer range, then ~~x will do the correct thing in all scenarios.If you look up binary not (~), the spec requires a "ToInt32" conversion for the argument which does the obvious conversion to an Int32 and is specified to coerce NaN values to zero.Yes, this is incredibly hackish but is so convenient...From the parseInt documentation, use the optional radix argument to specify base-10:This strikes me as pedantic, confusing, and verbose (really, an extra argument in every single parseInt?) so I\'m hoping there is a Better Way.edit: making your own function, to do what you really want, is just an option if you don\'t like adding the ",10" all the time to the parseInt() call. It has the disadvantage of being a nonstandard function: more convenient for you if you use it a lot, but perhaps more confusing for others.Specify the base:Would it be very naughty to replace parseInt with a version that assumes decimal if it has no second parameter? (note - not tested)How about this for decimal:If you\'ve done a bunch of coding already with parseInt and don\'t want to add ",10" to everything, you can just override the function to make base 10 the default:That may confuse a later reader, so making a parseInt10() function might be more self-explanatory. Personally I prefer using a simple function than having to add ",10" all the time - just creates more opportunity for mistakes.You may also, instead of using parseFloat or parseInt, use the unary operator +.and for good measureMDN LinkThe unary plus operator precedes its operand and evaluates to its operand but attempts to converts it into a number, if it isn\'t already. Although unary negation (-) also can convert non-numbers, unary plus is the fastest and preferred way of converting something into a number, because it does not perform any other operations on the number.