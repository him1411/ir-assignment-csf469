In line:It give an error that:../main.cpp:35: error: passing \'const StudentT\' as \'this\' argument of \'int StudentT::getId()\' discards qualifiers../main.cpp:35: error: passing \'const StudentT\' as \'this\' argument of \'std::string StudentT::getName()\' discards qualifiersWhat\'s wrong with this code? Thank you!The objects in the std::set are stored as const StudentT. So when you try to call getId() with the const object the compiler  detects a problem, namely you\'re calling a non-const member function on const object which is not allowed because non-const member functions make NO PROMISE not to modify the object; so the compiler is going to make a safe assumption that getId() might attempt to modify the object but at the same time, it also notices that the object is const; so any attempt to modify the const object should be an error. Hence compiler generates error message. The solution is simple: make the functions const as:This is necessary because now you can call getId() and getName() on const objects as:As a sidenote, you should implement operator< as : Note parameters are now const reference.Member functions that do not modify the class instance should be declared as const:Anytime you see "discards qualifiers", it\'s talking about const or volatile.Actually the C++ standard (i.e. C++ 0x draft) says (tnx to @Xeo & @Ben Voigt for pointing that out to me):23.2.4 Associative containers\n  5 For set and multiset the value type\n  is the same as the key type. For map\n  and multimap it is equal to pair. Keys in an associative\n  container are immutable.\n  6 iterator of\n  an associative container is of the\n  bidirectional iterator category. For\n  associative containers where the value\n  type is the same as the key type, both\n  iterator and const_iterator are\n  constant iterators. It is unspecified\n  whether or not iterator and\n  const_iterator are the same type.So VC++ 2008 Dinkumware implementation is faulty.Old answer:You got that error because in certain implementations of the std lib the set::iterator is the same as set::const_iterator.  For example libstdc++ (shipped with g++) has it (see here for the entire source code):And in SGI\'s docs it states:On the other hand VC++ 2008 Express compiles your code without complaining that you\'re calling non const methods on set::iterators.