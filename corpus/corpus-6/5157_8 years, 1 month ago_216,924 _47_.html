I need to execute some amount of tasks 4 at a time, something like this:How can I get notified once all of them are complete? For now I can\'t think about anything better than setting some global task counter and decrease it at the end of every task, then monitor in infinite loop this counter to become 0; or get a list of Futures and in infinite loop monitor isDone for all of them. What are better solutions not involving infinite loops?Thanks.Basically on an ExecutorService you call shutdown() and then awaitTermination():Use a CountDownLatch:and within your task (enclose in try / finally)ExecutorService.invokeAll() does it for you.You can use Lists of Futures, as well:then when you want to join on all of them, its essentially the equivalent of joining on each, (with the added benefit that it re-raises exceptions from child threads to the main):Basically the trick is to call .get() on each Future one at a time, instead of infinite looping calling isDone() on (all or each).  So you\'re guaranteed to "move on" through and past this block as soon as the last thread finishes.  The caveat is that since the .get() call re-raises exceptions, if one of the threads dies, you would raise from this possibly before the other threads have finished to completion [to avoid this, you could add a catch ExecutionException around the get call].  The other caveat is it keeps a reference to all threads so if they have thread local variables they won\'t get collected till after you get past this block (though you might be able to get around this, if it became a problem, by removing Future\'s off the ArrayList).  If you wanted to know which Future "finishes first" you could use some something like https://stackoverflow.com/a/31885029/32453Just my two cents.\nTo overcome the requirement of CountDownLatch to know the number of tasks beforehand, you could do it the old fashion way by using a simple Semaphore.In your task just call s.release() as you would latch.countDown();The CyclicBarrier class in Java 5 and later is designed for this sort of thing.In Java8 you can do it with CompletableFuture:A bit late to the game but for the sake of completion...Instead of \'waiting\' for all tasks to finish, you can think in terms of the Hollywood principle, "don\'t call me, I\'ll call you" - when I\'m finished.\nI think the resulting code is more elegant...Guava offers some interesting tools to accomplish this.An example ::Wrap an ExecutorService into a ListeningExecutorService ::Submit a collection of callables for execution ::Now the essential part: Attach a callback to the ListenableFuture, that you can use to be notified when all futures complete ::This also offers the advantage that you can collect all the results in one place once the processing is finished...More information hereYou could wrap your tasks in another runnable, that will send notifications:I\'ve just written a sample program that solves your problem. There was no concise implementation given, so I\'ll add one. While you can use executor.shutdown() and executor.awaitTermination(), it is not the best practice as the time taken by different threads would be unpredictable.Just to provide more alternatives here different to use latch/barriers.\nYou can also get the partial results until all of them finish using CompletionService.From Java Concurrency in practice:\n"If you have a batch of computations to submit to an Executor and you want to retrieve their results as they become\navailable, you could retain the Future associated with each task and repeatedly poll for completion by calling get with a\ntimeout of zero. This is possible, but tedious. Fortunately there is a better way: a completion service."Here the implementationFollow one of below approaches. Related SE questions:How is CountDownLatch used in Java Multithreading?How to properly shutdown java ExecutorServiceYou could use your own subclass of ExecutorCompletionService to wrap taskExecutor, and your own implementation of BlockingQueue to get informed when each task completes and perform whatever callback or other action you desire when the number of completed tasks reaches your desired goal.you should use executorService.shutdown() and executorService.awaitTermination method.An example as follows :Java 8 - We can use stream API to process stream. Please see snippet belowYou could use this code:This might helpYou could call waitTillDone() on this Runner class:You can reuse this class and call waitTillDone() as many times as you want to before calling shutdown(), plus your code is extremly simple. Also you don\'t have to know the number of tasks upfront.To use it just add this gradle/maven compile \'com.github.matejtymes:javafixes:1.1.1\' dependency to your project.More details can be found here:https://github.com/MatejTymes/JavaFixeshttp://matejtymes.blogspot.com/2016/04/executor-that-notifies-you-when-task.htmlThere is a method in executor getActiveCount() - that gives the count of active threads. After spanning the thread, we can check if the activeCount() value is 0. Once the value is zero, it is meant that there are no active threads currently running which means task is finished: