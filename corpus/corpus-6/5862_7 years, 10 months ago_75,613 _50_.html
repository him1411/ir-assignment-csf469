What is the difference between a var and val definition in Scala and why does the language need both?  Why would you choose a val over a var and vice versa?As so many others have said, the object assigned to a val cannot be replaced, and the object assigned to a var can. However, said object can have its internal state modified. For example:So, even though we can\'t change the object assigned to x, we could change the state of that object. At the root of it, however, there was a var.Now, immutability is a good thing for many reasons. First, if an object doesn\'t change internal state, you don\'t have to worry if some other part of your code is changing it. For example:This becomes particularly important with multithreaded systems. In a multithreaded system, the following can happen:If you use val exclusively, and only use immutable data structures (that is, avoid arrays, everything in scala.collection.mutable, etc.), you can rest assured this won\'t happen. That is, unless there\'s some code, perhaps even a framework, doing reflection tricks -- reflection can change "immutable" values, unfortunately.That\'s one reason, but there is another reason for it. When you use var, you can be tempted into reusing the same var for multiple purposes. This has some problems:Simply put, using val is safer and leads to more readable code.We can, then, go the other direction. If val is that better, why have var at all? Well, some languages did take that route, but there are situations in which mutability improves performance, a lot.For example, take an immutable Queue. When you either enqueue or dequeue things in it, you get a new Queue object. How then, would you go about processing all items in it?I\'ll go through that with an example. Let\'s say you have a queue of digits, and you want to compose a number out of them. For example, if I have a queue with 2, 1, 3, in that order, I want to get back the number 213. Let\'s first solve it with a mutable.Queue:This code is fast and easy to understand. Its main drawback is that the queue that is passed is modified by toNum, so you have to make a copy of it beforehand. That\'s the kind of object management that immutability makes you free from.Now, let\'s covert it to an immutable.Queue:Because I can\'t reuse some variable to keep track of my num, like in the previous example, I need to resort to recursion. In this case, it is a tail-recursion, which has pretty good performance. But that is not always the case: sometimes there is just no good (readable, simple) tail recursion solution.Note, however, that I can rewrite that code to use an immutable.Queue and a var at the same time! For example:This code is still efficient, does not require recursion, and you don\'t need to worry whether you have to make a copy of your queue or not before calling toNum. Naturally, I avoided reusing variables for other purposes, and no code outside this function sees them, so I don\'t need to worry about their values changing from one line to the next -- except when I explicitly do so.Scala opted to let the programmer do that, if the programmer deemed it to be the best solution. Other languages have chosen to make such code difficult. The price Scala (and any language with widespread mutability) pays is that the compiler doesn\'t have as much leeway in optimizing the code as it could otherwise. Java\'s answer to that is optimizing the code based on the run-time profile. We could go on and on about pros and cons to each side.Personally, I think Scala strikes the right balance, for now. It is not perfect, by far. I think both Clojure and Haskell have very interesting notions not adopted by Scala, but Scala has its own strengths as well. We\'ll see what comes up on the future.val is final, that is, cannot be set. Think final in java.In simple terms:var  = variableval = variable + finalval means immutable and var means mutable.Full discussion.The difference is that a var can be re-assigned to whereas a val cannot. The mutability, or otherwise of whatever is actually assigned, is a side issue:Whereas:And hence:If you are building a data structure and all of its fields are vals, then that data structure is therefore immutable, as its state cannot change.Thinking in terms of C++, is analogous to constant pointer to non-constant datawhile is analogous to non-constant pointer to non-constant data Favoring val over var increases immutability of the codebase which can facilitate its correctness, concurrency and understandability."val means immutable and var means mutable."To paraphrase, "val means value and var means variable".A distinction that happens to be extremely important in computing (because those two concepts define the very essence of what programming is all about), and that OO has managed to blur almost completely, because in OO, the only axiom is that "everything is an object".  And that as a consequence, lots of programmers these days tend not to understand/appreciate/recognize, because they have been brainwashed into "thinking the OO way" exclusively.  Often leading to variable/mutable objects being used like everywhere, when value/immutable objects might/would often have been better.val means immutable and var means mutableyou can think val as java programming language final key world  or c++ language const key world\xe3\x80\x82A val is similar to a final variable in Java. Once initialized, a val can never be reassigned.A var, by contrast, is similar to a non-final variable in Java. A var can be reassigned throughout its lifetime.It\'s as simple as it name. var means it can varyval means invariableVal - values are typed storage constants. Once created its value cant be re-assigned. a new value can be defined with keyword val.eg. val x: Int = 5Here type is optional as scala can infer it from the assigned value.Var - variables are typed storage units which can be assigned values again as long as memory space is reserved. eg. var x: Int = 5Data stored in both the storage units are automatically de-allocated by JVM once these are no longer needed.In scala values are preferred over variables due to stability these brings to the code particularly in concurrent and multithreaded code.