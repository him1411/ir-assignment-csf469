Can anyone tell me if there is a way with generics to limit a generic type argument T to only:I\'m aware of the where keyword, but can\'t find an interface for only these types,Something like:Hejlsberg has described the reasons for not implementing the feature in an interview with Bruce Eckel.I have to admit, though, that I don\'t know how he thinks his proposed workaround will work. His proposal is to defer arithmetic operations to some other generic class (read the interview!). How does this help? IMHO, not much.There\'s no constraint for this. It\'s a real issue for anyone wanting to use generics for numeric calculations.I\'d go further and say we needOr evenUnfortunately you only have interfaces, base classes and the keywords struct (must be value-type), class (must be reference type) and new() (must have default constructor)You could wrap the number in something else (similar to INullable<T>) like here on codeproject.You could apply the restriction at runtime (by reflecting for the operators or checking for types) but that does lose the advantage of having the generic in the first place.Considering the popularity of this question and the interest behind such a function I am surprised to see that there is no answer involving T4 yet.In this sample code I will demonstrate a very simple example of how you can use the powerful templating engine to do what the compiler pretty much does behind the scenes with generics.Instead of going through hoops and sacrificing compile-time certainty you can simply generate the function you want for every type you like and use that accordingly (at compile time!).In order to do this: That\'s it. You\'re done now.Saving this file will automatically compile it to this source file:In your main method you can verify that you have compile-time certainty:I\'ll get ahead of one remark: no, this is not a violation of the DRY principle. The DRY principle is there to prevent people from duplicating code in multiple places that would cause the application to become hard to maintain.This is not at all the case here: if you want a change then you can just change the template (a single source for all your generation!) and it\'s done.In order to use it with your own custom definitions, add a namespace declaration (make sure it\'s the same one as the one where you\'ll define your own implementation) to your generated code and mark the class as partial. Afterwards, add these lines to your template file so it will be included in the eventual compilation:Let\'s be honest: This is pretty cool.Disclaimer: this sample has been heavily influenced by Metaprogramming in .NET by Kevin Hazzard and Jason Bock, Manning Publications.Workaround using policies:Algorithms:Usage:Update: The solution is compile-time safe. CityLizard Framework provides compiled version for .NET 4.0. The file is lib/NETFramework4.0/CityLizard.Policy.dll.Update 2: Code is updated so it can be compiled.Update 3: In Nuget: https://www.nuget.org/packages/CityLizard/ See CityLizard.Policy.I structure.Update 4: Rename \'All.P\' to \'NumericPolicies.Instance\'.Unfortunately you are only able to specify struct in the where clause in this instance. It does seem strange you can\'t specify Int16, Int32, etc. specifically but I\'m sure there\'s some deep implementation reason underlying the decision to not permit value types in a where clause.I guess the only solution is to do a runtime check which unfortunately prevents the problem being picked up at compile time. That\'d go something like:-Which is a little bit ugly I know, but at least provides the required constraints.I\'d also look into possible performance implications for this implementation, perhaps there\'s a faster way out there.This question is a bit of a FAQ one, so I\'m posting this as wiki (since I\'ve posted similar before, but this is an older one); anyway...What version of .NET are you using? If you are using .NET 3.5, then I have a generic operators implementation in MiscUtil (free etc).This has methods like T Add<T>(T x, T y), and other variants for arithmetic on different types (like DateTime + TimeSpan).Additionally, this works for all the inbuilt, lifted and bespoke operators, and caches the delegate for performance.Some additional background on why this is tricky is here.You may also want to know that dynamic (4.0) sort-of solves this issue indirectly too - i.e.Probably the closest you can do is Not sure if you could do the followingFor something so specific, why not just have overloads for each type, the list is so short and it would possibly have less memory footprint.There is no way to restrict templates to types, but you can define different actions based on the type.  As part of a generic numeric package, I needed a generic class to add two values.   Note that the typeofs are evaluated at compile time, so the if statements would be removed by the compiler. The compiler also removes spurious casts.  So Something would resolve in the compiler to I was wondering the same as samjudson, why only to integers? and if that is the case, you might want to create a helper class or something like that to hold all the types you want.If all you want are integers, don\'t use a generic, that is not generic; or better yet, reject any other type by checking its type. What is the point of the exercise?As people pointed out already, you could have a non-generic function taking the largest item, and compiler will automatically convert up smaller ints for you. If your function is on performance-critical path (very unlikely, IMO), you could provide overloads for all needed functions.I would use a generic one which you could handle externaly...This limitation affected me when I tried to overload operators for generic types; since there was no "INumeric" constraint, and for a bevy of other reasons the good people on stackoverflow are happy to provide, operations cannot be defined on generic types.I wanted something likeI have worked around this issue using .net4 dynamic runtime typing.  The two things about using dynamic are There is no \'good\' solution for this yet. However you can narrow the type argument significantly to rule out many missfits for your hypotetical \'INumeric\' constraint as Haacked has shown above.static bool IntegerFunction<T>(T value) where T: IComparable, IFormattable, IConvertible, IComparable<T>, IEquatable<T>, struct \n{... The .NET numeric primitive types do not share any common interface that would allow them to be used for calculations.  It would be possible to define your own interfaces (e.g. ISignedWholeNumber) which would perform such operations, define structures which contain a single Int16, Int32, etc. and implement those interfaces, and then have methods which accept generic types constrained to ISignedWholeNumber, but having to convert numeric values to your structure types would likely be a nuisance.An alternative approach would be to define static class Int64Converter<T> with a static property bool Available {get;}; and static delegates for Int64 GetInt64(T value), T FromInt64(Int64 value), bool TryStoreInt64(Int64 value, ref T dest).  The class constructor could use be hard-coded to load delegates for known types, and possibly use Reflection to test whether type T implements methods with the proper names and signatures (in case it\'s something like a struct which contains an Int64 and represents a number, but has a custom ToString() method).  This approach would lose the advantages associated with compile-time type-checking, but would still manage to avoid boxing operations and each type would only have to be "checked" once.  After that, operations associated with that type would be replaced with a delegate dispatch.I created a little library functionality to solve these problems:Instead of:You could write:See: https://codereview.stackexchange.com/questions/26022/improvement-requested-for-generic-calculator-and-generic-numberIf you are using .NET 4.0 and later then you can just use dynamic as method argument and check in runtime that the passed dynamic argument type is numeric/integer type.If the type of the passed dynamic is not numeric/integer type then throw exception.An example short code that implements the idea is something like:Of course that this solution works in run time only but never in compile time.If you want a solution that always works in compile time and never in run time then you will have to wrap the dynamic with a public struct/class whose overloaded public constructors accept arguments of the desired types only and give the struct/class appropriate name.It makes sense that the wrapped dynamic is always private member of the class/struct and it is the only member of the struct/class and the name of the only member of the struct/class is "value".You will also have to define and implement public methods and/or operators that work with the desired types for the private dynamic member of the class/struct if necessary.It also makes sense that the struct/class has special/unique constructor that accepts dynamic as argument that initializes it\'s only private dynamic member called "value" but the modifier of this constructor is private of course.Once the class/struct is ready define the argument\'s type of IntegerFunction to be that class/struct that has been defined.An example long code that implements the idea is something like:Note that in order to use dynamic in your code you must Add Reference to Microsoft.CSharpIf the version of the .NET framework is below/under/lesser than 4.0 and dynamic is undefined in that version then you will have to use object instead and do casting to the integer type, which is trouble, so I recommend that you use at least .NET 4.0 or newer if you can so you can use dynamic instead of object.There is no single interface or base class that they all inherit (that is not also inherited by other classes) so the simple answer is no.I do wonder why this is an issue though. What are you wanting to do inside your IntegerFunction class that can only be done to integers?I think you are misunderstanding generics. If the operation you are trying to perform is only good for specific data types then you are not doing something "generic".Also, since you are only wanting to allow the function to work on int data types then you shouldn\'t need a separate function for each specific size. Simply taking a parameter in the largest specific type will allow the program to automatically upcast the smaller data types to it. (i.e. passing an Int16 will auto-convert to Int64 when calling).If you are performing different operations based on the actual size of int being passed into the function then I would think you should seriously reconsider even trying to do what you are doing. If you have to fool the language you should think a bit more about what you are trying to accomplish rather than how to do what you want.Failing all else, a parameter of type Object could be used and then you will have to check the type of the parameter and take appropriate action or throw an exception.