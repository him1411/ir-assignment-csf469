I have a bunch of Spring beans which are picked up from the classpath via annotations, e.g.In the Spring XML file, there\'s a PropertyPlaceholderConfigurer defined:I want to inject one of the properties from app.properites into the bean shown above. I can\'t simply do something like Because PersonDaoImpl does not feature in the Spring XML file (it is picked up from the classpath via annotations). I\'ve got as far as the following:But it\'s not clear to me how I access the property I\'m interested in from ppc?You can do this in Spring 3 using EL support. Example:systemProperties is an implicit object and strategyBean is a bean name.One more example, which works when you want to grab a property from a Properties object. It also shows that you can apply @Value to fields:Here is a blog post I wrote about this for a little more info.Personally I love this new way in Spring 3.0 from the docs:No getters or setters! With the properties being loaded via the config:To further my glee I can even control click on the EL expression in IntelliJ and it brings me to the property definition!There\'s also the totally non xml version:There is a new annotation @Value in Spring 3.0.0M3. @Value support not only #{...} expressions but ${...} placeholders as well<context:property-placeholder ... /> is the XML equivalent to the PropertyPlaceholderConfigurer. Example:\napplicationContext.xmlComponent classAnother alternative is to add the appProperties bean shown below:When retrieved, this bean can be cast to a java.util.Properties which will contain a property named results.max whose value is read from app.properties. Again, this bean can be dependency injected (as an instance of java.util.Properties) into any class via the @Resource annotation.Personally, I prefer this solution (to the other I proposed), as you can limit exactly which properties are exposed by appProperties, and don\'t need to read app.properties twice.I need to have two properties files, one for production and an override for development (that will not be deployed). To have both, a Properties Bean that can be autowired and a PropertyConfigurer, you can write:and reference the Properties Bean in the PropertyConfigurerBefore we get Spring 3 - which allows you to inject property constants directly into your beans using annotations - I wrote a sub-class of the PropertyPlaceholderConfigurer bean that does the same thing. So, you can mark up your property setters and Spring will autowire your properties into your beans like so:The Annotation is as follows:The PropertyAnnotationAndPlaceholderConfigurer is as follows:Feel free to modify to tasteA possible solutions is to declare a second bean which reads from the same properties file:The bean named \'appProperties\' is of type java.util.Properties and can be dependency injected using the @Resource attruibute shown above.You also can annotate you class:And have a variable like this:Now you can access to all your properties in this way:Spring way:\nprivate @Value("${propertyName}") \nString propertyField;is a new way to inject the value using Spring\'s "PropertyPlaceholderConfigurer" class. \nAnother way is to callNote: For @Value, you can not use static propertyField, it should be non-static only, otherwise it returns null. To fix it a non static setter is created for the static field and @Value is applied above that setter.If you are stuck using Spring 2.5 you could define a bean for each of your properties and inject them using qualifiers.  Like this:and Its not super readable but it gets the job done.As mentioned @value do the job and it is quite flexible as you can have spring EL in it.Here are some examples, which could be helpful:Another to get a set from a listYou can also set values for primitive types.You can call static methods:You can have logicAutowiring Property Values into Spring Beans:Most people know that you can use @Autowired to tell Spring to inject one object into another when it loads your application context. A lesser known nugget of information is that you can also use the @Value annotation to inject values from a property file into a bean\xe2\x80\x99s attributes.\nsee this post for more info...new stuff in Spring 3.0\n|| autowiring bean values\n||autowiring property values in springFor me, it was @Lucky\'s answer, and specifically, the linefrom the Captain Debug pagethat fixed my problem. I have an ApplicationContext-based app running from the command-line, and judging by a number of the comments on SO, Spring wires up these differently to MVC-based apps.If you need more Flexibility for the configurations, try the Settings4jPlaceholderConfigurer:\nhttp://settings4j.sourceforge.net/currentrelease/configSpringPlaceholder.htmlIn our application we use:The default order which key-value-Source is checked first, is described in:\nhttp://settings4j.sourceforge.net/currentrelease/configDefault.html \nIt can be customized with a settings4j.xml (accurate to log4j.xml) in your classpath.Let me know your opinion: settings4j-user@lists.sourceforge.netwith friendly regards, \nHaraldI think it\'s most convenient way to inject properties into bean is setter method.Example:Bean xml definition:For every named property method setProperty(value) will be invoked.This way is especially helpful if you need more than one bean based on one implementation.For example, if we define one more bean in xml:Then code like this:Will printSo, in your case it should look like this:Use Spring\'s "PropertyPlaceholderConfigurer" class A simple example showing property file read dynamically as bean\'s propertyProperty Filedev.app.jdbc.driver=com.mysql.jdbc.Driverdev.app.jdbc.url=jdbc:mysql://localhost:3306/addvertisementdev.app.jdbc.username=rootdev.app.jdbc.password=root