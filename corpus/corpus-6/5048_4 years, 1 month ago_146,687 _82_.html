I know how to create a reference to a method that has a String parameter and returns an int, it\'s:However, this doesn\'t work if the function throws an exception, say it\'s defined as:How would I define this reference?You\'ll need to do one of the following.If it\'s your code, then define your own functional interface that declares the checked exceptionand use itOtherwise, wrap Integer myMethod(String s) in a method that doesn\'t declare a checked exception:and thenorYou can actually extend Consumer (and Function etc.) with a new interface that handles exceptions -- using Java 8\'s default methods!Consider this interface (extends Consumer):Then, for example, if you have a list:If you want to consume it (eg. with forEach) with some code that throws exceptions, you would traditionally have set up a try/catch block:But with this new interface, you can instantiate it with a lambda expression and the compiler will not complain:Or even just cast it to be more succinct!:Update: Looks like there\'s a very nice utility library part of Durian called Errors which can be used to solve this problem with a lot more flexibility. For example, in my implementation above I\'ve explicitly defined the error handling policy (System.out... or throw RuntimeException), whereas Durian\'s Errors allow you to apply a policy on the fly via a large suite of utility methods. Thanks for sharing it, @NedTwigg!.Sample usage:I think Durian\'s Errors class combines many of the pros of the various suggestions above.To include Durian in your project, you can either:This is not specific to Java 8. You are trying to compile something equivalent to:Disclaimer: I haven\'t used Java 8 yet, only read about it.Function<String, Integer> doesn\'t throw IOException, so you can\'t put any code in it that throws IOException. If you\'re calling a method that expects a Function<String, Integer>, then the lambda that you pass to that method can\'t throw IOException, period. You can either write a lambda like this (I think this is the lambda syntax, not sure):Or, if the method you\'re passing the lambda to is one you wrote yourself, you can define a new functional interface and use that as the parameter type instead of Function<String, Integer>:You can use unthrow wrapperorThis problem has been bothering me as well; this is why I have created this project.With it you can do:There are a totla of 39 interfaces defined by the JDK which have such a Throwing equivalent; those are all @FunctionalInterfaces used in streams (the base Stream but also IntStream, LongStream and DoubleStream).And as each of them extend their non throwing counterpart, you can directly use them in lambdas as well:The default behavior is that when your throwing lambda throws a checked exception, a ThrownByLambdaException is thrown with the checked exception as the cause. You can therefore capture that and get the cause.Other features are available as well.I had this problem with Class.forName and Class.newInstance inside a lambda, so I just did:Inside the lambda, instead of calling Class.forName("myClass").newInstance() I just called uncheckedNewInstanceForName ("myClass")If you don\'t mind to use a 3rd party lib (Vavr) you could writeIt also has the so-called Try monad which handles errors:Please read more here.Disclaimer: I\'m the creator of Vavr.Another solution using a Function wrapper would be to return either an instance of a wrapper of your result, say Success, if everything went well, either an instance of, say Failure.Some code to clarify things :A simple use case :You could however create your own FunctionalInterface that throws as below..then implement it using Lambdas or references as shown below.You can.Extending @marcg \'s UtilException and adding generic <E extends Exception> where necessary: this way, the compiler will force you again to add throw clauses and everything\'s as if you could throw checked exceptions natively on java 8\'s streams.You can use ET for this. ET is a small Java 8 library for exception conversion/translation.With ET it looks like this:ExceptionTranslator instances are thread safe an can be shared by multiple components. You can configure more specific exception conversion rules (e.g. FooCheckedException -> BarRuntimeException) if you like. \nIf no other rules are available, checked exceptions are automatically converted to RuntimeException.(Disclaimer: I am the author of ET)Create a custom return type that will propagate the checked exception.  This is an alternative to creating a new interface that mirrors the existing functional interface with the slight modification of a "throws exception" on the functional interface\'s method.Adding "throws exception" to every functional interface in the JDK would violate the DRY principle in a most heinous fashion.  In order to avoid this, a single functional interface that throws a checked exception is created (CheckedValueSupplier).  This will be the only functional interface which allows checked exceptions.  All other functional interfaces will leverage the CheckedValueSupplier to wrap any code that throws a checked exception.The CheckedValue class will hold the result of executing any logic that throws a checked exception.  This prevents propagation of a checked exception until the point at which code attempts to access the value that an instance of CheckedValue contains.Some functional interfaces (Consumer for example) must be handled in a  different manner as they don\'t provide a return value.One approach is to use a function instead of a consumer, which applies when handling streams.Alternatively, you can always escalate to a RuntimeException.  There are other answers that cover escalation of a checked exception from within a Consumer.Just avoid functional interfaces all together and use a good-ole-fashioned for loop.There are a lot of great responses already posted here. Just attempting to solve the problem with a different perspective. Its just my 2 cents, please correct me if I am wrong somewhere. Throws clause in FunctionalInterface is not a good ideaI think this is probably not a good idea to enforce throws IOException because of following reasonsThis looks to me like an anti-pattern to Stream/Lambda. The whole idea is that the caller will decide what code to provide and how to handle the exception. In many scenarios, the IOException might not be applicable for the client. For example, if the client is getting value from cache/memory instead of performing actual I/O. Also, the exceptions handling in streams becomes really hideous. For example, here is my code will look like if I use your APIUgly isn\'t it? Moreover, as I mentioned in my first point, that the doSomeOperation method may or may not be throwing IOException (depending on the implementation of the client/caller), but because of the throws clause in your FunctionalInterface method, I always have to write the try-catch.What do I do if I really know this API throws IOExceptionThen probably we are confusing FunctionalInterface with typical Interfaces. If you know this API will throw IOException, then most probably you also know some default/abstract behavior as well. I think you should define an interface and deploy your library (with default/abstract implementation) as followsBut, the try-catch problem still exists for the client. If I use your API in stream, I still need to handle IOException in hideous try-catch block.Provide a default stream-friendly API as followsThe default method takes the consumer object as argument, which will be responsible to handle the exception. Now, from client\'s point of view, the code will look like thisNice right? Of course, logger or other handling logic could be used instead of Exception::printStackTrace. You can also expose a method similar to  https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#exceptionally-java.util.function.Function- . Meaning that you can expose another method, which will contain the exception from previous method call. The disadvantage is that you are now making your APIs stateful, which means that you need to handle thread-safety and which will be eventually become a performance hit. Just an option to consider though. If you don\'t mind using a third party library, with cyclops-react, a library I contribute to, you can use the FluentFunctions API to writeofChecked takes a jOO\xce\xbb CheckedFunction and returns the reference softened back to a standard (unchecked) JDK java.util.function.Function.Alternatively you can keep working with the captured function via the FluentFunctions api!For example to execute your method, retrying it up to 5 times and logging it\'s status you can write By default, Java 8 Function does not allow to throw exception and as suggested in multiple answers there are many ways to achieve it, one way is:Define as:And add throws or try/catch the same exception in caller method.What I\'m doing is to allow the user to give the value he actually want in case of exception .\nSo I\'ve something looking like this And this can then be call like : Several of the offered solutions use a generic argument of E to pass in the type of the exception which gets thrown.Take that one step further, and rather than passing in the type of the exception, pass in a Consumer of the type of exception, as in...You might create several re-usable variations of Consumer<Exception> which would cover the common exception handling needs of your application.  I will do something generic:usage: