When piping the output of a Python program, the Python interpreter gets confused about encoding and sets it to None. This means a program like this:will work fine when run normally, but fail with:UnicodeEncodeError: \'ascii\' codec can\'t encode character u\'\\xa0\' in position 0: ordinal not in range(128)when used in a pipe sequence.What is the best way to make this work when piping? Can I just tell it to use whatever encoding the shell/filesystem/whatever is using? The suggestions I have seen thus far is to modify your site.py directly, or hardcoding the defaultencoding using this hack:Is there a better way to make piping work?Your code works when run in an script because Python encodes the output to whatever encoding your terminal application is using. If you are piping you must encode it yourself.A rule of thumb is: Always use Unicode internally. Decode what you receive, and encode what you send.Another didactic example is a Python program to convert between ISO-8859-1 and UTF-8, making everything uppercase in between.Setting the system default encoding is a bad idea, because some modules and libraries you use can rely on the fact it is ASCII. Don\'t do it.First, regarding this solution:It\'s not practical to explicitly print with a given encoding every time. That would be repetitive and error-prone.A better solution is to change sys.stdout at the start of your program, to encode with a selected encoding. Here is one solution I found on Python: How is sys.stdout.encoding chosen?, in particular a comment by "toka":You may want to try changing the environment variable "PYTHONIOENCODING" to "utf_8." I have written a page on my ordeal with this problem.Tl;dr of the blog post:gives youdo the job, but can\'t set it on python itself ...what we can do is verify if isn\'t setting and tell the user to set it before call script with :Update to reply to the comment: \nthe problem just exist when piping to stdout .\nI tested in Fedora 25 Python 2.7.13cat b.py running ./b.py running ./b.py | lessI had a similar issue last week. It was easy to fix in my IDE (PyCharm).Here was my fix:Starting from PyCharm menu bar: File -> Settings... -> Editor -> File Encodings, then set: "IDE Encoding", "Project Encoding" and "Default encoding for properties files" ALL to UTF-8 and she now works like a charm.Hope this helps!I could "automate" it with a call to:Yes, it\'s possible to get an infinite loop here if this "setenv" fails.I just thought I\'d mention something here which I had to spent a long time experimenting with before I finally realised what was going on. This may be so obvious to everyone here that they haven\'t bothered mentioning it. But it would\'ve helped me if they had, so on that principle...!NB: I am using Jython specifically, v 2.7, so just possibly this may not apply to CPython...NB2: the first two lines of my .py file here are:The "%" (AKA "interpolation operator") string construction mechanism causes ADDITIONAL problems too... If the default encoding of the "environment" is ASCII and you try to do something likeYou will have no difficulty running in Eclipse... In a Windows CLI (DOS window) you will find that the encoding is code page 850 (my Windows 7 OS) or something similar, which can handle European accented characters at least, so it\'ll work.will also work.If, OTOH, you direct to a file from the CLI, the stdout encoding will be None, which will default to ASCII (on my OS anyway), which will not be able to handle either of the above prints... (dreaded encoding error).So then you might think of redirecting your stdout by usingand try running in the CLI piping to a file... Very oddly, print A above will work... But print B above will throw the encoding error! The following will however work OK:The conclusion I have come to (provisionally) is that if a string which is specified to be a Unicode string using the "u" prefix is submitted to the %-handling mechanism it appears to involve the use of the default environment encoding, regardless of whether you have set stdout to redirect!How people deal with this is a matter of choice. I would welcome a Unicode expert to say why this happens, whether I\'ve got it wrong in some way, what the preferred solution to this, whether it also applies to CPython, whether it happens in Python 3, etc., etc.An arguable sanitized version of Craig McQueen\'s answer.Usage:On Ubuntu 12.10 and GNOME Terminal, no error is produced when the program is printing to stdout or hooked to a pipe for other programs. Both file encoding and terminal encoding is UTF-8.What OS and terminal emulator are you using? I heard some of my colleagues have similar problems when using iTerm 2 and OS X; iTerm 2 may be the culprit.Update: This answer is wrong - see comments for details