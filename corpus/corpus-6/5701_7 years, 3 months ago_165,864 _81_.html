What is the difference between cohesion and coupling?How can coupling and cohesion lead to either good or poor software design?What are some examples that outline the difference between the two, and their impact on overall code quality?Cohesion refers to what the class (or module) will do. Low cohesion would mean that the class does a great variety of actions and is not focused on what it should do. High cohesion would then mean that the class is focused on what it should be doing, i.e. only methods relating to the intention of the class.Example of Low Cohesion:Example of High Cohesion:As for coupling, it refers to how related are two classes / modules and how dependent they are on each other. Being low coupling would mean that changing something major in one class should not affect the other. High coupling would make your code difficult to make changes as well as to maintain it, as classes are coupled closely together, making a change could mean an entire system revamp.All good software design will go for high cohesion and low coupling.High cohesion within modules and low coupling between modules are often regarded as related to high quality in OO programming languages.For example, the code inside each Java class must have high internal cohesion, but be as loosely coupled as possible to the code in other Java classes.Chapter 3 of Meyer\'s Object-Oriented Software Construction (2nd edition) is a great description of these issues.Increased cohesion and decreased coupling do lead to good software design. Cohesion partitions your functionality so that it is concise and closest to the data relevant to it, whilst decoupling ensures that the functional implementation is isolated from the rest of the system. Decoupling allows you to change the implementation without affecting other parts of your software.Cohesion ensures that the implementation more specific to functionality and at the same time easier to maintain.The most effective method of decreasing coupling and increasing cohesion is design by interface. That is major functional objects should only \'know\' each other through the interface(s) that they implement. The implementation of an interface introduces cohesion as a natural consequence.Whilst not realistic in some senarios it should be a design goal to work by.Example (very sketchy):Some where else in your codebase you could have a module that processes questions regardless of what they are:Cohesion is an indication of how related and focused the responsibilities of an software element are. Coupling refers to how strongly a software element is connected to other elements.The software element could be class, package, component, subsystem or a system. And while designing the systems it is recommended to have software elements that have High cohesion and support Low coupling.Low cohesion results in monolithic classes that are difficult to maintain, understand and reduces re-usablity. Similarly High Coupling results in classes that are tightly coupled and changes tend not be non-local, difficult to change and reduces the reuse.We can take a hypothetical scenario where we are designing an typical monitor-able ConnectionPool with the following requirements. Note that, it might look too much for a simple class like ConnectionPool but the basic intent is just to demonstrate low coupling and high cohesion with some simple example and I think should help.With low cohesion we could design a ConnectionPool class by forcefully stuffing all this functionality/responsibilities into a single class as below. We can see that this single class is responsible for connection management, interacting with database as well maintaining connection stats.With high cohesion we can assign these responsibility across the classes and make it more maintainable and reusable.To demonstrate Low coupling we will continue with the high cohesion ConnectionPool diagram above. If we look at the above diagram although it supports high cohesion, the ConnectionPool is tightly coupled with ConnectionStatistics class and PersistentStore it interacts with them directly. Instead to reduce the coupling we could introduce a ConnectionListener interface and let these two classes implement the interface and let them register with ConnectionPool class. And the ConnectionPool will iterate through these listeners and notify them of connection get and release events and allows less coupling.Note/Word or Caution: For this simple scenario it may look like an overkill but if we imagine a real-time scenario where our application needs to interact with multiple third party services to complete a transaction: Directly coupling our code with the third party services would mean that any changes in the third party service could result in changes to our code at multiple places, instead we could have Facade that interacts with these multiple services internally and any changes to the services become local to the Facade and enforce low coupling with the third party services.best explanation of Cohesion comes from Uncle Bob\'s Clean Code:Classes should have a small number of instance variables. Each of the methods of a class should manipulate one or more of those variables. In general the more variables a method manipulates the more cohesive that method is to its class. A class in which each variable is used by each method is maximally cohesive.In general it is neither advisable nor possible to create such maximally cohesive classes; on the other hand, we would like cohesion to be high. When cohesion is high, it means that the methods and variables of the class are co-dependent and hang together as a logical whole.The strategy of keeping functions small and keeping parameter lists short can sometimes lead to a proliferation of instance variables that are used by a subset of methods. When this happens, it almost always means that there is at least one other class trying to get out of the larger class. You should try to separate the variables and methods into two or more classes such that the new classes are more cohesive.Cohesion in software engineering is the degree to which the elements of a certain module belong together. Thus, it is a measure of how strongly related each piece of functionality expressed by the source code of a software module is.Coupling in simple words, is how much one component (again, imagine a class, although not necessarily) knows about the inner workings or inner elements of another one, i.e. how much knowledge it has of the other component.I wrote a blog post about this, if you want to read up in a little bit more details with examples and drawings. I think it answers most of your questions.Cohesion is the indication of the relationship within module.Coupling is the indication of the relationships between modules.check this linkI think the differences can be put as the following:In this blog post I write about it in more detail. Cohesion is an indication of the relative functional strength of a module.\xef\x81\xaeConventional view:the \xe2\x80\x9csingle-mindedness\xe2\x80\x9d of a module\xef\x81\xaeOO view:\xef\x81\xaecohesion implies that a component or class encapsulates only attributes and operations that are closely related to one another and to the class or component itself\xef\x81\xaeLevels of cohesion\xef\x81\xaeFunctional\xef\x81\xaeLayer\xef\x81\xaeCommunicational\xef\x81\xaeSequential\xef\x81\xaeProcedural\xef\x81\xaeTemporal\xef\x81\xaeutilityCoupling is an indication of the relative interdependence among modules.Coupling depends on the interface complexity between modules, the\npoint at which entry or reference is made to a module, and what data\npass across the interface.Conventional View : \n  The degree to which a component is connected to other components and to the external worldOO view: a qualitative measure of the degree to which classes are connected to one anotherLevel of coupling\xef\x81\xaeContent\xef\x81\xaeCommon\xef\x81\xaeControl\xef\x81\xaeStamp\xef\x81\xaeData\xef\x81\xaeRoutine call\xef\x81\xaeType use\xef\x81\xaeInclusion or import\xef\x81\xaeExternal #We want related behavior to sit together, and unrelated behavior to sit elsewhere. Why? Well, if we want to change behavior, we want to be able to change it in one place, and release that change as soon as possible. If we have to change that behavior in lots of different places, we\xe2\x80\x99ll have to release lots of different services (perhaps at the same time) to deliver that change. Making changes in lots of different places is slower, and deploying lots of services at once is risky \xe2\x80\x94both of which we want to avoid. So we want to find boundaries within our problem domain that help ensure that related behavior is in one place. - cohesion and that communicate with other boundaries as loosely as possible. - coupling Coupling = interaction / relationship between two modules...\nCohesion = interaction between two elements within a module.A software is consisting of many modules. Module consists of elements. Consider a module is a program. A function within a program is a element. At run time, output of a program is used as input for another program. This is called module to module interaction or process to process communication. This is  also called as Coupling.Within a single program, output of a function is passed to another function. This is called interaction of elements within a module. This is also called as Cohesion.Example: Coupling = communication in between 2 different families... \nCohesion = communication in between father-mother-child within a family.Generally cohesion is where all methods in a class sound similar, and are often overloaded. eg: