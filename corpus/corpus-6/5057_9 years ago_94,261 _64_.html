Inspired by another question asking about the missing Zip function:Why is there no ForEach extension method in the Enumerable class? Or anywhere? The only class that gets a ForEach method is List<>. Is there a reason why it\'s missing (performance)?There is already a foreach statement included in the language that does the job most of the time.I\'d hate to see the following:Instead of:The latter is clearer and easier to read in most situation, although maybe a bit longer to type. However, I must admit I changed my stance on that issue; a ForEach() extension method would indeed be useful in some situations.Here are the major differences between the statement and the method:Those are all great points made by many people here and I can see why people are missing the function. I wouldn\'t mind Microsoft adding a standard ForEach method in the next framework iteration.ForEach method was added before LINQ. If you add ForEach extension, it will never be called for List instances because of extension methods constraints.  I think the reason it was not added is to not interference with existing one.However, if you really miss this little nice function, you can roll out your own versionYou could write this extension method:ProsAllows chaining:ConsIt won\'t actually do anything until you do something to force iteration.  For that reason, it shouldn\'t be called .ForEach().  You could write .ToList() at the end, or you could write this extension method, too:This may be too significant a departure from the shipping C# libraries; readers who are not familiar with your extension methods won\'t know what to make of your code.The discussion here gives the answer:Actually, the specific discussion I witnessed did in fact hinge over functional purity.  In an expression, there are frequently assumptions made about not having side-effects.  Having ForEach is specifically inviting side-effects rather than just putting up with them. -- Keith Farmer (Partner)Basically the decision was made to keep the extension methods functionally "pure". A ForEach would encourage side-effects when using the Enumerable extension methods, which was not the intent.While I agree that it\'s better to use the built-in foreach construct in most cases, I find the use of this variation on the ForEach<> extension to be a little nicer than having to manage the index in a regular foreach myself:Would give you:One workaround is to write .ToList().ForEach(x => ...).   prosEasy to understand - reader only needs to know what ships with C#, not any additional extension methods.Syntactic noise is very mild (only adds a little extranious code).Doesn\'t usually cost extra memory, since a native .ForEach() would have to realize the whole collection, anyway.consOrder of operations isn\'t ideal.  I\'d rather realize one element, then act on it, then repeat.  This code realizes all elements first, then acts on them each in sequence.If realizing the list throws an exception, you never get to act on a single element.If the enumeration is infinite (like the natural numbers), you\'re out of luck.I\'ve always wondered that myself, that is why that I always carry this with me:Nice little extension method.So there has been a lot of comments about the fact that a ForEach extension method isn\'t appropriate because it doesn\'t return a value like the LINQ extension methods. While this is a factual statement, it isn\'t entirely true.The LINQ extension methods do all return a value so they can be chained together:However, just because LINQ is implemented using extension methods does not mean that extension methods must be used in the same way and return a value. Writing an extension method to expose common functionality that does not return a value is a perfectly valid use.The specific arguement about ForEach is that, based on the constraints on extension methods (namely that an extension method will never override an inherited method with the same signature), there may be a situation where the custom extension method is available on all classes that impelement IEnumerable<T> except List<T>. This can cause confusion when the methods start to behave differently depending on whether or not the extension method or the inherit method is being called.You could use the (chainable, but lazily evaluated) Select, first doing your operation, and then returning identity (or something else if you prefer)You will need to make sure it is still evaluated, either with Count() (the cheapest operation to enumerate afaik) or another operation you needed anyway.I would love to see it brought in to the standard library though:The above code then becomes people.WithLazySideEffect(p => Console.WriteLine(p)) which is effectively equivalent to foreach, but lazy and chainable.@CoincoinThe real power of the foreach extension method involves reusability of the Action<> without adding unnecessary methods to your code. Say that you have 10 lists and you want to perform the same logic on them, and a corresponding function doesn\'t fit into your class and is not reused. Instead of having ten for loops, or a generic function that is obviously a helper that doesn\'t belong, you can keep all of your logic in one place (the Action<>. So, dozens of lines get replaced withetc...The logic is in one place and you haven\'t polluted your class.In 3.5, all the extension methods added to IEnumerable are there for LINQ support (notice that they are defined in the System.Linq.Enumerable class). In this post, I explain why foreach doesn\'t belong in LINQ: \nExisting LINQ extension method similar to Parallel.For?Note that the MoreLINQ NuGet provides the ForEach extension method you\'re looking for (as well as a Pipe method which executes the delegate and yields its result).  See:Most of the LINQ extension methods return results. ForEach does not fit into this pattern as it returns nothing.You can use select when you want to return something.\nIf you don\'t, you can use ToList first, because you probably don\'t want to modify anything in the collection.I wrote a blog post about it:\nhttp://blogs.msdn.com/kirillosenkov/archive/2009/01/31/foreach.aspxYou can vote here if you\'d like to see this method in .NET 4.0:\nhttp://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=279093Is it me or is the List<T>.Foreach pretty much been made obsolete by Linq. \nOriginally there was where Y simply had to be IEnumerable (Pre 2.0), and implement a GetEnumerator().\nIf you look at the MSIL generated you can see that it is exactly the same as(See http://alski.net/post/0a-for-foreach-forFirst-forLast0a-0a-.aspx for the MSIL)Then in DotNet2.0 Generics came along and the List. Foreach has always felt to me to be an implementation of the Vistor pattern, (see Design Patterns by Gamma, Helm, Johnson, Vlissides).Now of course in 3.5 we can instead use a Lambda to the same effect, for an example try \nhttp://dotnet-developments.blogs.techtarget.com/2008/09/02/iterators-lambda-and-linq-oh-my/If you have F# (which will be in the next version of .NET), you can useSeq.iter doSomething myIEnumerableNo one has yet pointed out that ForEach<T> results in compile time type checking where the foreach keyword is runtime checked.Having done some refactoring where both methods were used in the code, I favor .ForEach, as I had to hunt down test failures / runtime failures to find the foreach problems.I would like to expand on Aku\'s answer.If you want to call a method for the sole purpose of it\'s side-effect without iterating the whole enumerable first you can use this:To use Foreach, your list should be loaded in primary memory. But due to lazy loading nature of IEnumerable, they doesn\'t provide ForEach in IEnumerable.However by eager loading (using ToList()), you can load your list in to memory and take advantage of ForEach.