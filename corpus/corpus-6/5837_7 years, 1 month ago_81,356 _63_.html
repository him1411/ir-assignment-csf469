I\'m wondering what\'s the best, the cleanest and the most simply way to work with many-to-many relations in Doctrine2. Let\'s assume that we\'ve got an album like Master of Puppets by Metallica with several tracks. But please note the fact that one track might appears in more that one album, like Battery by Metallica does - three albums are featuring this track.So what I need is many-to-many relationship between albums and tracks, using third table with some additional columns (like position of the track in specified album). Actually I have to use, as Doctrine\'s documentation suggests, a double one-to-many relation to achieve that functionality.Sample data:Now I can display a list of albums and tracks associated to them:The results are what I\'m expecting, ie: a list of albums with their tracks in appropriate order and promoted ones being marked as promoted.This code demonstrates what\'s wrong:Album::getTracklist() returns an array of AlbumTrackReference objects instead of Track objects. I can\'t create proxy methods cause what if both, Album and Track would have getTitle() method? I could do some extra processing within Album::getTracklist() method but what\'s the most simply way to do that? Am I forced do write something like that?@beberlei suggested to use proxy methods:That would be a good idea but I\'m using that "reference object" from both sides: $album->getTracklist()[12]->getTitle() and $track->getAlbums()[1]->getTitle(), so getTitle() method should return different data based on the context of invocation.I would have to do something like:And that\'s not a very clean way.I\'ve opened a similar question in the Doctrine user mailing list and got a really simple answer;consider the many to many relation as an entity itself, and then you realize you have 3 objects, linked between them with a one-to-many and many-to-one relation.http://groups.google.com/group/doctrine-user/browse_thread/thread/d1d87c96052e76f7/436b896e83c10868#436b896e83c10868Once a relation has data, it\'s no more a relation !From $album->getTrackList() you will alwas get "AlbumTrackReference" entities back, so what about adding methods from the Track and proxy?This way your loop simplifies considerably, aswell as all other code related to looping the tracks of an album, since all methods are just proxied inside AlbumTrakcReference:Btw You should rename the AlbumTrackReference (for example "AlbumTrack"). It is clearly not only a reference, but contains additional logic. Since there are probably also Tracks that are not connected to an album but just available through a promo-cd or something this allows for a cleaner separation also.Nothing beats a nice exampleFor people looking for a clean coding example of an one-to-many/many-to-one associations between the 3 participating classes to store extra attributes in the relation check this site out:nice example of one-to-many/many-to-one associations between the 3 participating classesThink about your primary keysAlso think about your primary key. You can often use composite keys for relationships like this. Doctrine natively supports this. You can make your referenced entities into ids.\nCheck the documentation on composite keys hereI think I would go with @beberlei\'s suggestion of using proxy methods. What you can do to make this process simpler is to define two interfaces:Then, both your Album and your Track can implement them, while the AlbumTrackReference can still implement both, as following:This way, by removing your logic that is directly referencing a Track or an Album, and just replacing it so that it uses a TrackInterface or AlbumInterface, you get to use your AlbumTrackReference in any possible case. What you will need is to differentiate the methods between the interfaces a bit.This won\'t differentiate the DQL nor the Repository logic, but your services will just ignore the fact that you\'re passing an Album or an AlbumTrackReference, or a Track or an AlbumTrackReference because you\'ve hidden everything behind an interface :)Hope this helps!First, I mostly agree with beberlei on his suggestions.  However, you may be designing yourself into a trap.  Your domain appears to be considering the title to be the natural key for a track, which is likely the case for 99% of the scenarios you come across.  However, what if Battery on Master of the Puppets is a different version (different length, live, acoustic, remix, remastered, etc) than the version on The Metallica Collection.Depending on how you want to handle (or ignore) that case, you could either go beberlei\'s suggested route, or just go with your proposed extra logic in Album::getTracklist().  Personally, I think the extra logic is justified to keep your API clean, but both have their merit.If you do wish to accommodate my use case, you could have Tracks contain a self referencing OneToMany to other Tracks, possibly $similarTracks.  In this case, there would be two entities for the track Battery, one for The Metallica Collection and one for Master of the Puppets.  Then each similar Track entity would contain a reference to each other.  Also, that would get rid of the current AlbumTrackReference class and eliminate your current "issue".  I do agree that it is just moving the complexity to a different point, but it is able to handle a usecase it wasn\'t previously able to.You ask for the "best way" but there is no best way. There are many ways and you already discovered some of them. How you want to manage and/or encapsulate association management when using association classes is entirely up to you and your concrete domain, noone can show you a "best way" I\'m afraid.Apart from that, the question could be simplified a lot by removing Doctrine and relational databases from the equation. The essence of your question boils down to a question about how to deal with association classes in plain OOP.I was getting from a conflict with join table defined in an association class ( with additional custom fields ) annotation and a join table defined in a many-to-many annotation.The mapping definitions in two entities with a direct many-to-many relationship appeared to result in the automatic creation of the join table using the \'joinTable\' annotation. However the join table was already defined by an annotation in its underlying entity class and I wanted it to use this association entity class\'s own field definitions so as to extend the join table with additional custom fields.The explanation and solution is that identified by FMaz008 above. In my situation, it was thanks to this post in the forum \'Doctrine Annotation Question\'. This post draws attention to the Doctrine documentation regarding ManyToMany Uni-directional relationships. Look at the note regarding the approach of using an \'association entity class\' thus replacing the many-to-many annotation mapping directly between two main entity classes with a one-to-many annotation in the main entity classes and two \'many-to-one\' annotations in the associative entity class. There is an example provided in this forum post Association models with extra fields:This really useful example. It lacks in the documentation doctrine 2.Very thank you.For the proxies functions can be done :and What you are referring to is metadata, data about data. I had this same issue for the project I am currently working on and had to spend some time trying to figure it out. It\'s too much information to post here, but below are two links you may find useful. They do reference the Symfony framework, but are based on the Doctrine ORM.http://melikedev.com/2010/04/06/symfony-saving-metadata-during-form-save-sort-ids/http://melikedev.com/2009/12/09/symfony-w-doctrine-saving-many-to-many-mm-relationships/Good luck, and nice Metallica references!The solution is in the documentation of Doctrine. In the FAQ you can see this :http://docs.doctrine-project.org/en/2.1/reference/faq.html#how-can-i-add-columns-to-a-many-to-many-tableAnd the tutorial is here :http://docs.doctrine-project.org/en/2.1/tutorials/composite-primary-keys.htmlSo you do not anymore do a manyToMany but you have to create an extra Entity and put manyToOne to your two entities.ADD for @f00bar comment :it\'s simple, you have just to to do something like this : So you create an entity ArticleTagI hope it helpsUnidirectional. Just add the inversedBy:(Foreign Column Name) to make it Bidirectional.I hope it helps.\nSee you.You may be able to achieve what you want with Class Table Inheritance where you change AlbumTrackReference to AlbumTrack:And getTrackList() would contain AlbumTrack objects which you could then use like you want:You will need to examine this throughly to ensure you don\'t suffer performance-wise. Your current set-up is simple, efficient, and easy to understand even if some of the semantics don\'t quite sit right with you.While getting all album tracks form inside album class, you\'ll generate one more query for one more record. That\'s because of proxy method. There\'s another example of my code (see last post in topic): http://groups.google.com/group/doctrine-user/browse_thread/thread/d1d87c96052e76f7/436b896e83c10868#436b896e83c10868Is there any other method to resolve that? Isn\'t a single join a better solution?Here is the solution as described in the Doctrine2 Documentation