I\'ve got a datatable with 5 columns, where a row is being filled with data then saved to the database via a transaction.While saving, an error is returned:The conversion of a datetime2 data type to a datetime data type resulted in an out-of-range valueIt implies, as read, that my datatable has a type of DateTime2 and my database a DateTime; that is wrong.The date column is set to a DateTime like this: new DataColumn("myDate", Type.GetType("System.DateTime"))QuestionCan this be solved in code or does something have to be changed on a database level?What kind of dates do you have in the column?Do all of them fit within the range of the type?As an aside, the correct way to get a Type object for the DataColumn constructor is the typeof keyword, which is orders of magnitude faster.Therefore, to create the column, you should writeThis can happen if you do not assign a value to a DateTime field when the field does not accept NULL values. That fixed it for me!Both the DATETIME and DATETIME2 map to System.DateTime in .NET - you cannot really do a "conversion", since it\'s really the same .NET type.See the MSDN doc page:  http://msdn.microsoft.com/en-us/library/bb675168.aspxThere are two different values for the "SqlDbType" for these two - can you specify those in your DataColumn definition?BUT: on SQL Server, the date range supported is quite different.DATETIME supports 1753/1/1 to "eternity" (9999/12/31), while DATETIME2 supports 0001/1/1 through eternity.So what you really need to do is check for the year of the date - if it\'s before 1753, you need to change it to something AFTER 1753 in order for the DATETIME column in SQL Server to handle it.MarcIn my SQL Server 2008 database, I had a DateTime column flagged as not nullable, but with a GetDate() function as its default value. When inserting new object using EF4, I got this error because I wasn\'t passing a DateTime property on my object explicitly. I expected the SQL function to handle the date for me but it did not. My solution was to send the date value from code instead of relying on the database to generate it. for me it was because the datetime was..01/01/0001 00:00:00in this case you want to assign null to you EF DateTime Object... using my FirstYearRegistered code as an exampleThis one was driving me crazy.  I wanted to avoid using a nullable date time (DateTime?). I didn\'t have the option of using SQL Server 2008\'s datetime2 type either I eventually opted for the following:Sometimes EF does not know that is dealing with a computed column or a trigger. By design, those operations will set a value outside of EF after an insert. The fix is to specify Computed in EF\'s edmx for that column in the StoreGeneratedPattern property. For me it was when the column had a trigger which inserted the current date and time, see below in the third section.Steps To ResolveIn Visual Studio open the Model Browser page then Model then Entity Types -> thenThe other answers are workarounds, for the purpose of the column is to have a time/date specified when the record was created, and that is SQL\'s job to execute a trigger to add the correct time. Such as this SQL trigger:DEFAULT (GETDATE()) FOR [DateCreated]. The easiest thing would be to change your database to use datetime2 instead of datetime. The compatibility works nicely, and you won\'t get your errors.You\'ll still want to do a bunch of testing...The error is probably because you\'re trying to set a date to year 0 or something - but it all depends on where you have control to change stuff.I ran into this and added the following to my datetime property:I found this post trying to figure why I kept getting the following error which is explained by the other answers.The conversion of a datetime2 data type to a datetime data type resulted in an out-of-range value.Use a nullable DateTime object.\n    public DateTime? PurchaseDate { get; set; }If you are using entity framework\nSet the nullable property in the edmx file to TrueThe Entity Framework 4 works with the datetime2 data type so in db the corresponding field must be datetime2 for SQL Server 2008. To achive the solution there are two ways.Created a base class based on @sky-dev implementation. So this can be easily applied to multiple contexts, and entities.Usage:As andyuk has already pointed-out, this can happen when a NULL value is assigned to a non nullable DateTime field. Consider changing DateTime to DateTime? or Nullable<DateTime>. Bear in mind that, in case you are using a Dependency Property, should also make sure that your dependency property\'s type is also a nullable DateTime type.Below is a real life example of an incomplete DateTime to DateTime? type adjustment that raises the odd behaviourIf we dont pass a date time to date time field the default date {1/1/0001 12:00:00 AM} will be passed.But this date is not compatible with entity frame work so it will throw \nconversion of a datetime2 data type to a datetime data type resulted in an out-of-range valueJust default DateTime.now to the date field if you are not passing any date .In my case we were casting a Date to a Datetime and we got this error.\nWhat happens is that Date has a "more programmer oriented" minimum of 01/01/0001, while Datetime is stuck at 1753Combine that with a data collection error on our part, and you get your exception!Sometimes it works fine on development machines and not in servers. In my case I had to put :In the web.config file.  The timezone in the machine (Server) was right (to the CO locale) but the web app did not. This setting done and it worked fine again. Off course, all dates had value. :Dyou will have date column which was set to lesathan the min value of allowed dattime like 1/1/1001. to overcome this issue you can set the proper datetime value to ur property adn also set another magical property like IsSpecified=true.