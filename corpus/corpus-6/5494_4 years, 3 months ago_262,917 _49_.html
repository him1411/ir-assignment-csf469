I have a directive, here is the code : I would like to call updateMap() on a user action. The action button is not on the directive. What is the best way to call updateMap() from a controller?If you want to use isolated scopes you can pass a control object using bi-directional binding = of a variable from the controller scope. You can also control also several instances of the same directive on a page with the same control object.Assuming that the action button uses the same controller $scope as the directive, just define function updateMap on $scope inside the link function.  Your controller can then call that function when the action button is clicked.fiddleAs per @FlorianF\'s comment, if the directive uses an isolated scope, things are more complicated.  Here\'s one way to make it work: add a set-fn attribute to the map directive which will register the directive function with the controller:fiddleAlthough it might be tempting to expose an object on the isolated scope of a directive to facilitate communicating with it, doing can lead to confusing "spaghetti" code, especially if you need to chain this communication through a couple levels (controller, to directive, to nested directive, etc.) We originally went down this path but after some more research found that it made more sense and resulted in both more maintainable and readable code to expose events and properties that a directive will use for communication via a service then using $watch on that service\'s properties in the directive or any other controls that would need to react to those changes for communication.This abstraction works very nicely with AngularJS\'s dependency injection framework as you can inject the service into any items that need to react to those events. If you look at the Angular.js file, you\'ll see that the directives in there also use services and $watch in this manner, they don\'t expose events over the isolated scope.Lastly, in the case that you need to communicate between directives that are dependent on one another, I would recommend sharing a controller between those directives as the means of communication.AngularJS\'s Wiki for Best Practices also mentions this:Only use .$broadcast(), .$emit() and .$on() for atomic events\n  Events that are relevant globally across the entire app (such as a user authenticating or the app closing). If you want events specific to modules, services or widgets you should consider Services, Directive Controllers, or 3rd Party LibsBuilding on Oliver\'s answer - you might not always need to access a directive\'s inner methods, and in those cases you probably don\'t want to have to create a blank object and add a control attr to the directive just to prevent it from throwing an error (cannot set property \'takeTablet\' of undefined).   You also might want to use the method in other places within the directive.I would add a check to make sure scope.control exists, and set methods to it in a similar fashion to the revealing module patternA bit late, but this is a solution with isololated scope and "events" to call a function in the directive. This solution is inspiered by this SO post by satchmorun and adds a module and an API.Create an API to communicate with the directive. The addUpdateEvent adds an event to the event array and updateMap calls every event function.(Maybe you have to add funcitonality to remove event.)In the directive set a reference to the MapAPI and add $scope.updateMap as an event when MapApi.updateMap is called.In the "main" controller add a reference to the MapApi and just call MapApi.updateMap() to update the map.To be honest, I was not really convinced with any of the answers in this thread. So, here\'s are my solutions:This method is agnostic to whether the directive\'s $scope is a shared one or isolated oneA factory to register the directive instancesThe directive code, I usually put all the logic that doesn\'t deal with DOM inside directive controller. And registering the controller instance inside our handlertemplate codeAccess the controller instance using the factory & run the publicly exposed methodsTaking a leaf out of angular\'s book on how they deal withusing $parse and registering controller on $parent scope. This technique doesn\'t work on isolated $scope directives. Access it inside controller using $scope.fooYou can specify a DOM attribute that can be used to allow the directive to define a function on the parent scope.  The parent scope can then call this method like any other.  Here\'s a plunker.  And below is the relevant code.clearfn is an attribute on the directive element into which the parent scope can pass a scope property which the directive can then set to a function that accomplish\'s the desired behavior.Just use scope.$parent to associate function called to directive functionin HTMLYou can tell the method name to directive to define which you want to call from controller but without isolate scope,Maybe this is not the best choice, but you can do angular.element("#element").isolateScope() or $("#element").isolateScope() to access the scope and/or the controller of your directive.How to get a directive\'s controller in a page controller:write a custom directive to get the reference to the directive controller from the DOM element:  use it in the page controller\'s html:Use the directive controller in the page controller:Note: the given solution works only for element directives\' controllers (tag name is used to get the name of the wanted directive).Below solution will be useful when, you are having controllers (both parent and directive (isolated)) in \'controller As\' formatsomeone might find this useful,directive :directive Controller : html code : 