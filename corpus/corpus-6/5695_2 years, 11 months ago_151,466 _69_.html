I would like to change ListView to RecyclerView. I want to use the onScroll of the OnScrollListener in RecyclerView to determine if a user scrolled to the end of the list. How do I know if a user scrolls to the end of the list so that I can fetch new data from a REST service?Thanks to @Kushal and this is how I implemented itDon\'t forget to addMake these variables.Set on Scroll for recycler view.Note : Make sure you are using LinearLayoutManager as layout manager for RecyclerView.and for a gridHave fun with your endless scrolls !! ^.^Update : mRecyclerView.setOnScrollListener() is deprecated just replace with mRecyclerView.addOnScrollListener() and the warning will be gone! You can read more from this SO question.Since Android now officially support Kotlin, here is an update for the same -Make OnScrollListener and add it to your RecyclerView like this For a full code example, feel free to refer this Github repo.For those who only want to get notified when the last item is totally shown, you can use View.canScrollVertically().Here is my implementation:Note: You can use recyclerView.getLayoutManager().canScrollVertically() if you want to support API < 14.Here is another approach. It will work with any layout manager.For a detail understanding I wrote a blog post and example project get it here\nhttp://sab99r.com/blog/recyclerview-endless-load-more/MyAdapter.javaMyActivity.javaMy answer is a modified version of Noor. I passed from a ListView where i had EndlessScrollListener (that you can find easily in many answers on SO) to a RecyclerView so i wanted a EndlessRecyclScrollListener to easily update my past listener.So here is the code, hope it helps:For me, it\'s very simple: Be careful with asynchronous jobs: mLoading must be changed at the end of the asynchronous jobs. Hope it will be helpful!Most answer are assuming the RecyclerView uses a LinearLayoutManager, or GridLayoutManager, or even StaggeredGridLayoutManager, or assuming that the scrolling is vertical or horyzontal, but no one has posted a completly generic answer.Using the ViewHolder\'s adapter is clearly not a good solution. An adapter might have more than 1 RecyclerView using it. It "adapts" their contents. It should be the RecyclerView (which is the one class which is responsible of what is currently displayed to the user, and not the adapter which is responsible only to provide content to the RecyclerView) which must notify your system that more items are needed (to load).Here is my solution, using nothing else than the abstracted classes of the RecyclerView (RecycerView.LayoutManager and RecycerView.Adapter): Although the accepted answer works perfectly, the solution below uses addOnScrollListener since setOnScrollListener is deprecated, and reduces number of variables, and if conditions.Although there are so many answers to the question, I would like to share our experience of creating the endless list view. We have recently implemented custom Carousel LayoutManager that can work in the cycle by scrolling the list infinitely as well as up to a certain point. Here is a detailed description on GitHub.I suggest you take a look at this article with short but valuable recommendations on creating custom LayoutManagers: http://cases.azoft.com/create-custom-layoutmanager-android/My way to detect loading event is not to detect scrolling, but to listen whether the last view was attached. If the last view was attached, I regard it as timing to load more content.OK, I did it by using the onBindViewHolder method of RecyclerView.Adapter.Adapter:Fragment (or Activity):I would try to extend used LayoutManager (e.g. LinearLayoutManager) and override scrollVerticallyBy() method. Firstly, I would call super first and then check returned integer value. If the value equals to 0 then a bottom or a top border is reached. Then I would use findLastVisibleItemPosition() method to find out which border is reached and load more data if needed. Just an idea.In addition, you can even return your value from that method allowing overscroll and showing "loading" indicator.I achieved an infinite scrolling type implementation using this logic in the onBindViewHolder method of my RecyclerView.Adapter class. With this code when the RecyclerView gets to the last item, it increments the current page and callbacks on an interface which is responsible for loading more data from the api and adding the new results to the adapter. I can post more complete example if this isn\'t clear?For people who use StaggeredGridLayoutManager here is my implementation, it works for me.There is an easy to use library for this named paginate . Supports both ListView and RecyclerView ( LinearLayout , GridLayout and StaggeredGridLayout).Here is the link to the project on GithubI have a pretty detailed example of how to paginate with a RecyclerView.  At a high level, I have a set PAGE_SIZE , lets say 30.  So I request 30 items and if I get 30 back then I request the next page.  If I get less than 30 items I flag a variable to indicate that the last page has been reached and then I stop requesting for more pages.  Check it out and let me know what you think.https://medium.com/@etiennelawlor/pagination-with-recyclerview-1cb7e66a502bHere my solution using AsyncListUtil, in the web says:\nNote that this class uses a single thread to load the data, so it suitable to load data from secondary storage such as disk, but not from network. \nbut i am using odata to read the data and work fine.\nI miss in my example data entities and network methods.\nI include only the example adapter.@kushal @abdulaziz  Why not use this logic instead?Try below:There is a method public void setOnScrollListener (RecyclerView.OnScrollListener listener) in https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html#setOnScrollListener%28android.support.v7.widget.RecyclerView.OnScrollListener%29. Use thatEDIT:Override onScrollStateChanged method inside the onScrollListener and do thisCheck this every thing is explained in detail:\nPagination using RecyclerView From A to ZloadMoreItems():in MyAdapter :None of these answers take into account if the list is too small or not.Here\'s a piece of code I\'ve been using that works on RecycleViews in both directions.I let you my aproximation. Works fine for me.I hope it helps you.I have created LoadMoreRecyclerView using Abdulaziz Noor AnswerLoadMoreRecyclerViewWrapperLinearLayout//Add it in xml likeOnCreate or onViewCreatedcallYourServiceIt is also possible to implement without the scroll listener, using the pure logic of the data model alone. The scroll view requires to get items by position as well as the maximal item count. The model can have the background logic to fetch the needed items in chunks, rather than one by one, and do this in the background thread, notifying the view when the data are ready.This approach allows to have the fetching queue which prefers most recently requested (so currently visible) items over older (most likely already scrolled away) submissions, control the number of parallel threads to use and things the like. The complete source code for this approach (demo app and reusable library) are available here.This solution works perfectly for me.@erdna Please refer my below code.May be it will become helpful to you.