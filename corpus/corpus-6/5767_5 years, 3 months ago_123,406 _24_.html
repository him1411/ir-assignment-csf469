Starting with the documentation:public void setRetainInstance (boolean retain)Control whether a fragment instance is retained across Activity re-creation (such as from a configuration change). This can only be used with fragments not in the back stack. If set, the fragment lifecycle will be slightly different when an activity is recreated:I have some questions:Does the fragment also retain its view, or will this be recreated on configuration change? What exactly is "retained"?Will the fragment be destroyed when the user leaves the activity?Why doesn\'t it work with fragments on the back stack?Which are the use cases where it makes sense to use this method?First of all, check out my post on retained Fragments. It might help.Now to answer your questions:Does the fragment also retain its view state, or will this be recreated on configuration change - what exactly is "retained"?Yes, the Fragment\'s state will be retained across the configuration change. Specifically, "retained" means that the fragment will not be destroyed on configuration changes. That is, the Fragment will be retained even if the configuration change causes the underlying Activity to be destroyed.Will the fragment be destroyed when the user leaves the activity?Just like Activitys, Fragments may be destroyed by the system when memory resources are low. Whether you have your fragments retain their instance state across configuration changes will have no effect on whether or not the system will destroy the Fragments once you leave the Activity. If you leave the Activity (i.e. by pressing the home button), the Fragments may or may not be destroyed. If you leave the Activity by pressing the back button (thus, calling finish() and effectively destroying the Activity), all of the Activitys attached Fragments will also be destroyed.Why doesn\'t it work with fragments on the back stack?There are probably multiple reasons why it\'s not supported, but the most obvious reason to me is that the Activity holds a reference to the FragmentManager, and the FragmentManager manages the backstack. That is, no matter if you choose to retain your Fragments or not, the Activity (and thus the FragmentManager\'s backstack) will be destroyed on a configuration change. Another reason why it might not work is because things might get tricky if both retained fragments and non-retained fragments were allowed to exist on the same backstack.Which are the use cases where it makes sense to use this method?Retained fragments can be quite useful for propagating state information \xe2\x80\x94 especially thread management \xe2\x80\x94 across activity instances. For example, a fragment can serve as a host for an instance of Thread or AsyncTask, managing its operation. See my blog post on this topic for more information.In general, I would treat it similarly to using onConfigurationChanged with an Activity... don\'t use it as a bandaid just because you are too lazy to implement/handle an orientation change correctly. Only use it when you need to.setRetaininstance is only useful when your activity is destroyed and recreated due to a configuration change because the instances are saved during a call to onRetainNonConfigurationInstance. That is, if you rotate the device, the retained fragments will remain there(they\'re not destroyed and recreated.) but when the runtime kills the activity to reclaim resources, nothing is left. When you press back button and exit the activity, everything is destroyed.Usually I use this function to saved orientation changing Time.Say I have download a bunch of Bitmaps from server and each one is 1MB, when the user accidentally rotate his device, I certainly don\'t want to do all the download work again.So I create a Fragment holding my bitmaps and add it to the manager and call setRetainInstance,all the Bitmaps are still there even if the screen orientation changes.SetRetainInstance(true) allows the fragment sort of survive. Its members will be retained during configuration change like rotation. But it still may be killed when the activity is killed in the background. If the containing activity in the background is killed by the system, it\'s instanceState should be saved by the system you handled onSaveInstanceState  properly. In another word the onSaveInstanceState will always be called. Though onCreateView won\'t be called if SetRetainInstance is true and fragment/activity is not killed yet, it still will be called if it\'s killed and being tried to be brought back.Here are some analysis of the android activity/fragment hope it helps.\nhttp://ideaventure.blogspot.com.au/2014/01/android-activityfragment-life-cycle.htmlsetRetainInstance(boolean) is useful when you want to have some component which is not tied to Activity lifecycle. This technique is used for example by rxloader to "handle Android\'s activity lifecyle for rxjava\'s Observable" (which I\'ve found here).