I understand this occurs with Java 7 when using varargs with a generic type;But my question is..What exactly does Eclipse mean when it says "its use could potentially pollute the heap?"And How does the new @SafeVarargs annotation prevent this?Heap pollution is a technical term. It refers to references which have a type that is not a supertype of the object they point to.This can lead to "unexplainable" ClassCastExceptions.@SafeVarargs does not prevent this at all. However, there are methods which provably will not pollute the heap, the compiler just can\'t prove it. Previously callers of such APIs would get annoying warnings that were completely pointless, but had to be suppressed at every call site. Now the API author can suppress it once at the declaration site.However, if the method actually is not safe, users will no longer be warned.When you declarepublic static <T> void foo(List<T>... bar) the compiler converts it topublic static <T> void foo(List<T>[] bar) then topublic static <T> void foo(List[] bar)The danger then arises that you\'ll mistakenly assign incorrect values into the list and the compiler will not trigger any error. For example, if T is a String then the following code will compile without error but will fail at runtime:If you reviewed the method to ensure that it doesn\'t contain such vulnerabilities then you can annotate it with @SafeVarargs to suppress the warning. For interfaces, use @SuppressWarnings("unchecked").If you get this error message:Varargs method could cause heap pollution from non-reifiable varargs parameterand you are sure that your usage is safe then you should use @SuppressWarnings("varargs") instead. See Is @SafeVarargs an appropriate annotation for this method? and https://stackoverflow.com/a/14252221/14731 for a nice explanation of this second kind of error.References:@SafeVarargs does not prevent it from happening, however it mandates that the compiler is stricter when compiling code that uses it. http://docs.oracle.com/javase/7/docs/api/java/lang/SafeVarargs.html explains this in futher detail.Heap pollution is when you get a ClassCastException when doing an operation on a generic interface and it contains another type than declared.When you use varargs, it can result in the creation of an Object[] to hold the arguments.Due to escape analysis, the JIT can optimise away this array creation. (One of the few times I have found it does so) Its not guaranteed to be optimised away, but I wouldn\'t worry about it unless you see its an issue in your memory profiler.AFAIK @SafeVarargs suppresses a warning by the compiler and doesn\'t change how the JIT behaves.