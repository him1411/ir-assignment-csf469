This question already has an answer here:Is it possible to pass a method into a Java method as a parameter? If so, could someone please guide me? This doesn\'t seem trivialNote: The following answer suffices for versions of Java BEFORE Java 8. If you\'re using Java 8, look up \'java 8 lambda expressions\'.\n  It is syntactic sugar for what I describe below.A common pattern would be to \'wrap\' it within an interface, like Callable, for example, then you pass in a Callable:This pattern is known as the Command Pattern.Keep in mind you would be best off creating an interface for your particular usage. If you chose to go with callable, then you\'d replace T above with whatever type of return value you expect, such as String.In response to your comment below you could say:then call it, perhaps using an anonymous inner class:Keep in mind this is not a \'trick\'. It\'s just java\'s basic conceptual equivalent to function pointers.You could use Java reflection to do this.  The method would be represented as an instance of java.lang.reflect.Method.To add on to jk.\'s excellent answer, you can now pass a method more easily using Lambda Expressions (in Java 8). First, some background. A functional interface is an interface that has one and only one abstract method, although it can contain any number of default methods (new in Java 8) and static methods. A lambda expression can quickly implement the abstract method, without all the unnecessary syntax needed if you don\'t use a lambda expression.Without lambda expressions:With lambda expressions:Here is an excerpt from the Java tutorial on Lambda Expressions:A lambda expression consists of the following:A comma-separated list of formal parameters enclosed in parentheses. The CheckPerson.test method contains one parameter, p,\n  which represents an instance of the Person class.Note: You\n  can omit the data type of the parameters in a lambda expression. In\n  addition, you can omit the parentheses if there is only one parameter.\n  For example, the following lambda expression is also valid:The arrow token, ->A body, which consists of a single expression or a statement block. This example uses the following expression:If you specify a single expression, then the Java runtime evaluates the expression and then returns its value. Alternatively,\n  you can use a return statement:A return statement is not an expression; in a lambda expression, you must enclose statements in braces ({}). However, you do not have\n  to enclose a void method invocation in braces. For example, the\n  following is a valid lambda expression:Note that a lambda expression looks a lot like a method declaration;\n  you can consider lambda expressions as anonymous methods\xe2\x80\x94methods\n  without a name.Here is how you can "pass a method" using a lambda expression:Note: this uses a new standard functional interface, java.util.function.IntConsumer.The above example can be shortened even more using the :: operator.Thanks to Java 8 you don\'t need to do the steps below to pass a function to a method, that\'s what lambdas are for, see Oracle\'s Lambda Expression tutorial. The rest of this post describes what we used to have to do in the bad old days in order to implement this functionality.Typically you declare your method as taking some interface with a single method, then you pass in an object that implements that interface. An example is in commons-collections, where you have interfaces for Closure, Transformer, and Predicate, and methods that you pass implementations of those into. Guava is the new improved commons-collections, you can find equivalent interfaces there.So for instance, commons-collections has org.apache.commons.collections.CollectionUtils, which has lots of static methods that take objects passed in, to pick one at random, there\'s one called exists with this signature:It takes an object that implements the interface Predicate, which means it has to have a method on it that takes some Object and returns a boolean.So I can call it like this:and it returns true or false depending on whether someCollection contains an object that the predicate returns true for.Anyway, this is just an example, and commons-collections is outdated. I just forget the equivalent in Guava.I know this is a rather old post but I have another slightly simpler solution.\nYou could create another class within and make it abstract. Next make an Abstract method name it whatever you like. In the original class make a method that takes the new class as a parameter, in this method call the abstract method. It will look something like this.Now you can do something like this to call a method from within the class.Like I said I know its old but this way I think is a little easier. Hope it helps.I used the command pattern that @jk. mentioned, adding a return type:Java supports closures just fine. It just doesn\'t support functions, so the syntax you\'re used to for closures is much more awkward and bulky: you have to wrap everything up in a class with a method. For example,Will return a Runnable object whose run() method "closes over" the x passed in, just like in any language that supports first-class functions and closures.Java does not (yet) support closures. But there are other languages like Scala and Groovy which run in the JVM and do support closures.