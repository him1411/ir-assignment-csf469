I\'ve got an arbitrary list of .NET assemblies.I need to programmatically check if each DLL was built for x86 (as opposed to x64 or Any CPU). Is this possible?Look at System.Reflection.AssemblyName.GetAssemblyName(string assemblyFile)You can examine assembly metadata from the returned AssemblyName instance:Using PowerShell:Here, ProcessorArchitecture identifies target platform.I\'m using PowerShell in this example to call the method.You can use the CorFlags CLI tool (for instance, C:\\Program Files\\Microsoft SDKs\\Windows\\v7.0\\Bin\\CorFlags.exe) to determine the status of an assembly, based on its output and opening an assembly as a binary asset you should be able to determine where you need to seek to determine if the 32BIT flag is set to 1 (x86) or 0 (Any CPU or x64, depending on PE):The blog post x64 Development with .NET has some information about corflags.Even better, you can use Module.GetPEKind to determine whether an assembly is PortableExecutableKinds value PE32Plus (64-bit), Required32Bit (32-bit and WOW), or ILOnly (any CPU) along with other attributes.Just for clarification, CorFlags.exe is part of the .NET Framework SDK. I have the development tools on my machine, and the simplest way for me determine whether a DLL is 32-bit only is to:Open the Visual Studio Command Prompt (In Windows: menu Start/Programs/Microsoft Visual Studio/Visual Studio Tools/Visual Studio 2008 Command Prompt)CD to the directory containing the DLL in questionRun corflags like this:\ncorflags MyAssembly.dllYou will get output something like this:As per comments the flags above are to be read as following:How about you just write you own? The core of the PE architecture hasn\'t been seriously changed since its implementation in Windows 95. Here\'s a C# example:Now the current constants are:But with this method it allows for the possibilities of new constants, just validate the return as you see fit.Try to use CorFlagsReader from this project at CodePlex. It has no references to other assemblies and it can be used as is.Below is a batch file that will run corflags.exe against all dlls and exes in the current working directory and all sub-directories, parse the results and display the target architecture of each.Depending on the version of corflags.exe that is used, the line items in the output will either include 32BIT, or 32BITREQ (and 32BITPREF).  Whichever of these two is included in the output is the critical line item that must be checked to differentiate between Any CPU and x86.  If you are using an older version of corflags.exe (pre Windows SDK v8.0A), then only the 32BIT line item will be present in the output, as others have indicated in past answers.  Otherwise 32BITREQ and 32BITPREF replace it.This assumes corflags.exe is in the %PATH%.  The simplest way to ensure this is to use a Developer Command Prompt.  Alternatively you could copy it from it\'s default location.If the batch file below is run against an unmanaged dll or exe, it will incorrectly display it as x86, since the actual output from Corflags.exe will be an error message similar to: corflags : error CF008 : The specified file does not have a valid managed headerAnother way to check the target platform of a .NET assembly is inspecting the assembly with .NET Reflector...@#~#\xe2\x82\xac~! I\'ve just realized that the new version is not free! So, correction, if you have a free version of .NET reflector, you can use it to check the target platform. cfeduke notes the possibility of calling GetPEKind. It\'s potentially interesting to do this from PowerShell.Here, for example, is code for a cmdlet that could be used: https://stackoverflow.com/a/16181743/64257Alternatively, at https://stackoverflow.com/a/4719567/64257 it is noted that "there\'s also the Get-PEHeader cmdlet in the PowerShell Community Extensions that can be used to test for executable images."A more advanced application for that you can find here: CodePlex - ApiChangeExamples:One more way would be to use dumpbin from the Visual Studio tools on DLL and look for the appropriate outputNote: Above o/p is for 32bit dllOne more useful option with dumpbin.exe is /EXPORTS, It will show you the function exposed by the dllDotPeek from JetBrians provides quick and easy way to see msil(anycpu), x86, x64\n