I can\'t update the content in ViewPager.A question: What is the relationship and correct usage of methods instantiateItem() and getItem() in FragmentPagerAdapter class?I was using only getItem() to instantiate and return my fragments:This worked well (but as said I can\'t change the content).So I found this: ViewPager PagerAdapter not updating the ViewParticulary one in which it\'s talked about method instantiateItem():"My approach is to use the setTag() method for any instantiated view in the instantiateItem() method"So now I want to implement instantiateItem() in order to do that. But I don\'t know what I have to return there (return is Object) and what is the relation with getItem(int position)?Currently I\'m using getItem to instantiate the Fragment, is that wrong? But then do I have to put the fragments in instance variable, or not implement getItem() at all...? I just don\'t understand it.I tried reading the reference:public abstract Fragment getItem (int position)Return the Fragment associated with a specified position.public Object instantiateItem (ViewGroup container, int position)Create the page for the given position. The adapter is responsible for adding the view to the container given here, although it only must ensure this is done by the time it returns from finishUpdate(ViewGroup).\n  Parameterscontainer   The containing View in which the page will be shown.\n  position    The page position to be instantiated.ReturnsReturns an Object representing the new page. This does not need to be a View, but can be some other container of the page.... but I still don\'t understand how are they related and what I have to do.Here\'s my code. I\'m using support package v4.ViewPagerTest MyFragmentAdapterMyFragmentHere is also somebody with a similar problem, no answers...http://www.mail-archive.com/android-developers@googlegroups.com/msg200477.htmlWhen using FragmentPagerAdapter or FragmentStatePagerAdapter, it is best to deal solely with getItem() and not touch instantiateItem() at all. The instantiateItem()-destroyItem()-isViewFromObject() interface on PagerAdapter is a lower-level interface that FragmentPagerAdapter uses to implement the much simpler getItem() interface.Before getting into this, I should clarify that if you want to switch out the actual fragments that are being displayed, you need to avoid FragmentPagerAdapter and use\n  FragmentStatePagerAdapter.An earlier version of this answer made the mistake of using FragmentPagerAdapter for its example - that won\'t work because FragmentPagerAdapter never destroys a fragment after it\'s been displayed the first time.I don\'t recommend the setTag() and findViewWithTag() workaround provided in the post you linked. As you\'ve discovered, using setTag() and findViewWithTag() doesn\'t work with fragments, so it\'s not a good match.The right solution is to override getItemPosition(). When notifyDataSetChanged() is called, ViewPager calls getItemPosition() on all the items in its adapter to see whether they need to be moved to a different position or removed. By default, getItemPosition() returns POSITION_UNCHANGED, which means, "This object is fine where it is, don\'t destroy or remove it." Returning POSITION_NONE fixes the problem by instead saying, "This object is no longer an item I\'m displaying, remove it." So it has the effect of removing and recreating every single item in your adapter. This is a completely legitimate fix! This fix makes notifyDataSetChanged behave like a regular Adapter without view recycling. If you implement this fix and performance is satisfactory, you\'re off to the races. Job done.If you need better performance, you can use a fancier getItemPosition() implementation. Here\'s an example for a pager creating fragments off of a list of strings:With this implementation, only fragments displaying new titles will get displayed. Any fragments displaying titles that are still in the list will instead be moved around to their new position in the list, and fragments with titles that are no longer in the list at all will be destroyed.What if the fragment has not been recreated, but needs to be updated anyway? Updates to a living fragment are best handled by the fragment itself. That\'s the advantage of having a fragment, after all - it is its own controller. A fragment can add a listener or an observer to another object in onCreate(), and then remove it in onDestroy(), thus managing the updates itself. You don\'t have to put all the update code inside getItem() like you do in an adapter for a ListView or other AdapterView types.One last thing - just because FragmentPagerAdapter doesn\'t destroy a fragment doesn\'t mean that getItemPosition is completely useless in a FragmentPagerAdapter. You can still use this callback to reorder your fragments in the ViewPager. It will never remove them completely from the FragmentManager, though.Instead of returning POSITION_NONE from getItemPosition() and causing full view recreation, do this:Your fragments should implement UpdateableFragment interface:and the interface:Your data class:I have encountered this problem and finally solved it today, so I write down what I have learned and I hope it is helpful for someone who is new to Android\'s ViewPager and update as I do. I\'m using FragmentStatePagerAdapter in API level 17 and currently have just 2 fragments. I think there must be something not correct, please correct me, thanks.\nSerialized data has to be loaded into memory. This can be done using a CursorLoader/AsyncTask/Thread. Whether it\'s automatically loaded depends on your code. If you are using a CursorLoader, it\'s auto-loaded since there is a registered data observer.After you call viewpager.setAdapter(pageradapter), the adapter\'s getCount() is constantly called to build fragments. So if data is being loaded, getCount() can return 0, thus you don\'t need to create dummy fragments for no data shown.After the data is loaded, the adapter will not build fragments automatically since getCount() is still 0, so we can set the actually loaded data number to be returned by getCount(), then call the adapter\'s notifyDataSetChanged(). ViewPager begin to create fragments (just the first 2 fragments) by data in memory. It\'s done before notifyDataSetChanged() is returned. Then the ViewPager has the right fragments you need.If the data in the database and memory are both updated (write through), or just data in memory is updated (write back), or only data in the database is updated. In the last two cases if data is not automatically loaded from the database to memory (as mentioned above).\nThe ViewPager and pager adapter just deal with data in memory.So when data in memory is updated, we just need to call the adapter\'s notifyDataSetChanged(). Since the fragment is already created, the adapter\'s onItemPosition() will be called before notifyDataSetChanged(\xef\xbc\x89 returns. Nothing needs to be done in getItemPosition(). Then the data is updated.Try destroyDrawingCache() on ViewPager after notifyDataSetChanged() in your code.for those who still face the same problem which i faced before when i have viewpager with seven fragments. the default for these fragments to load the english content from service but the problem here that i want to change the language from settins activity and after finish \nSettings activity i want viewpager in main activity to refresh the fragments to match the langauge selection from the user and load the arabic content if user choose arabic here what i did to work from the first time 1-you must use vFragmentStatePagerAdapter as mentioned above.2-on mainActivity i overrided the onResume and did the following  3-i ovveride the getItemPosition() in mPagerAdapter and make it return POSITION_NONE.works like charmAfter hours of frustration while trying all the above solutions to overcome this problem and also trying many solutions on other similar questions like this, this and this which all FAILED with me to solve this problem and to make the ViewPager to destroy the old Fragment and fill the pager with the new Fragments. I have solved the problem as following:1) Make the ViewPager class to extends FragmentPagerAdapter as following:2) Create an Item for the ViewPager that store the title and the fragment as following:3) Make the constructor of the ViewPager take my FragmentManager instance to store it in my class as following:4) Create a method to re-set the adapter data with the new data by deleting all the previous fragment from the fragmentManager itself directly to make the adapter to set the new fragment from the new list again as following:5) From the container Activity or Fragment do not re-initialize the adapter with the new data. Set the new data through the method setPagerItems with the new data as following:I hope it helps.For some reason none of the answers worked for me so I had to override the restoreState method without calling super in my fragmentStatePagerAdapter. Code:I slightly modified the solution provided by Bill Phillips to suit my needsso that the getItemPosition() returns POSITION_NONE only for those fragments which are currently in the FragmentManager when getItemPosition is called.\n(Note that this FragmentStatePager and the ViewPager associated with it are contained in a Fragment not in a Activity)I had a similar problem but don\'t want to trust on the existing solutions (hard coded tag names etc.) and I couldn\'t make M-WaJeEh\'s solution work for me. Here is my solution:I keep references to the fragments created in getItem in an array. This works fine as long as the activity is not destroyed due to configurationChange or lack of memory or whatever (--> when coming back to the activity, fragments return to their last state without \'getItem\' being called again and thus without updating the array).To avoid this problem I implemented instantiateItem(ViewGroup, int) and update my array there, like this:So, on the one hand I\'m happy that I found a solution that works for me and wanted to share it with you, but I also wanted to ask whether somebody else tried something similar and whether there is any reason why I shouldn\'t do it like that? So far it works very good for me...If you want to use FragmentStatePagerAdapter, please take a look at https://code.google.com/p/android/issues/detail?can=2&start=0&num=100&q=&colspec=ID%20Type%20Status%20Owner%20Summary%20Stars&groupby=&sort=&id=37990.\nThere are issues with FragmentStatePagerAdapter that may or may not trouble your use case.  Also, link has few solutions too..few may suit to your requirement.I use EventBus library to update Fragment content in ViewPager. The logic is simple, just like document of EventBus how to do. It is no need to control FragmentPagerAdapter instance. The code is here:1: Define eventsDefine which message which is needed to update.  2.Prepare subscribersWrite below code in the Fragment which is needed update.3.Post eventsWrite below code in other Activity or other Fragment which needs to update parameter    I had been trying so many different approaches, none really sove my problem. Below are how I solve it with a mix of solutions provided by you all. Thanks everyone.I only want to refresh page 0 after onResume().In my FragmentsMain, there is public integer "page", which can tell me whether it is the page I want to refresh.I know am late for the Party. I\'ve fixed the problem by calling TabLayout#setupWithViewPager(myViewPager); just after FragmentPagerAdapter#notifyDataSetChanged();This solution won\'t work for everyone, but in my case, every Fragment in my ViewPager is a different class, and only one of them ever exist at a time. With this constraint, this solution is safe and should be safe to use in production.If you have multiple versions of the same fragment, you can use this same strategy to call methods on those fragments to determine if it is the fragment you wish to update.This might be of help to someone - in my case when inserting a new page the view pager was asking for the position of an existing fragment twice, but not asking for the position of the new item, causing incorrect behaviour and data not displaying.Copy the source for for FragmentStatePagerAdapter (seems to have not been updated in ages).Override notifyDataSetChanged()Add a sanity check to destroyItem() to prevent crashes:Accepted answer is not understand, That\'s why added easy solution. \nfind Working solution.Just notify to your adapter, it\'s working amazing,Reference codecall this code when you set adapter and when you want to refresh UI.In Your fragment add this code for refresh\nUse instanceof for cast context.This code share only helping purpose who find working solution, Hope its helpful !I\'ve gone through all the answers above and a number of others posts but still couldn\'t find something that worked for me (with different fragment types along with dynamically adding and removing tabs).  FWIW following approach is what worked for me (in case anyone else has same issues).  I have lived same problem and I have searched too much times. Any answer given in stackoverflow or via google was not solution for my problem. My problem was easy. I have a list, I show this list with viewpager. When I add a new element to head of the list and I refresh the viewpager nothings changed. My final solution was very easy anybody can use. When a new element added to list and want to refresh the list. Firstly set viewpager adapter to null then recreate the adapter and set i to it to viewpager.Be sure your adapter must extend FragmentStatePagerAdapter