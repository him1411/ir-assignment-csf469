Is it possible in Hibernate to print generated SQL queries with real values instead of question marks?How would you suggest to print queries with real values if it is not possible with Hibernate API?You need to enable logging for the the following categories:So a log4j configuration could look like:The first is equivalent to hibernate.show_sql=true legacy property, the second prints the bound parameters among other things.Another solution (non hibernate based) would be to use a JDBC proxy driver like P6Spy.Just for convenience, here is the same configuration example for Logback (SLF4J)The output in your sql.log (example) then looks like this:Change hibernate.cfg.xml to:Include log4j and below entries in "log4j.properties":Log4JDBC is a nice solution which prints the exact SQL going to the database with parameters in place rather than the most popular answer here which does not do this. One major convenience of this is that you can copy the SQL straight to your DB front-end and execute as is.http://log4jdbc.sourceforge.net/https://code.google.com/p/log4jdbc-remix/The latter also outputs a tabular representation of query results.Sample Output showing generated SQL with params in place together with result set table from query:Most recently I have now been using log4jdbc-log4j2 (https://code.google.com/archive/p/log4jdbc-log4j2/ ) with SLF4j and logback. Maven dependencies required for my set-up are as below:The Driver and DB Urls then look like:My logback.xml configuration file looks like the below: this outputs all SQL statements with parameters plus the resultset tables for all queries.Finally, I had to create a file named log4jdbc.log4j2.properties at the root of the classpath e.g. src/test/resources or src/main/resources in a Mevn project.  This file has one line which is the below:The above will depend on your logging library. See the docs at https://code.google.com/archive/p/log4jdbc-log4j2 for further infoSample Output:You can add category lines to log4j.xml:and add hibernate properties: turn on the org.hibernate.type Logger to see how the actual parameters are bind to the question marks.You can do it using the datasource-proxy, as I described in this post.Assuming your application expects a dataSource bean (e.g. via @Resource), this is how you can configure datasource-proxy:Now the Hibernate output vs datasource-proxy:The datasource-proxy queries contain parameter values and you can even add custom JDBC statement interceptors so that you can catch N+1 query issues right from your integration tests.add following properties and values to your log4j or logback configuration:In case of spring boot is being used , just config this :aplication.ymlaplication.propertiesand nothing more.HTHThis answer is a little variance for the question.\nSometimes, we only need the sql only for debug purposes in runtime.\nIn that case, there are a more easy way, using debug on editors.This is for hibernate 3. I\'m not sure that this work on other versions.The solution is correct but logs also all bindings for the result objects.\nTo prevent this it\'s possibile to create a separate appender and enable filtering, for example:I like this for log4j:\nUsing Hibernate 4 and slf4j/log4j2 , I tried adding the following in my log4j2.xml configuration :But without success.I found out through this thread that the jboss-logging framework used by hibernate needed to be configured in order to log through slf4j. I added the following argument to the VM arguments of the application:And it worked like a charm.if you are using hibernate 3.2.xx\nuse instead of You can log this:Output example:Log4Jdbc plugin would be best for your requirement. It shows following-Refer below link to configure Log4Jdbc-Logging works but not exactly you want or i wanted some time ago, but P6Spy does work perfectly, here is the simple tutorial to implement as well MKYONG tutorial for P6Spy.for me it worked like charm.Get the \xe2\x80\x9cp6spy-install.jar\xe2\x80\x9cExtract the p6spy-install.jar file, look for p6spy.jar and spy.propertiesAdd p6spy.jar into your project library dependencyModify your database configuration file. You need to replace your existing JDBC driver with P6Spy JDBC driver \xe2\x80\x93 com.p6spy.engine.spy.P6SpyDriverOriginal is MySQL JDBC driver \xe2\x80\x93 com.mysql.jdbc.DriverChanged it to P6Spy JDBC driver \xe2\x80\x93 com.p6spy.engine.spy.P6SpyDriverReplace the real driver with your existing MySQL JDBC driverChange the Log file location\nChange the log file location in logfile property, all SQL statements will log into this file.Windows*nixCopy \xe2\x80\x9cspy.properties\xe2\x80\x9d to your project root folder, make sure your project can locate \xe2\x80\x9cspy.properties\xe2\x80\x9d, else it will prompt \xe2\x80\x9cspy.properties\xe2\x80\x9d file not found exception.Use Wireshark or something similar:None of the above mentioned answers will print sql with parameters properly or is a pain. I achieved this by using WireShark, which captures all sql/commands being send from the application to Oracle/Mysql etc with the queries.\nAll of the answers here are helpful, but if you\'re using a Spring application context XML to setup your session factory, setting the log4j SQL level variable only gets you part of the way there, you also have to set the hibernate.show_sql variable in the app context itself to get Hibernate to start actually showing the values.ApplicationContext.xml has:And your log4j file needsmysql jdbc driver has already provide a convenient to meet this requirement, you must at least the have the jar version >= mysql-connect-jar-5.1.6.jarstep 1: [configure your jdbc.url to add logger and custom logging]now, it is using slf4j logging, if your default logging is log4j, you must add slf4j-api, slf4j-log4j12 dependencies to use slf4j loggingstep 2: [write your custom logging]Here is what worked for me, set below property in the log4j.file:Hibernate properties settings :