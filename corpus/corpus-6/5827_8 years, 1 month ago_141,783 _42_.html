This question already has an answer here:What is the difference between the dot (.) operator and ->  in C++?foo->bar() is the same as (*foo).bar().The parenthesizes above are necessary because of the binding strength of the * and . operators.  *foo.bar() wouldn\'t work because Dot (.) operator is evaluated first (see operator precedence)The Dot (.) operator can\'t be overloaded, arrow (->) operator can be overloaded.The Dot (.) operator can\'t be applied to pointers.Also see: What is the arrow operator (->) synonym for in C++?Dot operator can\'t be overloaded, arrow operator can be overloaded. Arrow operator is generally meant to be applied to pointers (or objects that behave like pointers, like smart pointers). Dot operator can\'t be applied to pointers.EDIT\nWhen applied to pointer arrow operator is equivalent to applying dot operator to pointee\n(ptr->field is equivalent to (*ptr).field)For a pointer, we could just useBut the . operator has greater precedence than the * operator, so . is evaluated first. So we need to force this with parenthesis:But typing the ()\'s all the time is hard, so they developed -> as a shortcut to say the same thing. If you are accessing a property of an object or object reference, use .  If you are accessing a property of an object through a pointer, use ->The arrow operator is like dot, except it dereferences a pointer first. foo.bar() calls method bar() on object foo, foo->bar calls method bar on the object pointed to by pointer foo.is equivalent toThe target.\ndot works on objects; arrow works on pointers to objects.The . operator is for direct member access.The arrow dereferences a pointer so you can access the object/memory it is pointing to-> use when you have pointer\n. use when you have structure (class)\nwhen you want point attribute that belong to structure use .  structure.attribute\nwhen want point to attribute that have refference to memory by pointer use -> :Note that the -> operator cannot be used for certain things, for instance, accessing operator[].The -> is simply syntactic sugar for a pointer dereference,As others have said:pointer->method();is a simple method of saying:(*pointer).method();For more pointer fun, check out Binky, and his magic wand of dereferencing:http://www.youtube.com/watch?v=UvoHwFvAvQEThe simplest difference between the two is that  "->" dereferences a pointer before it goes to look at that objects fields, function etc. whereas "." doesn\'t dereference first. Use "->" when you have a pointer to an object, and use "." when you\'re working with the actual instance of an object.Another equivalent way of wrinting this might be to use the dereferencing "*" on the pointer first and then just use the ".". We skip middleman by using "->".There are other differences, but the other answers have covered this extensively.If you have a background in Java this might confuse you, since, in Java, everything is pointers. This means that there\'s no reason to have symbol that doesn\'t dereference your pointer first. In c++ however you gotta be a little more careful with remembering what is and what isn\'t a pointer, and it might be a good idea to label them with the prefix "p_" or simply "p".The -> operator is used when we are working with a pointer and the dot is used otherwise. \nSo if we have a struct class like:and we have an instance of a class* curr_class (class pointer),  then to get access to number of students we would do In case we had a simple class object , say class_2016, we would do For the pointer to class the -> operator is equivalent to Note: For a class, the way to access member functions of the class will also be the same wayIt\'s simple, whenever you seeknow it is the same asThe . (dot) operator is usually used to get a field / call a method from an instance of class (or a static field / method of a class).p.myField, p.myMethod() - p instance of a classThe -> (arrow) operator is used to get a field / call a method from the content pointed by the class.p->myField, p->myMethod() - p points to a class