Under what scenarios would one want to use instead of The only scenario that I can think of is if you need the task to be able to track it\'s progress. Additionally, in the following method, are the async and await keywords unnecessary?1) Normally, you would want to return a Task. The main exception should be when you need to have a void return type (for events). If there\'s no reason to disallow having the caller await your task, why disallow it?2) async methods that return void are special in another aspect: they represent top-level async operations, and have additional rules that come into play when your task returns an exception. The easiest way is to show the difference is with an example:f\'s exception is always "observed". An exception that leaves a top-level asynchronous method is simply treated like any other unhandled exception. g\'s exception is never observed. When the garbage collector comes to clean up the task, it sees that the task resulted in an exception, and nobody handled the exception. When that happens, the TaskScheduler.UnobservedTaskException handler runs. You should never let this happen. To use your example,Yes, use async and await here, they make sure your method still works correctly if an exception is thrown.for more information see: http://msdn.microsoft.com/en-us/magazine/jj991977.aspxI have come across this very usefull article about async and void written by J\xc3\xa9r\xc3\xb4me Laban:\nhttp://www.jaylee.org/post/2012/07/08/c-sharp-async-tips-and-tricks-part-2-async-void.aspxThe bottom line is that an async+void can crash the system and usually should be used only on the UI side event handlers.The reason behind this is the Synchronization Context used by the\n  AsyncVoidMethodBuilder, being none in this example. When there is no\n  ambient Synchronization Context, any exception that is unhandled by\n  the body of an async void method is rethrown on the ThreadPool. While\n  there is seemingly no other logical place where that kind of unhandled\n  exception could be thrown, the unfortunate effect is that the process\n  is being terminated, because unhandled exceptions on the ThreadPool\n  effectively terminate the process since .NET 2.0. You may intercept\n  all unhandled exception using the AppDomain.UnhandledException event,\n  but there is no way to recover the process from this event.When writing UI event handlers, async void methods are somehow\n  painless because exceptions are treated the same way found in\n  non-async methods; they are thrown on the Dispatcher. There is a\n  possibility to recover from such exceptions, with is more than correct\n  for most cases. Outside of UI event handlers however, async void\n  methods are somehow dangerous to use and may not that easy to find.I got clear idea from this statements.Exceptions from an Async Void Method Can\xe2\x80\x99t Be Caught with CatchThese exceptions can be observed using AppDomain.UnhandledException or a similar catch-all event for GUI/ASP.NET applications, but using those events for regular exception handling is a recipe for unmaintainability(it crashes the application).Async void methods have different composing semantics. Async methods returning Task or Task can be easily composed using await, Task.WhenAny, Task.WhenAll and so on. Async methods returning void don\xe2\x80\x99t provide an easy way to notify the calling code that they\xe2\x80\x99ve completed. It\xe2\x80\x99s easy to start several async void methods, but it\xe2\x80\x99s not easy to determine when they\xe2\x80\x99ve finished. Async void methods will notify their SynchronizationContext when they start and finish, but a custom SynchronizationContext is a complex solution for regular application code.Async Void method useful when using synchronous event handler because they raise their exceptions directly on the SynchronizationContext, which is similar to how synchronous event handlers behaveFor more details check this link\nhttps://msdn.microsoft.com/en-us/magazine/jj991977.aspx