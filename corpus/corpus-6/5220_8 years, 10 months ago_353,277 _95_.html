I have seen many programs consisting of structures like the one belowWhy is it needed so often? Any specific reason or applicable area?As Greg Hewgill said, the typedef means you no longer have to write struct all over the place. That not only saves keystrokes, it also can make the code cleaner since it provides a smidgen more abstraction.Stuff likebecomes cleaner when you don\'t need to see the "struct" keyword all over the place, it looks more as if there really is a type called "Point" in your language. Which, after the typedef, is the case I guess.Also note that while your example (and mine) omitted naming the struct  itself, actually naming it is also useful for when you want to provide an opaque type. Then you\'d have code like this in the header, for instance:and then provide the struct declaration in the implementation file:In this latter case, you cannot return the Point by value, since its declaration is hidden from users of the header file. This is a technique used widely in GTK+, for instance.UPDATE Note that there are also highly-regarded C projects where this use of typedef to hide struct is considered a bad idea, the Linux kernel is probably the most well-known such project. See Chapter 5 of The Linux Kernel CodingStyle document for Linus\' angry words. :) My point is that the "should" in the question is perhaps not set in stone, after all.It\'s amazing how many people get this wrong. PLEASE don\'t typedef structs in C, it needlessly pollutes the global namespace which is typically very polluted already in large C programs.Also, typedef\'d structs without a tag name are a major cause of needless imposition of ordering relationships among header files.Consider:With such a definition, not using typedefs, it is possible for a compiland unit to include foo.h to get at the FOO_DEF definition.  If it doesn\'t attempt to dereference  the \'bar\' member of the foo struct then there will be no need to include the "bar.h" file.Also, since the namespaces are different between the tag names and the member names, it is possible to write very readable code such as:Since the namespaces are separate, there is no conflict in naming variables coincident with their struct tag name.If I have to maintain your code, I will remove your typedef\'d structs.From an old article by Dan Saks (http://www.ddj.com/cpp/184403396?pgno=3):The C language rules for naming\n  structs are a little eccentric, but\n  they\'re pretty harmless. However, when\n  extended to classes in C++, those same\n  rules open little cracks for bugs to\n  crawl through.In C, the name s appearing inis a tag. A tag name is not a type\n  name. Given the definition above,\n  declarations such asare errors in C. You must write them\n  asThe names of unions and enumerations\n  are also tags rather than types.In C, tags are distinct from all other\n  names (for functions, types,\n  variables, and enumeration constants).\n  C compilers maintain tags in a symbol\n  table that\'s conceptually if not\n  physically separate from the table\n  that holds all other names. Thus, it\n  is possible for a C program to have\n  both a tag and an another name with\n  the same spelling in the same scope.\n  For example,is a valid declaration which declares\n  variable s of type struct s. It may\n  not be good practice, but C compilers\n  must accept it. I have never seen a\n  rationale for why C was designed this\n  way. I have always thought it was a\n  mistake, but there it is.Many programmers (including yours\n  truly) prefer to think of struct names\n  as type names, so they define an alias\n  for the tag using a typedef. For\n  example, defininglets you use S in place of struct s,\n  as inA program cannot use S as the name of\n  both a type and a variable (or\n  function or enumeration constant):This is good.The tag name in a struct, union, or\n  enum definition is optional. Many\n  programmers fold the struct definition\n  into the typedef and dispense with the\n  tag altogether, as in:The linked article also has a discussion about how the C++ behavior of not requireing a typedef can cause subtle name hiding problems.  To prevent these problems, it\'s a good idea to typedef your classes and structs in C++, too, even though at first glance it appears to be unnecessary.  In C++, with the typedef the name hiding become an error that the compiler tells you about rather than a hidden source of potential problems.Using a typedef avoids having to write struct every time you declare a variable of that type:One other good reason to always typedef enums and structs results from this problem:Notice the typo in EnumDef in the struct (EnuumDef)? This compiles without error (or warning) and is (depending on the literal interpretation of the C Standard) correct. The problem is that I just created an new (empty) enumeration definition within my struct. I am not (as intended) using the previous definition EnumDef.With a typdef similar kind of typos would have resulted in a compiler errors for using an unknown type:I would advocate ALWAYS typedef\'ing structs and enumerations. Not only to save some typing (no pun intended ;)), but because it is safer.Linux kernel coding style Chapter 5 gives great pros and cons (mostly cons) of using typedef.Please don\'t use things like "vps_t".It\'s a mistake to use typedef for structures and pointers. When you see ain the source, what does it mean?In contrast, if it saysyou can actually tell what "a" is.Lots of people think that typedefs "help readability". Not so. They are useful only for:(a) totally opaque objects (where the typedef is actively used to hide what the object is).Example: "pte_t" etc. opaque objects that you can only access using the proper accessor functions.NOTE! Opaqueness and "accessor functions" are not good in themselves. The reason we have them for things like pte_t etc. is that there really is absolutely zero portably accessible information there.(b) Clear integer types, where the abstraction helps avoid confusion whether it is "int" or "long".u8/u16/u32 are perfectly fine typedefs, although they fit into category (d) better than here.NOTE! Again - there needs to be a reason for this. If something is "unsigned long", then there\'s no reason to dobut if there is a clear reason for why it under certain circumstances might be an "unsigned int" and under other configurations might be "unsigned long", then by all means go ahead and use a typedef.(c) when you use sparse to literally create a new type for type-checking.(d) New types which are identical to standard C99 types, in certain exceptional circumstances.Although it would only take a short amount of time for the eyes and brain to become accustomed to the standard types like \'uint32_t\', some people object to their use anyway.Therefore, the Linux-specific \'u8/u16/u32/u64\' types and their signed equivalents which are identical to standard types are permitted -- although they are not mandatory in new code of your own.When editing existing code which already uses one or the other set of types, you should conform to the existing choices in that code.(e) Types safe for use in userspace.In certain structures which are visible to userspace, we cannot require C99 types and cannot use the \'u32\' form above. Thus, we use __u32 and similar types in all structures which are shared with userspace.Maybe there are other cases too, but the rule should basically be to NEVER EVER use a typedef unless you can clearly match one of those rules.In general, a pointer, or a struct that has elements that can reasonably be directly accessed should never be a typedef.I don\'t think forward declarations are even possible with typedef. Use of struct, enum and union allows for forward declarations when dependencies (knows about) is bidirectional.Style:\nUse of typedef in C++ makes quite a bit of sense. It can almost be necessary when dealing with templates that require multiple and/or variable parameters. The typedef helps keep the naming straight.Not so in the C programming language. The use of typedef most often serves no purpose but to obfuscate the data structure usage. Since only { struct (6), enum (4), union (5) } number of keystrokes are used to declare a data type there is almost no use for the aliasing of the struct. Is that data type a union or a struct? Using the straight forward non-typdefed declaration lets you know right away what type it is. Notice how Linux is written with strict avoidance of this aliasing nonsense typedef brings. The result is a minimalist and clean style.It turns out that there are prons and cons.  A useful source of information is the seminal book "Expert C Programming" (Chapter 3). Briefly, in C you have multiple namespaces: tags, types, member names and identifiers. typedef introduces an alias for a type and locates it in the tag namespace. Namely,defines two things. One Tag in the tag namespace and one Type in the type namespace. So you can do both Type myType and struct Tag myTagType. Declarations like struct Type myType or Tag myTagType are illegal. In addition, in a declaration like this:we define a pointer to our Type. So if we declare:then var1,var2 and myTagType1 are pointers to Type but myTagType2 not.In the above mentioned book it mentions that typedefing structs is not very useful as it only saves the programmer from writing the word struct. However, I have an objection, like many other C programmers. Although it sometimes turns to obfuscate some names (that\'s why it is not advisable in large code bases like the kernel) when you want to implement polymorphism in C it helps a lot look here for details. Example:you can do:So you can access an outer member (flags) by the inner struct (MyPipe) through casting. For me it is less confusing to cast the whole type than doing (struct MyWriter_ *) s; every time you want to perform such functionality. In these cases brief referencing is a big deal especially if you heavily employ the technique in your code.Finally, a last aspect with typedefed types is the inability to extend them, in contrast to macros. If for example you have: you can then declareWe do not really care for this for structs because it does not apply for storage specifiers (volatile and const).the name you (optionally) give the struct is called the tag name and, as has been noted, is not a type in itself. To get to the type requires the struct prefix.GTK+ aside, I\'m not sure the tagname is used anything like as commonly as a typedef to the struct type, so in C++ that is recognised and you can omit the struct keyword and use the tagname as the type name too:typedef will not provide a co-dependent set of data structures. This you cannot do with typdef:Of course you can always add:What exactly is the point of that?In \'C\' programming language the  keyword \'typedef\' is used to declare a new name for some object(struct,array,function..enum type).For example I will use a \'struct-s\'.\nIn \'C\' we often declare a \'struct\' outside of the \'main\' function.For example:Each time I decide to use a struct type I will need this keyword \'struct \'something\' \'name\'.\'typedef\' will simply rename that type and i can use that new name in my program every time I want.So our code will be:If you have some local object(struct,array,valuable) that will be used in your entire program you can simply give it a name using a \'typedef\'. Turns out in C99 typedef is required. It is outdated, but a lot of tools (ala HackRank) use c99 as its pure C implementation. And typedef is required there.I\'m not saying they should change (maybe have two C options) if the requirement changed, those of us studing for interviews on the site would be SOL. A>\na typdef aids in the meaning and documentation of a program by allowing creation of more meaningful synonyms for data types. In addition, they help parameterize a program against portability problems (K&R, pg147, C prog lang).B>\na structure defines a type. Structs allows convenient grouping of a collection of vars for convenience of handling (K&R, pg127, C prog lang.) as a single unitC>\ntypedef\'ing a struct is explained in A above.D> To me, structs are custom types or containers or collections or namespaces or complex types, whereas a typdef is just a means to create more nicknames. At all, in C language, struct/union/enum are macro instruction processed by the C language preprocessor (do not mistake with the preprocessor that treat "#include" and other)so :struct b is expended as something like this :and so, at compile time it evolve on stack as something like:\nb:\nint ai\nint i\nint jthat also why it\'s dificult to have selfreferent structs, C preprocessor round in a d\xc3\xa9claration loop that can\'t terminate.typedef are type specifier, that means only C compiler process it and it can do like he want for optimise assembler code implementation. It also dont expend member of type par stupidly like pr\xc3\xa9processor do with structs but use more complex reference construction algorithm, so construction like :is permited and fully functional. This implementation give also access to compilator type conversion and remove some bugging effects when execution thread leave the application field of initialisation functions. This mean that in C typedefs are more near as C++ class than lonely structs.