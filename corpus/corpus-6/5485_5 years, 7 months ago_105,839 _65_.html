I have XML documents that I need to parse and/or I need to build XML documents and write them to text (either files or memory). Since the C++ standard library does not have a library for this, what should I use?Note: This is intended to be a definitive, C++-FAQ-style question for this. So yes, it is a duplicate of others. I did not simply appropriate those other questions because they tended to ask for something slightly more specific. This question is more generic.Just like with standard library containers, what library you should use depends on your needs. Here\'s a convenient flowchart:So the first question is this: What do you need?OK, so you need to process XML. Not toy XML, real XML. You need to be able to read and write all of the XML specification, not just the low-lying, easy-to-parse bits. You need Namespaces, DocTypes, entity substitution, the works. The W3C XML Specification, in its entirety.The next question is: Does your API need to conform to DOM or SAX?OK, so you really need the API to be DOM and/or SAX. It can\'t just be a SAX-style push parser, or a DOM-style retained parser. It must be the actual DOM or the actual SAX, to the extent that C++ allows.You have chosen:XercesThat\'s your choice. It\'s pretty much the only C++ XML parser/writer that has full (or as near as C++ allows) DOM and SAX conformance. It also has XInclude support, XML Schema support, and a plethora of other features.It has no real dependencies. It uses the Apache license.You have chosen:LibXML2LibXML2 offers a C-style interface (if that really bothers you, go use Xerces), though the interface is at least somewhat object-based and easily wrapped. It provides a lot of features, like XInclude support (with callbacks so that you can tell it where it gets the file from), an XPath 1.0 recognizer, RelaxNG and Schematron support (though the error messages leave a lot to be desired), and so forth.It does have a dependency on iconv, but it can be configured without that dependency. Though that does mean that you\'ll have a more limited set of possible text encodings it can parse.It uses the MIT license.OK, so full XML compliance doesn\'t matter to you. Your XML documents are either fully under your control or are guaranteed to use the "basic subset" of XML: no namespaces, entities, etc.So what does matter to you? The next question is: What is the most important thing to you in your XML work?Your application needs to take XML and turn it into C++ datastructures as fast as this conversion can possibly happen. You have chosen:RapidXMLThis XML parser is exactly what it says on the tin: rapid XML. It doesn\'t even deal with pulling the file into memory; how that happens is up to you. What it does deal with is parsing that into a series of C++ data structures that you can access. And it does this about as fast as it takes to scan the file byte by byte.Of course, there\'s no such thing as a free lunch. Like most XML parsers that don\'t care about the XML specification, Rapid XML doesn\'t touch namespaces, DocTypes, entities (with the exception of character entities and the 6 basic XML ones), and so forth. So basically nodes, elements, attributes, and such.Also, it is a DOM-style parser. So it does require that you read all of the text in. However, what it doesn\'t do is copy any of that text (usually). The way RapidXML gets most of its speed is by refering to strings in-place. This requires more memory management on your part (you must keep that string alive while RapidXML is looking at it).RapidXML\'s DOM is bare-bones. You can get string values for things. You can search for attributes by name. That\'s about it. There are no convenience functions to turn attributes into other values (numbers, dates, etc). You just get strings.One other downside with RapidXML is that it is painful for writing XML. It requires you to do a lot of explicit memory allocation of string names in order to build its DOM. It does provide a kind of string buffer, but that still requires a lot of explicit work on your end. It\'s certainly functional, but it\'s a pain to use.It uses the MIT licence. It is a header-only library with no dependencies.Yes, performance matters to you. But maybe you need something a bit less bare-bones. Maybe something that can handle more Unicode, or doesn\'t require so much user-controlled memory management. Performance is still important, but you want something a little less direct.You have chosen:PugiXMLHistorically, this served as inspiration for RapidXML. But the two projects have diverged, with Pugi offering more features, while RapidXML is focused entirely on speed.PugiXML offers Unicode conversion support, so if you have some UTF-16 docs around and want to read them as UTF-8, Pugi will provide. It even has an XPath 1.0 implementation, if you need that sort of thing.But Pugi is still quite fast. Like RapidXML, it has no dependencies and is distributed under the MIT License.You need to read documents that are measured in the gigabytes in size. Maybe you\'re getting them from stdin, being fed by some other process. Or you\'re reading them from massive files. Or whatever. The point is, what you need is to not have to read the entire file into memory all at once in order to process it.You have chosen:LibXML2Xerces\'s SAX-style API will work in this capacity, but LibXML2 is here because it\'s a bit easier to work with. A SAX-style API is a push-API: it starts parsing a stream and just fires off events that you have to catch. You are forced to manage context, state, and so forth. Code that reads a SAX-style API is a lot more spread out than one might hope.LibXML2\'s xmlReader object is a pull-API. You ask to go to the next XML node or element; you aren\'t told. This allows you to store context as you see fit, to handle different entities in a way that\'s much more readable in code than a bunch of callbacks.ExpatExpat is a well-known C++ parser that uses a pull-parser API. It was written by James Clark.It\'s current status is... not active. The most recent version is 2.1.0, which was released 3 years ago. That doesn\'t mean it can\'t be useful. But it does mean that, if there are bugs in it, you will have to fix them.You can still use it. Just be aware of what you\'re getting.LlamaXMLIt is an implementation of an StAX-style API. It is a pull-parser, similar to LibXML2\'s xmlReader parser.But it hasn\'t been updated since 2005. So again, Caveat Emptor.XPath is a system for querying elements within an XML tree. It\'s a handy way of effectively naming an element or collection of element by common properties, using a standardized syntax. Many XML libraries offer XPath support.There are effectively three choices here:So, you don\'t care about XML correctness. Performance isn\'t an issue for you. Streaming is irrelevant. All you want is something that gets XML into memory and allows you to stick it back onto disk again. What you care about is API.You want an XML parser that\'s going to be small, easy to install, trivial to use, and small enough to be irrelevant to your eventual executable\'s size.You have chosen:TinyXMLI put TinyXML in this slot because it is about as braindead simple to use as XML parsers get. Yes, it\'s slow, but it\'s simple and obvious. It has a lot of convenience functions for converting attributes and so forth.Writing XML is no problem in TinyXML. You just new up some objects, attach them together, send the document to a std::ostream, and everyone\'s happy.There is also something of an ecosystem built around TinyXML, with a more iterator-friendly API, and even an XPath 1.0 implementation layered on top of it.TinyXML uses the zLib license, which is more or less the MIT License with a different name.There is another approach to handling XML that you may want to consider, called XML\ndata binding. Especially if you already have a formal specification of your XML vocabulary, for example, in XML Schema. XML data binding allows you to use XML without actually doing any XML parsing or serialization. A data binding compiler auto-generates all the low-level code and presents the parsed data as C++ classes that correspond to your application domain. You then work with this data by calling functions, and working with C++ types (int, double, etc) instead of comparing strings and parsing text (which is what you do with low-level XML access APIs such as DOM or SAX).See, for example, an open-source XML data binding implementation that I wrote, \nCodeSynthesis XSD and, for a\nlighter-weight, dependency-free version, CodeSynthesis\nXSD/e.Put mine as well.http://www.codeproject.com/Articles/998388/XMLplusplus-version-The-Cplusplus-update-of-my-XMLNo XML validation features, but fast.In Secured Globe, Inc. we use rapidxml. We tried all the others but rapidxml seems to be the best choice for us. Here is an example:One other note about Expat: it\'s worth looking at for embedded systems work.  However, the documentation you are likely to find on the web is ancient and wrong.  The source code actually has fairly thorough function-level comments, but it will take some perusing for them to make sense.