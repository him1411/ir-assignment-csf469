If I call a command using Kernel#system in Ruby, how do I get its output?I\'d like to expand & clarify chaos\'s answer a bit.If you surround your command with backticks, then you don\'t need to (explicitly) call system() at all. The backticks execute the command and return the output as a string. You can then assign the value to a variable like so:orBe aware that all the solutions where you pass a string containing user provided values to system, %x[] etc. are unsafe! Unsafe actually means: the user may trigger code to run in the context and with all permissions of the program.As far as I can say only system and Open3.popen3 do provide a secure/escaping variant in Ruby 1.8. In Ruby 1.9 IO::popen also accepts an array.Simply pass every option and argument as an array to one of these calls.If you need not just the exit status but also the result you probably want to use Open3.popen3:Note that the block form will auto-close stdin, stdout and stderr- otherwise they\'d have to be closed explicitly.More information here: Forming sanitary shell commands or system calls in RubyJust for the record, if you want both (output and operation result) you can do:You can use system() or %x[] depending what kind of result you need.system() returning true if the command was found and ran successfully, false otherwise.%x[..] on the other hand saves the results of the command as a string:Th blog post by Jay Fields explains in detail the differences between using system, exec and %x[..] .The straightforward way to do this correctly and securely is to use Open3.capture2(), Open3.capture2e(), or Open3.capture3().Using ruby\'s backticks and its %x alias are NOT SECURE UNDER ANY CIRCUMSTANCES if used with untrusted data. It is DANGEROUS, plain and simple:The system function, in contrast, escapes arguments properly if used correctly:Trouble is, it returns the exit code instead of the output, and capturing the latter is convoluted and messy.The best answer in this thread so far mentions Open3, but not the functions that are best suited for the task. Open3.capture2, capture2e and capture3 work like system, but returns two or three arguments:Another mentions IO.popen(). The syntax can be clumsy in the sense that it wants an array as input, but it works too:For convenience, you can wrap Open3.capture3() in a function, e.g.:Example:Yields the following:You use backticks:Another way is:Note that\'s the "pipe" character before "ls" in open. This can also be used to feed data into the programs standard input as well as reading its standard output.If you need to escape the arguments, in Ruby 1.9 IO.popen also accepts an array:In earlier versions you can use Open3.popen3:If you also need to pass stdin, this should work in both 1.9 and 1.8:I found that the following is useful if you need the return value:I specifically wanted to list the pids of all the Java processes on my machine, and used this:As Simon H\xc3\xbcrlimann already explained, Open3 is safer than backticks etc. Note that the block form will auto-close stdin, stdout and stderr- otherwise they\'d have to be closed explicitly.As a direct system(...) replacement you may use Open3.popen3(...)Further discussion:\nhttp://tech.natemurray.com/2007/03/ruby-shell-commands.htmlWhile using backticks or popen is often what you really want, it doesn\'t actually answer the question asked. There may be valid reasons for capturing system output (maybe for automated testing). A little Googling turned up an answer I thought I would post here for the benefit of others. Since I needed this for testing my example uses a block setup to capture the standard output since the actual system call is buried in the code being tested:So this gives us a method that will capture any output in the given block using a tempfile to store the actual data. Example usage:Of course you can replace the system call with anything that might internally call system. You could also use the same method for capturing stderr if you wanted.If you want the output redirected to a file using Kernel#system, you can do modify descriptors like this:redirect stdout and stderr to a file(/tmp/log) in append mode:\nsystem(\'ls -al\', :out => [\'/tmp/log\', \'a\'], :err => [\'/tmp/log\', \'a\'])\nFor a long running command, this will store the output in real time. You can also, store the output using a IO.pipe and redirect it from Kernel#system.I didn\'t find this one here so adding it, I had some issues getting the full output. You can redirect STDERR to STDOUT if you want to capture STDERR using\n  backtick.output = `grep hosts /private/etc/* 2>&1`source: http://blog.bigbinary.com/2012/10/18/backtick-system-exec-in-ruby.html