I want to read a file and save it in variable, but I need to keep the variable and not just print out the file.\nHow can I do this? I have written this script but it isn\'t quite what I needed:In my script, I can give the file name as a parameter, so, if the file contains "aaaa", for example, it would print out this:But this just prints out the file onto the screen, and I want to save it into a variable!\nIs there an easy way to do this?In cross-platform, lowest-common-denominator sh you use:In bash or zsh, to read a whole file into a variable without invoking cat:Invoking cat in bash or zsh to slurp a file would be considered a Useless Use of Cat.Note that it is not necessary to quote the command substitution to preserve newlines.See: Bash Hacker\'s Wiki - Command substitution - Specialities.If you want to read the whole file into a variable:If you want to read it line-by-line:Two important pitfallswhich were ignored by other answers so far:Trailing newline removal from command expansionThis is a problem for the:type solutions, but not for read based solutions.Command expansion removes trailing newlines:Outputs:This breaks the naive method of reading from files:POSIX workaround: append an extra char to the command expansion and remove it later:Outputs:Almost POSIX workaround: ASCII encode. See below.NUL character removalThere is no sane Bash way to store NUL characters in variables.This affects both expansion and read solutions, and I don\'t know any good workaround for it.Example:Outputs:Ha, our NUL is gone!Workarounds:ASCII encode. See below.use bash extension $"" literals:Only works for literals, so not useful for reading from files.Workaround for the pitfallsStore an uuencode base64 encoded version of the file in the variable, and decode before every usage:Output:uuencode and udecode are POSIX 7 but not in Ubuntu 12.04 by default (sharutils package)... I don\'t see a POSIX 7 alternative for the bash process <() substitution extension except writing to another file...Of course, this is slow and inconvenient, so I guess the real answer is: don\'t use Bash if the input file may contain NUL characters.