Can someone explain to me in detail when I must use each attribute: nonatomic, copy, strong, weak, and so on, for a declared property, and explain what each does? Some sort of example would be great also. I am using ARC.Nonatomicnonatomic is used for multi threading purposes. If we have set the nonatomic attribute at the time of declaration, then any other thread wanting access to that object can access it and give results in respect to multi-threading.   Copycopy is required when the object is mutable. Use this if you need the value of the object as it is at this moment, and you don\'t want that value to reflect any changes made by other owners of the object. You will need to release the object when you are finished with it because you are retaining the copy.AssignAssign is somewhat the opposite to copy. When calling the getter of an assign property, it returns a reference to the actual data. Typically you use this attribute when you have a property of primitive type (float, int, BOOL...)Retainretain is required when the attribute is a pointer to an object. The setter generated by @synthesize will retain (aka add a retain count to) the object. You will need to release the object when you are finished with it. By using retain it will increase the retain count and occupy memory in autorelease pool.Strongstrong is a replacement for the retain attribute, as part of Objective-C Automated Reference Counting (ARC). In non-ARC code it\'s just a synonym for retain. This is a good website to learn about strong and weak for iOS 5.\nhttp://www.raywenderlich.com/5677/beginning-arc-in-ios-5-part-1Weakweak is similar to strong except that it won\'t increase the reference count by 1. It does not become an owner of that object but just holds a reference to it. If the object\'s reference count drops to 0, even though you may still be pointing to it here, it will be deallocated from memory.The above link contain both Good information regarding Weak and Strong.nonatomic property states that the object is not thread safe which means if a different thread tries to access this object than bad things can happen but this is much faster than atomic property.strong is used with ARC and it basically helps you , by not having to worry about the retain count of an object. ARC automatically releases it for you when you are done with it.Using the keyword strong means that you own the object.weak ownership means that you don\'t own it and it just keeps track of the object till the object it was assigned to stays , as soon as the second object is released it loses is value. For eg. obj.a=objectB; is used and a has weak property , than its value will only be valid till objectB remains in memory.copy property is very well explained here strong,weak,retain,copy,assign are mutually exclusive so you can\'t use them on one single object... read the "Declared Properties " section hoping this helps you out a bit... This link has the break downhttp://clang.llvm.org/docs/AutomaticReferenceCounting.html#ownership.spelling.propertyassign implies __unsafe_unretained ownership.copy implies __strong ownership, as well as the usual behavior of copy\n  semantics on the setter.retain implies __strong ownership.strong implies __strong ownership.unsafe_unretained implies __unsafe_unretained ownership.weak implies __weak ownership.Great answers!\nOne thing that I would like to clarify deeper is nonatomic/atomic.\nThe user should understand that this property - "atomicity" spreads only on the attribute\'s reference and not on it\'s contents.\nI.e. atomic will guarantee the user atomicity for reading/setting the pointer and only the pointer to the attribute.\nFor example:In this case it is guaranteed that the pointer to the dict will be read/set in the atomic manner by different threads.\nBUT the dict itself (the dictionary dict pointing to) is still thread unsafe, i.e. all read/add operations to the dictionary are still thread unsafe.If you need thread safe collection you either have bad architecture (more often) OR real requirement (more rare).\nIf it is "real requirement" - you should either find good&tested thread safe collection component OR be prepared for trials and tribulations writing your own one.\nIt latter case look at "lock-free", "wait-free" paradigms. Looks like rocket-science at a first glance, but could help you achieving fantastic performance in comparison to "usual locking".