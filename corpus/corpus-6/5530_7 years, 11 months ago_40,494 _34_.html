In C programming, you can pass any kind of pointer you like as an argument to free, how does it know the size of the allocated memory to free? Whenever I pass a pointer to some function, I have to also pass the size (ie an array of 10 elements needs to receive 10 as a parameter to know the size of the array), but I do not have to pass the size to the free function. Why not, and can I use this same technique in my own functions to save me from needing to cart around the extra variable of the array\'s length?When you call malloc(), you specify the amount of memory to allocate. The amount of memory actually used is slightly more than this, and includes extra information that records (at least) how big the block is. You can\'t (reliably) access that other information - and nor should you :-).When you call free(), it simply looks at the extra information to find out how big the block is.Most implementations of C memory allocation functions will store accounting information for each block, either in-line or separately.One typical way (in-line) is to actually allocate both a header and the memory you asked for, padded out to some minimum size. So for example, if you asked for 20 bytes, the system may allocate a 48-byte block:The address then given to you is the address of the data area.  Then, when you free the block, free will simply take the address you give it and, assuming you haven\'t stuffed up that address or the memory around it, check the accounting information immediately before it. Graphically, that would be along the lines of:Keep in mind the size of the header and the padding are totally implementation defined (actually, the entire thing is implementation-defined (a) but the in-line accounting option is a common one).The checksums and special markers that exist in the accounting information are often the cause of errors like "Memory arena corrupted" or "Double free" if you overwrite them or free them twice.The padding (to make allocation more efficient) is why you can sometimes write a little bit beyond the end of your requested space without causing problems (still, don\'t do that, it\'s undefined behaviour and, just because it works sometimes, doesn\'t mean it\'s okay to do it).(a) I\'ve written implementations of malloc in embedded systems where you got 128 bytes no matter what you asked for (that was the size of the largest structure in the system), assuming you asked for 128 bytes or less (requests for more would be met with a NULL return value). A very simple bit-mask (i.e., not in-line) was used to decide whether a 128-byte chunk was allocated or not.Others I\'ve developed had different pools for 16-byte chunks, 64-bytes chunks, 256-byte chunks and 1K chunks, again using a bit-mask to decide what blocks were used or available.Both these options managed to reduce the overhead of the accounting information and to increase the speed of malloc and free (no need to coalesce adjacent blocks when freeing), particularly important in the environment we were working in.From the comp.lang.c FAQ list: How does free know how many bytes to free?The malloc/free implementation remembers the size of each block as it is allocated, so it is not necessary to remind it of the size when freeing. (Typically, the size is stored adjacent to the allocated block, which is why things usually break badly if the bounds of the allocated block are even slightly overstepped)This answer is relocated from How does free() know how much memory to deallocate? where I was abrubtly prevented from answering by an apparent duplicate question. This answer then should be relevant to this duplicate:For the case of malloc, the heap allocator stores a mapping of the original returned pointer, to relevant details needed for freeing the memory later. This typically involves storing the size of the memory region in whatever form relevant to the allocator in use, for example raw size, or a node in a binary tree used to track allocations, or a count of memory "units" in use.free will not fail if you "rename" the pointer, or duplicate it in any way. It is not however reference counted, and only the first free will be correct. Additional frees are "double free" errors.Attempting to free any pointer with a value different to those returned by previous mallocs, and as yet unfreed is an error. It is not possible to partially free memory regions returned from malloc.malloc() and free() are system/compiler dependent so it\'s hard to give a specific answer.More information on this other question.On a related note GLib library has memory allocation functions which do not save implicit size - and then you just pass the size parameter to free. This can eliminate part of the overhead.The heap manager stored the amount of memory belonging to the allocated block somewhere when you called malloc.I never implemented one myself, but I guess the memory right in front of the allocated block might contain the meta information.To answer the second half of your question: yes, you can, and a fairly common pattern in C is the following:The original technique was to allocate a slightly larger block and store the size at the beginning, then give the application the rest of the blog. The extra space holds a size and possibly links to thread the free blocks together for reuse.There are certain issues with those tricks, however, such as poor cache and memory management behavior. Using memory right in the block tends to page things in unnecessarily and it also creates dirty pages which complicate sharing and copy-on-write.So a more advanced technique is to keep a separate directory. Exotic approaches have also been developed where areas of memory use the same power-of-two sizes.In general, the answer is: a separate data structure is allocated to keep state.memory allocated using malloc() or calloc() or realloc().void free(void *ptr);the free function does not accept size as a parameter. How does free() function know how much memory to free given just a pointer?Following is the most common way to store size of memory so that free() knows the size of memory to be deallocated.When memory allocation is done, the actual heap space allocated is one word larger than the requested memory. The extra word is used to store the size of the allocation and is later used by free( )When we call malloc it\'s simply consume more byte from it\'s requirement. This more byte consumption contain information like check sum,size and other additional information.\nWhen we call free at that time it directly go to that additional information where it\'s find the address and also  find how much block will be free.