How far do you go with const?  Do you just make functions const when necessary or do you go the whole hog and use it everywhere?  For example, imagine a simple mutator that takes a single boolean parameter:Is that const actually useful?  Personally I opt to use it extensively, including parameters, but in this case I wonder if it\'s worthwhile?I was also surprised to learn that you can omit const from parameters in a function declaration but can include it in the function definition, e.g.:.h file.cpp fileIs there a reason for this? It seems a little unusual to me.The reason is that const for the parameter only applies locally within the function, since it is working on a copy of the data. This means the function signature is really the same anyways. It\'s probably bad style to do this a lot though.I personally tend to not use const except for reference and pointer parameters. For copied objects it doesn\'t really matter, although it can be safer as it signals intent within the function. It\'s really a judgement call. I do tend to use const_iterator though when looping on something and I don\'t intend on modifying it, so I guess to each his own, as long as const correctness for reference types is rigorously maintained."const is pointless when the argument is passed by value since you will not be modifying the caller\'s object."Wrong. It\'s about self-documenting your code and your assumptions.If your code has many people working on it and your functions are non-trivial then you should mark "const" any and everything that you can. When writing industrial-strength code, you should always assume that your coworkers are psychopaths trying to get you any way they can (especially since it\'s often yourself in the future).Besides, as somebody mentioned earlier, it might help the compiler optimize things a bit  (though it\'s a long shot).Sometimes (too often!) I have to untangle someone else\'s C++ code. And we all know that someone else\'s C++ code is a complete mess almost by definition :) So the first thing I do to decipher local data flow is put const in every variable definition until compiler starts barking. This means const-qualifying value arguments as well, because they are just fancy local variables initialized by caller.Ah, I wish variables were const by default and mutable was required for non-const variables :)The following two lines are functionally equivalent:Obviously you won\'t be able to modify a in the body of foo if it\'s defined the second way, but there\'s no difference from the outside.Where const really comes in handy is with reference or pointer parameters:What this says is that foo can take a large parameter, perhaps a data structure that\'s gigabytes in size, without copying it. Also, it says to the caller, "Foo won\'t* change the contents of that parameter." Passing a const reference also allows the compiler to make certain performance decisions.*: Unless it casts away the const-ness, but that\'s another post.Extra Superfluous const are bad from an API stand-point:Putting extra superfluous const\'s in your code for intrinsic type parameters passed by value clutters your API while making no meaningful promise to the caller or API user (it only hampers the implementation).Too many \'const\' in an API when not needed is like "crying wolf", eventually people will start ignoring \'const\' because it\'s all over the place and means nothing most of the time.The "reductio ad absurdum" argument to extra consts in API are good for these first two points would be is if more const parameters are good, then every argument that can have a const on it, SHOULD have a const on it.  In fact, if it were truly that good, you\'d want const to be the default for parameters and have a keyword like "mutable" only when you want to change the parameter.So lets try putting in const whereever we can:Consider the line of code above.  Not only is the declaration more cluttered and longer and harder to read but three of the four \'const\' keywords can be safely ignored by the API user.  However, the extra use of \'const\' has made the second line potentially DANGEROUS! Why?A quick misread of the first parameter char * const buffer might make you think that it will not modify the memory in data buffer that is passed in -- however, this is not true! Superfluous \'const\' can lead to dangerous and incorrect assumptions about your API when scanned or misread quickly.Superfluous const are bad from a Code Implementation stand-point as well:If FLEXIBLE_IMPLEMENTATION  is not true, then the API is \xe2\x80\x9cpromising\xe2\x80\x9d not to implement the function the first way below.That\xe2\x80\x99s a very silly promise to make. Why should you make a promise that gives no benefit at all to your caller and only limits your implementation?Both of these are perfectly valid implementations of the same function though so all you\xe2\x80\x99ve done is tied one hand behind your back unnecessarily.Furthermore, it\xe2\x80\x99s a very shallow promise that is easily (and legally circumvented).Look, I implemented it that way anyhow even though I promised not to \xe2\x80\x93 just using a wrapper function.  It\xe2\x80\x99s like when the bad guy promises not to kill someone in a movie and orders his henchman to kill them instead.Those superfluous const\xe2\x80\x99s are worth no more than a promise from a movie bad-guy.But the ability to lie gets even worse:I have been enlightened that you can mismatch const in header (declaration) and code (definition) by using spurious const.  The const-happy advocates claim this is a good thing since it lets you put const only in the definition.However, the converse is true... you can put a spurious const only in the declaration and ignore it in the definition.  This only makes superfluous const in an API more of a terrible thing and a horrible lie - see this example:All the superfluous const actually does is make the implementer\'s code less readable by forcing him to use another local copy or a wrapper function when he wants to change the variable or pass the variable by non-const reference.Look at this example.  Which is more readable ?  Is it obvious that the only reason for the extra variable in the second function is because some API designer threw in a superfluous const ?Hopefully we\'ve learned something here.  Superfluous const is an API-cluttering eyesore, an annoying nag, a shallow and meaningless promise, an unnecessary hindrance, and occasionally leads to very dangerous mistakes.const should have been the default in C++.\nLike this :When I coded C++ for a living I consted everything I possibly could.  Using const is a great way to help the compiler help you.  For instance, const-ing your method return values can save you from typos such as: when you meant:If foo() is defined to return a non-const reference:The compiler will happily let you assign a value to the anonymous temporary returned by the function call.  Making it const:Eliminates this possibility.There is a good discussion on this topic in the old "Guru of the Week" articles on comp.lang.c++.moderated here.The corresponding GOTW article is available on Herb Sutter\'s web site here.I use const on function parameters that are references (or pointers) which are only [in] data and will not be modified by the function. Meaning, when the purpose of using a reference is to avoid copying data and not to allow changing the passed parameter.Putting const on the boolean b parameter in your example only puts a constraint on the implementation and doesn\'t contribute for the class\'s interface (although not changing parameters is usually advised).The function signature forand is the same, which explains your .c and .hAsafIt prevents you from writing something likewhich I almost did right now, and which probably doesn\'t do what you intend.What I intended to say wasand if I had put a const in between Bar * and p, the compiler would have told me that.Ah, a tough one. On one side, a declaration is a contract and it really does not make sense to pass a const argument by value. On the other hand, if you look at the function implementation, you give the compiler more chances to optimize if you declare an argument constant.I say const your value parameters.Consider this buggy function:If the number parameter was const, the compiler would stop and warn us of the bug.const is pointless when the argument is passed by value since you will not be modifying the caller\'s object.const should be preferred when passing by reference, unless the purpose of the function is to modify the passed value.Finally, a function which does not modify current object (this) can, and probably should be declared const.  An example is below:This is a promise to not modify the object to which this call is applied. In other words, you can call:If the function was not const, this would result in a compiler warning.Marking value parameters \'const\' is definitely a subjective thing.However I actually prefer to mark value parameters const, just like in your example.The value to me is in clearly indicating that the function parameter values are never changed by the function. They will have the same value at the beginning as at the end. For me, it is part of keeping to a very functional programming sort of style.For a short function, it\'s arguably a waste of time/space to have the \'const\' there, since it\'s usually pretty obvious that the arguments aren\'t modified by the function.However for a larger function, its a form of implementation documentation, and it is enforced by the compiler.I can be sure if I make some computation with \'n\' and \'l\', I can refactor/move that computation without fear of getting a different result because I missed a place where one or both is changed.Since it is an implementation detail, you don\'t need to declare the value parameters const in the header, just like you don\'t need to declare the function parameters with the same names as the implementation uses.In the case you mention, it doesn\'t affect callers of your API, which is why it\'s not commonly done (and isn\'t necessary in the header).  It only affects the implementation of your function.It\'s not particularly a bad thing to do, but the benefits aren\'t that great given that it doesn\'t affect your API, and it adds typing, so it\'s not usually done.I do not use const for value-passed parametere. The caller does not care whether you modify the parameter or not, it\'s an implementation detail.What is really important is to mark methods as const if they do not modify their instance. Do this as you go, because otherwise you might end up with either lots of const_cast<> or you might find that marking a method const requires changing a lot of code because it calls other methods which should have been marked const.I also tend to mark local vars const if I do not need to modify them. I believe it makes the code easier to understand by making it easier to identify the "moving parts".I tend to use const wherever possible. (Or other appropriate keyword for the target language.) I do this purely because it allows the compiler to make extra optimizations that it would not be able to make otherwise. Since I have no idea what these optimizations may be, I always do it, even where it seems silly.For all I know, the compiler might very well see a const value parameter, and say, "Hey, this function isn\'t modifying it anyway, so I can pass by reference and save some clock cycles." I don\'t think it ever would do such a thing, since it changes the function signature, but it makes the point. Maybe it does some different stack manipulation or something... The point is, I don\'t know, but I do know trying to be smarter than the compiler only leads to me being shamed.C++ has some extra baggage, with the idea of const-correctness, so it becomes even more important.I use const were I can. Const for parameters means that they should not change their value. This is especially valuable when passing by reference. const for function declares that the function should not change the classes members.May be this wont be a valid argument. but if we increment the value of a const variable inside a function compiler will give us an error:\n "error: increment of read-only parameter". so that means we can use const key word as a way to prevent accidentally modifying our variables inside functions(which we are not supposed to/read-only). so if we accidentally did it at the compile time compiler will let us know that. this is specially important if you are not the only one who is working on this project.Const parameter is useful only when the parameter is passed by reference i.e., either reference or pointer. When compiler sees a const parameter, it make sure that the variable used in the parameter is not modified within the body of the function. Why would anyone want to make a by-value parameter as constant? :-)If the parameter is passed by value (and is not a reference), usually there is not much difference whether the parameter is declared as const or not (unless it contains a reference member -- not a problem for built-in types).  If the parameter is a reference or pointer, it is usually better to protect the referenced/pointed-to memory, not the pointer itself (I think you cannot make the reference itself const, not that it matters much as you cannot change the referee).\nIt seems a good idea to protect everything you can as const.  You can omit it without fear of making a mistake if the parameters are just PODs (including built-in types) and there is no chance of them changing further along the road (e.g. in your example the bool parameter).I didn\'t know about the .h/.cpp file declaration difference, but it does make some sense.  At the machine code level, nothing is "const", so if you declare a function (in the .h) as non-const, the code is the same as if you declare it as const (optimizations aside).  However, it helps you to enlist the compiler that you will not change the value of the variable inside the implementation of the function (.ccp).  It might come handy in the case when you\'re inheriting from an interface that allows change, but you don\'t need to change to parameter to achieve the required functionality.On compiler optimizations: http://www.gotw.ca/gotw/081.htmTo summarize:I wouldn\'t put const on parameters like that - everyone already knows that a boolean (as opposed to a boolean&) is constant, so adding it in will make people think "wait, what?" or even that you\'re passing the parameter by reference.the thing to remember with const is that it is much easier to make things const from the start, than it is to try and put them in later.Use const when you want something to be unchanged - its an added hint that describes what your function does and what to expect. I\'ve seen many an C API that could do with some of them, especially ones that accept c-strings!I\'d be more inclined to omit the const keyword in the cpp file than the header, but as I tend to cut+paste them, they\'d be kept in both places. I have no idea why the compiler allows that, I guess its a compiler thing. Best practice is definitely to put your const keyword in both files.There\'s really no reason to make a value-parameter "const" as the function can only modify a copy of the variable anyway.The reason to use "const" is if you\'re passing something bigger (e.g. a struct with lots of members) by reference, in which case it ensures that the function can\'t modify it; or rather, the compiler will complain if you try to modify it in the conventional way. It prevents it from being accidentally modified.As parameters are  being passed by value,it doesnt make any difference if you specify const or not from the calling function\'s perspective.It basically  does not make any sense to declare pass by value parameters as const.All the consts in your examples have no purpose.  C++ is pass-by-value by default, so the function gets copies of those ints and booleans.  Even if the function does modify them, the caller\'s copy is not affected.  So I\'d avoid extra consts because I know the question is "a bit" outdated but as I came accross it somebody else may also do so in future... ...still I doubt the poor fellow will list down here to read my comment :)It seems to me that we are still too confined to C-style way of thinking. In the OOP paradigma we play around with objects, not types. Const object may be conceptually different from a non-const object, specifically in the sense of logical-const (in contrast to bitwise-const). Thus even if const correctness of function params is (perhaps) an over-carefulness in case of PODs it is not so in case of objects. If a function works with a const object it should say so. Consider the following code snippetps.: you may argue that (const) reference would be more appropriate here and gives you the same behaviour. Well, right. Just giving a different picture from what I could see elsewhere...Being a VB.NET programmer that needs to use a C++ program with 50+ exposed functions, and a .h file that sporadically uses the const qualifier, it is difficult to know when to access a variable using ByRef or ByVal.Of course the program tells you by generating an exception error on the line where you made the mistake, but then you need to guess which of the 2-10 parameters is wrong.So now I have the distasteful task of trying to convince a developer that they should really define their variables (in the .h file) in a manner that allows an automated method of creating all of the VB.NET function definitions easily. They will then smugly say, "read the ... documentation." I have written an awk script that parses a .h file, and creates all of the Declare Function commands, but without an indicator as to which variables are R/O vs R/W, it only does half the job.EDIT:At the encouragement of another user I am adding the following;Here is an example of a (IMO) poorly formed .h entry;The resultant VB from my script;Note the missing "const" on the first parameter.  Without it, a program (or another developer) has no Idea the 1st parameter should be passed "ByVal." By adding the "const" it makes the .h file self documenting so that developers using other languages can easily write working code.