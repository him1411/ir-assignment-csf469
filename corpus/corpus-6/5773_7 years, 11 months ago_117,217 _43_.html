If I have an array like this in Bash:How do I join the elements with commas?  For example, producing a,b,c.Rewriting solution by Pascal Pilz as a function in 100% pure Bash (no external commands):For example,Alternatively, we can use printf to support multi-character delimiters, using the idea by @gniourf_gniourfFor example,Yet another solution:Edit: same but for multi-character variable length separator:Maybe, e.g.,Here\'s a 100% pure Bash function that does the job:Look:This preserves even the trailing newlines, and doesn\'t need a subshell to get the result of the function. If you don\'t like the printf -v (why wouldn\'t you like it?) and passing a variable name, you can of course use a global variable for the returned string:Surprisingly my solution is not yet given :) This is the simplest way for me. It doesn\'t need a function:With re-use of @doesn\'t matters\' solution, but with a one statement by avoiding the ${:1} substition and need of an intermediary variable.printf has \'The format string is reused as often as necessary to satisfy the arguments.\' in its man pages, so that the concatenations of the strings is documented. Then the trick is to use the LIST length to chop the last sperator, since cut will retain only the lenght of LIST as fields count.printf solution that accept separators of any length (based on @doesn\'t matters answer)I would echo the array as a string, then transform the spaces into line feeds, and then use paste to join everything in one line like so:tr " " "\\n" <<< "$FOO" | paste -sd , -Results:a,b,cThis seems to be the quickest and cleanest to me !Shorter version of top answer:Usage:Right now I\'m using:Which works, but (in the general case) will break horribly if array elements have a space in them.(For those interested, this is a wrapper script around pep8.py)Warning, it assumes elements don\'t have whitespaces.Use perl for multicharacter separators:Or in one line:This approach takes care of spaces within the values, but requires a loop:In case the elements you want to join is not an array just a space separated string, you can do something like this:foo="aa bb cc dd"\nbar=for i in $foo; do printf ",\'%s\'" $i; done\nbar=${bar:1}\necho $bar\n    \'aa\',\'bb\',\'cc\',\'dd\'for example, my use case is that some strings are passed in my shell script and I need to use this to run on a SQL query:./my_script "aa bb cc dd"In my_script, I need to do "SELECT * FROM table WHERE name IN (\'aa\',\'bb\',\'cc\',\'dd\'). Then above command will be useful.My attempt.If you build the array in a loop, here is a simple way:Perhaps I\'m missing something obvious, since I\'m a newb to the whole bash/zsh thing, but it looks to me like you don\'t need to use printf at all. Nor does it get really ugly to do without.At least, it has worked for me thus far without issue.For instance, join \\| *.sh, which, let\'s say I\'m in my ~ directory, outputs utilities.sh|play.sh|foobar.sh. Good enough for me.EDIT: This is basically Nil Geisweiller\'s answer, but generalized into a function.This takes care of the extra comma at the end also. I am no bash expert. Just my 2c, since this is more elementary and understandableor