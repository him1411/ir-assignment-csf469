We have the question is there a performance difference between i++ and ++i in C?What\'s the answer for C++?[Executive Summary: Use ++i if you don\'t have a specific reason to use i++.]For C++, the answer is a bit more complicated.If i is a simple type (not an instance of a C++ class), then the answer given for C ("No there is no performance difference") holds, since the compiler is generating the code.However, if i is an instance of a C++ class, then i++ and ++i are making calls to one of the operator++ functions. Here\'s a standard pair of these functions:Since the compiler isn\'t generating code, but just calling an operator++ function, there is no way to optimize away the tmp variable and its associated copy constructor. If the copy constructor is expensive, then this can have a significant performance impact.(Thanks to Paul for inquiring about the difference between C and C++.)Yes.  There is.The ++ operator may or may not be defined as a function.  For primitive types (int, double, ...) the operators are built in, so the compiler will probably be able to optimize your code.  But in the case of an object that defines the ++ operator things are different.The operator++(int) function must create a copy.  That is because postfix ++ is expected to return a different value than what it holds:  it must hold its value in a temp variable, increment its value and return the temp.  In the case of operator++(), prefix ++, there is no need to create a copy:  the object can increment itself and then simply return itself.Here is an illustration of the point:Every time you call operator++(int) you must create a copy, and the compiler can\'t do anything about it.  When given the choice, use operator++();  this way you don\'t save a copy.  It might be significant in the case of many increments (large loop?) and/or large objects.Here\'s a benchmark for the case when increment operators are in different translation units. Compiler with g++ 4.5.Ignore the style issues for nowResults (timings are in seconds) with g++ 4.5 on a virtual machine:Let us now take the following file:It does nothing in the incrementation. This simulates the case when incrementation has constant complexity.Results now vary extremely:If you do not need the previous value, make it a habit to use pre-increment. Be consistent even with builtin types, you\'ll get used to it and do not run risk of suffering unecessary performance loss if you ever replace a builtin type with a custom type.Premature optimization is the root of all evil. As is premature pessimization.It\'s not entirely correct to say that the compiler can\'t optimize away the temporary variable copy in the postfix case. A quick test with VC shows that it, at least, can do that in certain cases.In the following example, the code generated is identical for prefix and postfix, for instance:Whether you do ++testFoo or testFoo++, you\'ll still get the same resulting code. In fact, without reading the count in from the user, the optimizer got the whole thing down to a constant. So this:Resulted in the following:So while it\'s certainly the case that the postfix version could be slower, it may well be that the optimizer will be good enough to get rid of the temporary copy if you\'re not using it.The Google C++ Style Guide says:Preincrement and PredecrementUse prefix form (++i) of the increment and decrement operators with\n  iterators and other template objects.Definition: When a variable is incremented (++i or i++) or decremented (--i or\n  i--) and the value of the expression is not used, one must decide\n  whether to preincrement (decrement) or postincrement (decrement).Pros: When the return value is ignored, the "pre" form (++i) is never less\n  efficient than the "post" form (i++), and is often more efficient.\n  This is because post-increment (or decrement) requires a copy of i to\n  be made, which is the value of the expression. If i is an iterator or\n  other non-scalar type, copying i could be expensive. Since the two\n  types of increment behave the same when the value is ignored, why not\n  just always pre-increment?Cons: The tradition developed, in C, of using post-increment when the\n  expression value is not used, especially in for loops. Some find\n  post-increment easier to read, since the "subject" (i) precedes the\n  "verb" (++), just like in English.Decision: For simple scalar (non-object) values there is no reason to prefer one\n  form and we allow either. For iterators and other template types, use\n  pre-increment.I would like to point out an excellent post by Andrew Koenig on Code Talk very recently.http://dobbscodetalk.com/index.php?option=com_myblog&show=Efficiency-versus-intent.html&Itemid=29At our company also we use convention of ++iter for consistency and performance where applicable. But Andrew raises over-looked detail regarding intent vs performance. There are times when we want to use iter++ instead of ++iter.So, first decide your intent and if pre or post does not matter then go with pre as it will have some performance benefit by avoiding creation of extra object and throwing it.@Ketan ...raises over-looked detail regarding intent vs performance. There are times when we want to use iter++ instead of ++iter.Obviously post and pre-increment have different semantics and I\'m sure everyone agrees that when the result is used you should use the appropriate operator. I think the question is what should one do when the result is discarded (as in for loops). The answer to this question (IMHO) is that, since the performance considerations are negligible at best, you should do what is more natural. For myself ++i is more natural but my experience tells me that I\'m in a minority and using i++ will cause less metal overhead for most people reading your code. After all that\'s the reason the language is not called "++C".[*][*] Insert obligatory discussion about ++C being a more logical name. Mark: Just wanted to point out that operator++\'s are good candidates to be inlined, and if the compiler elects to do so, the redundant copy will be eliminated in most cases. (e.g. POD types, which iterators usually are.)That said, it\'s still better style to use ++iter in most cases. :-)When not using the return value the compiler is guaranteed not to use a temporary in the case of ++i. Not guaranteed to be faster, but guaranteed not to be slower.When using the return value i++ allows the processor to push both the\n increment and the left side into the pipeline since they don\'t depend on each other. ++i may stall the pipeline because the processor cannot start the left side until the pre-increment operation has meandered all the way through. Again, a pipeline stall is not guaranteed, since the processor may find other useful things to stick in.@Mark: I deleted my previous answer because it was a bit flip, and deserved a downvote for that alone. I actually think it\'s a good question in the sense that it asks what\'s on the minds of a lot of people.The usual answer is that ++i is faster than i++, and no doubt it is, but the bigger question is "when should you care?"If the fraction of CPU time spent in incrementing iterators is less than 10%, then you may not care.If the fraction of CPU time spent in incrementing iterators is greater than 10%, you can look at which statements are doing that iterating. See if you could just increment integers rather than using iterators. Chances are you could, and while it may be in some sense less desirable, chances are pretty good you will save essentially all the time spent in those iterators.I\'ve seen an example where the iterator-incrementing was consuming well over 90% of the time. In that case, going to integer-incrementing reduced execution time by essentially that amount. (i.e. better than 10x speedup)The intended question was about when the result is unused (that\'s clear from the question for C). Can somebody fix this since the question is "community wiki"?About premature optimizations, Knuth is often quoted. That\'s right. but Donald Knuth would never defend with that the horrible code which you can see in these days. Ever seen a = b + c among Java Integers (not int)? That amounts to 3 boxing/unboxing conversions. Avoiding stuff like that is important. And uselessly writing i++ instead of ++i is the same mistake.\nEDIT: As phresnel nicely puts it in a comment, this can be summed up as "premature optimization is evil, as is premature pessimization".Even the fact that people are more used to i++ is an unfortunate C legacy, caused by a conceptual mistake by K&R (if you follow the intent argument, that\'s a logical conclusion; and defending K&R because they\'re K&R is meaningless, they\'re great, but they aren\'t great as language designers; countless mistakes in the C design exist, ranging from gets() to strcpy(), to the strncpy() API (it should have had the strlcpy() API since day 1)).Btw, I\'m one of those not used enough to C++ to find ++i annoying to read. Still, I use that since I acknowledge that it\'s right.The performance difference between ++i and i++ will be more apparent when you think of operators as value-returning functions and how they are implemented.  To make it easier to understand what\'s happening, the following code examples will use int as if it were a struct.++i increments the variable, then returns the result.  This can be done in-place and with minimal CPU time, requiring only one line of code in many cases:But the same cannot be said of i++.Post-incrementing, i++, is often seen as returning the original value before incrementing.  However, a function can only return a result when it is finished.  As a result, it becomes necessary to create a copy of the variable containing the original value, increment the variable, then return the copy holding the original value:When there is no functional difference between pre-increment and post-increment, the compiler can perform optimization such that there is no performance difference between the two.  However, if a composite data type such as a struct or class is involved, the copy constructor will be called on post-increment, and it will not be possible to perform this optimization if a deep copy is needed.  As such, pre-increment generally is faster and requires less memory than post-increment.An the reason why you ought to use ++i even on built-in types where there\'s no performance advantage is to create a good habit for yourself.Both are as fast ;)\nIf you want it is the same calculation for the processor, it\'s just the order in which it is done that differ.For example, the following code :Produce the following assembly :You see that for a++ and b++ it\'s an incl mnemonic, so it\'s the same operation ;)@wilhelmtellThe compiler can elide the temporary. Verbatim from the other thread:The C++ compiler is allowed to eliminate stack based temporaries even if doing so changes program behavior. MSDN link for VC 8: http://msdn.microsoft.com/en-us/library/ms364057(VS.80).aspx++i is faster than i++ because it doesn\'t return an old copy of the value.It\'s also more intuitive:This C example prints "02" instead of the "12" you might expect:Same for C++: