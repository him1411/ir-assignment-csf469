I know there is a method for python list to return the first index of somethingIs there something like that for numpy arrays?Yes, here is the answer given a Numpy array, array, and a value, item, to search for.The result is a tuple with first all the row indices, then all the column indices.For example if array is two dimensions and it contained your item at two locations thenwould be equal to your item and so wouldnumpy.whereIf you need the index of the first occurrence of only one value, you can use nonzero (or where, which amounts to the same thing in this case):If you need the first index of each of many values, you could obviously do the same as above repeatedly, but there is a trick that may be faster.  The following finds the indices of the first element of each subsequence:Notice that it finds the beginning of both subsequence of 3s and both subsequences of 8s:[1, 1, 1, 2, 2, 3, 8, 3, 8, 8]So it\'s slightly different than finding the first occurrence of each value.  In your program, you may be able to work with a sorted version of t to get what you want:you can also convert a Numpy array to list in the air and get its index .\nfor exampleWill print 1.If you\'re going to use this as an index into something else, you can use boolean indices if the arrays are broadcastable; you don\'t need explicit indices.  The absolute simplest way to do this is to simply index based on a truth value.Any boolean operation works:The nonzero method takes booleans, too:The two zeros are for the tuple of indices (assuming first_array is 1D) and then the first item in the array of indices.to index on any criteria, you can so something like the following:[edit] and here\'s a quick function to do what list.index() does, except doesn\'t raise an exception if it\'s not found.  beware -- this is probably very slow on large arrays.  you can probably monkeypatch this on to arrays if you\'d rather use it as a method.Just to add a very performant and handy numba alternative to find the first index:This is pretty fast and deals naturally with multidimensional arrays:This can be much faster (because it\'s short-circuiting the operation) than any approach using np.where or np.nonzero.However np.argwhere could also deal gracefully with multidimensional arrays (you would need to manually cast it to a tuple and it\'s not short-circuited) but it would fail if no match is found:There are lots of operations in numpy that could perhaps be put together to accomplish this.  This will return indices of elements equal to item:You could then take the first elements of the lists to get a single element.l.index(x) returns the smallest i such that i is the index of the first occurrence of x in the list.One can safely assume that the index() function in Python is implemented so that it stops after finding the first match, and this results in an optimal average performance.For finding an element stopping after the first match in a numpy array use an iterator (ndenumerate).Numpy array:Note that both methods index() and next return an error if the element is not found. With next one can use a second argument to return a special value in case the element is not found, e.g.  There are other functions in numpy (argmax, where, and nonzero) that can be used to find an element in an array, but they all have the drawback of going through the whole array looking for all occurrences, thus not being optimized for finding the first element. Note also that where and nonzero return arrays,so you need to select the first element to get the index.Just checking that for large arrays the solution using an iterator is faster when the searched item is at the beginning of the array (using %timeit in the IPython shell)This is an open Numpy Github issue.See also:  Numpy: find first index of value fastAn alternative to selecting the first element from np.where() is to use a generator expression together with enumerate, such as: For a two dimensional array one would do: The advantage of this approach is that it stops checking the elements of the array after the first match is found, whereas np.where checks all elements for a match. A generator expression would be faster if there\'s  match early in the array.For 1D arrays, I\'d recommend np.flatnonzero(array == value)[0], which is equivalent to both np.nonzero(array == value)[0][0] and np.where(array == value)[0][0] but avoids the ugliness of unboxing a 1-element tuple.The numpy_indexed package (disclaimer, I am its author) contains a vectorized equivalent of list.index for numpy.ndarray; that is:This solution has vectorized performance, generalizes to ndarrays, and has various ways of dealing with missing values.