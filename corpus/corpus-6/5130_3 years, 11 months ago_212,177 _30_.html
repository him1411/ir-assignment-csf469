Java 8 has a completely new API for date and time. One of the most useful classes in this API is LocalDateTime, for holding a timezone-independent date-with-time value. There are probably millions of lines of code using the legacy class java.util.Date for this purpose. As such, when interfacing old and new code there will be a need for converting between the two. As there seems to be no direct methods for accomplishing this, how can it be done?Short answer:Explanation:\n(based on this question about LocalDate)Despite its name, java.util.Date represents an instant on the time-line, not a "date". The actual data stored within the object is a long count of milliseconds since 1970-01-01T00:00Z (midnight at the start of 1970 GMT/UTC).The equivalent class to java.util.Date in JSR-310 is Instant, thus there are convenient methods to provide the conversion to and fro:A java.util.Date instance has no concept of time-zone. This might seem strange if you call toString() on a java.util.Date, because the toString is relative to a time-zone. However that method actually uses Java\'s default time-zone on the fly to provide the string. The time-zone is not part of the actual state of java.util.Date.An Instant also does not contain any information about the time-zone. Thus, to convert from an Instant to a local date-time it is necessary to specify a time-zone. This might be the default zone - ZoneId.systemDefault() - or it might be a time-zone that your application controls, such as a time-zone from user preferences. LocalDateTime has a convenient factory method that takes both the instant and time-zone:In reverse, the LocalDateTime the time-zone is specified by calling the atZone(ZoneId) method. The ZonedDateTime can then be converted directly to an Instant:Note that the conversion from LocalDateTime to ZonedDateTime has the potential to introduce unexpected behaviour. This is because not every local date-time exists due to Daylight Saving Time. In autumn/fall, there is an overlap in the local time-line where the same local date-time occurs twice. In spring, there is a gap, where an hour disappears. See the Javadoc of atZone(ZoneId) for more the definition of what the conversion will do.Summary, if you round-trip a java.util.Date to a LocalDateTime and back to a java.util.Date you may end up with a different instant due to Daylight Saving Time.Additional info: There is another difference that will affect very old dates. java.util.Date uses a calendar that chances at October 15, 1582, with dates before that using the Julian calendar instead of the Gregorian one. By contrast, java.time.* uses the ISO calendar system (equivalent to the Gregorian) for all time. In most use cases, the ISO calendar system is what you want, but you may see odd effects when comparing dates before year 1582.Here is what I came up with ( and like all Date Time conundrums it is probably going to be disproved based on some weird timezone-leapyear-daylight adjustment :D )Given: Date date = [some date](1) LocalDateTime << Instant<< Date(2)  Date << Instant << LocalDateTimeExample:Create Instant from Date:Create Date from Instant (not necessary,but for illustration):Create LocalDateTime from InstantCreate Instant from LocalDateTime:Create Date from Instant:Much more convenient way if you are sure you need a default timezone :the following seems to work when converting from new API LocalDateTime into java.util.date:the reverse conversion can be (hopefully) achieved similar way...hope it helps...Everything is here : http://blog.progs.be/542/date-to-java-timeThe answer with "round-tripping" is not exact : when you do if your system timezone is not UTC/GMT, you change the time !I\'m not sure if this is the simplest or best way, or if there are any pitfalls, but it works: