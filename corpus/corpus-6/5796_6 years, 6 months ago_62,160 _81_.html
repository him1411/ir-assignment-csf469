I found this excellent tutorial on regular expressions and while I intuitively understand what "greedy", "reluctant" and "possessive" quantifiers do, there seems to be a serious hole in my understanding.Specifically, in the following example:The explanation mentions eating the entire input string, letters been consumed, matcher backing off, rightmost occurrence of "foo" has been regurgitated, etc.Unfortunately, despite the nice metaphors, I still don\'t understand what is eaten by whom... Do you know of another tutorial that explains (concisely) how regular expressions engines work?Alternatively, if someone can explain in somewhat different phrasing the following paragraph, that would be much appreciated:The first example uses the greedy\n  quantifier .* to find "anything", zero\n  or more times, followed by the letters\n  "f" "o" "o". Because the quantifier is\n  greedy, the .* portion of the\n  expression first eats the entire input\n  string. At this point, the overall\n  expression cannot succeed, because the\n  last three letters ("f" "o" "o") have\n  already been consumed (by whom?). So the matcher\n  slowly backs off (from right-to-left?) one letter at a time\n  until the rightmost occurrence of\n  "foo" has been regurgitated (what does this mean?), at which\n  point the match succeeds and the\n  search ends.The second example, however, is\n  reluctant, so it starts by first\n  consuming (by whom?) "nothing". Because "foo"\n  doesn\'t appear at the beginning of the\n  string, it\'s forced to swallow (who swallows?) the\n  first letter (an "x"), which triggers\n  the first match at 0 and 4. Our test\n  harness continues the process until\n  the input string is exhausted. It\n  finds another match at 4 and 13.The third example fails to find a\n  match because the quantifier is\n  possessive. In this case, the entire\n  input string is consumed by .*+, (how?)\n  leaving nothing left over to satisfy\n  the "foo" at the end of the\n  expression. Use a possessive\n  quantifier for situations where you\n  want to seize all of something without\n  ever backing off (what does back off mean?); it will outperform\n  the equivalent greedy quantifier in\n  cases where the match is not\n  immediately found.I\'ll give it a shot.A greedy quantifier first matches as much as possible. So the .* matches the entire string. Then the matcher tries to match the f following, but there are no characters left. So it "backtracks", making the greedy quantifier match one less thing (leaving the "o" at the end of the string unmatched). That still doesn\'t match the f in the regex, so it "backtracks" one more step, making the greedy quantifier match one less thing again (leaving the "oo" at the end of the string unmatched). That still doesn\'t match the f in the regex, so it backtracks one more step (leaving the "foo" at the end of the string unmatched). Now, the matcher finally matches the f in the regex, and the o and the next o are matched too. Success!A reluctant or "non-greedy" quantifier first matches as little as possible. So the .* matches nothing at first, leaving the entire string unmatched. Then the matcher tries to match the f following, but the unmatched portion of the string starts with "x" so that doesn\'t work. So the matcher backtracks, making the non-greedy quantifier match one more thing (now it matches the "x", leaving "fooxxxxxxfoo" unmatched). Then it tries to match the f, which succeeds, and the o and the next o in the regex match too. Success!In your example, it then starts the process over with the remaining unmatched portion of the string, following the same process.A possessive quantifier is just like the greedy quantifier, but it doesn\'t backtrack. So it starts out with .* matching the entire string, leaving nothing unmatched. Then there is nothing left for it to match with the f in the regex. Since the possessive quantifier doesn\'t backtrack, the match fails there.I haven\'t heard the exact terms \'regurgitate\' or \'backing off\' before; the phrase that would replace these is "backtracking", but \'regurgitate\' seems like as good a phrase as any for "the content that had been tentatively accepted before backtracking threw it away again".The important thing to realize about most regex engines is that they are backtracking: they will tentatively accept a potential, partial match, while trying to match the entire contents of the regex. If the regex cannot be completely matched at the first attempt, then the regex engine will backtrack on one of its matches. It will try matching *, +, ?, alternation, or {n,m} repetition differently, and try again. (And yes, this process can take a long time.)The first example uses the greedy\n  quantifier .* to find "anything", zero\n  or more times, followed by the letters\n  "f" "o" "o". Because the quantifier is\n  greedy, the .* portion of the\n  expression first eats the entire input\n  string. At this point, the overall\n  expression cannot succeed, because the\n  last three letters ("f" "o" "o") have\n  already been consumed (by whom?).The last three letters, f, o, and o were already consumed by the initial .* portion of the rule. However, the next element in the regex, f, has nothing left in the input string. The engine will be forced to backtrack on its initial .* match, and try matching all-but-the-last character. (It might be smart and backtrack to all-but-the-last-three, because it has three literal terms, but I\'m unaware of implementation details at this level.)So the matcher\n  slowly backs off (from right-to-left?) one letter at a time\n  until the rightmost occurrence of\n  "foo" has been regurgitated (what does this mean?), at whichThis means the foo had tentatively been including when matching .*. Because that attempt failed, the regex engine tries accepting one fewer character in .*. If there had been a successful match before the .* in this example, then the engine would probably try shortening the .* match (from right-to-left, as you pointed out, because it is a greedy qualifier), and if it was unable to match the entire inputs, then it might be forced to re-evaluate what it had matched before the .* in my hypothetical example.point the match succeeds and the\n  search ends.The second example, however, is\n  reluctant, so it starts by first\n  consuming (by whom?) "nothing". Because "foo"The initial nothing is consumed by .?*, which will consume the shortest possible amount of anything that allows the rest of the regex to match.doesn\'t appear at the beginning of the\n  string, it\'s forced to swallow (who swallows?) theAgain the .?* consumes the first character, after backtracking on the initial failure to match the entire regex with the shortest possible match. (In this case, the regex engine is extending the match for .*? from left-to-right, because .*? is reluctant.)first letter (an "x"), which triggers\n  the first match at 0 and 4. Our test\n  harness continues the process until\n  the input string is exhausted. It\n  finds another match at 4 and 13.The third example fails to find a\n  match because the quantifier is\n  possessive. In this case, the entire\n  input string is consumed by .*+, (how?)A .*+ will consume as much as possible, and will not backtrack to find new matches when the regex as a whole fails to find a match. Because the possessive form does not perform backtracking, you probably won\'t see many uses with .*+, but rather with character classes or similar restrictions: account: [[:digit:]]*+ phone: [[:digit:]]*+. This can drastically speed up regex matching, because you\'re telling the regex engine that it should never backtrack over potential matches if an input doesn\'t match. (If you had to write all the matching code by hand, this would be similar to never using putc(3) to \'push back\' an input character. It would be very similar to the naive code one might write on a first try. Except regex engines are way better than a single character of push-back, they can rewind all the back to zero and try again. :)But more than potential speed ups, this also can let you write regexs that match exactly what you need to match. I\'m having trouble coming up with an easy example :) but writing a regex using possessive vs greedy quantifiers can give you different matches, and one or the other may be more appropriate.leaving nothing left over to satisfy\n  the "foo" at the end of the\n  expression. Use a possessive\n  quantifier for situations where you\n  want to seize all of something without\n  ever backing off (what does back off mean?); it will outperform"Backing off" in this context means "backtracking" -- throwing away a tentative partial match to try another partial match, which may or may not succeed.the equivalent greedy quantifier in\n  cases where the match is not\n  immediately found.http://swtch.com/~rsc/regexp/regexp1.htmlI\'m not sure that\'s the best explanation on the internet, but it\'s reasonably well written and appropriately detailed, and I keep coming back to it. You might want to check it out.If you want a higher-level (less detailed explanation), for simple regular expressions such as the one you\'re looking at, a regular expression engine works by backtracking. Essentially, it chooses ("eats") a section of the string and tries to match the regular expression against that section. If it matches, great. If not, the engine alters its choice of the section of the string and tries to match the regexp against that section, and so on, until it\'s tried every possible choice.This process is used recursively: in its attempt to match a string with a given regular expression, the engine will split the regular expression into pieces and apply the algorithm to each piece individually.The difference between greedy, reluctant, and possessive quantifiers enters when the engine is making its choices of what part of the string to try to match against, and how to modify that choice if it doesn\'t work the first time. The rules are as follows:A greedy quantifier tells the engine to start with the entire string (or at least, all of it that hasn\'t already been matched by previous parts of the regular expression) and check whether it matches the regexp. If so, great; the engine can continue with the rest of the regexp. If not, it tries again, but trimming one character (the last one) off the section of the string to be checked. If that doesn\'t work, it trims off another character, etc. So a greedy quantifier checks possible matches in order from longest to shortest.A reluctant quantifier tells the engine to start with the shortest possible piece of the string. If it matches, the engine can continue; if not, it adds one character to the section of the string being checked and tries that, and so on until it finds a match or the entire string has been used up. So a reluctant quantifier checks possible matches in order from shortest to longest.A possessive quantifier is like a greedy quantifier on the first attempt: it tells the engine to start by checking the entire string. The difference is that if it doesn\'t work, the possessive quantifier reports that the match failed right then and there. The engine doesn\'t change the section of the string being looked at, and it doesn\'t make any more attempts.This is why the possessive quantifier match fails in your example: the .*+ gets checked against the entire string, which it matches, but then the engine goes on to look for additional characters foo after that - but of course it doesn\'t find them, because you\'re already at the end of the string. If it were a greedy quantifier, it would backtrack and try making the .* only match up to the next-to-last character, then up to the third to last character, then up to the fourth to last character, which succeeds because only then is there a foo left after the .* has "eaten" the earlier part of the string.It is just my practice output to visualise the scene-Here is my take using Cell and Index positions (See the diagram here to distinguish a Cell from an Index).Greedy - Match as much as possible to the greedy quantifier and the entire regex. If there is no match, backtrack on the greedy quantifier.Input String: xfooxxxxxxfoo \nRegex: .*fooThe above Regex has two parts: \n(i)\'.*\' and \n(ii)\'foo\' \nEach of the steps below will analyze the two parts. Additional comments for a match to \'Pass\' or \'Fail\' is explained within braces. Step 1:\n(i) .*  = xfooxxxxxxfoo    - PASS (\'.*\' is a greedy quantifier and will use the entire Input String)\n(ii) foo    = No character left to match after index 13 - FAIL\nMatch failed.Step 2:\n(i) .*  = xfooxxxxxxfo  - PASS (Backtracking on the greedy quantifier \'.*\')\n(ii) foo = o - FAIL\nMatch failed.Step 3:\n(i) .*  = xfooxxxxxxf - PASS (Backtracking on the greedy quantifier \'.*\')\n(ii) foo = oo - FAIL\nMatch failed.Step 4:\n(i) .*  = xfooxxxxxx - PASS (Backtracking on the greedy quantifier \'.*\')\n(ii) foo = foo  - PASS \nReport MATCHResult: 1 match(es)\nI found the text "xfooxxxxxxfoo" starting at index 0 and ending at index 13.Reluctant - Match as little as possible to the reluctant quantifier and match the entire regex. if there is no match, add characters to the reluctant quantifier.Input String: xfooxxxxxxfoo\nRegex: .*?fooThe above regex has two parts: \n(i) \'.*?\' and \n(ii) \'foo\'Step 1:\n.*?    = \'\' (blank)        - PASS (Match as little as possible to the reluctant quantifier \'.*?\'. Index 0 having \'\' is a match.)\nfoo = xfo               - FAIL (Cell 0,1,2 - i.e index between 0 and 3)\nMatch failed.Step 2:\n.*?    = x                 - PASS (Add characters to the reluctant quantifier \'.*?\'. Cell 0 having \'x\' is a match.)\nfoo = foo               - PASS \nReport MATCHStep 3:\n.*?    = \'\' (blank)        - PASS (Match as little as possible to the reluctant quantifier \'.*?\'. Index 4 having \'\' is a match.)\nfoo = xxx               - FAIL (Cell 4,5,6 - i.e index between 4 and 7)\nMatch failed.Step 4:\n.*?    = x                 - PASS (Add characters to the reluctant quantifier \'.*?\'. Cell 4.)\nfoo = xxx               - FAIL (Cell 5,6,7 - i.e index between 5 and 8)\nMatch failed.Step 5:\n.*?    = xx                - PASS (Add characters to the reluctant quantifier \'.*?\'. Cell 4 thru 5.)\nfoo = xxx               - FAIL (Cell 6,7,8 - i.e index between 6 and 9)\nMatch failed.Step 6:\n.*?    = xxx               - PASS (Add characters to the reluctant quantifier \'.*?\'. Cell 4 thru 6.)\nfoo = xxx               - FAIL (Cell 7,8,9 - i.e index between 7 and 10)\nMatch failed.Step 7:\n.*?    = xxxx              - PASS (Add characters to the reluctant quantifier \'.*?\'. Cell 4 thru 7.)\nfoo = xxf               - FAIL (Cell 8,9,10 - i.e index between 8 and 11)\nMatch failed.Step 8:\n.*?    = xxxxx             - PASS (Add characters to the reluctant quantifier \'.*?\'. Cell 4 thru 8.)\nfoo = xfo               - FAIL (Cell 9,10,11 - i.e index between 9 and 12)\nMatch failed.Step 9:\n.*?    = xxxxxx            - PASS (Add characters to the reluctant quantifier \'.*?\'. Cell 4 thru 9.)\nfoo = foo               - PASS (Cell 10,11,12 - i.e index between 10 and 13)\nReport MATCHStep 10:\n.*?    = \'\' (blank)        - PASS (Match as little as possible to the reluctant quantifier \'.*?\'. Index 13 is blank.)\nfoo = No character left to match    - FAIL (There is nothing after index 13 to match)\nMatch failed.Result: 2 match(es)\nI found the text "xfoo" starting at index 0 and ending at index 4.\nI found the text "xxxxxxfoo" starting at index 4 and ending at index 13.Possessive - Match as much as possible to the possessive quantifer and match the entire regex. Do NOT backtrack.Input String: xfooxxxxxxfoo\nRegex: .*+fooThe above regex has two parts: \'.*+\' and \'foo\'.Step 1:\n.*+    = xfooxxxxxxfoo     - PASS (Match as much as possible to the possessive quantifier \'.*\')\nfoo = No character left to match    - FAIL (Nothing to match after index 13)\nMatch failed.Note: Backtracking is not allowed.Result: 0 match(es)Greedy: "match the longest possible sequence of characters"Reluctant: "match the shortest possible sequence of characters"Possessive: This is a bit strange as it does NOT (in contrast to greedy and reluctant) try to find a match for the whole regex.By the way: No regex pattern matcher implementation will ever use backtracking. All real-life pattern matcher are extremely fast - nearly independent of the complexity of the regular expression!Greedy Quantification involves pattern matching using all of the remaining unvalidated characters of a string during an iteration.  Unvalidated characters start in the active sequence.  Every time a match does not occur, the character at the end is quarantined and the check is performed again.When only leading conditions of the regex pattern are satisfied by the active sequence, an attempt is made to validate the remaining conditions against the quarantine.  If this validation is successful, matched characters in the quarantine are validated and residual unmatched characters remain unvalidated and will be used when the process begins anew in the next iteration.The flow of characters is from the active sequence into the quarantine.  The resulting behavior is that as much of the original sequence is included in a match as possible.Reluctant Quantification is mostly the same as greedy qualification except the flow of characters is the opposite--that is, they start in the quarantine and flow into the active sequence.  The resulting behavior is that as little of the original sequence is included in a match as possible.Possessive Quantification does not have a quarantine and includes everything in a fixed active sequence.