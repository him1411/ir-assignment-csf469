Is there an XSLT equivalent for JSON? Something to allow me to do transformations on JSON like XSLT does to XML.Interesting idea. Some searching on Google produced a few pages of interest, including:Hope this helps.Try JOLT. It is a JSON to JSON transformation library written in Java. It was created specifically because we did not want to play the "JSON -> XML -> XSLT -> XML -> JSON" game, and using a template for any sufficiently complex transform is unmaintainable.I recently found a tool that I love for styling JSON: http://twigkit.github.com/tempo/.  Very easy tool to use--in my opinion, it is much easier to work with than XSLT--no need for XPATH queries.Have a look at jsonpath-object-transformXSLT supports JSON as seen at http://www.w3.org/TR/xslt-30/#jsonXML uses angular brackets for delimiter tokens, JSON uses braces, square brackets, ... I. e. XML\'s fewer token recognition comparisons means it\'s optimized for declarative transformation, whereas more comparisons, being like switch statement, for speed reasons assume speculative branch prediction that imperative code in scripting languages is useful for. As direct consequence, for different mixes of semi-structured data, you may want to benchmark XSLT and javascript engines\' performance as part of responsive pages. For negligible data payload, transformations might work just as well with JSON without XML serialization. W3\'s decision ought to be based on better analysis.To say lack of tools suggest lack of need is just begging the question. The same could be applied to support for X or Y in Linux (Why bother developing quality drivers and/or games  for such a minority OS? And why pay attention to an OS that big game and hardware companies don\'t develop for?). Probably the people who would need to use XSLT and JSON end up using a somewhat trivial workaround: Transforming JSON into XML. But that\'s not the optimal solution, is it?When you have a native JSON format and you want to edit it "wysywyg" in the browser, XSLT would be a more than adequate solution for the problem. Doing that with traditional javascript programming can become a pain in the arse.In fact, I have implemented a "stone-age" approach to XSLT, using substring parsing to interpret some basic commands for javascript, like calling a template, process children, etc. Certainly implementing a transformation engine with a JSON object is much easier than implementing a full-fledged XML parser to parse the XSLT. Problem is, that to use XML templates to transform a JSON object you need to parse the XML of the templates.To tranform a JSON object with XML (or HTML, or text or whatever) you need to think carefully about the syntax and what special characters you need to use to identify the transformation commands. Otherwise you\'ll end up having to design a parser for your own custom templating language. Having walked through that path, I can tell you that it\'s not pretty.Update (Nov 12, 2010): After a couple of weeks working on my parser, I\'ve been able to optimize it. Templates are parsed beforehand and commands are stored as JSON objects. Transformation rules are also JSON objects, while the template code is a mix of HTML and a homebrew syntax similar to shell code. I\'ve been able to transform a complex JSON document into HTML to make a document editor. The code is around 1K lines for the editor (it\'s for a private project so I can\'t share it) and around 990 lines for the JSON transformation code (includes iteration commands, simple comparisons, template calling, variable saving and evaluation). I plan to release it under a MIT license. Drop me a mail if you want to get involved.jq - lightweight and flexible command-line JSON processorIt\'s not template-based like XSLT, but more concise. e.g. to extract name and address fields into an array: [.name, .address]The tutorial walks through an example of transforming Twitter\'s  JSON API (and the manual has many examples).I wrote my own small library around this, recently, which tries to stay as close to5.1 Processing Model (XSLT REC)\nhttps://www.w3.org/TR/xslt#section-Processing-Modelas is possible (as I could anyway), in a few lines of JavaScript code.Here are a few not-completely-trivial examples of use...Fiddle: https://jsfiddle.net/YSharpLanguage/kj9pk8oz/10(inspired by D.1 Document Example (XSLT REC) https://www.w3.org/TR/xslt#section-Document-Example)where this:... gives:andFiddle: https://jsfiddle.net/YSharpLanguage/ppfmmu15/10where this:... gives:A JavaScript equivalent of...XSLT 3.0 REC Section 14.4 Example: Grouping Nodes based on Common Values(at: http://jsfiddle.net/YSharpLanguage/8bqcd0ey/1)Cf. https://www.w3.org/TR/xslt-30/#grouping-exampleswhere...... gives:A JavaScript equivalent of...JSONiq Use Cases Section 1.1.2. Grouping Queries for JSON(at: https://jsfiddle.net/YSharpLanguage/hvo24hmk/3)Cf. http://jsoniq.org/docs/JSONiq-usecases/html-single/index.html#jsongroupingwhere...... gives:It is also useful to overcome the limitations of JSONPath wrt. querying against the ancestor axis, as raised by this SO question (and certainly others).E.g., how to get the discount of a grocery item knowing its brand id, in?A possible solution is:... which gives:\'HTH,As yet another new answer to an old question, I\'d suggest a look at DefiantJS.  It\'s not an XSLT equivalent for JSON, it is XSLT for JSON.  The "Templating" section of the documentation includes this example:I\'ve been really tired of the enormous amount of JavaScript templating engines out there, and all their inline HTML-templates, different markup styles, etc., and decided to build a small library that enables XSLT formatting for JSON data structures. Not rocket science in any way -- it\'s just JSON parsed to XML and then formatted with a XSLT document. It\'s fast too, not as fast as JavaScript template engines in Chrome, but in most other browsers it\'s at least as fast as the JS engine alternative for larger data structures.There is now! I recently created a library, json-transforms, exactly for this purpose:https://github.com/ColinEberhardt/json-transformsIt uses a combination of JSPath, a DSL modelled on XPath, and a recursive pattern matching approach, inspired directly by XSLT.Here\'s a quick example. Given the following JSON object:Here\'s a transformation:Which output the following:This transform is composed of three rules. The first matches any automobile which is made by Honda, emitting an object with a Honda property, then recursively matching. The second rule matches any object with a maker property, outputting the model and year properties. The final is the identity transform that recursively matches.JSONiq is such a standard and Zorba an open-source C++ implementation. JSONiq can also be seen as XQuery with adding JSON as a native data type.I am using Camel route umarshal(xmljson) -> to(xlst) -> marshal(xmljson). Efficient enough (though not 100% perfect), but simple, if you are already using Camel.Not too sure there is need for this, and to me lack of tools suggests lack of need. JSON is best processed as objects (the way it\'s done in JS anyway), and you typically use language of the objects itself to do transformations (Java for Java objects created from JSON, same for Perl, Python, Perl, c#, PHP and so on). Just with normal assignments (or set, get), looping and so on.I mean, XSLT is just another language, and one reason it is needed is that XML is not an object notation and thus objects of programming languages are not exact fits (impedance between hierarchic xml model and objects/structs).it is very possible to convert JSON using XSLT: you need JSON2SAX deserializer and SAX2JSON serializer.Sample code in Java:\nhttp://www.gerixsoft.com/blog/json/xslt4jsonYate (https://github.com/pasaran/yate) is specifically designed after XSLT, features JPath (a\xc2\xa0natural XPath equivalent for JS), compiles to JavaScript and has quite a\xc2\xa0history of production use. It\xe2\x80\x99s practically undocumented, but reading through samples and tests should be enough.Why don\'t you converts JSON to XML using Mr. Data Coverter , tranform it using XSLT and then change it back to JSON using the same.For a working doodle/proof of concept of an approach to utilize pure JavaScript along with the familiar and declarative pattern behind XSLT\'s matching expressions and recursive templates, see https://gist.github.com/brettz9/0e661b3093764f496e36(A similar approach might be taken for JSON.)Note that the demo also relies on JavaScript 1.8 expression closures for convenience in expressing templates in Firefox (at least until the ES6 short form for methods may be implemented).Disclaimer: This is my own code.I wrote a dom adapter for my jackson based json processing framework long time ago. It uses the nu.xom library. The resulting dom tree works with the java xpath and xslt facilities. I made some implementation choices that are pretty straightforward. For example the root node is always called "root", arrays go into an ol node with li sub elements (like in html), and everything else is just a sub node with a primitive value or another object node.JsonXmlConverter.javaUsage:\n\nJsonObject sampleJson = sampleJson();\n        org.w3c.dom.Document domNode = JsonXmlConverter.getW3cDocument(sampleJson, "root");\nOne approach not yet given is to use a parser generator to create a parser in XSLT which parses JSON and produces an XML output.One option that gets mentioned a lot at the XML conferences is the ReX parser generator (http://www.bottlecaps.de/rex/) - although totally undocumented on the site, recipes are available on searching.