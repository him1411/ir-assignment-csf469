What is the difference between asynchronous and non-blocking calls? Also between blocking and synchronous calls (with examples please)?In many circumstances they are different names for the same thing, but in some contexts they are quite different.  So it depends. Terminology is not applied in a totally consistent way across the whole software industry.For example in the classic sockets API, a non-blocking socket is one that simply returns immediately with a special "would block" error message, whereas a blocking socket would have blocked. You have to use a separate function such as select or poll to find out when is a good time to retry.But asynchronous sockets (as supported by Windows sockets), or the asynchronous IO pattern used in .NET, are more convenient. You call a method to start an operation, and the framework calls you back when it\'s done. Even here, there are basic differences. Asynchronous Win32 sockets "marshal" their results onto a specific GUI thread by passing Window messages, whereas .NET asynchronous IO is free-threaded (you don\'t know what thread your callback will be called on).So they don\'t always mean the same thing. To distil the socket example, we could say:As you can probably see from the multitude of different (and often mutually exclusive) answers, it depends on who you ask. In some arenas, the terms are synonymous. Or they might each refer to two similar concepts:In either case, the intention is to allow the program to not be blocked waiting for a slow process to complete - how the program is expected to respond is the only real difference. Which term refers to which also changes from programmer to programmer, language to language, or platform to platform. Or the terms may refer to completely different concepts (such as the use of synchronous/asynchronous in relation to thread programming).Sorry, but I don\'t believe there is a single right answer that is globally true.Putting this question in the context of NIO and NIO.2 in java 7, async IO is one step more advanced than non-blocking.\nWith java NIO non-blocking calls, one would set all channels (SocketChannel, ServerSocketChannel, FileChannel, etc) as such by calling AbstractSelectableChannel.configureBlocking(false).\nAfter those IO calls return, however, you will likely still need to control the checks such as if and when to read/write again, etc.\nFor instance, With the asynchronous api in java 7, these controls can be made in more versatile ways.\nOne of the 2 ways is to use CompletionHandler. Notice that both read calls are non-blocking.A nonblocking call returns immediately with whatever data are available: the full number of bytes requested, fewer, or none at all. An asynchronous call requests a transfer that will be performed in its whole(entirety) but will complete at some future time.Non-blocking:  This function won\'t wait while on the stack.Asynchronous:  Work may continue on behalf of the function call after that call has left the stacksynchronous / asynchronous is to describe the relation between two modules.\nblocking / non-blocking is to describe the situation of one module.\nAn example:\n"I": a\n"bookstore": b\na asks b: do you have a book named "c++ primer"?\n1) blocking: before b answers a, a keeps waiting there for the answer. Now a (one module) is blocking. a and b are two threads or two processes or one thread or one process? we DON\'T know.\n2) non-blocking: before b answers a, a just leaves there and every two minutes, a comes here to look for the answer. Here a (one module) is non-blocking. a and b are two threads or two processes or one process? we DON\'T know.\xc2\xa0BUT we are sure that a and b couldn\'t be one thread.\n3) synchronous: before b answers a, a keeps waiting there for the answer. It means that a can\'t continue until b finishes its job. Now we say: a and b (two modules) is synchronous.\xc2\xa0a and b are two threads or two processes or one thread or one process? we DON\'T know.\n4) asynchronous: before b answers a, a leaves there and a can do other jobs. When b gets the answer, b will call a: hey! I have it! Then a will come to b to get the book when a is free. Now we say: a and b (two modules) is asynchronous.\xc2\xa0a and b are two threads or two processes or one process? we DON\'T know. BUT we are sure that a and b couldn\'t be one thread.Here is a typical example about non-blocking & synchronous:You can see that this design is non-blocking (a is non-blocking) whereas a and b is synchronous because a can\'t continue do anything until it gets messages from b.\nNormally in this case, make a blocking is much better because non-blocking spends much resource. But this example is good to help you understand the four words: non-blocking doesn\'t mean asynchronous.They differ in spelling only.  There is no difference in what they refer to.  To be technical you could say they differ in emphasis. Non blocking refers to control flow(it doesn\'t block.) Asynchronous refers to when the event\\data is handled(not synchronously.)Blocking: control returns to invoking precess after processing of primitive(sync or async) completesNon blocking: control returns to process immediately after invocationBlocking call: Control returns only when the call completes.Non blocking call: Control returns immediately. Later OS somehow notifies the process that the call is complete.Synchronous program: A program which uses Blocking calls. In order not to freeze during the call it must have 2 or more threads (that\'s why it\'s called Synchronous - threads are running synchronously).Asynchronous program: A program which uses Non blocking calls. It can have only 1 thread and still remain interactive.