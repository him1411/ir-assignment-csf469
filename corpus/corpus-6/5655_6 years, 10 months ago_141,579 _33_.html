In C# 4.0, we have Task in the System.Threading.Tasks namespace. What is the true difference between Thread and Task. I did some sample program(help taken from MSDN)  for my own sake of learning with but have many doubts as the idea is not so clear. I have initially searched in Stackoverflow for a similar type of question but may be with this question title I was not able to get the same. If anyone knows about the same type of question being posted here earlier, kindly give the reference of the link.A task is something you want done.A thread is one of the many possible workers which performs that task.In .NET 4.0 terms, a Task represents an asynchronous operation. Thread(s) are used to complete that operation by breaking the work up into chunks and assigning to separate threads.In computer science terms, a Task is a future or a promise. (Some people use those two terms synomymously, some use them differently, nobody can agree on a precise definition.) Basically, a Task<T> "promises" to return you a T, but not right now honey, I\'m kinda busy, why don\'t you come back later?A Thread is a way of fulfilling that promise. But not every Task needs a brand-new Thread. (In fact, creating a thread is often undesirable, because doing so is much more expensive than re-using an existing thread from the threadpool. More on that in a moment.) If the value you are waiting for comes from the filesystem or a database or the network, then there is no need for a thread to sit around and wait for the data when it can be servicing other requests. Instead, the Task might register a callback to receive the value(s) when they\'re ready.In particular, the Task does not say why it is that it takes such a long time to return the value. It might be that it takes a long time to compute, or it might that it takes a long time to fetch. Only in the former case would you use a Thread to run a Task. (In .NET, threads are freaking expensive, so you generally want to avoid them as much as possible and really only use them if you want to run multiple heavy computations on multiple CPUs. For example, in Windows, a thread weighs 12 KiByte (I think), in Linux, a thread weighs as little as 4 KiByte, in Erlang/BEAM even just 400 Byte. In .NET, it\'s 1 MiByte!)The following two videos from channel-9 will give you better understanding of Tasks & Threads and where should we use them.http://channel9.msdn.com/blogs/bruceky/how-to-parallelize-your-application-part-2-theads-v-tasks\n http://channel9.msdn.com/blogs/bruceky/how-to-parallelize-your-application-part-3-using-tasksAnd if you have some more time then start with this videohttp://channel9.msdn.com/blogs/bruceky/how-to-parallelize-your-application-part-1-why-do-itWhen we execute things on multiple threads, it\xe2\x80\x99s not guaranteed that the threads are separated across multiple processors. Task is a lightweight object for managing a parallelizable unit of work. It can be used whenever you want to execute something in parallel. Parallel means the work is spread across multiple processors to maximize computational speed. Tasks are tuned for leveraging multicores processors.  Task provides following powerful features over thread.Wait on a set of tasks, without a signaling construct. We can chain tasks together to execute one after the other.   Establish a parent/child relationship when one task is started from\nanother task.   Child task exception can propagate to parent task.   Task support cancellation through the use of cancellation tokens. Asynchronous implementation is easy in task, using\xe2\x80\x99 async\xe2\x80\x99 and\n\xe2\x80\x98await\xe2\x80\x99 keywords.You can use Task to specify what you want to do then attach that Task with a Thread. so that Task would be executed in that newly made Thread rather than on the GUI thread.Use Task with the TaskFactory.StartNew(Action action). In here you execute a delegate so if you didn\'t use any thread it would be executed in the same thread (GUI thread). If you mention a thread you can execute this Task in a different thread. This is an unnecessary work cause you can directly execute the delegate or attach that delegate to a thread and execute that delegate in that thread. So don\'t use it. it\'s just unnecessary. If you intend to optimize your software this is a good candidate to be removed. **Please note that the Action is a delegate. The bare metal thing, you probably don\'t need to use it, you probably can use a LongRunning task and take the benefits from the TPL (task parallel library).Abstraction above the Threads. It uses the thread pool (unless you specify the task as a LongRunning operation, if so, a new thread is created under the hood for you).As the name suggests: a pool of threads. Is the .NET framework handling a limited number of threads for you. Why? Because opening 100 threads to execute expensive CPU operations on a Processor with just 8 cores definitely is not a good idea. The framework will maintain this pool for you, reusing the threads (not creating/killing them at each operation), and executing some of they in parallel in a way that your CPU will not burn.In resume: always use tasks.Task is an abstraction, so it is a lot easier to use. I advise you to always try to use tasks and if you face some problem that makes you need to handle a thread by yourself (probably 1% of the time) then use threads. Task is like a operation that you wanna perform , Thread helps to manage those operation through multiple process nodes. task is a lightweight option as Threading can lead to a complex code management\nI will suggest to read from MSDN(Best in world) always  TaskThreadIn addition to above points, it would be good to know that: