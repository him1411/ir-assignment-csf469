I\'m using an API client that is completely asynchrounous, that is, each operation either returns Task or Task<T>, e.g:Using the C# 5 async/await operators, what is the correct/most efficient way to start multiple tasks and wait for them all to complete:or:Since the API client is using HttpClient internally, I would expect this to issue 5 HTTP requests immediately, writing to the console as each one completes.Although you run the operations in parallel with the above code, this code blocks each thread that each operation runs on. For example, if the network call takes 2 seconds, each thread hangs for 2 seconds w/o doing anything but waiting.On the other hand, the above code with WaitAll also blocks the threads and your threads won\'t be free to process any other work till the operation ends. I would prefer WhenAll which will perform your operations asynchronously in Parallel.In fact, in the above case, you don\'t even need to await, you can just directly return from the method as you don\'t have any continuations:To back this up, here is a detailed blog post going through all the\nalternatives and their advantages/disadvantages: How and Where Concurrent Asynchronous I/O with ASP.NET Web APII was curious to see the results of the methods provided in the question as well as the accepted answer, so I put it to the test.Here\'s the code:And the resulting output:Since the API you\'re calling is async, the Parallel.ForEach version doesn\'t make much sense. You shouldnt use .Wait in the WaitAll version since that would lose the parallelism  Another alternative if the caller is async is using Task.WhenAll after doing Select and ToArray to generate the array of tasks. A second alternative is using Rx 2.0