This question already has an answer here:I\'ve tried the following with no success:In function a, I can use the arguments keyword to access an array of arguments, in function b these are lost. Is there a way of passing arguments to another javascript function like I try to do?Use .apply() to have the same access to arguments in function b, like this:You can test it out here.The spread operator allows an expression to be expanded in places where multiple arguments (for function calls) or multiple elements (for array literals) are expected.ECMAScript ES6 added a new operator that lets you do this in a more practical way: ...Spread Operator.Example without using the apply method:Note This snippet returns a syntax error if your browser still uses ES5.Editor\'s note: Since the snippet uses console.log(), you must open your browser\'s JS console to see the result - there will be no in-page result.It will display this result:In short, the spread operator can be used for different purposes if you\'re using arrays, so it can also be used for function arguments, you can see a similar example explained in the official docs: Rest parametersThe explanation that none of the other answers supplies is that the original arguments are still available, but not in the original position in the arguments object.  The arguments object contains one element for each actual parameter provided to the function. When you call a you supply three arguments: the numbers 1, 2, and, 3. So, arguments contains [1, 2, 3].When you call b, however, you pass exactly one argument: a\'s arguments object. So arguments contains [[1, 2, 3]] (i.e. one element, which is a\'s arguments object, which has properties containing the original arguments to a).As @Nick demonstrated, you can use apply to provide a set arguments object in the call.The following achieves the same result:But apply is the correct solution in the general case.