I ran across enable_shared_from_this while reading the Boost.Asio examples and after reading the documentation I am still lost for how this should correctly be used.  Can someone please give me an example and/or and explanation of when using this class makes sense.It enables you to get a valid shared_ptr instance to this, when all you have is this. Without it, you would have no way of getting a shared_ptr to this, unless you already had one as a member. This example from the boost documentation for enable_shared_from_this:The method f() returns a valid shared_ptr, even though it had no member instance. Note that you cannot simply do this:The shared pointer that this returned will have a different reference count from the "proper" one, and one of them will end up losing and holding a dangling reference when the object is deleted.enable_shared_from_this is going to be a part of the new C++0x standard as well, so you can also get it from there as well as from boost.from Dr Dobbs article on weak pointers, I think this example is easier to understand (source: http://drdobbs.com/cpp/184402026):...code like this won\'t work correctly:Neither of the two shared_ptr objects knows about the other, so both will try to release the resource when they are destroyed. That usually leads to problems. Similarly, if a member function needs a shared_ptr object that owns the object that it\'s being called on, it can\'t just create an object on the fly:This code has the same problem as the earlier example, although in a more subtle form. When it is constructed, the shared_ptr object sp1 owns the newly allocated resource. The code inside the member function S::dangerous doesn\'t know about that shared_ptr object, so the shared_ptr object that it returns is distinct from sp1. Copying the new shared_ptr object to sp2 doesn\'t help; when sp2 goes out of scope, it will release the resource, and when sp1 goes out of scope, it will release the resource again.The way to avoid this problem is to use the class template enable_shared_from_this. The template takes one template type argument, which is the name of the class that defines the managed resource. That class must, in turn, be derived publicly from the template; like this:When you do this, keep in mind that the object on which you call shared_from_this must be owned by a shared_ptr object. This won\'t work:Here\'s my explanation, from a nuts and bolts perspective (top answer didn\'t \'click\' with me). *Note that this is the result of investigating the source for shared_ptr and enable_shared_from_this that comes with Visual Studio 2012. Perhaps other compilers implement enable_shared_from_this differently...*enable_shared_from_this<T> adds a private weak_ptr<T> instance to T which holds the \'one true reference count\' for the instance of T.So, when you first create a shared_ptr<T> onto a new T*, that T*\'s internal weak_ptr gets initialized with a refcount of 1. The new shared_ptr basically backs onto this weak_ptr.T can then, in its methods, call shared_from_this to obtain an instance of shared_ptr<T> that backs onto the same internally stored reference count. This way, you always have one place where T*\'s ref-count is stored rather than having multiple shared_ptr instances that don\'t know about each other, and each think they are the shared_ptr that is in charge of ref-counting T and deleting it when their ref-count reaches zero.Note that using a boost::intrusive_ptr does not suffer from this problem.\nThis is often a more convenient way to get around this issue.Another way is to add a weak_ptr<Y> m_stub member into the class Y. Then write:Useful when you cannot change the class you are deriving from (e.g. extending other people\'s library). Do not forget to initialize the member, e.g. by m_stub = shared_ptr<Y>(this), its is valid even during a constructor.It is OK if there are more stubs like this one in inheritance hierarchy, it will not prevent destruction of the object.Edit: As correctly pointed out by user nobar, the code would destroy Y object when the assignment is finished and temporary variables are destroyed. Therefore my answer is incorrect.