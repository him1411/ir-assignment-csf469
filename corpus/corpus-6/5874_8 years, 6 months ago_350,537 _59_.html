This question already has an answer here:How do I convert a byte[] to a string? Every time I attempt it, I get System.Byte[] instead of the value.Also, how do I get the value in Hex instead of a decimal?There is a built in method for this:Result: 01-02-04-08-10-20If you want it without the dashes, just remove them:Result: 010204081020If you want a more compact representation, you can use Base64:Result: AQIECBAgI thought I would attempt to compare the speed of each of the methods listed here for the hell of it.  I based the speed testing code off this.The result is that BitConverter+String.Replace seems to be faster than most other simple ways.  But the speed can be improved with algorithms like Nathan Moinvaziri\'s ByteArrayToHexString or Kurt\'s ToHex.I also found it interesting that string.Concat and string.Join are much slower than StringBuilder implementations for long strings, but similar for shorter arrays.  Probably due to expanding the StringBuilder on the longer strings, so setting the initial size should negate this difference.With: LONG_STRING_LENGTH = 1000 * 1024;With: LONG_STRING_LENGTH = 100 * 1024;, Similar resultsWith: int MANY_STRING_COUNT = 1000; int MANY_STRING_LENGTH = 1024;\n  (Same byte count as first test but in different arrays)With: int MANY_STRING_COUNT = 2000; int MANY_STRING_LENGTH = 20;Testing code I used:Also another answer with a similar process, I haven\'t compared our results yet.Hex, Linq-fu:UPDATE with the timesAs noted by @RubenBartelink, the code that don\'t have a conversion of IEnumerable<string> to an array: ba.Select(b => b.ToString("X2")) does not work prior to 4.0, the same code is now working on 4.0.This code......prior to .NET 4.0, the output is:On .NET 4.0 onwards, string.Concat has an overload that accepts IEnumerable. Hence on 4.0, the above code will have same output for both variables s and tPrior to 4.0, ba.Select(b => b.ToString("X2")) goes to overload (object arg0), the way for the IEnumerable<string> to go to a proper overload, i.e. (params string[] values), is we need to convert the IEnumerable<string> to string array. Prior to 4.0, string.Concat has 10 overload functions, on 4.0 it is now 12I like using extension methods for conversions like this, even if they just wrap standard library methods. In the case of hexadecimal conversions, I use the following hand-tuned (i.e., fast) algorithms:Well I don\'t convert bytes to hex often so I have to say I don\'t know if there is a better way then this, but here is a way to do it.Here is another method:Alternatively, you could pre-build the translation table like so to achieve even faster results:http://blogs.msdn.com/b/blambert/archive/2009/02/22/blambert-codesnip-fast-byte-array-to-hex-string-conversion.aspxI thought I should provide an answer. From my test this method is the fastestVery fast extension methods (with reversal):Beats all the others in the speed test above:=== Long string test\n  BitConvertReplace calculation Time Elapsed 2415 ms\n  StringBuilder calculation Time Elapsed 5668 ms\n  LinqConcat calculation Time Elapsed 11826 ms\n  LinqJoin calculation Time Elapsed 9323 ms\n  LinqAgg calculation Time Elapsed 7444 ms\n  ToHexTable calculation Time Elapsed 1028 ms\n  ToHexAcidzombie calculation Time Elapsed 1035 ms\n  ToHexPatrick calculation Time Elapsed 814 ms\n  ToHexKurt calculation Time Elapsed 1604 ms\n  ByteArrayToHexString calculation Time Elapsed 1330 ms  === Many string test\n  BitConvertReplace calculation Time Elapsed 2238 ms\n  StringBuilder calculation Time Elapsed 5393 ms\n  LinqConcat calculation Time Elapsed 9043 ms\n  LinqJoin calculation Time Elapsed 9131 ms\n  LinqAgg calculation Time Elapsed 7324 ms\n  ToHexTable calculation Time Elapsed 968 ms\n  ToHexAcidzombie calculation Time Elapsed 969 ms\n  ToHexPatrick calculation Time Elapsed 956 ms\n  ToHexKurt calculation Time Elapsed 1547 ms\n  ByteArrayToHexString calculation Time Elapsed 1277 ms  Just to add one more answer to the pile, there is a System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHexBinary class that I\'ve used which can convert bytes to and from hex:Not sure how it compares (benchmark) to other implementations, but IMO it is pretty simple -- especially for converting from hex back into bytes.With:Result: 0102030d0e0fYou combine LINQ with string methods:You have to know the encoding of the string represented in bytes, but you can say System.Text.UTF8Encoding.GetString(bytes) or System.Text.ASCIIEncoding.GetString(bytes). (I\'m doing this from memory, so the API may not be exactly correct, but it\'s very close.)For the answer to your second question, see this question.As others have said it depends on the encoding of the values in the byte array.  Despite this you need to be very careful with this sort of thing or you may try to convert bytes that are not handled by the chosen encoding.Jon Skeet has a good article about encoding and unicode in .NET.  Recommended reading.I think I made a faster byte array to string convertor:And the test set up:The ToHexChar.ToHEx() method is the ToHex() method shown previously.Results are as follows:HexTable = 11808 ms\nToHEx = 12168msIt may not look that much of a difference, but it\'s still faster :)No one here mentioned the reason why you get the "System.Byte[]" string instead of the value, so I will.When an object is implicitly cast to a String, the program will default to the object\'s public String ToString() method which is inherited from System.Object:If you find that you are often making this conversion, you could simply create a wrapper class and override this method like so:Now each time you print this wrapper object you will get your value instead of the value from this.GetType().ToString().I\'m not sure if you need perfomance for doing this, but here is the fastest method to convert byte[] to hex string that I can think of :Nice way to do this with LINQ...Here is a extension method for byte array (byte[]), e.g.,