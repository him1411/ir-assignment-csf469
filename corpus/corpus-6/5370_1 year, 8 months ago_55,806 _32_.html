There is a lot of talk about the latest kid in redux town right now, yelouafi/redux-saga. It uses generator functions for listening to/dispatching actions.Before I wrap my head around it, I would like to know the pros/cons of using redux-saga instead of the approach below where I\'m using redux-thunk with async/await.A component might look like this, dispatch actions like usual.Then my actions look something like this:In redux-saga, the equivalent of the above example would beThe first thing to notice is that we\'re calling the api functions using the form yield call(func, ...args). call doesn\'t execute the effect, it just creates a plain object like {type: \'CALL\', func, args}. The execution is delegated to the redux-saga middleware which takes care of executing the function and resuming the generator with its result.The main advantage is that you can test the generator outside of Redux using simple equality checksNote we\'re mocking the api call result by simply injecting the mocked data into the next method of the iterator. Mocking data is way simpler than mocking functions.The second thing to notice is the call to yield take(ACTION). Thunks are called by the action creator on each new action (e.g. LOGIN_REQUEST). i.e. actions are continually pushed to thunks, and thunks have no control on when to stop handling those actions. In redux-saga, generators pull the next action. i.e. they have control when to listen for some action, and when to not. In the above example the flow instructions are placed inside a while(true) loop, so it\'ll listen for each incoming action, which somewhat mimics the thunk pushing behavior.The pull approach allows implementing complex control flows. Suppose for example we want to add the following requirements Handle LOGOUT user actionupon the first successful login, the server returns a token which expires in some delay stored in a expires_in field. We\'ll have to refresh the authorization in the background on each expires_in millisecondsTake into account that when waiting for the result of api calls (either initial login or refresh) the user may logout in-between.How would you implement that with thunks; while also providing full test coverage for the entire flow? Here is how it may look with Sagas:In the above example, we\'re expressing our concurrency requirement using race. If take(LOGOUT) wins the race (i.e. user clicked on a Logout Button). The race will automatically cancel the authAndRefreshTokenOnExpiry background task. And if the authAndRefreshTokenOnExpiry was blocked in middle of a call(authorize, {token}) call it\'ll also be cancelled. Cancellation propagates downward automatically.You can find a runnable demo of the above flowI will add my experience using saga in production system in addition to the library author\'s rather thorough answer.Pro (using saga):Testability. It\'s very easy to test sagas as call() returns a pure object. Testing thunks normally requires you to include a mockStore inside your test.redux-saga comes with lots of useful helper functions about tasks. It seems to me that the concept of saga is to create some kind of background worker/thread for your app, which act as a missing piece in react redux architecture(actionCreators and reducers must be pure functions.) Which leads to next point.Sagas offer independent place to handle all side effects. It is usually easier to modify and manage than thunk actions in my experience.Con:Generator syntax.Lots of concepts to learn.API stability. It seems redux-saga is still adding features (eg Channels?) and the community is not as big. There is a concern if the library makes a non backward compatible update some day.Here\'s a project that combines the best parts (pros) of both redux-saga and redux-thunk: you can handle all side-effects on sagas while getting a promise by dispatching the corresponding action:\nhttps://github.com/diegohaz/redux-saga-thunkAn easier way is to use redux-auto.from the documantasionredux-auto fixed this asynchronous problem simply by allowing you to create an "action" function that returns a promise. To accompany your "default" function action logic.The idea is to have each action in a specific file. co-locating the server call in the file with reducer functions for "pending", "fulfilled" and "rejected". This makes handling promises very easy.It also automatically attaches a helper object(called "async") to the prototype of your state, allowing you to track in your UI, requested transitions.