The following code does work how I need it to, but it\'s ugly, excessive or a number of other things. I\'ve looked at formulas and attempted to write a few solutions, but I end up with a similar amount of statements.Is there a type of math formula that would benefit me in this instance or are 16 if statements acceptable?To explain the code, it\'s for a kind of simultaneous-turn-based game.. two players have four action buttons each and the results come from an array (0-3), but the variables \'one\' & \'two\' can be assigned anything if this helps. The result is, 0 = neither win, 1 = p1 wins, 2 = p2 wins, 3 = both win.If you cannot come up with a formula, you can use a table for such a limited number of outcomes:Since your data set is so small, you can compress everything into 1 long integer and turn it into a formulaThis makes use of the fact everything is a multiple of 2What can I say? The world needs magic, sometimes the possibility of something calls for its creation. The essence of the function that solves OP\'s problem is a map from 2 numbers (one,two), domain {0,1,2,3} to the range {0,1,2,3}.  Each of the answers has approached how to implement that map.Also, you can see in a number of the answers a restatement of the problem as a map of 1 2-digit base 4 number N(one,two) where one is digit 1, two is digit 2, and N = 4*one + two; N = {0,1,2,...,15} -- sixteen different values, that\'s important. The output of the function is one 1-digit base 4 number {0,1,2,3} -- 4 different values, also important.Now, a 1-digit base 4 number can be expressed as a 2-digit base 2 number;  {0,1,2,3} = {00,01,10,11}, and so each output can be encoded with only 2 bits.  From above, there are only 16 different outputs possible, so 16*2 = 32 bits is all that is necessary to encode the entire map; this can all fit into 1 integer.The constant M is an encoding of the map m where m(0) is encoded in bits M[0:1], m(1) is encoded in bits M[2:3], and m(n) is encoded in bits M[n*2:n*2+1].All that remains is indexing and returning the right part of the constant, in this case you can shift M right 2*N times and take the 2 least significant bits, that is (M >> 2*N) & 0x3.  The expressions (one << 3) and (two << 1) are just multiplying things out while noting that 2*x = x << 1 and 8*x = x << 3.I don\'t like any of the solutions presented except for JAB\'s.  None of the others make it easy to read the code and understand what is being computed. Here\'s how I would write this code -- I only know C#, not Java, but you get the picture:Now it is much more clear what is being computed here: this emphasizes that we are computing who gets hit by what attack, and returning both results.However this could be even better; that Boolean array is somewhat opaque. I like the table lookup approach but I would be inclined to write it in such a way that made it clear what the intended game semantics were. That is, rather than "an attack of zero and a defense of one results in no hit", instead find a way to make the code more clearly imply "a low kick attack and a low block defense results in no hit".  Make the code reflect the business logic of the game.You can create matrix which contains results When you want to get value you will use Other people have already suggested my initial idea, the matrix method, but in addition to consolidating the if statements you can avoid some of what you have by making sure the arguments supplied are in the expected range and by using in-place returns (some coding standards I\'ve seen enforce one-point-of-exit for functions, but I\'ve found that multiple returns are very useful for avoiding arrow coding and with the prevalence of exceptions in Java there\'s not much point in strictly enforcing such a rule anyway as any uncaught exception thrown inside the method is a possible point of exit anyway). Nesting switch statements is a possibility, but for the small range of values you\'re checking here I find if statements to be more compact and not likely to result in much of a performance difference, especially if your program is turn-based rather than real-time.This does end up being less readable than it might otherwise be due to the irregularity of parts of the input->result mapping. I favor the matrix style instead due to its simplicity and how you can set up the matrix to make sense visually (though that is in part influenced by my memories of Karnaugh maps):Update: Given your mention of blocking/hitting, here\'s a more radical change to the function that utilizes propertied/attribute-holding enumerated types for inputs and the result and also modifies the result a little to account for blocking, which should result in a more readable function.You don\'t even have to change the function itself if you want to add blocks/attacks of more heights, just the enums; adding additional types of moves will probably require modification of the function, though. Also, EnumSets might be more extensible than using extra enums as properties of the main enum, e.g. EnumSet<Move> attacks = EnumSet.of(Move.ATTACK_HIGH, Move.ATTACK_LOW, ...); and then attacks.contains(move) rather than move.type == MoveType.ATTACK, though using EnumSets will probably be slightly slower than direct equals checks.For the case where a successful block results in a counter, you can replace if (one.height == two.height) return LandedHit.NEITHER; withAlso, replacing some of the if statements with usage of the ternary operator (boolean_expression ? result_if_true : result_if_false) could make the code more compact (for example, the code in the preceding block would become return one.isAttack() ? LandedHit.PLAYER_TWO : LandedHit.PLAYER_ONE;), but that can lead to harder-to-read oneliners so I wouldn\'t recommend it for more complex branching.Why not using an array?I will start from the beginning. I see a pattern, the values goes from 0 to 3 and you want catch all possible values. This is your table:when we look at this same table binary we see the following results:Now maybe you already see some pattern but when I combine value one and two I see that you\'re using all values 0000, 0001, 0010,..... 1110 and 1111. Now let\'s combine value one and two to make a single 4 bit integer. When we translate this back into decimal values we see an very possible array of values where the one and two combined could be used as index:The array is then {0, 0, 1, 2, 0, 0, 2, 1, 2, 1, 3, 3, 2, 1, 3, 3} which where it\'s index is simply one and two combined.I\'m not a Java programmer but you can get rid of all if statements and just write it down as something like this:Don\'t know if a bit shift of 2 is faster than multiplication. But it could be worth the try. This uses a little bit of bitmagic (you\'re already doing it by holding two bits of information (low/high & attack/block) in a single integer):I haven\'t run it, only typed it here, please doublecheck. The idea surely works.\nEDIT: It is now tested for every input, works fine.Or should I suggest to separate the two bits of information into separate variables?\nCode based mostly on bit operations like this above is usually really hard to maintain.To be quite honest, everyone has their own style of code. I wouldn\'t have thought performance would be affected too much. If you understand this better than using a switch case version, then carry on using this.You could nest the ifs , so potentially there would be a slight performance increase for your last if checks as it wouldn\'t have gone through as many if statements. But in your context of a basic java course it probably won\'t benefit.So, instead of...You\'d do...And just reformat it as you\'d prefer.This doesn\'t make the code look better, but potentially speeds it up a little I believe.Let\'s see what we know1: your answers are symmetrical for P1 (player one) and P2 (player two). This makes sense for a fighting game but is also something you can take advantage of to improve your logic.2: 3 beats 0 beats 2 beats 1 beats 3. The only cases not covered by these cases are combinations of 0 vs 1 and 2 vs 3. To put it another way the unique victory table looks like this: 0 beats 2, 1 beats 3, 2 beats 1, 3 beats 0. 3: If 0/1 go up against each other then there\'s a hitless draw but if 2/3 go up against each then both hitFirst, let us build a one-way function telling us if we won:We can then use this function to compose the final result:While this is arguably more complex and probably slower than the table lookup offered in many answers I believe it is a superior method because it actually encapsulates the logic of your code and describes it to anyone who\'s reading your code. I think this makes it a better implementation.(It\'s been a while since I did any Java so apologies if the syntax is off, hopefully it is still intelligible if I\'ve got it slightly wrong)By the way, 0-3 clearly mean something; they\'re not arbitrary values so it would help to name them.I hope I understand the logic correctly. How about something like:Checking one hit high or one hit low is not blocked and the same for player two. Edit: Algorithm was not fully understood, "hit" awarded when blocking which I did not realize (Thx elias):I don\'t have experience with Java so there might be some typos. Please consider the code as pseudo-code.I\'d go with a simple switch. For that, you\'d need a single number evaluation. However, for this case, since 0 <= one < 4 <= 9 and 0 <= two < 4 <= 9, we can convert both ints to a simple int by multiplying one by 10 and adding two. Then use a switch in the resulting number like this:There\'s another short method that I just want to point out as a theoretical code. However I wouldn\'t use it because it has some extra complexity that you don\'t normally want to deal with. The extra complexity comes from the base 4, because the counting is 0, 1, 2, 3, 10, 11, 12, 13, 20, ...Really just additional note, in case I\'m missing something from Java. In PHP I\'d do:Since you prefer nested if conditionals , here\'s another way.\nNote that it doesn\'t use the result member and it doesn\'t change any state.Try it with switch casing...Take a look here or here for more info about itYou can add multiple conditions(not simultaneously) to it and even have a default option where no other cases have been satisfied.PS: Only if one condition is to be satisfied..If 2 conditions arise simultaneously.. I don\'t think switch can be used.\nBut you can reduce your code here.Java switch statement multiple casesThe first thing that occurred to me was essentially the same answer given by Francisco Presencia, but optimized somewhat:You could further optimize it by making the last case (for 3) the default case:The advantage of this method is that it is easier to see which values for one and two correspond to which return values than some of the other suggested methods.You may use a switch case instead of mutiple ifAlso to mention that since you have two variables then you have to merge the two variables to use them in switchCheck this Java switch statement to handle two variables?As I draw a table between one/two and the result, I see one pattern, The above would cut down atleast 3 if statements. I don\'t see a set pattern nor I am able to glean much from the code given - but if such logic can be derived, it would cut down a number of if statements.Hope this helps.A good point would be to define the rules as text, you can easier derive the correct formula then. This is extracted from laalto\'s nice array representation:And here we go with some general comments, but you should describe them in rule terms:You could of course crunch this down to less code, but it is generally a good idea to understand what you code rather than finding a compact solution.Some explanation on the complicated p1/p2 hits would be great, looks interesting!The shortest and still readable solution:or even shorter:Doesn\'t contain any "magic" numbers ;)\nHope it helps.static int val(int i, int u){\n    int q = (i & 1) ^ (u & 1);\n    return ((i >> 1) << (1 ^ q))|((u >> 1) << q);\n}I personally like to cascade ternary operators:But in your case, you can use:Or, you can notice a pattern in bits:So you can use magic:Here\'s a fairly concise version, similar to JAB\'s response. This utilises a map to store which moves triumph over others.Example:Prints:I\'d use a Map, either a HashMap or a TreeMapEspecially if the parameters are not on the form 0 <= X < NLike a set of random positive integers ..CodeThanks to @Joe Harper as I ended up using a variation of his answer. To slim it down further as 2 results per 4 were the same I slimmed it down further.I may come back to this at some point, but if there\'s no major resistance caused by multiple if-statements then I\'ll keep this for now. I will look into the table matrix and switch statement solutions further.Here is a suggestion how this could look like, but using an ints here is still kind of ugly:It would be nicer to use a structured type for the input and the output. The input actually has two fields: the position and the type (block or attack). The output also has two fields: player1Wins and player2Wins. Encoding this into a single integer makes it harder to read the code.Unfortunately, Java is not very good at expressing those kinds of data-types.Instead do something like this