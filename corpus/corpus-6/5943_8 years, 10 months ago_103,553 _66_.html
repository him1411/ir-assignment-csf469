Does it mean that two threads can\'t change the underlying data simultaneously? Or does it mean that the given code segment will run with predictable results when more than one thread are running it?from wikipedia :Thread safety is a computer programming concept applicable in the context of multi-threaded programs. A piece of code is thread-safe if it functions correctly during simultaneous execution by multiple threads. In particular, it must satisfy the need for multiple threads to access the same shared data, and the need for a shared piece of data to be accessed by only one thread at any given time....There are a few ways to achieve thread safety:Re-entrancy Writing code in such a way that it can be partially executed by one task, reentered by another task, and then resumed from the original task. This requires the saving of state information in variables local to each task, usually on its stack, instead of in static or global variables.Mutual exclusion Access to shared data is serialized using mechanisms that ensure only one thread reads or writes the shared data at any time. Great care is required if a piece of code accesses multiple shared pieces of data\xe2\x80\x94problems include race conditions, deadlocks, livelocks, starvation, and various other ills enumerated in many operating systems textbooks.Thread-local storage Variables are localized so that each thread has its own private copy. These variables retain their values across subroutine and other code boundaries, and are thread-safe since they are local to each thread, even though the code which accesses them might be reentrant.Atomic operations Shared data are accessed by using atomic operations which cannot be interrupted by other threads. This usually requires using special machine language instructions, which might be available in a runtime library. Since the operations are atomic, the shared data are always kept in a valid state, no matter what other threads access it. Atomic operations form the basis of many thread locking mechanisms. read more :http://en.wikipedia.org/wiki/Thread_safetyin german :\nhttp://de.wikipedia.org/wiki/Threadsicherheitin french :\nhttp://fr.wikipedia.org/wiki/Threadsafe\n        (very short)Thread-safe code is code that will work even if many Threads are executing it simultaneously. http://mindprod.com/jgloss/threadsafe.htmlA more informative question is what makes code not thread safe- and the answer is that there are four conditions that must be true... Imagine the following code (and it\'s machine language translation)I like the definition from Brian Goetz\'s Java Concurrency in Practice for its comprehensiveness"A class is thread-safe if it behaves correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and with no additional synchronization or other coordination on the part of the calling code."Thread-safe-code works as specified, even when entered simultaneously by different threads. This often means, that internal data-structures or operations that should run uninterrupted are protected against different modifications at the same time.As others have pointed out, thread safety means that a piece of code will work without errors if it\'s used by more than one thread at once.It\'s worth being aware that this sometimes comes at a cost, of computer time and more complex coding, so it isn\'t always desirable. If a class can be safely used on only one thread, it may be better to do so.For example, Java has two classes that are almost equivalent, StringBuffer and StringBuilder. The difference is that StringBuffer is thread-safe, so a single instance of a StringBuffer may be used by multiple threads at once. StringBuilder is not thread-safe, and is designed as a higher-performance replacement for those cases (the vast majority) when the String is built by only one thread.An easier way to understand it, is what make code not thread-safe.  There\'s two main issue that will make a threaded application to have unwanted behavior.Accessing shared variable without locking\nThis variable could be modify by another thread while executing the function.  You want to prevent it with a locking mechanism to be sure of the behavior of your function.  General rule is to keep the lock for the shortest time possible.Deadlock cause by mutual dependency on shared variable\nIf you have two shared variable A and B.  In one function, you lock A first than later you lock B.  In another function, you start locking B and after a while, you lock A.  This is a potential deadlock where first function will wait for B to be unlocked when second function will wait for A to be unlocked.  This issue will probably not occurs in your development environment and only from time to time.  To avoid it, all lock must be always in the same order.Yes and no.Thread safety is a little bit more than just making sure your shared data is accessed by only one thread at a time.  You have to ensure sequential access to shared data, while at the same time avoiding race conditions, deadlocks, livelocks, and resource starvation.Unpredictable results when multiple threads are running is not a required condition of thread-safe code, but it is often a by-product.  For example, you could have a producer-consumer scheme set up with a shared queue, one producer thread, and few consumer threads, and the data flow might be perfectly predictable.  If you start to introduce more consumers you\'ll see more random looking results.Simply - code will run fine if many threads are executing this code at the same time. In essence, many things can go wrong in a multi threaded environment (instructions reordering, partially constructed objects, same variable having different values in different threads because of caching at the CPU level etc.).I like the definition given by Java Concurrency in Practice:A [portion of code] is thread-safe if it behaves correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and with no additional synchronization or other coordination on the part of the calling code.By correctly they mean that the program behaves in compliance with its specifications.Contrived exampleImagine that you implement a counter. You could say that it behaves correctly if:A thread safe counter would behave according to those rules regardless of how many threads access it concurrently (which would typically not be the case of a naive implementation).Note: cross-post on ProgrammersDon\'t confuse thread safety with determinism.  Thread-safe code can also be non-deterministic.  Given the difficulty of debugging problems with threaded code, this is probably the normal case.  :-)Thread safety simply ensures that when a thread is modifying or reading shared data, no other thread can access it in a way that changes the data.  If your code depends on a certain order for execution for correctness, then you need other synchronization mechanisms beyond those required for thread safety to ensure this.To complete other answers:Synchronization is only a worry when the code in your method does one of two things: This means that variables defined WITHIN your method are always threadsafe.  Every call to a method has its own version of these variables.  If the method is called by another thread, or by the same thread, or even if the method calls itself (recursion), the values of these variables are not shared. Thread scheduling is not guaranteed to be round-robin. A task may totally hog the CPU at the expense of threads of the same priority. You can use Thread.yield() to have a conscience. You can use (in java) Thread.setPriority(Thread.NORM_PRIORITY-1) to lower a thread\'s priorityPlus beware of:I would like to add some more info on top of other good answers.Thread safety implies multiple threads can write/read data in same object without memory inconsistency errors. In highly  multi threaded program, a thread safe program does not cause side effects to shared data.Have a look at this SE question for more details:What does threadsafe mean?Thread safe program guarantees memory consistency.From oracle documentation page on advanced concurrent API :Memory Consistency Properties:Chapter 17 of The Java\xe2\x84\xa2 Language Specification defines the happens-before relation on memory operations such as reads and writes of shared variables. The results of a write by one thread are guaranteed to be visible to a read by another thread only if the write operation happens-before the read operation. The synchronized and volatile constructs, as well as the Thread.start() and Thread.join() methods, can form happens-before relationships. The methods of all classes in java.util.concurrent and its subpackages extend these guarantees to higher-level synchronization. In particular:Yes and yes.  It implies that data is not modified by more than one thread simultaneously.   However, your program might work as expected, and appear thread-safe, even if it is fundamentally not.     Note that the unpredictablility of results is a consequence of \'race-conditions\' that probably result in data being modified in an order other than the expected one.In Simple wordsIn computer programming, thread-safe describes a program portion or routine that can be called from multiple programming threads without unwanted interaction between the threads. (A thread is an instance of the program running on behalf of some user or process.) In simplest words :P\n If it is safe to execute multiple threads on a block of code it is thread safe**conditions applyConditions are mentioned by other answeres like\n1. The result should be same if you execute one thread or multiple threads over it etc.A code is thread safe if it behaves correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment,and with no additional synchronization or other coordination on the part of the calling code.