Is there any way to get git to give you a commit log for just commits that touched a particular line in a file?Like git blame, but git blame will show you the LAST commit that touched a particular line. I\'d really like to get a similar log of, not the list of commits to anywhere in the file, but just the commits that touched a particular line.See also Git: discover which commits ever touched a range of lines.Since Git 1.8.4, git log has -L to view the evolution of a range of lines.For example, suppose you look at git blame\'s output. Here -L150,+11 means "only look at the lines 150 to 150+11":And you want to know the history of what is now line 155.Then, use git log. Here, -L 155,155:git-web--browse.sh means "trace the evolution of lines 155 to 155 in the file named git-web--browse.sh".You can get a set of commits by using pick-axe.This will give you all of the commits that affected that text in that file. If the file was renamed at some point, you can add --follow-parent.If you would like to inspect the commits at each of these edits, you can pipe that result to git show:Try using below command implemented in Git 1.8.4.So, in your case upperLimit & lowerLimit is the touched line_numberI don\'t believe there\'s anything built-in for this. It\'s made tricky by the fact that it\'s rare for a single line to change several times without the rest of the file changing substantially too, so you\'ll tend to end up with the line numbers changing a lot.If you\'re lucky enough that the line always has some identifying characteristic, e.g. an assignment to a variable whose name never changed, you could use the regex choice for git blame -L. For example:But this only finds the first match for that regex, so if you don\'t have a good way of matching the line, it\'s not too helpful.You could hack something up, I suppose. I don\'t have time to write out code just now, but... something along these lines. Run git blame -n -L $n,$n $file. The first field is the previous commit touched, and the second field is the line number in that commit, since it could\'ve changed. Grab those, and run git blame -n $n,$n $commit^ $file, i.e. the same thing starting from the commit before the last time the file was changed.(Note that this will fail you if the last commit that changed the line was a merge commit. The primary way this could happen if the line was changed as part of a merge conflict resolution.)Edit: I happened across this mailing list post from March 2011 today, which mentions that tig and git gui have a feature that will help you do this. It looks like the feature has been considered, but not finished, for git itself.An extremely easy way to do this is by using vim-fugitive. Just open the file in vim, select the line(s) you\'re interested in using V, then enterNow you can use :cnext and :cprev to see all the revisions of the file where that line is modified. At any point, enter :Gblame to see the sha, author, and date info.This will call git blame for every meaningful revision to show line $LINE of file $FILE: As usual, the blame shows the revision number in the beginning of each line. You can appendto get aggregated results, something like a list of commits that changed this line. (Not quite, if code only has been moved around, this might show the same commit ID twice for different contents of the line. For a more detailed analysis you\'d have to do a lagged comparison of the git blame results for adjacent commits. Anyone?)Here is a solution that defines a git alias, so you will be able use it like that :Output example :You can define the alias in your .gitconfig or simply run the following commandThis is an ugly one-liner, so here is a de-obfuscated equivalent bash function :The pickaxe solution ( git log --pickaxe-regex -S\'REGEX\' ) will only give you line additions/deletions, not the other alterations of the line containing the regular expression.A limitation of this solution is that git blame only returns the 1st REGEX match, so if multiple matches exist the recursion may "jump" to follow another line. Be sure to check the full history output to spot those "jumps" and then fix your REGEX to ignore the parasite lines.Finally, here is an alternate version that run git show on each commit to get the full diff :In my case the line number had changed a lot over time.\nI was also on git 1.8.3 which does not support regex in "git blame -L".\n(RHEL7 still has 1.8.3)Oneliner:This can of course be made into a script or a function.You can mix git blame and git log commands to retrieve the summary of each commit in the git blame command and append them. Something like the following bash + awk script. It appends the commit summary as code comment inline.In one line: