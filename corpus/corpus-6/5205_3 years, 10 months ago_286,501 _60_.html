I\'m trying to create a Docker container that acts like a full-on virtual machine. I know I can use the EXPOSE instruction inside a Dockerfile to expose a port, and I can use the -p flag with docker run to assign ports, but once a container is actually running, is there a command to open/map additional ports live?For example, let\'s say I have a Docker container that is running sshd. Someone else using the container ssh\'s in and installs httpd. Is there a way to expose port 80 on the container and map it to port 8080 on the host, so that people can visit the web server running in the container, without restarting it?You cannot do this via Docker, but you can access the container\'s un-exposed port from the host machine.if you have a container that with something running on its port 8000, you can run To get the container\xc2\xb4s ip address, run the 2 commands:Internally, Docker shells out to call iptables when you run an image, so maybe some variation on this will work.to expose the container\'s port 8000 on your localhosts port 8001:One way you can work this out, is to setup another container with the port mapping you want, and compare the output of the iptables-save command (though, I had to remove some of the other options that force traffic to go via the docker proxy).NOTE: this is subverting docker, so should be done with the awareness that it may well create blue smokeOR Another alternative, is to look the (new? post 0.6.6?) -P option - which will use random host ports, and then wire those up.ORwith 0.6.5, you could use the LINKs feature to bring up a new container that talks to the existing one, with some additional relaying to that container\xc2\xb4s -p flags? (I have not used LINKs yet)ORwith docker 0.11? you can use docker run --net host .. to attach your container directly to the host\'s network interfaces (ie, net is not name-spaced) and thus all ports you open in the container are exposed.Here\'s what I would do:Here\'s another idea. Use SSH to do the port forwarding; this has the benefit of also working in OSÂ X (and probably Windows) when your Docker host is a VM.IPtables hacks don\'t work, at least on Docker 1.4.1.The best way would be to run another container with the exposed port and relay with socat. This is what I\'ve done to (temporarily) connect to the database with SQLPlus:Dockerfile:I had to deal with this same issue and was able to solve it without stopping any of my running containers. This is a solution up-to-date as of February 2016, using Docker 1.9.1. Anyway, this answer is a detailed version of @ricardo-branco\'s answer, but in more depth for new users.In my scenario, I wanted to temporarily connect to MySQL running in a container, and since other application containers are linked to it, stopping, reconfiguring, and re-running the database container was a non-starter.Since I\'d like to access the MySQL database externally (from Sequel Pro via SSH tunneling), I\'m going to use port 33306 on the host machine. (Not 3306, just in case there is an outer MySQL instance running.)About an hour of tweaking iptables proved fruitless, even though:Step by step, here\'s what I did:Edit dockerfile, placing this inside:Then build the image:Then run it, linking to your running container. (Use -d instead of -rm to keep it in the background until explicitly stopped and removed. I only want it running temporarily in this case.)While you cannot expose a new port of an existing container, you can start a new container in the same Docker network and get it to forward traffic to the original container.Launch a web-service that listens on port 80, but do not expose its internal port 80 (oops!):Find its Docker network IP:Launch verb/socat with port 8080 exposed, and get it to forward TCP traffic to that IP\'s port 80:You can now access pastebin on http://localhost:8080/, and your requests goes to socat:1234 which forwards it to pastebin:80, and the response travels the same path in reverse.To add to the accepted answer iptables solution, I had to run two more commands on the host to open it to the outside world.Note: I was opening port https (443), my docker internal IP was 172.17.0.2Note 2: These rules and temporrary and will only last until the container is restartedYou can use an overlay network like Weave Net, which will assign a unique IP address to each container and implicitly expose all the ports to every container part of the network.Weave also provides host network integration. It is disabled by default but, if you want to also access the container IP addresses (and all its ports) from the host, you can run simply run weave expose.Full disclosure: I work at Weaveworks.You can use SSH to create a tunnel and expose your container in your host.You can do it in both ways, from container to host and from host to container. But you need a SSH tool like OpenSSH in both (client in one and server in another).For example, in the container, you can doYou can find the container IP address from this line (in the container):Then in the host, you can just do:There is a handy HAProxy wrapper.This creates an HAProxy to the target container.  easy peasy.It\'s not possible to do live port mapping but there are multiple ways you can give a Docker container what amounts to a real interface like a virtual machine would have. Docker now includes a Macvlan network driver. This attaches a Docker network to a "real world" interface and allows you to assign that networks addresses directly to the container (like a virtual machines bridged mode).pipework can also map a real interface into a container or setup a sub interface in older versions of Docker.If you have control of the network you can route additional networks to your Docker host for use in the containers. Then you assign that network to the containers and setup your Docker host to route the packets via the docker network. The --net host option allows the host interface to be shared into a container but this is probably not a good setup for running multiple containers on the one host due to the shared nature. Read Ricardo\'s response first. This worked for me.However, there exists a scenario where this won\'t work if the running container was kicked off using docker-compose. This is because docker-compose (I\'m running docker 1.17) creates a new network. The way to address this scenario would bedocker network lsThen append the following\n\ndocker run -d --name sqlplus --link db:db -p 1521:1521 sqlplus --net network_name\nTo me the best way is to change the configuration file of the container directly, see How do I assign a port mapping to an existing Docker container?, press Ctrl+F and find "json".Use the following command to launch your container:There is also the -P flag which is quite new and tells Docker to map any required network ports inside our container to our host. This can help you view your web application from the outside world.When you bind to a port, Docker with redirect it for you. Using the Docker port command you will see something like this: