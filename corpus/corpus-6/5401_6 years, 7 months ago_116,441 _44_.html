jQuery 1.5 brings the new Deferred object and the attached methods .when, .Deferred and ._Deferred.For those who havn\'t used .Deferred before I\'ve annotated the source for itWhat are the possible usages of these new methods, how do we go about fitting them into patterns?I have already read the API and the source, so I know what it does. My question is how can we use these new features in everyday code?I have a simple example of a buffer class that calls AJAX request in order. (Next one start after previous one finishes).I\'m looking for demonstrations and possible uses of .Deferred and .when.It would also be lovely to see examples of ._Deferred. Linking to the new jQuery.ajax source for examples is cheating.Bounty: Show us what techniques are available when we abstract away whether an operation is synchronously or asynchronously done.The best use case I can think of is in caching AJAX responses.  Here\'s a modified example from Rebecca Murphey\'s intro post on the topic:Basically, if the value has already been requested once before it\'s returned immediately from the cache.  Otherwise, an AJAX request fetches the data and adds it to the cache.  The $.when/.then doesn\'t care about any of this; all you need to be concerned about is using the response, which is passed to the .then() handler in both cases. jQuery.when() handles a non-Promise/Deferred as a Completed one, immediately executing any .done() or .then() on the chain.Deferreds are perfect for when the task may or may not operate asynchronously, and you want to abstract that condition out of the code.Another real world example using the $.when helper:Here is a slightly different implementation of an AJAX cache as in ehynd\'s answer.As noted in fortuneRice\'s follow-up question, ehynd\'s implementation didn\'t actually prevent multiple identical requests if the requests were performed before one of them had returned. That is,will most likely result in 3 AJAX requests if the result for "xxx" has not already been cached before.This can be solved by caching the request\'s Deferreds instead of the result:A deferred can be used in place of a mutex. This is essentially the same as the multiple ajax usage scenarios.MUTEXDEFERREDWhen using a Deferred as a mutex only, watch out for performance impacts (http://jsperf.com/deferred-vs-mutex/2). Though the convenience, as well as additional benefits supplied by a Deferred is well worth it, and in actual (user driven event based) usage the performance impact should not be noticeable.This is a self-promotional answer, but I spent a few months researching this and presented the results at jQuery Conference San Francisco 2012. Here is a free video of the talk:http://www.confreaks.com/videos/993-jqcon2012-i-promise-to-show-you-when-to-use-deferredsAnother use that I\'ve been putting to good purpose is fetching data from multiple sources.  In the example below, I\'m fetching multiple, independent JSON schema objects used in an existing application for validation between a client and a REST server.  In this case, I don\'t want the browser-side application to start loading data before it has all the schemas loaded.  $.when.apply().then() is perfect for this.  Thank to Raynos for pointers on using then(fn1, fn2) to monitor for error conditions.  Another example using Deferreds to implement a cache for any kind of computation (typically some performance-intensive or long-running tasks):Here is an example of using this class to perform some (simulated heavy) calculation:The same underlying cache could be used to cache Ajax requests:You can play with the above code in this jsFiddle.1) Use it to ensure an ordered execution of callbacks:2) Use it to verify the status of the app:You can use a deferred object to make a fluid design that works well in webkit browsers. Webkit browsers will fire resize event for each pixel the window is resized, unlike FF and IE which fire the event only once for each resize. As a result, you have no control over the order in which the functions bound to your window resize event will execute. Something like this solves the problem:This will serialize the execution of your code so that it executes as you intended it to. Beware of pitfalls when passing object methods as callbacks to a deferred. Once such method is executed as a callback to deferred, the \'this\' reference will be overwritten with reference to the deferred object and will no longer refer to the object the method belongs to.You can also integrate it with any 3rd-party libraries which makes use of JQuery.One such library is Backbone, which is actually going to support Deferred in their next version. I have talked about it also on my blogI\'ve just used Deferred in real code. In project jQuery Terminal I have function exec that call commands defined by user (like he was entering it and pressing enter), I\'ve added Deferreds to the API and call exec with arrays. like this:or the commands can run async code, and exec need to call user code in order. My first api use pair of pause/resume calls and in new API I call those automatic when user return promise. So user code can just useorI use code like this:dalyed_commands is used in resume function that call exec again with all dalyed_commands.and part of the commands function (I\'ve stripped not related parts)The answer by ehynds will not work, because it caches the responses data. It should cache the jqXHR which is also a Promise.\nHere is the correct code:The answer by Julian D. will work correct and is a better solution.