How would it be possible to generate a random, unique string using numbers and letters for use in a verify link? Like when you create an account on a website, and it sends you an email with a link, and you have to click that link in order to verify your account...yeah...one of those.How can I generate one of those using PHP?Update: Just remembered about uniqid(). It\'s a PHP function that generates a unique identifier based on the current time in microseconds. I think I\'ll use that.Security Notice: This solution should not be used in situations where the quality of your randomness can affect the security of an application. In particular, rand() and uniqid() are not cryptographically secure random number generators. See Scott\'s answer for a secure alternative.If you do not need it to be absolutely unique over time:md5(uniqid(rand(), true))Otherwise (given you have already determined a unique login for your user):I was just looking into how to solve this same problem, but I also want my function to create a token that can be used for password retrieval as well. This means that I need to limit the ability of the token to be guessed. Because uniqid is based on the time, and according to php.net "the return value is little different from microtime()", uniqid does not meet the criteria. PHP recommends using openssl_random_pseudo_bytes() instead to generate cryptographically secure tokens.A quick, short and to the point answer is:which will generate a random string of alphanumeric characters of length = $bytes * 2. Unfortunately this only has an alphabet of [a-f][0-9], but it works.\ncrypto_rand_secure($min, $max) works as a drop in replacement for rand() or mt_rand. It uses openssl_random_pseudo_bytes to help create a random number between $min and $max.getToken($length) creates an alphabet to use within the token and then creates a string of length $length.EDIT: I neglected to cite source - http://us1.php.net/manual/en/function.openssl-random-pseudo-bytes.php#104322EDIT (PHP7): With the release of PHP7, the standard library now has two new functions that can replace/improve/simplify the crypto_rand_secure function above. random_bytes($length) and random_int($min, $max)http://php.net/manual/en/function.random-bytes.phphttp://php.net/manual/en/function.random-int.phpExample:I\'ve created an object-oriented solution based on Scott\'s answer:You can use custom alphabet if required.\nJust pass a string with supported chars to the constructor or setter:I hope it will help someone. Cheers!This function will generate a random key using numbers and letters:Example output:You can use UUID(Universally Unique Identifier), it can be used for any purpose, from user authentication string to payment transaction id.A UUID is a 16-octet (128-bit) number. In its canonical form, a UUID is represented by 32 hexadecimal digits, displayed in five groups separated by hyphens, in the form 8-4-4-4-12 for a total of 36 characters (32 alphanumeric characters and four hyphens).//calling funtionsome example outputs will be like:hope it helps someone in future :) I use this one-liner:where length is the length of the desired string (divisible by 4, otherwise it gets rounded down to the nearest number divisible by 4)e.g (in pseudo code)I\'m late but I\'m here with some good research data based on the functions provided by Scott\'s answer. So I set up a Digital Ocean droplet just for this 5-day long automated test and stored the generated unique strings in a MySQL database.During this test period, I used 5 different lengths (5, 10, 15, 20, 50) and +/-0.5 million records were inserted for each length. During my test, only the length 5 generated +/-3K duplicates out of 0.5 million and the remaining lengths didn\'t generate any duplicates. So we can say that if we use a length of 15 or above with Scott\'s functions, then we can generate highly reliable unique strings. Here is the table showing my research data:I hope this helps.Here is ultimate unique id generator for you. made by me.you can echo any \'var\' for your id as you like. but $mdun is better, you can replace md5 to sha1 for better code but that will be very long which may you dont need.Thank you.Use below code to generate the random number of 11 characters or change the number as per your requirement.I like to use hash keys when dealing verification links. I would recommend using the microtime and hashing that using MD5 since there should be no reason why the keys should be the same since it hashes based off of the microtime.Scott, yes you are very write and good solution! Thanks.I am also required to generate unique API token for my each user. Following is my approach, i used user information (Userid and Username):Please have a look and let me know if any improvement i can do. Thanksafter reading previous examples I came up with this:I duplicate 10 times the array[0-9,A-Z] and shuffle the elements, after I get a random start point for substr() to be more \'creative\' :)\nyou can add [a-z] and other elements to array, duplicate more or less, be more creative than meHere is what I use:I think this is the best method to use.above function will generate you a random string which is length of 11 characters.  I believe the problem with all the existing ideas is that they are probably unique, but not definitely unique (as pointed out in Dariusz Walczak\'s reply to loletech). I have a solution that actually is unique. It requires that your script have some sort of memory. For me this is a SQL database. You could also simply write to a file somewhere. There are two implementations:First method: have TWO fields rather than 1 that provide uniqueness. The first field is an ID number that is not random but is unique (The first ID is 1, the second 2...). If you are using SQL, just define the ID field with the AUTO_INCREMENT property. The second field is not unique but is random. This can be generated with any of the other techniques people have already mentioned. Scott\'s idea was good, but md5 is convenient and probably good enough for most purposes:Second method: Basically the same idea, but initially pick a maximum number of strings that will ever be generated. This could just be a really big number like a trillion. Then do the same thing, generate an ID, but zero pad it so that all IDs are the same number of digits. Then just concatenate the ID with the random string. It will be random enough for most purposes, but the ID section will ensure that it is also unique. Here is what I\'m using on one of my projects, it\'s working great and it generates a UNIQUE RANDOM TOKEN:Please note that I multiplied the timestamp by three to create a confusion for whoever user  might be wondering how this token is generated ;)I hope it helps :)You can use this code,\nI hope it will be helpful for you.Details about Random code generator in PHPSimplifying Scotts code above by removing unnecessary loops which is slowing down badly and does not make it any more secure than calling openssl_random_pseudo_bytes just once