I\xe2\x80\x99ve only been trying it in Firefox\xe2\x80\x99s JavaScript console, but neither of the following statements return true:Try this code:For checking whether any value is NaN, instead of just numbers, see here: How do you test for NaN in Javascript?I just came across this technique in the book Effective JavaScript that is pretty simple:Since NaN is the only JavaScript value that is treated as unequal to itself, you can always test if a value is NaN by checking it for equality to itself:Didn\'t realize this until @allsyed commented, but this is in the ECMA spec: https://tc39.github.io/ecma262/#sec-isnan-numberUse this code:See isNaN() docs on MDN.As far as a value of type Number is to be tested whether it is a NaN or not, the global function isNaN will do the workFor a generic approach which works for all the types in JS, we can use any of the following:For ECMAScript-5 Users: For people using ECMAScript-6:And For consistency purpose across ECMAScript 5 & 6 both, we can also use this polyfill for Number.isNanplease check This Answer for more details.NaN is a special value that can\'t be tested like that. An interesting thing I just wanted to share is thisThis returns true only for NaN values and Is a safe way of testing. Should definitely be wrapped in a function or atleast commented, because It doesnt make much sense obviously to test if the same variable is not equal to each other, hehe.You should use the global isNaN(value) function call, because:Examples:I hope this will help you.While @chiborg \'s answer IS correct, there is more to it that should be noted:Point being, if you\'re using this method for validation of input, the result will be rather liberal.So, yes you can use parseFloat(string) (or in the case of full numbers parseInt(string, radix)\' and then subsequently wrap that with isNaN(), but be aware of the gotcha with numbers intertwined with additional non-numeric characters.To fix the issue where \'1.2geoff\' becomes parsed, just use the Number() parser instead.So rather than this:Do this:EDIT: I just noticed another issue from this though... false values (and true as a real boolean) passed into Number() return as 0! In which case... parseFloat works every time instead. So fall back to that:And that covers seemingly everything. I benchmarked it at 90% slower than lodash\'s _.isNaN but then that one doesn\'t cover all the NaN\'s:http://jsperf.com/own-isnan-vs-underscore-lodash-isnanJust to be clear, mine takes care of the human literal interpretation of something that is "Not a Number" and lodash\'s takes care of the computer literal interpretation of checking if something is "NaN".REALLY super simple! Here! Have this method!Use as simple as:See performance test here using this func vs selected answerAlso: See below 1st example for a couple alternate implementations.There are a couple alternate paths you take for implementaion, if you don\'t want to use an alternately named method, and would like to ensure it\'s more globally available. Warning These solutions involve altering native objects, and may not be your best solution. Always use caution and be aware that other Libraries you might use may depend on native code or similar alterations.Alternate solution test if emptyA simple window method I wrote that test if object is Empty. It\'s a little different in that it doesn\'t give if item is "exactly" NaN, but I figured I\'d throw this up as it may also be useful when looking for empty items.This last one goes a bit deep, even checking if an Object is full of blank Objects. I\'m sure it has room for improvement and possible pits, but so far, it appears to catch most everything. As of ES6, Object.is(..) is a new utility that can be used to test two values for absolute equality:If your environment supports ECMAScript 2015, then you might want to use Number.isNaN to make sure that the value is really NaN.The problem with isNaN is, if you use that with non-numeric data there are few confusing rules (as per MDN) are applied. For example,So, in ECMA Script 2015 supported environments, you might want to use It seems that isNaN() is not supported in Node.js out of the box.\nI worked around with  I use underscore\'s isNaN function because in JavaScript:At the least, be aware of that gotcha.I just want to share another alternative, it\'s not necessarily better than others here, but I think it\'s worth looking at:The logic behind this is that every number except 0 and NaN are cast to true.I\'ve done a quick test, and it performs as good as Number.isNaN and as checking against itself for false. All three perform better than isNanThe resultsMay become useful if you want to avoid the broken isNaN function.The exact way to check is:According to IEEE 754, all relationships involving NaN evaluate as false except !=.  Thus, for example, (A >= B) = false and (A <= B) = false if A or B or both is/are NaN.Equality operator (== and ===) cannot be used to test a value against NaN.Look at Mozilla Documentation The global NaN property is a value representing Not-A-NumbeThe best way is using \'isNaN()\' which is buit-in function  to check NaN. All browsers supports the way..I wrote this answer to another question on StackOverflow where another checks when NaN == null but then it was marked as duplicate so I don\'t want to waste my job.Look at Mozilla Developer Network about NaN.Just use distance || 0 when you want to be sure you value is a proper number or isNaN() to check it.The NaN (Not-a-Number) is a weirdo Global Object in javascript frequently returned when some mathematical operation failed.You wanted to check if NaN == null which results false. Hovewer even NaN == NaN results with false.A Simple way to find out if variable is NaN is an global function isNaN().Another is x !== x which is only true when x is NaN. (thanks for remind to @raphael-schweikert)Let\'s find out.When you call NaN == false the result is false, same with NaN == true.Somewhere in specifications JavaScript has an record with always false values, which includes:Another solution is mentioned in MDN\'s parseFloat pageIt provides a filter function to do strict parsingAnd then you can use isNaN to check if it is NaNI\'ve created this little function that works like a charm.\nInstead of checking for NaN which seems to be counter intuitive, you check for a number. I\'m pretty sure I am not the first to do it this way, but I thought i\'d share.Found another way, just for fun.marksyzm\'s answer works well, but it does not return false for Infinity as Infinity is techinicly not a number.i came up with a isNumber function that will check if it is a number.UPDATE:\ni noticed that this code fails for some parameters, so i made it better.This is not elegant. but after trying isNAN() I arrived at this solution which is another alternative. In this example I also allowed \'.\' because I am masking for float. You could also reverse this to make sure no numbers are used. This is a single character evaluation but you could also loop through a string to check for any numbers.NaN in JavaScript stands for "Not A Number", although its type is actually number.To check if a variable is of value NaN, we cannot simply use function isNaN(), because isNaN() has the following issue, see below:What really happens here is that myVar is implicitly coerced to a number:It actually makes sense, because "A" is actually not a number. But what we really want to check is if myVar is exactly of value NaN.So isNaN() cannot help. Then what should we do instead?In the light that NaN is the only JavaScript value that is treated unequal to itself, so we can check for its equality to itself using !==So to conclude, if it is true that a variable !== itself, then this variable is exactly of value NaN:Is (NaN >= 0) ?...... "I don\'t Know".Conditions only execute if TRUE.Not on FALSE.Not on "I Don\'t Know".Simply convert the result to String and compare with \'NaN\'.