Consider the main axis and cross axis of a flex container:\n                                                                                                                       Source: W3CTo align flex items along the main axis there is one property:To align flex items along the cross axis there are three properties:In the image above, the main axis is horizontal and the cross axis is vertical. These are the default directions of a flex container.However, these directions can be easily interchanged with the flex-direction property.(The cross axis is always perpendicular to the main axis.)My point in describing how the axes\' work is that there doesn\'t seem to be anything special about either direction. Main axis, cross axis, they\'re both equal in terms of importance and flex-direction makes it easy to switch back and forth. So why does the cross axis get two additional alignment properties?Why are align-content and align-items consolidated into one property for the main axis?Why does the main axis not get a justify-self property?Scenarios where these properties would be useful:placing a flex item in the corner of the flex container\n#box3 { align-self: flex-end; justify-self: flex-end; }making a group of flex items align-right (justify-content: flex-end) but have the first item align left (justify-self: flex-start)Consider a header section with a group of nav items and a logo. With justify-self the logo could be aligned left while the nav items stay far right, and the whole thing adjusts smoothly ("flexes") to different screen sizes.in a row of three flex items, affix the middle item to the center of the container  (justify-content: center) and align the adjacent items to the container edges (justify-self: flex-start and justify-self: flex-end). Note that values space-around and space-between on\njustify-content property  will not keep the middle item centered in relation to the container if the adjacent items have different widths.jsFiddle versionAs of this writing, there is no mention of justify-self or justify-items in the flexbox spec.However, in the CSS Box Alignment Module, which is the W3C\'s unfinished proposal to establish a common set of alignment properties for use across all box models, there is this:\n                                                                                                                       \nSource: W3CYou\'ll notice that justify-self and justify-items are being considered... but not for flexbox.I\'ll end by reiterating the main question:Why are there no "justify-items" and "justify-self" properties?As stated in the question:To align flex items along the main axis there is one property: justify-contentTo align flex items along the cross axis there are three properties: align-content, align-items and align-self.The question then asks:Why are there no justify-items and justify-self properties?One answer may be: Because they\'re not necessary.The flexbox specification provides two methods for aligning flex items along the main axis:justify-contentThe justify-content property aligns flex items along the main axis of the flex container. It is applied to the flex container but only affects flex items. There are five alignment options:flex-start ~ Flex items are packed toward the start of the line.flex-end ~ Flex items are packed toward the end of the line.center ~ Flex items are packed toward the center of the line.space-between ~ Flex items are evenly spaced, with the first item aligned to one edge of the container and the last item aligned to the opposite edge. The edges used by the first and last items depends on flex-direction and writing mode (ltr or rtl).space-around ~ Same as space-between except with half-size spaces on both ends.With auto margins, flex items can be centered, spaced away or packed into sub-groups.Unlike justify-content, which is applied to the flex container, auto margins go on flex items.Scenario from the question:making a group of flex items align-right (justify-content: flex-end)\n  but have the first item align left (justify-self: flex-start)Consider a header section with a group of nav items and a logo. With\n  justify-self the logo could be aligned left while the nav items stay\n  far right, and the whole thing adjusts smoothly ("flexes") to\n  different screen sizes.Other useful scenarios:Scenario from the question:margin: auto is an alternative to justify-content: center and align-items: center.Instead of this code on the flex container:You can use this on the flex item:This alternative is useful when centering a flex item that overflows the container.A flex container aligns flex items by distributing free space.Hence, in order to create equal balance, so that a middle item can be centered in the container with a single item alongside, a counterbalance must be introduced.In the examples below, invisible third flex items (boxes 61 & 68) are introduced to balance out the "real" items (box 63 & 66).Of course, this method is nothing great in terms of semantics.Alternatively, you can use a pseudo-element instead of an actual DOM element. Or you can use absolute positioning. All three methods are covered here: Center and bottom-align flex itemsNOTE: The examples above will only work – in terms of true centering – when the outermost items are equal height/width. When flex items are different lengths, see next example.Scenario from the question:in a row of three flex items, affix the middle item to the center of the container  (justify-content: center) and align the adjacent\n  items to the container edges (justify-self: flex-start and\n  justify-self: flex-end). Note that values space-around and space-between on justify-content property  will not keep the middle item centered in relation to the container if the adjacent items have different widths (see demo).As noted, unless all flex items are of equal width or height (depending on flex-direction), the middle item cannot be truly centered. This problem makes a strong case for a justify-self property (designed to handle the task, of course).Here are two methods for solving this problem:Solution #1: Absolute PositioningThe flexbox spec allows for absolute positioning of flex items. This allows for the middle item to be perfectly centered regardless of the size of its siblings.Just keep in mind that, like all absolutely positioned elements, the items are removed from the document flow. This means they don\'t take up space in the container and can overlap their siblings. In the examples below, the middle item is centered with absolute positioning and the outer items remain in-flow. But the same layout can be achieved in reverse fashion: Center the middle item with justify-content: center and absolutely position the outer items.Solution #2: Nested Flex Containers (no absolute positioning)Here\'s how it works:You could also forgo justify-content and use auto margins exclusively.But justify-content can work here because auto margins always have priority. From the spec:8.1. Aligning with auto\n  marginsPrior to alignment via justify-content and align-self, any\n  positive free space is distributed to auto margins in that dimension.justify-content: space-same (concept)Going back to justify-content for a minute, here\'s an idea for one more option.This layout can be achieved with ::before and ::after pseudo-elements on the flex container.(credit: @oriol for the code, and @crl for the label)UPDATE: Browsers have begun implementing space-evenly, which accomplishes the above. See this post for details: Equal spacing around flex itemsPLAYGROUND (includes code for all examples above)I know not an answer but I like to contribute to this matter for what it\'s worth. It would be great if they could release justify-self for flexbox to make it truly flexible. In my believe when there are multiple items on the axis, the most logical way for justify-self to behave is to align itself to it\'s nearest neighbors (or edge) as demonstrated below. I truly hope, W3C watches this and will at least consider it. =)This way you can have an item that is truly centered regardless of the size of the left and right box. When one of the boxes reaches the point of the center box it will simply push it until there is no more space to distribute.The ease of making awesome layouts are endless, take a look at this "complex" example.This was asked on the www-style list, and Tab Atkins (spec editor) provided an answer explaining why. I\'ll elaborate on that a bit here.To start out, let\'s initially assume our flex container is single-line (flex-wrap: nowrap). In this case, there\'s clearly an alignment difference between the main axis and the cross axis -- there are multiple items stacked in the main axis, but only one item stacked in the cross axis. So it makes sense to have a customizeable-per-item "align-self" in the cross axis (since each item is aligned separately, on its own), whereas it doesn\'t make sense in the main axis (since there, the items are aligned collectively).For multi-line flexbox, the same logic applies to each "flex line". In a given line, items are aligned individually in the cross axis (since there\'s only one item per line, in the cross axis), vs. collectively in the main axis.Here\'s another way of phrasing it: so, all of the *-self and *-content properties are about how to distribute extra space around things.  But the key difference is that the *-self versions are for cases where there\'s only a single thing in that axis, and the *-content versions are for when there are potentially many things in that axis. The one-thing vs. many-things scenarios are different types of problems, and so they have different types of options available -- for example, the space-around / space-between values make sense for *-content, but not for *-self.SO: In a flexbox\'s main axis, there are many things to distribute space around. So a *-content property makes sense there, but not a *-self property.In contrast, in the cross axis, we have both a *-self and a *-content property.  One determines how we\'ll distribute space around the many flex lines (align-content), and one determines how to distribute space around individual flex items in the cross axis, within a given flex line.(I\'m ignoring *-items properties here, since they simply establish defaults for *-self.)There is justify-self, but in Chrome Canary, not in Chrome stable version. There is even justify-items:But as far as I can tell those properties do not work either. So probably Google saved it beforehand for future CSS releases. Can only hope they will add the properties soon.