I know, I\'ve read about the difference between double precision and single precision, etc. But they should give the same results on most cases right?I was solving a problem on a programming contest and there were calculations with floating point numbers that were not really big, so I decided to use float instead of double, and I checked it - I was getting the correct results. But when I send the solution, it said only 1 of 10 tests was correct. I checked again and again, until I found that using float is not the same using double. I put double for the calculations and double for the output, and the program gave the SAME results, but this time it passed all the 10 tests correctly.I repeat, the output was the SAME, the results were the SAME, but putting float didn\'t work - only double. The values were not so big too, and the program gave the same results on the same tests both with float and double, but the online judge accepted only the double-provided solution.Why? What is the difference?Huge difference.As the name implies, a double has 2x the precision of float[1]. In general a double has 15 decimal digits of precision, while float has 7.Here\'s how the number of digits are calculated:double has 52 mantissa bits + 1 hidden bit: log(253)\xc3\xb7log(10) = 15.95 digitsfloat has 23 mantissa bits + 1 hidden bit: log(224)\xc3\xb7log(10) = 7.22 digitsThis precision loss could lead to truncation errors much easier to float up, e.g.whileAlso, the maximum value of float is about 3e38, but double is about 1.7e308, so using float can hit Infinity much more easily than double for something simple e.g. computing 60 factorial.Maybe their test case contains these huge numbers which causes your program to fail.Of course sometimes even double isn\'t accurate enough, hence we sometimes have long double[1] (the above example gives 9.000000000000000066 on Mac), but all floating point types suffer from round-off errors, so if precision is very important (e.g. money processing) you should use int or a fraction class.BTW, don\'t use += to sum lots of floating point numbers as the errors accumulate quickly. If you\'re using Python, use fsum. Otherwise, try to implement the Kahan summation algorithm.[1]: The C and C++ standards do not specify the representation of float, double and long double. It is possible that all three are implemented as IEEE double-precision. Nevertheless, for most architectures (gcc, MSVC; x86, x64, ARM) float is indeed a IEEE single-precision floating point number (binary32), and double is a IEEE double-precision floating point number (binary64).Here is what the standard C99 (ISO-IEC 9899 6.2.5 \xc2\xa710) or C++2003 (ISO-IEC 14882-2003 3.1.9 \xc2\xa78) standards say:There are three floating point types: float, double, and long double. The type double provides at least as much precision as float, and the type long double provides at least as much precision as double. The set of values of the type float is a subset of the set of values of the type double; the set of values of the type double is a subset of the set of values of the type long double.The C++ standard adds:The value representation of floating-point types is implementation-defined.I would suggest having a look at the excellent What Every Computer Scientist Should Know About Floating-Point Arithmetic that covers the IEEE floating-point standard in depth. You\'ll learn about the representation details and you\'ll realize there is a tradeoff between magnitude and precision. The precision of the floating point representation increases as the magnitude decreases, hence floating point numbers between -1 and 1 are those with the most precision.Given a quadratic equation: x2 − 4.0000000 x + 3.9999999 = 0, the exact roots to 10 significant digits are, r1 = 2.000316228 and r2 = 1.999683772.Using float and double, we can write a test program:Running the program gives me:Note that the numbers aren\'t large, but still you get cancellation effects using float.(In fact, the above is not the best way of solving quadratic equations using either single- or double-precision floating-point numbers, but the answer remains unchanged even if one uses a more stable method.)"there were calculations with floating\n  point numbers that were not really\n  big"The size of the numbers is irrelevant it\'s the calculation that is being performed that is relevant. In essence if you\'re performing a calculation and the result is an irrational number or recurring decimal then there will be rounding errors when that number is squashed into the finite size datastructure you\'re using. Since double is twice the size of float then the rounding error will be a lot smaller.The online test probably specifically used numbers which would cause this kind of error and therefore tested that you\'d used the appropriate type in your code.Floats have less precision than doubles. Although you already know, read  What WE Should Know About Floating-Point Arithmetic for better understanding.type float, 32 bits long, has a precision of 7 digits. While it may store values with very large or very small range (+/- 3.4 * 10^38 or * 10^-38), it has only 7 significant digits.type double, 64 bits long, has a bigger range ( *10^+/-308) and 15 digits precision.long double is nominally 80 bits, though a given compiler/OS pairing may store it as 12-16 bytes for alignment purposes. The long double has an exponent that just ridiculously huge, and should have 19 digits precision. M$, in their infinite wisdom, limits long double to 8 bytes, same as plain double.Generally speaking, just use type double when you need a floating point value/variable. Literal floating point values used in expressions will be treated as doubles by default, and most of the math functions that return floating point values return doubles. You\'ll save yourself many headaches and typecastings if you just use double. When using floating point numbers you cannot trust that your local tests will be exactly the same as the tests that are done on the server side. The environment and the compiler are probably different on you local system and where the final tests are run. I have seen this problem many times before in some TopCoder competitions especially if you try to compare two floating point numbers.I just run into a error that took me forever to figure out and potentially can give you a good example of float precision.The output is \n00.010.020.030.040.050.060.070.080.090.10.110.120.130.140.150.160.170.180.190.20.210.220.230.240.250.260.270.280.290.30.310.320.330.340.350.360.370.380.390.40.410.420.430.440.450.460.470.480.490.50.510.520.530.540.550.560.570.580.590.60.610.620.630.640.650.660.670.680.690.70.710.720.730.740.750.760.770.780.790.80.810.820.830.8399990.8499990.8599990.8699990.8799990.8899990.8999990.9099990.9199990.9299990.9399990.9499990.9599990.9699990.9799990.9899990.999999As you can see since 0.83, the precision runs down significantly.However, if I set up t as double, such issue won\'t happen.It took me five hours to realize this minor error, which ruined my program.Hope it\'s helpful.The built-in comparison operations differ as in when you compare 2 numbers with floating point, the difference in data type (i.e. float or double) may result in different outcomes.Unlike an int (whole number), a float have a decimal point, and so can a double.\nBut the difference between the two is that a double is twice as detailed as a float, meaning that it can have double the amount of numbers after the decimal point.float and double are floating binary point types. In other words, they represent a number like this:10001.10010110011\nThe binary number and the location of the binary point are both encoded within the value.decimal is a floating decimal point type. In other words, they represent a number like this:12345.65789