I use LINQ to Objects instructions on an ordered array. \nWhich operations shouldn\'t I do to be sure the order of the array is not changed?I examined the methods of System.Linq.Enumerable, discarding any that returned non-IEnumerable results.  I checked the remarks of each to determine how the order of the result would differ from order of the source.Preserves Order Absolutely.  You can map a source element by index to a result elementPreserves Order.  Elements are filtered, but not re-ordered.Destroys Order - we don\'t know what order to expect results in.Redefines Order Explicitly - use these to change the order of the resultRedefines Order according to some rules.Edit: I\'ve moved Distinct to Preserving order based on this implementation.Are you actually talking about SQL, or about arrays? To put it another way, are you using LINQ to SQL or LINQ to Objects?The LINQ to Objects operators don\'t actually change their original data source - they build sequences which are effectively backed by the data source. The only operations which change the ordering are OrderBy/OrderByDescending/ThenBy/ThenByDescending - and even then, those are stable for equally ordered elements. Of course, many operations will filter out some elements, but the elements which are returned will be in the same order.If you convert to a different data structure, e.g. with ToLookup or ToDictionary, I don\'t believe order is preserved at that point - but that\'s somewhat different anyway. (The order of values mapping to the same key is preserved for lookups though, I believe.)If you are working on an array, it sounds like you are using LINQ-to-Objects, not SQL;  can you confirm? Most LINQ operations don\'t re-order anything (the output will be in the same order as the input) - so don\'t apply another sort (OrderBy[Descending]/ThenBy[Descending]).[edit: as Jon put more clearly; LINQ generally creates a new sequence, leaving the original data alone]Note that pushing the data into a Dictionary<,> (ToDictionary) will scramble the data, as dictionary does not respect any particular sort order.But most common things (Select, Where, Skip, Take) should be fine.Any \'group by\' or \'order by\' will possibly change the order.I found a great answer in a similar question which references official documentation. To quote it:For Enumerable methods (LINQ to Objects, which applies to List<T>), you can rely on the order of elements returned by Select, Where, or GroupBy. This is not the case for things that are inherently unordered like ToDictionary or Distinct.The IGrouping<TKey, TElement> objects are yielded in an order based on the order of the elements in source that produced the first key of each IGrouping<TKey, TElement>. Elements in a grouping are yielded in the order they appear in source.This is not necessarily true for IQueryable extension methods (other LINQ providers).Source: Do LINQ's Enumerable Methods Maintain Relative Order of Elements?