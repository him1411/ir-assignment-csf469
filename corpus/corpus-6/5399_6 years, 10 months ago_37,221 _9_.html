I flubbed up my history and want to do some changes to it. Problem is, I have a commit with two unrelated changes, and this commit is surrounded by some other changes in my local (non-pushed) history.I want to split up this commit before I push it out, but most of the guides I\'m seeing have to do with splitting up your most recent commit, or uncommitted local changes. Is it feasible to do this to a commit that is buried in history a bit, without having to "re-do" my commits since then?There is a guide to splitting commits in the rebase manpage. The quick summary is:Perform an interactive rebase including the target commit (e.g. git rebase -i <commit-to-split>^ branch) and mark it to be edited.When the rebase reaches that commit, use git reset HEAD^ to reset to before the commit, but keep your work tree intact.Incrementally add changes and commit them, making as many commits as desired. add -p can be useful to add only some of the changes in a given file. Use commit -c ORIG_HEAD if you want to re-use the original commit message for a certain commit.If you want to test what you\'re committing (good idea!) use git stash to hide away the part you haven\'t committed (or stash --keep-index before you even commit it), test, then git stash pop to return the rest to the work tree. Keep making commits until you get all modifications committed, i.e. have a clean work tree.Run git rebase --continue to proceed applying the commits after the now-split commit.If you haven\'t pushed yet, just use git rebase. Even better, use git rebase -i to move commits around interactively. You can move the offending commit to the front, then split it up as you like and move the patches back (if needed).