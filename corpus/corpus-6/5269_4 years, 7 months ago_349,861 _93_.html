How do I check if a variable is an integer in JavaScript, and throw an alert if it isn\'t?  I tried this, but it doesn\'t work:use the === operator as belowThat depends, do you also want to cast strings as potential integers as well?This will do:Simple parse and checkShort-circuiting, and saving a parse operation:Or perhaps both in one shot:Tests:Here\'s the fiddle: http://jsfiddle.net/opfyrqwp/28/Here\'s the yolpo: http://www.yolpo.com/embed.html?gist=a3c46f837ea7bbb708ae&autoplay=2Testing reveals that the short-circuiting solution has the best performance (ops/sec).Here is a benchmark:\nhttp://jsben.ch/#/htLVwIf you fancy a shorter, obtuse form of short circuiting:Of course, I\'d suggest letting the minifier take care of that.Assuming you don\'t know anything about the variable in question, you should take this approach:To put it simply:You could check if the number has a remainder:Mind you, if your input could also be text and you want to check first it is not, then you can check the type first:Number.isInteger() seems to be the way to go.MDN has also provided the following polyfill for browsers not supporting Number.isInteger(), mainly all versions of IE.Link to MDN pageBe careful while usingnum % 1empty string (\'\') or boolean (true or false) will return as integer. You might not want to do thatbuild in function in the browser. Dosnt support older browsersAlternatives:However, Math.round() also will fail for empty string and booleanYou can use a simple regular expression:First off, NaN is a "number" (yes I know it\'s weird, just roll with it), and not a "function".You need to check both if the type of the variable is a number, and to check for integer I would use modulus.To check if integer like poster wants:notice + in front of data (converts string to number), and === for exact.Here are examples:ECMA-262 6.0 (ES6) standard include Number.isInteger function.In order to add support for old browser I highly recommend using strong and community supported solution from:https://github.com/paulmillr/es6-shimwhich is pure ES6 JS polyfills library.Note that this lib require es5-shim, just follow README.md.You could tryNumber.isInteger(Number(value)) if value might be an integer in string form e.g var value = "23" and you want this to evaluate to true. Avoid trying Number.isInteger(parseInt(value)) because this won\'t always return the correct value. e.g if var value = "23abc" and you use the parseInt implementation, it would still return true.But if you want strictly integer values then probably Number.isInteger(value) should do the trick.Check if the variable is equal to that same variable rounded to an integer, like this:Number.isInteger() is the best way if your browser support it, if not, I think there are so many ways to go:or:or:or:now we can test the results:So, all of these methods are works, but when the number is very big, parseInt and ^ operator would not works well.The simplest and cleanest pre-ECMAScript-6 solution (which is also sufficiently robust to return false even if a non-numeric value such as a string or null is passed to the function) would be the following:The following solution would also work, although not as elegant as the one above:Note that Math.ceil() or Math.floor() could be used equally well (instead of Math.round()) in the above implementation.Or alternatively:One fairly common incorrect solution is the following:While this parseInt-based approach will work well for many values of x, once x becomes quite large, it will fail to work properly. The problem is that parseInt() coerces its first parameter to a string before parsing digits. Therefore, once the number becomes sufficiently large, its string representation will be presented in exponential form (e.g., 1e+21). Accordingly, parseInt() will then try to parse 1e+21, but will stop parsing when it reaches the e character and will therefore return a value of 1. Observe:Besides, Number.isInteger(). Maybe Number.isSafeInteger() is another option here by using the ES6-specified.To polyfill Number.isSafeInteger(..) in pre-ES6 browsers:You can use regexp for this:You could use this function:It will return true even if the value is a string containing an integer value.\nSo, the results will be:From http://www.toptal.com/javascript/interview-questions:Found it to be the best way to do this.Use the | operator:So, a test function might look like this:This will solve one more scenario (121.), a dot at endFor positive integer values without separators:Tests\n1. if not empty and\n2. if value is equal to the result of a replace of a non-digit char in its value.I had to check if a variable (string or number) is an integer and I used this condition:http://jsfiddle.net/e267369d/1/Some of the other answers have a similar solution (rely on parseFloat combined with isNaN), but mine should be more straight forward and self explaining.Edit: I found out that my method fails for strings containing comma (like "1,2") and I also realized that in my particular case I want the function to fail if a string is not a valid integer (should fail on any float, even 1.0). So here is my function Mk II:http://jsfiddle.net/e267369d/3/Of course in case you actually need the function to accept integer floats (1.0 stuff), you can always remove the dot condition a.indexOf(\'.\') == -1.Usage:or:Usage:Lodash https://lodash.com/docs#isInteger (since 4.0.0) has function to check if variable is an integer:After few successes and failures, I came up with this solution:I liked the idea above of checking the value for not being NaN and use parseFloat, but when I tried it in React infrastructure it didn\'t work for some reason.Edit:\nI found a nicer way without using strings:I think it\'s the shortest answer. Maybe even the most efficient, but I could be stand corrected. :)function isInteger(x) { return (x^0) === x; } \nThe following solution would also work, although not as elegant as the one above:function isInteger(x) { return Math.round(x) === x; }\nNote that Math.ceil() or Math.floor() could be used equally well (instead of Math.round()) in the above implementation.Or alternatively: function isInteger(x) { return (typeof x === \'number\') && (x % 1 === 0); }One fairly common incorrect solution is the following:function isInteger(x) { return parseInt(x, 10) === x; }While this parseInt-based approach will work well for many values of x, once x becomes quite large, it will fail to work properly. The problem is that parseInt() coerces its first parameter to a string before parsing digits. Therefore, once the number becomes sufficiently large, its string representation will be presented in exponential form (e.g., 1e+21). Accordingly, parseInt() will then try to parse 1e+21, but will stop parsing when it reaches the e character and will therefore return a value of 1. Observe:String(1000000000000000000000)\n  \'1e+21\'parseInt(1000000000000000000000, 10)\n  1parseInt(1000000000000000000000, 10) === 1000000000000000000000\n  falseYou can use regexp to do this:It will return false if data isn\'t an integer, true otherwise.It Works for Me.. Try this one..You can use keypress,keyup,keydown etc, instead of input.