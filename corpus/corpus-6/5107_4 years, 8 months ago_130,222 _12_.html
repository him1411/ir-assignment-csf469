I\'m trying to represent a simplified chromosome, which consists of N bases, each of which can only be one of {A, C, T, G}.I\'d like to formalize the constraints with an enum, but I\'m wondering what the most idiomatic way of emulating an enum is in Go.Quoting from the language specs:IotaWithin a constant declaration, the predeclared identifier iota represents successive untyped integer constants. It is reset to 0 whenever the reserved word const appears in the source and increments after each ConstSpec. It can be used to construct a set of related constants:Within an ExpressionList, the value of each iota is the same because it is only incremented after each ConstSpec:This last example exploits the implicit repetition of the last non-empty expression list.So your code might be likeorif you want bases to be a separate type from int.Refering to the answer of jnml, you could prevent new instances of Base type by not exporting the Base type at all (i.e. write it lowercase). If needed, you may make an exportable interface that has a method that returns a base type, so that this interface could be used in functions from the outside that deal with Bases, i.e.Inside the main package a.Baser is effectively like an enum now.\nOnly inside the a package you may defined new instances.As of Go 1.4, the go generate tool has been introduced together with the stringer command that makes your enum easily debuggable and printable.