When writing custom classes it is often important to allow equivalence by means of the == and != operators. In Python, this is made possible by implementing the __eq__ and __ne__ special methods, respectively. The easiest way I\'ve found to do this is the following method:Do you know of more elegant means of doing this? Do you know of any particular disadvantages to using the above method of comparing __dict__s?Note: A bit of clarification--when __eq__ and __ne__ are undefined, you\'ll find this behavior:That is, a == b evaluates to False because it really runs a is b, a test of identity (i.e., "Is a the same object as b?").When __eq__ and __ne__ are defined, you\'ll find this behavior (which is the one we\'re after):Sorry, but non of the answers fully "work".\nConsider the simple problem:So, Python by default uses the id of objects for comparison.Overriding the __eq__ function seems to solve the problem:Always remember to add the __ne__ function override:But that doesn\'t solve all our problems.\nLet\'s add a subclass:Note - new style classes behave a bit differently yet I will provide a generic solution.  To fix we need to return the singleton NotImplemented when the object types do not match, delegating the result to superclass.__eq__(subclass).  The result looks like this:Are we there yet? Not quite.\nHow many unique numbers do we have?Hmmm. Sets use the hashes of objects, and by default Python returns the id() of the object as a hash. Let\'s try to override:The end result looks like this (I added some assertions at the end for validation):You need to be careful with inheritance:Check types more strictly, like this:Besides that, your approach will work fine, that\'s what special methods are there for.The way you describe is the way I\'ve always done it. Since it\'s totally generic, you can always break that functionality out into a mixin class and inherit it in classes where you want that functionality.Not a direct answer but seemed relevant enough to be tacked on as it saves a bit of verbose tedium on occasion. Cut straight from the docs...functools.total_ordering(cls)Given a class defining one or more rich comparison ordering methods, this class decorator supplies the rest. This simplifies the effort involved in specifying all of the possible rich comparison operations:The class must define one of lt(), le(), gt(), or ge(). In addition, the class should supply an eq() method.New in version 2.7You don\'t have to override both __eq__ and __ne__ you can override only __cmp__ but this will make an implication on the result of ==, !==, < , > and so on.is tests for object identity. This means a is b will be True in the case when a and b both hold the reference to the same object. In python you always hold a reference to an object in a variable not the actual object, so essentially for a is b to be true the objects in them should be located in the same memory location. How and most importantly why would you go about overriding this behaviour?Edit: I didn\'t know __cmp__ was removed from python 3 so avoid it.From this answer: https://stackoverflow.com/a/30676267/541136 I have demonstrated that, while it\'s correct to define __ne__ in terms __eq__ - instead of you should use:I think that the two terms you\'re looking for are equality (==) and identity (is). For example:The \'is\' test will test for identity using the builtin \'id()\' function which essentially returns the memory address of the object and therefore isn\'t overloadable.However in the case of testing the equality of a class you probably want to be a little bit more strict about your tests and only compare the data attributes in your class:This code will only compare non function data members of your class as well as skipping anything private which is generally what you want. In the case of Plain Old Python Objects I have a base class which implements __init__, __str__, __repr__ and __eq__ so my POPO objects don\'t carry the burden of all that extra (and in most cases identical) logic.