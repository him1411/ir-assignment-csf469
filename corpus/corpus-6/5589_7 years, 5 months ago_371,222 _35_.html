Fri Jul 08 2005 00:00:00 GMT-0700 (PST)Thu Jul 07 2005 17:00:00 GMT-0700 (PST)Why is the second parse incorrect?Until the 5th edition spec came out, the Date.parse method was completely implementation dependent (new Date(string) is equivalent to Date.parse(string) except the latter returns a number rather than a Date). In the 5th edition spec the requirement was added to support a simplified (and slightly incorrect) ISO-8601, but other than that, there was no requirement for what Date.parse / new Date(string) should accept other than that they had to accept whatever Date#toString output (without saying what that was).I would recommend you to parse your date string manually, and use the Date constructor with the year, month and day arguments to avoid ambiguity:During recent experience writing a JS interpreter I wrestled plenty with the inner workings of ECMA/JS dates. So, I figure I\'ll throw in my 2 cents here. Hopefully sharing this stuff will help others with any questions about the differences among browsers in how they handle dates.All implementations store their date values internally as 64-bit numbers that represent the number of milliseconds since 1/1/1970 UTC (GMT is the same thing as UTC). Dates occurring after 1/1/1970 00:00:00 are positive numbers and dates prior are negative.Therefore, the following code produces the exact same result on all browsers.In my timezone (EST), the result is 18000000 because that\'s how many ms are in 5 hours (it\'s only 4 hours during daylight savings months). The value will be different in different time zones. All the major browsers do it the same way.Here is the rub though. While there is some variance in the input string formats that the major browsers will parse as dates, they essentially interpret them the same as far as time zones and daylight savings are concerned. The one hold out is the ISO 8601 format. It\'s the only format outlined in the ECMA-262 v.5 spec specifically. For all other string formats, the interpretation is implementation-dependent. Ironically, this is the format where browsers can differ. Here is a comparison output of Chrome vs Firefox for 1/1/1970 on my machine using the ISO 8601 string format.But here is where it gets worse, FF treats the short form of the ISO 8601 format ("YYYY-MM-DD") differently than it treats the long form ("YYYY-MM-DDTHH:mm:ss:sssZ") for no logical reason whatsoever. Here is the output from FF with the long and short ISO date formats with no time zone specifier.So, to answer the original asker\'s question directly, "YYYY-MM-DD" is the short form of the ISO 8601 format "YYYY-MM-DDTHH:mm:ss:sssZ". So, it is interpreted as UTC time while the other is interpreted as local. That\'s why, The bottom line is this for parsing date strings. The ONLY ISO 8601 string that you can safely parse across browsers is the long form. And, ALWAYS use the "Z" specifier. If you do that you can safely go back and forth between local and UTC time.Fortunately, most current browsers do treat the other input formats equally, including the most frequently used \'1/1/1970\' and \'1/1/1970 00:00:00 AM\' formats. All of the following formats (and others) are treated as local time input in all browsers and converted to UTC before storage. Thus, making them cross-browser compatible. The output of this code is the same in all browsers in my timezone.On the output side, all browsers translate time zones the same way but they handle the string formats differently. Here are the toString functions and what they output. Notice the toUTCString and toISOString functions output 5:00 AM on my machine.Converts from UTC to Local time before printingPrints the stored UTC time directlyI normally don\'t use the ISO format for string input. The only time that using that format is beneficial to me is when dates need to be sorted as strings. The ISO format is sortable as-is while the others are not. If you have to have cross-browser compatibility, either specify the timezone or use a compatible string format.The code new Date(\'12/4/2013\').toString() goes through the following internal pseudo-transformation:I hope this answer was helpful.There is some method to the madness. As a general rule, if a browser can interpret a date as an ISO-8601, it will. "2005-07-08" falls into this camp, and so it is parsed as UTC. "Jul 8, 2005" cannot, and so it is parsed in the local time.See JavaScript and Dates, What a Mess! for more.Another solution is to build an associative array with date format and then reformat data.This method is useful for date formatted in an unussual way.An example:According to http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html the format "yyyy/mm/dd" solves the usual problems. \nHe says: "Stick to "YYYY/MM/DD" for your date strings whenever possible. It\'s universally supported and unambiguous. With this format, all times are local."\nI\'ve set tests: http://jsfiddle.net/jlanus/ND2Qg/432/\nThis format: \n + avoids the day and month order ambiguity by using y m d ordering and a 4-digit year\n + avoids the UTC vs. local issue not complying with ISO format by using slashes\n + danvk, the dygraphs guy, says that this format is good in all browsers. While CMS is correct that passing strings into the parse method is generally unsafe, the new ECMA-262 5th Edition (aka ES5) specification in section 15.9.4.2 suggests that Date.parse() actually should handle ISO-formatted dates.  The old specification made no such claim.  Of course, old browsers and some current browsers still do not provide this ES5 functionality.Your second example isn\'t wrong.  It is the specified date in UTC, as implied by Date.prototype.toISOString(), but is represented in your local timezone.This light weight date parsing library should solve all similar problems. I like the library because it is quite easy to extend. It\'s also possible to i18n it (not very straight forward, but not that hard).Parsing example:And formatting back to string (you will notice both cases give exactly the same result):Here is a short, flexible snippet to convert a datetime-string in a cross-browser-safe fashion as nicel detailed by @drankin2112.Your browser should provide the same timestamp result as Date.parse with:Use moment.js to parse dates:The 3rd argument determines strict parsing (available as of 2.3.0). Without it moment.js may also give incorrect results.