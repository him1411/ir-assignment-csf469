I\'ve used recursion quite a lot on my many years of programming to solve simple problems, but I\'m fully aware that sometimes you need iteration due to memory/speed problems.So, sometime in the very far past I went to try and find if there existed any "pattern" or text-book way of transforming a common recursion approach to iteration and found nothing. Or at least nothing that I can remember it would help.Usually, I replace a recursive algorithm by an iterative algorithm by pushing the parameters that would normally be passed to the recursive function onto a stack. In fact, you are replacing the program stack by one of your own.Note: if you have more than one recursive call inside and you want to preserve the order of the calls, you have to add them in the reverse order to the stack:has to be replaced byEdit: The article Stacks and Recursion Elimination (or Article Backup link) goes into more details on this subject.Really, the most common way to do it is to keep your own stack.  Here\'s a recursive quicksort function in C:Here\'s how we could make it iterative by keeping our own stack:Obviously, this example doesn\'t check stack boundaries... and really you could size the stack based on the worst case given left and and right values.  But you get the idea.It seems nobody has addressed where the recursive function calls itself more than once in the body, and handles returning to a specific point in the recursion (i.e. not primitive-recursive). It is said that every recursion can be turned into iteration, so it appears that this should be possible.I just came up with a C# example of how to do this.  Suppose you have the following recursive function, which acts like a postorder traversal, and that AbcTreeNode is a 3-ary tree with pointers a, b, c.The iterative solution:Strive to make your recursive call Tail Recursion (recursion where the last statement is the recursive call).  Once you have that, converting it to iteration is generally pretty easy.Well, in general, recursion can be mimicked as iteration by simply using a storage variable. Note that recursion and iteraction are generally equivalent; one can almost always be converted to the other. A tail-recursive function is very easily converted to an iterative one. Just make the accumulator variable a local one, and iterate instead of recurse. Here\'s an example in C++ (C were it not for the use of a default argument):Knowing me, I probably made a mistake in the code, but the idea is there.Even using stack will not convert a recursive algorithm into iterative. Normal recursion is function based recursion and if we use stack then it becomes stack based recursion. But its still recursion.For recursive algorithms, space complexity is O(N) and time complexity is O(N). \nFor iterative algorithms, space complexity is O(1) and time complexity is O(N). But if we use stack things in terms of complexity remains same. I think only tail recursion can be converted into iteration.The stacks and recursion elimination article captures the idea of externalizing the stack frame on heap, but does not provide a straightforward and repeatable way to convert. Below is one.While converting to iterative code, one must be aware that the recursive call may happen from an arbitrarily deep code block. Its not just the parameters, but also the point to return to the logic that remains to be executed and the state of variables which participate in subsequent conditionals, which matter. Below is a very simple way to convert to iterative code with least changes. Consider this recursive code:Iterative code:Notice how the structure of the code still remains true to the recursive logic and modifications are minimal, resulting in less number of bugs. For comparison, I have marked the changes with ++ and --. Most of the new inserted blocks except v.push_back, are common to any converted iterative logic +++++++++++++++++++++++++------------------------+++++++++++++++++++++++++-------------------------+++++++++++++++++++++++++-------------------------+++++++++++++++++++++++++-------------------------Search google for "Continuation passing style." There is a general procedure for converting to a tail recursive style; there is also a general procedure for turning tail recursive functions into loops.Generally the technique to avoid stack overflow is for recursive functions is called trampoline technique which is widely adopted by Java devs.However, for C# there is a little helper method here that turns your recursive function to iterative without requiring to change logic or make the code in-comprehensible. C# is such a nice language that amazing stuff is possible with it.It works by wrapping parts of the method by a helper method. For example the following recursive function:Turns into:Just killing time... A recursive function can be converted toOne pattern to look for is a recursion call at the end of the function (so called tail-recursion). This can easily be replaced with a while. For example, the function foo:ends with a call to foo. This can be replaced with:which eliminates the second recursive call.I just upvoted the answer suggesting to use an explicit stack that I think is the right solution and is of general applicability.I mean that you can use it to transform any recursive function in an iterative function. Just check which values are saved across recursive calls, those are the ones that have to be local to the recursive function, and replace the calls with a cycle where you\'ll push them on a stack. When the stack is empty the recursive function would have been terminated.I can\'t resist to say that the proof that every recursive function is equivalent to an iterative function on a different data type, it\'s one of my dearest memory of my University times. That was the course (and the professor) that really made me understand what computer programming was about.Recursion is nothing but the process of calling of one function from the other only this process is done by calling of a function by itself. As we know when one function calls the other function the first function saves its state(its variables) and then passes the control to the called function. The called function can be called by using the same name of variables ex fun1(a) can call fun2(a). \nWhen we do recursive call nothing new happens. One function calls itself by passing the same type and similar in name variables(but obviously the values stored in variables are different,only the name remains same.)to itself. But before every call the function saves its state and this process of saving continues. The SAVING IS DONE ON A STACK.NOW THE STACK COMES INTO PLAY.So if you write an iterative program and save the state on a stack each time and then pop out the values from stack when needed, you have successfully converted a recursive program into an iterative one!The proof is simple and analytical.In recursion the computer maintains a stack and in iterative version you will have to manually maintain the stack.Think over it, just convert a depth first search(on graphs) recursive program into a dfs iterative program.All the best!A question that had been closed as a duplicate of this one had a very specific data structure:The node had the following structure:The recursive deletion function looked like:In general, it is not always possible to avoid a stack for recursive functions that invoke itself more than one time (or even once). However, for this particular structure, it is possible. The idea is to flatten all the nodes into a single list. This is accomplished by putting the current node\'s child at the end of the top row\'s list.This technique can be applied to any data linked structure that can be reduce to a DAG with a deterministic topological ordering. The current nodes children are rearranged so that the last child adopts all of the other children. Then the current node can be deleted and traversal can then iterate to the remaining child.A rough description of how a system takes any recursive function and executes it using a stack:This intended to show the idea without details. Consider this function that would print out nodes of a graph:For example graph:\nA->B\nA->C\nshow(A) would print B, A, CFunction calls mean save the local state and the continuation point so you can come back, and then jump the the function you want to call.For example, suppose show(A) begins to run. The function call on line 3. show(B) means\n - Add item to the stack meaning "you\'ll need to continue at line 2 with local variable state node=A"\n - Goto line 0 with node=B.To execute code, the system runs through the instructions. When a function call is encountered, the system pushes information it needs to come back to where it was, runs the function code, and when the function completes, pops the information about where it needs to go to continue.This link provides some explanation and proposes the idea of keeping "location" to be able to get to the exact place between several recursive calls:However, all these examples describe scenarios in which a recursive call is made a fixed amount of times. Things get trickier when you have something like:Thinking of things that actually need a stack:If we consider the pattern of recursion as:For example, the classic Tower of HanoiThis can be translated into a loop working on an explicit stack, by restating it as:For Tower of Hanoi this becomes:There is considerable flexibility here as to how you define your stack. You can make your stack a list of Command objects that do sophisticated things. Or you can go the opposite direction and make it a list of simpler types (e.g. a "task" might be 4 elements on a stack of int, rather than one element on a stack of Task).All this means is that the memory for the stack is in the heap rather than in the Java execution stack, but this can be useful in that you have more control over it.