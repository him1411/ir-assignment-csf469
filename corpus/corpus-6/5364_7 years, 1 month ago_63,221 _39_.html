I just want to create a regular expression out of any possible string.Is there a built in method for that?  If not, what do people use?  Ruby has RegExp.escape.  I don\'t feel like I\'d need to write my own, there\'s gotta be something standard out there.  Thanks!The function linked above is insufficient. It fails to escape ^ or $ (start and end of string), or -, which in a character group is used for ranges.Use this function:While it may seem unnecessary at first glance, escaping - (as well as ^) makes the function suitable for escaping characters to be inserted into a character class as well as the body of the regex.Escaping / makes the function suitable for escaping characters to be used in a JS regex literal for later eval.As there is no downside to escaping either of them it makes sense to escape to cover wider use cases.And yes, it is a disappointing failing that this is not part of standard JavaScript.For anyone using lodash, since v3.0.0 a _.escapeRegExp function is built-in:And, in the event that you don\'t want to require the full lodash library, you may require just that function!Most of the expressions here solve single specific use cases.That\'s okay, but I prefer an "always works" approach.This will "fully escape" a literal string for any of the following uses in regular expressions:Special Characters Covered:Notes:If you also need to future-proof the regular expression against potential additions to the JavaScript regex engine capabilities, I recommend using the more paranoid:This function escapes every character except those explicitly guaranteed not be used for syntax in future regular expression flavors.For the truly sanitation-keen, consider this edge case:This should compile fine in JavaScript, but will not in some other flavors. If intending to pass to another flavor, the null case of s === \'\' should be independently checked, like so:In jQueryUI\'s autocomplete widget (version 1.9.1) they use a slightly different regex (Line 6753), here\'s the regular expression combined with @bobince approach.Mozilla Developer Network\'s Guide to Regular Expressions provides this escaping function:There is an ES7 proposal for RegExp.escape at https://github.com/benjamingr/RexExp.escape/, with a polyfill available at https://github.com/ljharb/regexp.escape.Nothing should prevent you from just escaping every non-alphanumeric character:You lose a certain degree of readability when doing re.toString() but you win a great deal of simplicity (and security).According to ECMA-262, on the one hand, regular expression "syntax characters" are always non-alphanumeric, such that the result is secure, and special escape sequences (\\d, \\w, \\n) are always alphanumeric such that no false control escapes will be produced.This is a shorter version.This includes the non-meta characters of %, &, \', and ,, but the JavaScript RegExp specification allows this.escapeRegExp = function(str){\n      if (str == null) return \'\';\n      return String(str).replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, \'\\\\$1\');\n    },XRegExp has an escape function:XRegExp.escape(\'Escaped? <.>\');\n// -> \'Escaped\\?\\ <\\.>\'\nMore on: http://xregexp.com/api/#escapeRather than only escaping characters which will cause issues in your regular expression (e.g.: a blacklist), why not consider using a whitelist instead. This way each character is considered tainted unless it matches.For this example, assume the following expression:This whitelists letters, number and spaces:Returns:This may escape characters which do not need to be escaped, but this doesn\'t hinder your expression (maybe some minor time penalties - but it\'s worth it for safety).The functions in the other answers are overkill for escaping entire regular expressions (they may be useful for escaping parts of regular expressions that will later be concatenated into bigger regexps).If you escape an entire regexp and are done with it, quoting the metacharacters that are either standalone (., ?, +, *, ^, $, |, \\) or start something ((, [, {) is all you need:And yes, it\'s disappointing that JavaScript doesn\'t have a function like this built-in.