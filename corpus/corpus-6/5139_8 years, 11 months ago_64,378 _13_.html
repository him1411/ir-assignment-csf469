The above seems to work fine though ReSharper complains that this is "access to modified closure".  Can any one shed light on this?(this topic continued here)In this case, it\'s okay, since you are actually executing the delegate within the loop.If you were saving the delegate and using it later, however, you\'d find that all of the delegates would throw exceptions when trying to access files[i] - they\'re capturing the variable i rather than its value at the time of the delegates creation.In short, it\'s something to be aware of as a potential trap, but in this case it doesn\'t hurt you.See the bottom of this page for a more complex example where the results are counterintuitive.I know this is an old question, but I\'ve recently been studying closures and thought a code sample might be useful. Behind the scenes, the compiler is generating a class that represents a lexical closure for your function call. It probably looks something like:As mentioned above, your function works because the predicates are invoked immediately after creation. The compiler will generate something like:On the other hand, if you were to store and then later invoke the predicates, you would see that every single call to the predicates would really be calling the same method on the same instance of the closure class and therefore would use the same value for i."files" is a captured outer variable because it has been captured by the anonymous delegate function. Its lifetime is extended by the anonymous delegate function.Captured outer variables\n  When an outer variable is referenced by an anonymous function, the outer variable is said to have been captured by the anonymous function. Ordinarily, the lifetime of a local variable is limited to execution of the block or statement with which it is associated (Local variables). However, the lifetime of a captured outer variable is extended at least until the delegate or expression tree created from the anonymous function becomes eligible for garbage collection.https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#outer-variablesWhen a local variable or a value parameter is captured by an anonymous function, the local variable or parameter is no longer considered to be a fixed variable (Fixed and moveable variables), but is instead considered to be a moveable variable. Thus any unsafe code that takes the address of a captured outer variable must first use the fixed statement to fix the variable.\n  Note that unlike an uncaptured variable, a captured local variable can be simultaneously exposed to multiple threads of execution.