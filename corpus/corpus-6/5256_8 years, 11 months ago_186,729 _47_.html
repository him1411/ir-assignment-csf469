Why is volatile needed in C? What is it used for? What will it do?Volatile tells the compiler not to optimize anything that has to do with the volatile variable.     There is only one reason to use it: When you interface with hardware. Let\'s say you have a little piece of hardware that is mapped into RAM somewhere and that has two addresses: a command port and a data port:Now you want to send some command:Looks easy, but it can fail because the compiler is free to change the order in which data and commands are written. This would cause our little gadget to issue commands with the previous data-value. Also take a look at the wait while busy loop. That one will be optimized out. The compiler will try to be clever, read the value of isbusy just once and then go into an infinite loop. That\'s not what you want. The way to get around this is to declare the pointer gadget as volatile. This way the compiler is forced to do what you wrote. It can\'t remove the memory assignments, it can\'t cache variables in registers and it can\'t change the order of assignments either:This is the correct version:Another use for volatile is signal handlers. If you have code like this:The compiler is allowed to notice the loop body does not touch the quit variable and convert the loop to a while (true) loop. Even if the quit variable is set on the signal handler for SIGINT and SIGTERM; the compiler has no way to know that.However, if the quit variable is declared volatile, the compiler is forced to load it every time, because it can be modified elsewhere. This is exactly what you want in this situation.volatile in C actually came into existence for the purpose of not caching the values of the variable automatically. It will tell the machine not to cache the value of this variable. So it will take the value of the given volatile variable from the main memory every time it encounters it. This mechanism is used because at any time the value can be modified by the OS or any interrupt. So using volatile will help us accessing the value afresh every time.volatile tells the compiler that your variable may be changed by other means, than the code that is accessing it. e.g., it may be a I/O-mapped memory location. If this is not specified in such cases, some variable accesses can be optimised, e.g., its contents can be held in a register, and the memory location not read back in again.See this article by Andrei Alexandrescu, "volatile - Multithreaded Programmer\'s Best Friend"The volatile keyword was\n  devised to prevent compiler\n  optimizations that might render code\n  incorrect in the presence of certain\n  asynchronous events. For example, if\n  you declare a primitive variable as\n  volatile, the compiler is not\n  permitted to cache it in a register --\n  a common optimization that would be\n  disastrous if that variable were\n  shared among multiple threads. So the\n  general rule is, if you have variables\n  of primitive type that must be shared\n  among multiple threads, declare those\n  variables volatile. But you can\n  actually do a lot more with this\n  keyword: you can use it to catch code\n  that is not thread safe, and you can\n  do so at compile time. This article\n  shows how it is done; the solution\n  involves a simple smart pointer that\n  also makes it easy to serialize\n  critical sections of code.The article applies to both C and C++.Also see the article "C++ and the Perils of Double-Checked Locking" by Scott Meyers and Andrei Alexandrescu:So when dealing with some memory locations (e.g. memory mapped ports or memory referenced by ISRs [ Interrupt Service Routines ] ), some optimizations must be suspended. volatile exists for specifying special treatment for such locations, specifically: (1) the content of a volatile variable is "unstable" (can change by means unknown to the compiler), (2) all writes to volatile data are "observable" so they must be executed religiously, and (3) all operations on volatile data are executed in the sequence in which they appear in the source code. The first two rules ensure proper reading and writing. The last one allows implementation of I/O protocols that mix input and output. This is informally what C and C++\'s volatile guarantees.My simple explanation is:In some scenarios, based on the logic or code, the compiler will do optimisation of variables which it thinks do not change. The volatile keyword prevents a variable being optimised.For example:From the above code, the compiler may think usb_interface_flag is defined as 0, and that in the while loop it will be zero forever. After optimisation, the compiler will treat it as while(true) all the time, resulting in an infinite loop. To avoid these kinds of scenarios, we declare the flag as volatile, we are telling to compiler that this value may be changed by an external interface or other module of program, i.e., please don\'t optimise it. That\'s the use case for volatile. A marginal use for volatile is the following. Say you want to compute the numerical derivative of a function f :The problem is that x+h-x is generally not equal to h due to roundoff errors. Think about it : when you substract very close numbers, you lose a lot of significant digits which can ruin the computation of the derivative (think 1.00001 - 1). A possible workaround could bebut depending on your platform and compiler switches, the second line of that function may be wiped out by a aggressively optimizing compiler. So you write insteadto force the compiler to read the memory location containing hh, forfeiting an eventual optimization opportunity. I\'ll mention another scenario where volatiles are important.Suppose you memory-map a file for faster I/O and that file can change behind the scenes (e.g. the file is not on your local hard drive, but is instead served over the network by another computer).If you access the memory-mapped file\'s data through pointers to non-volatile objects (at the source code level), then the code generated by the compiler can fetch the same data multiple times without you being aware of it.If that data happens to change, your program may become using two or more different versions of the data and get into an inconsistent state. This can lead not only to logically incorrect behavior of the program but also to exploitable security holes in it if it processes untrusted files or files from untrusted locations.If you care about security, and you should, this is an important scenario to consider.There are two uses. These are specially used more often in embedded development.Compiler will not optimise the functions that uses variables that are defined with volatile keywordVolatile is used to access exact memory locations in RAM, ROM, etc... This is used more often to control memory-mapped devices, access CPU registers and locate specific memory locations.See examples with assembly listing.\nRe: Usage of C "volatile" Keyword in Embedded DevelopmentVolatile is also useful, when you want to force the compiler not to optimize a specific code sequence (e.g. for writing a micro-benchmark).volatile means the storage is likely to change at anytime and be changed but something outside the control of the user program. This means that if you reference the variable, the program should always check the physical address (ie a mapped input fifo), and not use it in a cached way.Also see the article at http://clinuxpro.com/volatile-in-cThe Wiki say everything about volatile:And the Linux kernel\'s doc also make a excellent notation about volatile:A volatile can be changed from outside the compiled code (for example, a program may map a volatile variable to a memory mapped register.) The compiler won\'t apply certain optimizations to code that handles a volatile variable - for example, it won\'t load it into a register without writing it to memory. This is important when dealing with hardware registers.it does not allows compiler to automatic changing values of variables.  a volatile variable is for dynamic use.In my opinion, you should not expect too much from volatile. To illustrate, look at the example in Nils Pipenbrinck\'s highly-voted answer.I would say, his example is not suitable for volatile. volatile is only used to:\n prevent the compiler from making useful and desirable optimizations. It is nothing about the thread safe, atomic access or even memory order.In that example:the gadget->data = data before gadget->command = command only is only guaranteed in compiled code by compiler. At running time, the processor still possibly reorders the data and command assignment, regarding to the processor architecture. The hardware could get the wrong data(suppose gadget is mapped to hardware I/O). The memory barrier is needed between data and command assignment.