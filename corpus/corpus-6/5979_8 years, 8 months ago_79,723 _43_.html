This question already has an answer here:I\'m new to both JavaScript and YUI. In YUI library examples, you can find many uses of this construct:I think last couple of parentheses are to execute the function just after the declaration.... But what about the previous set of parentheses surrounding the function declaration?I think it is a matter of scope, that\'s to hide inside variables to outside functions and possibly global objects. Is it? More generally, what are the mechanics of those parentheses?It is a self-executing anonymous function. The first set of parentheses contain the expressions to be executed, and the second set of parentheses executes those expressions.It is a useful construct when trying to hide variables from the parent namespace. All the code within the function is contained in the private scope of the function, meaning it can\'t be accessed at all from outside the function, making it truly private.See:http://en.wikipedia.org/wiki/Closure_%28computer_science%29http://peter.michaux.ca/articles/javascript-namespacingAndy Hume pretty much gave the answer, I just want to add a few more details.With this construct you are creating an anonymous function with its own evaluation environment or closure, and then you immediately evaluate it. The nice thing about this is that you can access the variables declared before the anonymous function, and you can use local variables inside this function without accidentally overwriting an existing variable.The use of the var keyword is very important, because in JavaScript every variable is global by default, but with the keyword you create a new, lexically scoped variable, that is, it is visible by the code between the two braces. In your example, you are essentially creating short aliases to the objects in the YUI library, but it has more powerful uses.I don\'t want to leave you without a code example, so I\'ll put here a simple example to illustrate a closure:What is going on here? In the function add_gen you are creating an another function which will simply add the number n to its argument. The trick is that in the variables defined in the function parameter list act as lexically scoped variables, like the ones defined with var.The returned function is defined between the braces of the add_gen function so it will have access to the value of n even after add_gen function has finished executing, that is why you will get 5 when executing the last line of the example.With the help of function parameters being lexically scoped, you can work around the "problems" arising from using loop variables in anonymous functions. Take a simple example:The "expected" result could be the numbers from zero to four, but you get four instances of fives instead. This happens because the anonymous function in setTimeout and the for loop are using the very same i variable, so by the time the functions get evaluated, i will be 5.You can get the naively expected result by using the technique in your question and the fact, that function parameters are lexically scoped. (I\'ve used this approach in an other answer)With the immediate evaluation of the outer function you are creating a completely independent variable named j in each iteration, and the current value of i will be copied in to this variable, so you will get the result what was naively expected from the first try.I suggest you to try to understand the excellent tutorial at http://ejohn.org/apps/learn/ to understand closures better, that is where I learnt very-very much....but what about the previous round parenteses surrounding all the function declaration?Specifically, it makes JavaScript interpret the \'function() {...}\' construct as an inline anonymous function expression. If you omitted the brackets:You\'d get a syntax error, because the JS parser would see the \'function\' keyword and assume you\'re starting a function statement of the form:...and you can\'t have a function statement without a function name.function expressions and function statements are two different constructs which are handled in very different ways. Unfortunately the syntax is almost identical, so it\'s not just confusing to the programmer, even the parser has difficulty telling which you mean!Juts to follow up on what Andy Hume and others have said:The \'()\' surrounding the anonymous function is the \'grouping operator\' as defined in section 11.1.6 of the ECMA spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf. Taken verbatim from the docs:  11.1.6 The Grouping OperatorThe production PrimaryExpression : ( Expression ) is evaluated as follows:In this context the function is treated as an expression.few consideration on the subject:the parenthesis :The browser (engine/parser) associates the keyword function with       so in an expression like function(){}() the last parenthesis  make no  sense.Now think at Yes the first pair o parenthesis force the anonymous function to turn into variable (stored expression) and second launches evaluation/execution\nso ( function(){} )() makes sense1 for executing some code on load and isolate the used variables from the rest of the page especially when name conflicts are possible ;2 replace eval("string") with 3 wrap long code for   " =?:  " operator like:The first parentheses are for, if you will, order of operations. The \'result\' of the set of parentheses surrounding the function definition is the function itself which, indeed, the second set of parentheses executes. As to why it\'s useful, I\'m not enough of a Javascript wizard to have any idea. :PSee this question.  The first set of parenthesis aren\'t necessary if you use a function name, but a nameless function requires this construct and the parenthesis serve for coders to realize that they\'ve viewing a self-invoking function when browsing the code (see one blogger\'s best-practices recommendation).