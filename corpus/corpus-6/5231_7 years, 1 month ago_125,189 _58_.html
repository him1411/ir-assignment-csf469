I am really interested in how MySQL indexes work, more specifically, how can they return the data requested without scanning the entire table?It\'s off-topic, I know, but if there is someone who could explain this to me in detail, I would be very, very thankful.Basically an index on a table works like an index in a book (that\'s where the name came from):Let\'s say you have a book about databases and you want to find some information about, say,  storage. Without an index (assuming no other aid, such as a table of contents) you\'d have to go through the pages one by one, until you found the topic (that\'s a full table scan).\nOn the other hand, an index has a list of keywords, so you\'d consult the index and see that storage is mentioned on pages 113-120,231 and 354. Then you could flip to those pages directly, without searching (that\'s a search with an index, somewhat faster).Of course, how useful the index will be, depends on many things - a few examples, using the simile above:The first thing you must know is that indexes are a way to avoid scanning the full table to obtain the result that you\'re looking for.There are different kinds of indexes and they\'re implemented in the storage layer, so there\'s no standard between them and they also depend on the storage engine that you\'re using.For InnoDB, the most common index type is the B+Tree based index, that stores the elements in a sorted order. Also, you don\'t have to access the real table to get the indexed values, which makes your query return way faster.The "problem" about this index type is that you have to query for the leftmost value to use the index. So, if your index has two columns, say last_name and first_name, the order that you query these fields matters a lot.So, given the following table:This query would take advantage of the index:But the following one would notBecause you\'re querying the first_name column first and it\'s not the leftmost column in the index.This last example is even worse:Because now, you\'re comparing the rightmost part of the rightmost field in the index.This is a different index type that unfortunately, only the memory backend supports. It\'s lightning fast but only useful for full lookups, which means that you can\'t use it for operations like >, < or LIKE.Since it only works for the memory backend, you probably won\'t use it very often. The main case I can think of right now is the one that you create a temporary table in the memory with a set of results from another select and perform a lot of other selects in this temporary table using hash indexes.If you have a big VARCHAR field, you can "emulate" the use of a hash index when using a B-Tree, by creating another column and saving a hash of the big value on it. Let\'s say you\'re storing a url in a field and the values are quite big. You could also create an integer field called url_hash and use a hash function like CRC32 or any other hash function to hash the url when inserting it. And then, when you need to query for this value, you can do something like this:The problem with the above example is that since the CRC32 function generates a quite small hash, you\'ll end up with a lot of collisions in the hashed values. If you need exact values, you can fix this problem by doing the following:It\'s still worth to hash things even if the collision number is high cause you\'ll only perform the second comparison (the string one) against the repeated hashes.Unfortunately, using this technique, you still need to hit the table to compare the url field.Some facts that you may consider every time you want to talk about optimization:Integer comparison is way faster than string comparison. It can be illustrated with the example about the emulation of the hash index in InnoDB.Maybe, adding additional steps in a process makes it faster, not slower. It can be illustrated by the fact that you can optimize a SELECT by splitting it into two steps, making the first one store values in a newly created in-memory table, and then execute the heavier queries on this second table.MySQL has other indexes too, but I think the B+Tree one is the most used ever and the hash one is a good thing to know, but you can find the other ones in the MySQL documentation.I highly recommend you to read the "High Performance MySQL" book, the answer above was definitely based on its chapter about indexes.Basically an index is a map of all your keys that is sorted in order. With a list in order, then instead of checking every key, it can do something like this:1: Go to middle of list - is higher or lower than what I\'m looking for? 2: If higher, go to halfway point between middle and bottom, if lower, middle and top3: Is higher or lower? Jump to middle point again, etc.Using that logic, you can find an element in a sorted list in about 7 steps, instead of checking every item.Obviously there are complexities, but that gives you the basic idea.Database index, or just index, helps speed up the retrieval of data from tables. When you query data from a table, first MySQL checks if the indexes exist, then MySQL uses the indexes to select exact physical corresponding rows of the table instead of scanning the whole table.A database index is similar to an index of a book. If you want to find a topic, you look up in the index first, and then you open the page that has the topic without scanning the whole book.It is highly recommended that you should create index on columns of table from which you often query the data. Notice that all primary key columns are in the primary index of  the table automatically.If index helps speed up the querying data, why don\xe2\x80\x99t we use indexes for all columns? If you create an index for every column, MySQL has to build and maintain the index table. Whenever a change is made to the records of the table, MySQL has to rebuild the index, which takes time as well as decreases the performance of the database server.\nCreating MySQL IndexYou often create indexes when you create tables. MySQL automatically add any column that is declared as PRIMARY KEY, KEY, UNIQUE or INDEX to the index. In addition, you can add indexes to the tables that already have data.In order to create indexes, you use the CREATE INDEX statement. The following illustrates the syntax of the CREATE INDEX statement:\n1\n2\n3First, you specify the index based on the table type or storage engine:UNIQUE means MySQL will create a constraint that all values in the index must be unique. Duplicate NULL value is allowed in all storage engine except BDB.\n    FULLTEXT index is supported only by MyISAM storage engine and only accepted on column that has data type is CHAR, VARCHAR or TEXT.\n    SPATIAL index supports spatial column and is available on MyISAM storage engine. In addition, the column value must not be NULL.Then, you name the index and its type after the USING keyword such as BTREE, HASH or RTREE also based on the storage engine of the table.Here are the storage engines of the table with the corresponding allowed index types:\nStorage Engine  Allowable Index Types\nMyISAM  BTREE, RTREE\nInnoDB  BTREE\nMEMORY/HEAP HASH, BTREE\nNDB HASHThird, you declare table name and a list columns that you want to add to the index.\nExample of creating index in MySQLIn the sample database, you can add  officeCode column of  the employees table to the index by using the CREATE INDEX statement as follows:\n1CREATE INDEX officeCode ON employees(officeCode)Removing IndexesBesides creating index, you can also remove index by using the DROP INDEX statement. Interestingly, the DROP INDEX statement is also mapped to ALTER TABLE statement. The following is the syntax of removing the index:\n1DROP INDEX index_name ON table_nameFor example, if you want to drop index officeCode of the employees table,  which we have created above, you can execute following query:\n1DROP INDEX officeCode ON employeesTake a look at this link:  http://dev.mysql.com/doc/refman/5.0/en/mysql-indexes.htmlHow they work is too broad of a subject to cover in one SO post.Here is one of the best explanations of indexes I have seen.  Unfortunately it is for SQL Server and not MySQL.  I\'m not sure how similar the two are...Take at this videos for more details about IndexingSimple Indexing\nYou can create a unique index on a table. A unique index means that two rows cannot have the same index value. Here is the syntax to create an Index on a tableYou can use one or more columns to create an index. For example, we can create an index on tutorials_tbl using tutorial_author.You can create a simple index on a table. Just omit UNIQUE keyword from the query to create simple index. Simple index allows duplicate values in a table.If you want to index the values in a column in descending order, you can add the reserved word DESC after the column name.