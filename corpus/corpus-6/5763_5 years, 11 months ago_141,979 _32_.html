As asked in this question, I also want to know how to resolve a conflicting git stash pop without adding all modifications to a commit (just like "git stash pop" without a conflict does).My current approach is very uncool because I do it this way:[Update] A way to reproduce it:2016-06-27: Added a new file called \'third\' to the example to show that workarounds like the solution from scy only work for empty HEADs but don\'t fix the initial problem that the HEAD doesn\'t have the same content like for a git stash pop without a conflict.Suppose you have this scenario where you stash your changes in order to pull from origin. Possibly because your local changes are just debug: true in some settings file. Now you pull and someone has introduced a new setting there, creating a conflict.git status says:Okay. I decided to go with what Git suggested: I resolved the conflict and committed:Now my working copy is in the state I want, but I have created a commit that I don\'t want to have. How do I get rid of that commit without modifying my working copy? Wait, there\'s a popular command for that!My working copy has not been changed, but the WIP commit is gone. That\'s exactly what I wanted! (Note that I\'m not using --soft here, because if there are auto-merged files in your stash, they are auto-staged and thus you\'d end up with these files being staged again after reset.)But there\'s one more thing left: The man page for git stash pop reminds us that "Applying the state can fail with conflicts; in this case, it is not removed from the stash list. You need to resolve the conflicts by hand and call git stash drop manually afterwards." So that\'s exactly what we do now:And done.I don\'t think that doing a commit and then resetting the branch to remove that commit and similar workarounds are the clean way to solve this issue.Following solution seems to be much cleaner to me and it\'s also suggested by the Git itself - execute git status in the repository with a conflict:Let\'s do what Git suggests without doing any commit:So:Note: adding files to the index after a conflict is resolved is on purpose. This way you can differentiate the changes from the previous stash and changes you made after the conflict was resolved. If you don\'t like it, you can always use git reset to remove everything from the index.Another note: I highly recommend using any of 3-way merge tools for solving conflicts, e.g. KDiff3. It usually solves majority of conflicts automatically itself.Instead of adding the changes you make to resolve the conflict, you can use git reset HEAD file to resolve the conflict without staging your changes.You may have to run this command twice, however. Once to mark the conflict as resolved and once to unstage the changes that were staged by the conflict resolution routine.It is possible that there should be a reset mode that does both of these things simultaneously, although there is not one now.worked for me.Note: this can be dangerous since it doesn\'t try to merge the changes from the stash into your working copy, but overwrites it with the stashed files instead. So you can lose your uncommitted changes.It seems that this may be the answer you\'re looking for, I haven\'t tried this personally yet, but it seems like it may do the trick. With this command GIT will try to apply the changes as they were before, without trying to add all of them for commit.git stash apply --indexhere is the full explanation:http://git-scm.com/book/en/Git-Tools-Stashinggit stash branch will works, which creates a new branch for you, checks out\nthe commit you were on when you stashed your work, reapplies your work there, and\nthen drops the stash if it applies successfully. check thisThe fastest way I have found is to resolve the conflict, then do git add -u, and then do git reset HEAD, that doesn\'t even involve a commit.According to git stash questions, after fixing the conflict, git add <file> is the right course of action.It was after reading this comment that I understood that the changes are automatically added to the index (by design). That\'s why git add <file> completes the conflict resolution process.git add . will stage ALL the files telling git that you have resolved the conflictgit reset will unstage ALL the staged files without creating a commit