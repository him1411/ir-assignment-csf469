As JavaScript frameworks like jQuery make client side web applications richer and more functional, I\'ve started to notice one problem...How in the world do you keep this organized?I mention jQuery, but it\'s really any JavaScript code in general. I\'m finding that as lines upon lines begin to pile up, it gets harder to manage the script files or find what you are looking for. Quite possibly the biggest propblems I\'ve found is there are so many ways to do the same thing, it\'s hard to know which one is the current commonly accepted best practice.Are there any general recommendations on the best way to keep your .js files as nice and neat as the rest of your application? Or is this just a matter of IDE? Is there a better option out there?EDITThis question was intended to be more about code organization and not file organization. There has been some really good examples of merging files or splitting content around.My question is: what is the current commonly accepted best practice way to organize your actual code? What is your way, or even a recommended way to interact with page elements and create reuseable code that doesn\'t conflict with each other?Some people have listed namespaces which is a good idea. What are some other ways, more specifically dealing with elements on the page and keeping the code organized and neat?It would be a lot nicer if javascript had namespaces built in, but I find that organizing things like Dustin Diaz describes here helps me a lot. I put different "namespaces" and sometimes individual classes in separate files. Usually I start with one file and as a class or namespace gets big enough to warrant it, I separate it out into its own file. Using a tool to combine all you files for production is an excellent idea as well.I try to avoid including any javascript with the HTML. All the code is encapsulated into classes and each class is in its own file. For development, I have separate <script> tags to include each js file, but they get merged into a single larger package for production to reduce the overhead of the HTTP requests.Typically, I\'ll have a single \'main\' js file for each application. So, if I was writing a "survey" application, i would have a js file called "survey.js". This would contain the entry point into the jQuery code. I create jQuery references during instantiation and then pass them into my objects as parameters. This means that the javascript classes are \'pure\' and don\'t contain any references to CSS ids or classnames. I also find naming convention to be important for readability. For example: I prepend \'j\' to all jQuery instances.In the above example, there is a class called DimScreen. (Assume this dims the screen and pops up an alert box.) It needs a div element that it can enlarge to cover the screen, and then add an alert box, so I pass in a jQuery object. jQuery has a plug-in concept, but it seemed limiting (e.g. instances are not persistent and cannot be accessed) with no real upside. So the DimScreen class would be a standard javascript class that just happens to use jQuery.I\'ve built some fairly complex appliations using this approach.You can break up your scripts into separate files for development, then create a "release" version where you cram them all together and run YUI Compressor or something similar on it.Inspired by earlier posts I made a copy of Rakefile and vendor directories distributed with WysiHat (a RTE mentioned by changelog) and made a few modifications to include code-checking with JSLint and minification with YUI Compressor.The idea is to use Sprockets (from WysiHat) to merge multiple JavaScripts into one file, check syntax of the merged file with JSLint and minify it with YUI Compressor before distribution.PrerequisitesNow doNow create a file named "Rakefile" in the root directory of the JavaScript project and add the following content to it:If you done everything correctly, you should be able to use the following commands in your console:On source mergingUsing Sprockets, the JavaScript pre-processor you can include (or require) other JavaScript files. Use the following syntax to include other scripts from the initial file (named "main.js", but you can change that in the Rakefile):And then...Take a look at Rakefile provided with WysiHat to set the automated unit testing up. Nice stuff :)And now for the answerThis does not answer the original question very well. I know and I\'m sorry about that, but I\'ve posted it here because I hope it may be useful to someone else to organize their mess.My approach to the problem is to do as much object-oriented modelling I can and separate implementations into different files. Then the handlers should be as short as possible. The example with List singleton is also nice one.And namespaces... well they can be imitated by deeper object structure.I\'m not big fan of imitations, but this can be helpful if you have many objects that you would like to move out of the global scope.The code organization requires adoption of conventions and documentation standards:\n1. Namespace code for a physical file;2. Group classes in these namespaces javascript;\n3. Set Prototypes or related functions or classes for representing real-world objects;\n4. Set conventions to improve the code. For example, group all of its internal functions or methods in its class attribute of an object type.5. Make documentation of namespaces, classes, methods and variables. Where necessary also discuss some of the code (some FIs and Fors, they usually implement important logic of the code).\nThese are just some tips, but that has greatly helped in organizing the code. Remember you must have discipline to succeed!Following good OO design principals and design patterns goes a long way to making your code easy to maintain and understand.\nBut one of the best things I\'ve discovered recently are signals and slots aka publish/subscribe.\nHave a look at http://markdotmeyer.blogspot.com/2008/09/jquery-publish-subscribe.html\nfor a simple jQuery implementation.The idea is well used in other languages for GUI development. When something significant happens somewhere in your code you publish a global synthetic event which other methods in other objects may subscribe to.\nThis gives excellent separation of objects. I think Dojo (and Prototype?) have a built in version of this technique.see also What are signals and slots?I was able to successfully apply the Javascript Module Pattern to an Ext JS application at my previous job.  It provided a simple way to create nicely encapsulated code.Dojo had the module system from the day one. In fact it is considered to be a cornerstone of Dojo, the glue that holds it all together:Using modules Dojo achieves following objectives:Check out JavasciptMVC.You can :split up your code into model, view and controller layers.compress all code into a single production fileauto-generate codecreate and run unit testsand lots more...Best of all, it uses jQuery, so you can take advantage of other jQuery plugins too.My boss still speaks of the times when they wrote modular code (C language), and complains about how crappy the code is nowadays! It is said that programmers can write assembly in any framework. There is always a strategy to overcome code organisation. The basic problem is with guys who treat java script as a toy and never try to learn it.In my case, I write js files on a UI theme or application screen basis, with a proper init_screen(). Using proper id naming convention, I make sure that there are no name space conflicts at the root element level. In the unobstrusive window.load(), I tie the things up based on the top level id.I strictly use java script closures and patterns to hide all private methods. After doing this, never faced a problem of conflicting properties/function definitions/variable definitions. However, when  working with a team it is often difficult to enforce the same rigour. I\'m surprised no one mentioned MVC frameworks. I\'ve been using Backbone.js to modularize and decouple my code, and it\'s been invaluable.There are quite a few of these kinds of frameworks out there, and most of them are pretty tiny too. My personal opinion is that if you\'re going to be writing more than just a couple lines of jQuery for flashy UI stuff, or want a rich Ajax application, an MVC framework will make your life much easier."Write like crazy and just hope it works out for the best?", I\'ve seen a project like this which was developed and maintained by just 2 developers, a huge application with lots of javascript code. On top of that there were different shortcuts for every possible jquery function you can think of. I suggested they organize the code as plugins, as that is the jquery equivalent of class, module, namespace... and the whole universe. But things got much worse, now they started writing plugins replacing every combination of 3 lines of code used in the project.\nPersonaly I think jQuery is the devil and it shouldn\'t be used on projects with lots of javascript because it encourages you to be lazy and not think of organizing code in any way. I\'d rather read 100 lines of javascript than one line with 40 chained jQuery functions (I\'m not kidding).\nContrary to popular belief it\'s very easy to organize javascript code in equivalents to namespaces and classes. That\'s what YUI and Dojo do. You can easily roll your own if you like. I find YUI\'s approach much better and efficient. But you usualy need a nice editor with support for snippets to compensate for YUI naming conventions if you want to write anything useful.I create singletons for every thing I really do not need to instantiate several times on screen, a classes for everything else. And all of them are put in the same namespace in the same file. Everything is commented, and designed with UML , state diagrams. The javascript code is clear of html so no inline javascript and I tend to use jquery to minimize cross browser issues.Organising your code in a Jquery centric NameSpace way may look as follows... and will not clash with other Javascript API\'s like Prototype, Ext either.Hope this helps.Good principal of OO + MVC would definitely go a long way for managing a complex javascript app. Basically I am organizing my app and javascript to the following familiar design (which exists all the way back from my desktop programming days to Web 2.0)Description for the numeric values on the image:In the past, I would separate the files into its own js and use common practice to create OO principles in Javascript. The problem that I soon found that there are multiple ways to write JS OO and it\'s not necessarily that all team members have the same approach. As the team got larger (in my case more than 15 people), this gets complicated as there is no standard approach for Object Oriented Javascript. At the same time I don\'t want to write my own framework and repeat some of the work that I am sure smarter people than I have solved.jQuery is incredibly nice as Javascript Framework and I love it, however as project gets bigger, I clearly need additional structure for my web app especially to facilitate standardize OO practice. For myself, after several experiments, I find that YUI3 Base and Widget (http://yuilibrary.com/yui/docs/widget/ and http://yuilibrary.com/yui/docs/base/index.html) infrastructure provides exactly what I need. Few reasons why I use them.Contrary to many views, I don\'t necessarily have to choose between jQuery and YUI3. These two can peacefully co-exist. While YUI3 provides the necessary OO template for my complex web app, jQuery still provides my team with easy to use JS Abstraction that we all come to love and familiar with.Using YUI3, I have managed to create MVC pattern by separating classes that extend the Base as the Model, classes that extends Widget as a View and off course you have Controller classes that are making necessary logic and server side calls. Widget can communicate with each other using event based model and listening to the event and doing the necessary task based on predefined interface. Simply put, putting OO + MVC structure to JS is a joy for me. Just a disclaimer, I don\'t work for Yahoo! and simply an architect that is trying to cope with the same issue that is posed by the original question. I think if anyone finds equivalent OO framework, this would work as well. Principally, this question applies to other technologies as well. Thank God for all the people who came up with OO Principles + MVC to make our programming days more manageable. In my last project -Viajeros.com- I\'ve used a combination of several techniques. I wouldn\'t know how to organize a web app -- Viajeros is a social networking site for travellers with well-defined sections, so it\'s kind of easy to separate the code for each area.I use namespace simulation and lazy loading of modules according to the site section. On each page load I declare a "vjr" object, and always load a set of common functions to it (vjr.base.js). Then each HTML page decides which modules need with a simple:Vjr.base.js gets each one gzipped from the server and executes them.Every "module" has this structure:Given my limited Javascript knowledge, I know there must be better ways to manage this, but until now it\'s working great for us.I use Dojo\'s package management (dojo.require and dojo.provide) and class system (dojo.declare which also allows for simple multiple inheritance) to modularize all of my classes/widgets into separate files.  Not only dose this keep your code organized, but it also lets you do lazy/just in time loading of classes/widgets.A few days ago, the guys at 37Signals released a RTE control, with a twist. They made a library that bundles javascript files using a sort of pre-processor commands.I\'ve been using it since to separate my JS files and then in the end merge them as one. That way I can separate concerns and, in the end, have only one file that goes through the pipe (gzipped, no less).In your templates, check if you\'re in development mode, and include the separate files, and if in production, include the final one (which you\'ll have to "build" yourself).Create fake classes, and make sure that anything that can be thrown into a separate function that makes sense is done so. Also make sure to comment a lot, and not to write spagghetti code, rather keeping it all in sections. For example, some nonsense code depicting my ideals. Obviously in real life I also write many libraries that basically encompass their functionality.Use inheritance patterns to organize large jQuery applications.I think this ties into, perhaps, DDD (Domain-Driven Design). The application I\'m working on, although lacking a formal API, does give hints of such by way of the server-side code (class/file names, etc). Armed with that, I created a top-level object as a container for the entire problem domain; then, I added namespaces in where needed:For JavaScript organization been using the followingI\'m using this little thing. It gives you \'include\' directive for both JS and HTML templates. It eleminates the mess completely.https://github.com/gaperton/include.js/You can use jquery mx (used in javascriptMVC) which is a set of scripts that allows you to use models, views, and controllers. I\'ve used it in a project and helped me create structured javascript, with minimal script sizes because of compression. This is a controller example:You can also use only the controller side of jquerymx if you aren\'t interested in the view and model parts. Your question is one that plagued me late last year.  The difference - handing the code off to new developers who had never heard of private and public methods.  I had to build something simple.The end result was a small (around 1KB) framework that translates object literals into jQuery. The syntax is visually easier to scan, and if your js grows really large you can write reusable queries to find things like selectors used, loaded files, dependent functions, etc.Posting a small framework here is impractical, so I wrote a blog post with examples (My first. That was an adventure!).  You\'re welcome to take a look.For any others here with a few minutes to check it out, I\'d greatly appreciate feedback!FireFox recommended since it supports toSource() for the object query example.Cheers!AdamI use a custom script inspired by Ben Nolan\'s behaviour (I can\'t find a current link to this anymore, sadly) to store most of my event handlers. These event handlers are triggered by the elements className or Id, for example. \nExample:I like to include most of my Javascript libraries on the fly, except the ones that contain global behaviour. I use Zend Framework\'s headScript() placeholder helper for this, but you can also use javascript to load other scripts on the fly with Ajile for example.You don\'t mention what your server-side language is. Or, more pertinently, what framework you are using -- if any -- on the server-side. IME, I organise things on the server-side and let it all shake out onto the web page. The framework is given the task of organising not only JS that every page has to load, but also JS fragments that work with generated markup. Such fragments you don\'t usually want emitted more than once - which is why they are abstracted into the framework for that code to look after that problem. :-)For end-pages that have to emit their own JS, I usually find that there is a logical structure in the generated markup. Such localised JS can often be assembled at the start and/or end of such a structure. Note that none of this absolves you from writing efficient JavaScript! :-)Lazy Load the code you need on demand. Google does something like this with their google.loader 