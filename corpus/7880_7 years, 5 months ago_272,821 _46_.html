How can I programmatically (i.e., not using vi) convert DOS/Windows newlines to Unix?The dos2unix and unix2dos commands are not available on certain systems. How can I emulate these with commands like sed/awk/tr?You can use tr to convert from DOS to Unix; however, you can only do this safely if CR appears in your file only as the first byte of a CRLF byte pair.  This is usually the case.  You then use:Note that the name DOS-file is different from the name UNIX-file; if you try to use the same name twice, you will end up with no data in the file.You can\'t do it the other way round (with standard \'tr\').If you know how to enter carriage return into a script (control-V, control-M to enter control-M), then:where the \'^M\' is the control-M character.  You can also use the bash ANSI-C Quoting mechanism to specify the carriage return:However, if you\'re going to have to do this very often (more than once, roughly speaking), it is far more sensible to install the conversion programs (e.g. dos2unix and unix2dos, or perhaps dtou and utod) and use them.take a look here for examples using sed:Use sed -i for in-place conversion e.g. sed -i \'s/..../\' file.Doing this with POSIX is tricky:POSIX Sed does not support \\r or \\15. Even if it did, the in place\noption -i is not POSIXPOSIX Awk does support \\r and \\15, however the -i inplace option\nis not POSIXd2u and dos2unix are not POSIX utilities, but ex isPOSIX ex does not support \\r, \\15, \\n or \\12To remove carriage returns:To add carriage returns:This problem can be solved with standard tools, but there are sufficiently many traps for the unwary that I recommend you install the flip command, which was written over 20 years ago by Rahul Dhesi, the author of zoo.\nIt does an excellent job converting file formats while, for example, avoiding the inadvertant destruction of binary files, which is a little too easy if you just race around altering every CRLF you see...The solutions posted so far only deal with part of the problem, converting DOS/Windows\' CRLF into Unix\'s LF; the part they\'re missing is that DOS use CRLF as a line separator, while Unix uses LF as a line terminator.  The difference is that a DOS file (usually) won\'t have anything after the last line in the file, while Unix will.  To do the conversion properly, you need to add that final LF (unless the file is zero-length, i.e. has no lines in it at all).  My favorite incantation for this (with a little added logic to handle Mac-style CR-separated files, and not molest files that\'re already in unix format) is a bit of perl:Note that this sends the Unixified version of the file to stdout.  If you want to replace the file with a Unixified version, add perl\'s -i flag.Using AWK you can do:Using Perl you can do:If you don\'t have access to dos2unix, but can read this page, then you can copy/paste dos2unix.py from here.Cross-posted from superuser.An even simpler awk solution w/o a program:Technically \'1\' is your program, b/c awk requires one when given option. UPDATE: \nAfter revisiting this page for the first time in a long time I realized that no one has yet posted an internal solution, so here is one:This worked for me Super duper easy with PCRE;As a script, or replace $@ with your files.This will overwrite your files in place!I recommend only doing this with a backup (version control or otherwise)For Mac osx if you have homebrew installed  [http://brew.sh/][1]Make sure you have made copies of the files, as this command will modify the files in place.\nThe -c mac option makes the switch to be compatible with osx.TIMTOWTDI!Based on @GordonDavissonOne must consider the possibility of [noeol] ...You can use awk. Set the record separator (RS) to a regexp that matches all possible newline character, or characters. And set the output record separator (ORS) to the unix-style newline character.interestingly in my git-bash on windows sed "" did the trick already:My guess is that sed ignores them when reading lines from input and always writes unix line endings on output.As an extension to Jonathan Leffler\'s Unix to DOS solution, to safely convert to DOS when you\'re unsure of the file\'s current line endings:This checks that the line does not already end in CRLF before converting to CRLF.Had just to ponder that same question (on Windows-side, but equally applicable to linux.)\nSuprisingly nobody mentioned a very much automated way of doing CRLF<->LF conversion for text-files using good old zip -ll option (Info-ZIP):NOTE: this would create a zip file preserving the original file names but converting the line endings to LF. Then unzip would extract the files as zip\'ed, that is with their original names (but with LF-endings), thus prompting to overwrite the local original files if any.Relevant excerpt from the zip --help:I tried\nsed \'s/^M$//\' file.txt \non OSX as well as several other methods (http://www.thingy-ma-jig.co.uk/blog/25-11-2010/fixing-dos-line-endings or http://hintsforums.macworld.com/archive/index.php/t-125.html). None worked, the file remained unchanged (btw Ctrl-v Enter was needed to reproduce ^M). In the end I used TextWrangler. Its not strictly command line but it works and it doesn\'t complain.