I am trying to create a directive that would create an input field with the same ng-model as the element that creates the directive.Here\'s what I came up with so far:HTMLJavaScriptHowever, I am not confident this is the right way to handle this scenario, and there is a bug that my control is not getting initialized with the value of the ng-model target field.Here\'s a Plunker of the code above: http://plnkr.co/edit/IvrDbJWhat\'s the correct way of handling this?EDIT: After removing the ng-model="value" from the template, this seems to be working fine. However, I will keep this question open because I want to double check this is the right way of doing this.It\'s actually pretty good logic but you can simplify things a bit.You can see it in action with this Plunker.Here\'s what I see:EDIT As mentioned by Mark in his comment, there\'s no reason that you can\'t use ng-model, just to keep with convention.In general, your directives should use the isolated scope (which you did correctly) and use the \'=\' type scope if you want a value in your directive to always map to a value in the parent scope. I took a combo of all answers, and now have two ways of doing this with the ng-model attribute:I\'m not sure I like the compiling at link time. However, if you\'re just replacing the element with another you don\'t need to do that.All in all I prefer the first one. Simply set scope to {ngModel:"="} and set ng-model="ngModel" where you want it in your template.Update: I inlined the code snippet and updated it for Angular v1.2. Turns out that isolate scope is still best, especially when not using jQuery. So it boils down to:Are you replacing a single element: Just replace it, leave the scope alone, but note that replace is deprecated for v2.0:Otherwise use this:it\' s not so complicated:\nin your dirctive, use an alias: scope:{alias:\'=ngModel\'}in your html, use as normalYou only need ng-model when you need to access the model\'s $viewValue or $modelValue. See NgModelController. And in that case, you would use require: \'^ngModel\'.For the rest, see Roys answer.This is a little late answer, but I found this awesome post about NgModelController, which I think is exactly what you where looking for. TL;DR - you can use require: \'ngModel\' and then add NgModelController to your linking function:This way, no hacks needed - you are using Angular\'s built-in ng-modelI wouldn\'t set the ngmodel via an attribute, you can specify it right in the template:plunker: http://plnkr.co/edit/9vtmnw?p=previewSince Angular 1.5 it\'s possible to use Components. Components are the-way-to-go and solves this problem easy.Inside YourController all you need to do is:Creating an isolate scope is undesirable. I would avoid using the scope attribute and do something like this. scope:true gives you a new child scope but not isolate. Then use parse to point a local scope variable to the same object the user has supplied to the ngModel attribute.