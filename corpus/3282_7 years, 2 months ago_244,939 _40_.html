I\'m a little confused as to how the inversion of control (IoC) works in Spring.Say I have a service class called UserServiceImpl that implements UserService interface.How would this be @Autowired?And in my Controllers action, how would I instantiate an instance of this service?Would I just do the following?First, and most important - all Spring beans are managed - they "live" inside a container, called "application context".Second, each application has an entry point to that context. Web applications have a Servlet, JSF uses a el-resolver, etc. Also, there is a place where the application context is bootstrapped and all beans - autowired. In web applications this can be a startup listener.Autowiring happens by placing an instance of one bean into the desired field in an instance of another bean. Both classes should be beans, i.e. they should be defined to live in the application context.What is "living" in the application context? This means that the context instantiates the objects, not you. I.e. - you never make new UserServiceImpl() - the container finds each injection point and sets an instance there.In your controllers, you just have the following:A few notes:Depends on whether you went the annotations route or the bean XML definition route.Say you had the beans defined in your applicationContext.xml:The autowiring happens when the application starts up. So, in fooController, which for arguments sake wants to use the UserServiceImpl class, you\'d annotate it as follows:When it sees @Autowired, Spring will look for a class that matches the property in the applicationContext, and inject it automatically. If you have more than 1 UserService bean, then you\'ll have to qualify which one it should use.If you do the following:It will not pick up the @Autowired unless you set it yourself.@Autowired is a annotation introduced in Spring 2.5, and it\'s used only for injection. For example:@AutowiredMarks a constructor, field, setter method or config method as to be\nautowired by Spring\'s dependency injection facilities.Only one constructor (at max) of any given bean class may carry this\nannotation, indicating the constructor to autowire when used as a\nSpring bean. Such a constructor does not have to be public.Fields are injected right after construction of a bean, before any\nconfig methods are invoked. Such a config field does not have to be\npublic.Config methods may have an arbitrary name and any number of\narguments; each of those arguments will be autowired with a matching\nbean in the Spring container. Bean property setter methods are\neffectively just a special case of such a general config method. Such\nconfig methods do not have to be public.In the case of multiple argument methods, the \'required\' parameter is\napplicable for all arguments.In case of a Collection or Map dependency type, the container will\nautowire all beans matching the declared value type. In case of a\nMap, the keys must be declared as type String and will be resolved to\nthe corresponding bean names.How does @Autowired work internally?Ex - .xml file it will look alike if not using @AutowiredIf you are using @Autowired then .xml file it will look alike if not using @AutowiredIf still have some doubt then go through below live demo How does @Autowired work internally ? You just need to annotate your service class UserServiceImpl with annotationSpring container will take care of the life cycle of this class as it register as service.Then in your controller you can auto wire(instantiate) it and use its functionality.The whole concept of inversion of control means you are free from a chore to instantiate objects manually and provide all necessary dependencies.\nWhen you annotate class with appropriate annotation (e.g. @Service) Spring will automatically instantiate object for you. If you are not familiar with annotations you can also use XML file instead. However, it\'s not a bad idea to instantiate classes manually (with the new keyword) in unit tests when you don\'t want to load the whole spring context.Spring dependency inject help you to remove coupling from your classes.\nInstead of creating object like thisYou will be using this after introducing DIFor achieving this you need to create a bean of your service in your ServiceConfiguration file. After that you need to Import that ServiceConfiguration class to your WebApplicationConfiguration class so that you can Autowire that bean into your Controller like this.You can find a java configuration based POC here \nexample