In Python, is there a portable and simple way to test if an executable program exists?By simple I mean something like the which command which would be just perfect. I don\'t want to search PATH manually or something involving trying to execute it with Popen & al and see if it fails (that\'s what I\'m doing now, but imagine it\'s launchmissiles)Easiest way I can think of: Edit: Updated code sample to include logic for handling case where provided argument is already a full path to the executable, i.e. "which /bin/ls". This mimics the behavior of the UNIX \'which\' command.Edit: Updated to use os.path.isfile() instead of os.path.exists() per comments.I know this is an ancient question, but you can use distutils.spawn.find_executable.  This has  been documented since python 2.4 and has existed since python 1.6.  Also, Python 3.3 now offers shutil.which().Python 3.3 now offers shutil.which().Just remember to specify the file extension on windows. Otherwise, you have to write a much complicated is_exe for windows using PATHEXT environment variable. You may just want to use FindPath.OTOH, why are you even bothering to search for the executable? The operating system will do it for you as part of popen call & will raise an exception if the executable is not found. All you need to do is catch the correct exception for given OS. Note that on Windows, subprocess.Popen(exe, shell=True) will fail silently if exe is not found.Incorporating PATHEXT into the above implementation of which (in Jay\'s answer):This seems to be working for me:Edited to work on Linux, thanks to MestreionWhat we\'re doing here is using the builtin command type and checking the exit code. If there\'s no such command, type will exit with 1 (or a non-zero status code anyway).The bit about stdout and stderr is just to silence the output of the type command, since we\'re only interested in the exit status code.Example usage:This is a one-liner of Jay\'s Answer, Also here as a lambda func:Or lastly, indented as a function:As a one-liner of Jan-Philip Gehrcke Answer:As a def:See os.path module for some useful functions on pathnames. To check if an existing file is executable, use os.access(path, mode), with the os.X_OK mode.os.X_OKValue to include in the mode parameter of access() to determine if path can be executed.EDIT: The suggested which() implementations are missing one clue - using os.path.join() to build full file names.On the basis that it is easier to ask forgiveness than permission I would just try to use it and catch the error (OSError in this case - I checked for file does not exist and file is not executable and they both give OSError).It helps if the executable has something like a --version flag that is a quick no-op.This is not a general solution, but will be the easiest way for a lot of use cases - those where the code needs to look for a single well known executable.The best example should be the python bulit-in module shutil.which() in Python 3. The link is https://hg.python.org/cpython/file/default/Lib/shutil.py I found something in StackOverflow that solved the problem for me. This works provided the executable has an option (like --help or --version) that outputs something and returns an exit status of zero. See Suppress output in Python calls to executables - the "result" at the end of the code snippet in this answer will be zero if the executable is in path, else it is most likely to be 1.If you have bash and a function sh (subprocess.Popen( ... ).communicate() ),\nuse the bash builtin type:An important question is "Why do you need to test if executable exist?" Maybe you don\'t? ;-) Recently I needed this functionality to launch viewer for PNG file. I wanted to iterate over some predefined viewers and run the first that exists. Fortunately, I came across os.startfile. It\'s much better! Simple, portable and uses the default viewer on the system:Update: I was wrong about os.startfile being portable... It\'s Windows only. On Mac you have to run open command. And xdg_open on Unix. There\'s a Python issue on adding Mac and Unix support for os.startfile.I know that I\'m being a bit of a necromancer here, but I stumbled across this question and the accepted solution didn\'t work for me for all cases Thought it might be useful to submit anyway. In particular, the "executable" mode detection, and the requirement of supplying the file extension. Furthermore, both python3.3\'s shutil.which (uses PATHEXT) and python2.4+\'s distutils.spawn.find_executable (just tries adding \'.exe\') only work in a subset of cases.So I wrote a "super" version (based on the accepted answer, and the PATHEXT suggestion from Suraj). This version of which does the task a bit more thoroughly, and tries a series of "broadphase" breadth-first techniques first, and eventually tries more fine-grained searches over the PATH space:Usage looks like this:The accepted solution did not work for me in this case, since there were files like meld.1, meld.ico, meld.doap, etc also in the directory, one of which were returned instead (presumably since lexicographically first) because the executable test in the accepted answer was incomplete and giving false positives.This seems simple enough and works both in python 2 and 3Added windows supportyou can tell if a file exists with the os module.  an executable in particular seems quite unportable considering lots of things are executable on nix that aren\'t on windows and vice versa.It would seem the obvious choice is "which", parsing the results via popen,  but you could simulate it otherwise using the os class.  In pseudopython, it would look like this:So basically you want to find a file in mounted filesystem (not necessarily in PATH directories only) and check if it is executable. This translates to following plan: I\'d say, doing this in a portable way will require lots of computing power and time. Is it really what you need?There is a which.py script in a standard Python distribution (e.g. on Windows \'\\PythonXX\\Tools\\Scripts\\which.py\'). EDIT: which.py depends on ls therefore it is not cross-platform.None of previous examples do work on all platforms. Usually they fail to work on Windows because you can execute without the file extension and that you can register new extension. For example on Windows if python is well installed it\'s enough to execute \'file.py\' and it will work.The only valid and portable solution I had was to execute the command and see error code. Any decent executable should have a set of calling parameters that will do nothing.You can try the external lib called "sh" (http://amoffat.github.io/sh/).Using the python fabric library: