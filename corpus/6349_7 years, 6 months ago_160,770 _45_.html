I have a variable of type size_t, and I want to print it using printf(). What format specifier do I use to print it portably? In 32-bit machine, %u seems right. I compiled with g++ -g -W -Wall -Werror -ansi -pedantic, and there was no warning. But when I compile that code in 64-bit machine, it produces warning. The warning goes away, as expected, if I change that to %lu.The question is, how can I write the code, so that it compiles warning free on both 32- and 64- bit machines?Edit: I guess one answer might be to "cast" the variable into an unsigned long, and print using %lu. That would work in both cases. I am looking if there is any other idea.Use the z modifier:Looks like it varies depending on what compiler you\'re using (blech):...and of course, if you\'re using C++, you can use cout instead as suggested by AraK.For C89, use %lu and cast the value to unsigned long:For C99 and later, use %zu:Extending on Adam Rosenfield\'s answer for Windows.I tested this code with on both VS2013 Update 4 and VS2015 preview:VS2015 generated binary outputs:1\n  1\n  2while the one generated by VS2013 says:zu\n  zx\n  zdNote: ssize_t is a POSIX extension and SSIZE_T is similar thing in Windows Data Types, hence I added <BaseTsd.h> reference.Additionally, except for the follow C99/C11 headers, all C99 headers are available in VS2015 preview:Also, C11\'s <uchar.h> is now included in latest preview.For more details, see this old and the new list for standard conformance.For those talking about doing this in C++ which doesn\'t necessarily support the C99 extensions, then I heartily recommend boost::format. This makes the size_t type size question moot:Since you don\'t need size specifiers in boost::format, you can just worry about how you want to display the value.Will it warn you if you pass a 32-bit unsigned integer to a %lu format? It should be fine since the conversion is well-defined and doesn\'t lose any information.I\'ve heard that some platforms define macros in <inttypes.h> that you can insert into the format string literal but I don\'t see that header on my Windows C++ compiler, which implies it may not be cross-platform.As AraK said, the c++ streams interface will always work portably. std::size_t s = 1024;\n  std::cout << s; // or any other kind of stream like stringstream! If you want C stdio, there is no portable answer to this for certain cases of "portable." And it gets ugly since as you\'ve seen, picking the wrong format flags may yield a compiler warning or give incorrect output.C99 tried to solve this problem with inttypes.h formats like "%"PRIdMAX"\\n". But just as with "%zu", not everyone supports c99 (like MSVS prior to 2013). There are "msinttypes.h" files floating around to deal with this.If you cast to a different type, depending on flags you may get a compiler warning for truncation or a change of sign. If you go this route pick a larger relevant fixed size type. One of unsigned long long and "%llu" or unsigned long "%lu" should work, but llu may also slow things down in a 32bit world as excessively large.  (Edit - my mac issues a warning in 64 bit for %llu not matching size_t, even though %lu, %llu, and size_t are all the same size. And %lu and %llu are not the same size on my MSVS2012. So you may need to cast + use a format that matches.)For that matter, you can go with fixed size types, such as int64_t. But wait! Now we\'re back to c99/c++11, and older MSVS fails again. Plus you also have casts (e.g. map.size() is not a fixed size type)!You can use a 3rd party header or library such as boost. If you\'re not already using one, you may not want to inflate your project that way. If you\'re willing to add one just for this issue, why not use c++ streams, or conditional compilation?  So you\'re down to c++ streams, conditional compilation, 3rd party frameworks, or something sort of portable that happens to work for you.C99 defines "%zd" etc. for that. (thanks to the commenters) There is no portable format specifier for that in C++  - you could use %p, which woulkd word in these two scenarios, but isn\'t a portable choice either, and gives the value in hex.Alternatively, use some streaming (e.g. stringstream) or a safe printf replacement such as Boost Format.  I understand that this advice is only of limited use (and does require C++). (We\'ve used a similar approach fitted for our needs when implementing unicode support.)The fundamental problem for C is that printf using an ellipsis is unsafe by design - it needs to determine the additional argument\'s size from the known arguments, so it can\'t be fixed to support "whatever you got". So unless your compiler implement some proprietary extensions, you are out of luck.if you want to print the value of a size_t as a string you can do this:result is:number: 2337200120702199116text: Lets go fishing in stead of sitting on our but !!   Edit: rereading the question because of the down votes i noted his problem is not %llu or %I64d but the size_t type on different machines see this question https://stackoverflow.com/a/918909/1755797\nhttp://www.cplusplus.com/reference/cstdio/printf/size_t is unsigned int on a 32bit machine and unsigned long long int on 64bit\nbut %ll always expects a unsigned long long int.size_t varies in length on different operating systems while %llu is the same          On some platforms and for some types there are specific printf conversion specifiers available, but sometimes one has to resort to casting to larger types.I\'ve documented this tricky issue here, with example code:\nhttp://www.pixelbeat.org/programming/gcc/int_types/\nand update it periodically with info on new platforms and types.Nasty but it works :)