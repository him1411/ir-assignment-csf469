This seems like such a simple need but I\'ve spent an inordinate amount of time trying to do this to no avail. I\'ve looked at other questions on SO and I haven\'t found what I need. I have a very simple JavaScript array such as peoplenames = new Array("Mike","Matt","Nancy","Adam","Jenny","Nancy","Carl"); that may or may not contain duplicates and I need to simply remove the duplicates and put the unique values in a new array. That\'s it. I could point to all the codes that I\'ve tried but I think it\'s useless because they don\'t work. If anyone has done this and can help me out I\'d really appreciate it. JavaScript or jQuery solutions are both acceptable.Quick and dirty using jQuery:Basically, we iterate over the array and, for each element, check if the first position of this element in the array is equal to the current position. Obviously, these two positions are different for duplicate elements.Using the 3rd ("this array") parameter of the filter callback we can avoid a closure of the array variable:Although concise, this algorithm is not particularly efficient for large arrays (quadratic time).This is how it\'s usually done. The idea is to place each element in a hashtable and then check for its presence instantly. This gives us linear time, but has at least two drawbacks:That said, if your arrays contain only primitives and you don\'t care about types (e.g. it\'s always numbers), this solution is optimal.A universal solution combines both approaches: it uses hash lookups for primitives and linear search for objects.Another option is to sort the array first, and then remove each element equal to the preceding one:Again, this doesn\'t work with objects (because all objects are equal for sort). Additionally, we silently change the original array as a side effect - not good! However, if your input is already sorted, this is the way to go (just remove sort from the above).Sometimes it\'s desired to uniquify a list based on some criteria other than just equality, for example, to filter out objects that are different, but share some property. This can be done elegantly by passing a callback. This "key" callback is applied to each element, and elements with equal "keys" are removed. Since key is expected to return a primitive, hash table will work fine here:A particularly useful key() is JSON.stringify which will remove objects that are physically different, but "look" the same:If the key is not primitive, you have to resort to the linear search:or use the Set object in ES6:(Some people prefer !seen.has(k) && seen.add(k) instead of seen.has(k) ? false : seen.add(k)).Both underscore and Lo-Dash provide uniq methods. Their algorithms are basically similar to the first snippet above and boil down to this:This is quadratic, but there are nice additional goodies, like wrapping native indexOf, ability to uniqify by a key (iteratee in their parlance), and optimizations for already sorted arrays.If you\'re using jQuery and can\'t stand anything without a dollar before it, it goes like this:which is, again, a variation of the first snippet.Function calls are expensive in Javascript, therefore the above solutions, as concise as they are, are not particularly efficient. For maximal performance, replace filter with a loop and get rid of other function calls:This chunk of ugly code does the same as the snippet #3 above, but an order of magnitude faster (as of 2017 it\'s only twice as fast - JS core folks are doing a great job!)ES6 provides the Set object, which makes things a whole lot easier:orNote that, unlike in python, ES6 sets are iterated in insertion order, so this code preserves the order of the original array.However, if you need an array with unique elements, why not use sets right from the beginning?Got tired of seeing all bad examples with for-loops or jQuery. Javascript has the perfect tools for this nowadays: sort, map and reduce. There are probably faster ways but this one is pretty decent.In ES6 you have Sets and Spread which makes it very easy and performant to remove all duplicates:Someone asked about ordering the results based on how many unique names there are:It\'s a library with a host of functions for manipulating arrays. It\'s the tie to go along with jQuery\'s tux, and Backbone.js\'s\n  suspenders._.uniq_.uniq(array, [isSorted], [iterator]) Alias: unique\n  Produces a duplicate-free version of the array, using === to test object\n  equality. If you know in advance that the array is sorted, passing\n  true for isSorted will run a much faster algorithm. If you want to\n  compute unique items based on a transformation, pass an iterator\n  function.ExampleNote: Lo-Dash (an underscore competitor) also offers a comparable .uniq implementation.Vanilla JS: Remove duplicates using an Object like a SetYou can always try putting it into an object, and then iterating through its keys:Vanilla JS: Remove duplicates by tracking already seen values (order-safe)Or, for an order-safe version, use an object to store all previously seen values, and check values against it before before adding to an array.ECMAScript 6: Use the new Set data structure (order-safe)ECMAScript 6 adds the new Set Data-Structure, which lets you store values of any type.  Set.values returns elements in insertion order.Example usage:A single line version using array filter and indexOf functions:The most concise way to remove duplicates from an array using native javascript functions is to use a sequence like below:there\'s no need for slice nor indexOf within the reduce function, like i\'ve seen in other examples! it makes sense to use it along with a filter function though:Yet another ES6(2015) way of doing this that already works on a few browsers is: or even using the spread operator:cheers!Go for this one:Now uniqueArray contains no duplicates.You can simply do it in JavaScript, with the help of the second - index - parameter of the filter method:or in short handSimplest One I\'ve run into so far. In es6.https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SetThe following is more than 80% faster than the jQuery method listed (see tests below).\nIt is an answer from a similar question a few years ago, if I come across the person who originally proposed it I will post credit.\nPure JS.My Test Case comparison:\nhttp://jsperf.com/remove-duplicate-array-testsI had done a detailed comparison of dupes removal at some other question but having noticed that this is the real place i just wanted to share it here as well.I believe this is the best way to do thisOK .. even though this one is O(n) and the others are O(n^2) i was curious to see benchmark comparison between this reduce / look up table and filter/indexOf combo (I choose Jeetendras very nice implementation https://stackoverflow.com/a/37441144/4543207). I prepare a 100K item array filled with random positive integers in range 0-9999 and and it removes the duplicates. I repeat the test for 10 times and the average of the results show that they are no match in performance.Well ok so far so good. But let\'s do it properly this time in the ES6 style. It looks so cool..! But as of now how it will perform against the powerful lut solution is a mystery to me. Lets first see the code and then benchmark it.Wow that was short..! But how about the performance..? It\'s beautiful... Since the heavy weight of the filter / indexOf lifted over our shoulders now i can test an array 1M random items of positive integers in range 0..99999 to get an average from 10 consecutive tests. I can say this time it\'s a real match. See the result for yourself :)Which one would  you use..? Well not so fast...! Don\'t be deceived. Map is at displacement. Now look... in all of the above cases we fill an array of size n with numbers of range < n. I mean we have an array of size 100 and we fill with random numbers 0..9 so there are definite duplicates and "almost" definitely each number has a duplicate. How about if we fill the array in size 100 with random numbers 0..9999. Let\'s now see Map playing at home. This time an Array of 100K items but random number range is 0..100M. We will do 100 consecutive tests to average the results. OK let\'s see the bets..! <- no typoNow this is the spectacular comeback of Map()..! May be now you can make a better decision when you want to remove the dupes.Well ok we are all happy now. But the lead role always comes last with some applause. I am sure some of you wonder what Set object would do. Now that since we are open to ES6 and we know Map is the winner of the previous games let us compare Map with Set as a final. A typical Real Madrid vs Barcelona game this time... or is it? Let\'s see who will win the el classico :)Wow.. man..! Well unexpectedly it didn\'t turn out to be an el classico at all. More like Barcelona FC against CA Osasuna :))Here is a simple answer to the question.The top answers have complexity of O(n\xc2\xb2), but this can be done with just O(n) by using an object as a hash:This will work for strings, numbers, and dates.  If your array contains complex objects (ie, they have to be compared with ===), the above solution won\'t work.  You can get an O(n) implementation for objects by setting a flag on the object itself:In ECMAScript 6 (aka ECMAScript 2015), Set can be used to filter out duplicates. Then it can be converted back to an array using the spread operator.Apart from being a simpler, more terse solution than the current answers (minus the future-looking ES6 ones), I perf tested this and it was much faster as well: One caveat: Array.lastIndexOf() was added in IE9, so if you need to go lower than that, you\'ll need to look elsewhere.A simple but effective technique, is to use the filter method in combination with the filter function(value, index){ return this.indexOf(value) == index }.See also this Fiddle.You could also use the Array.unique() method from the JavaScript Lab library \xe2\x80\x93 or steal an idea from there.However, the code there isn\xe2\x80\x99t very well written, since it declares the unique() method as a property of the Array prototype, thus adding it to every Array, breaking the for...in functionality (because a for...in loop will always iterate over the unique variable, too).Here is a generic and strictly functional approach with ES2015:We can easily derive unique from unqiueBy or use the faster implementation utilizing Sets:Benefits of this approach:uniqueBy isn\'t as fast as an imperative implementation with loops, but it is way more expressive due to its genericity.If you identify uniqueBy as the cause of a concrete performance penalty in your app, replace it with optimized code. That is, write your code first in an functional, declarative way. Afterwards, provided that you encounter performance issues, try to optimize the code at the locations, which are the cause of the problem.uniqueBy utilizes mutations (push(x) (acc)) hidden inside its body. It reuses the accumulator instead of throwing it away after each iteration. This reduces memory consumption and GC pressure. Since this side effect is wrapped inside the function, everything outside remains pure.So the options is:here is the simple method without any special libraries are special function,One line:If by any chance you were usingD3.jsYou could dohttps://github.com/mbostock/d3/wiki/Arrays#set_valuesHere is very simple for understanding and working anywhere (even in PhotoshopScript) code. Check it!A slight modification of thg435\'s excellent answer to use a custom comparator:This is probably one of the fastest way to remove permanently the duplicates from an array\n10x times faster than the most functions here.& 78x faster in safariif you can\'t read the code above ask, read a javascript book or here are some explainations about shorter code. https://stackoverflow.com/a/21353032/2450730https://jsfiddle.net/2w0k5tz8/Loop through, remove duplicates, and create a clone array place holder because the array index will not be updated.Loop backward for better performance ( your loop wont need to keep checking the length of your array) This was just another solution but different than the rest.  Another method of doing this without writing much code is using the ES5 Object.keys-method:Extracted in a function