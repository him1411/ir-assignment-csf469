My java program is packaged in a jar file and makes use of an external jar library, bouncy castle. My code compiles fine, but running the jar leads to the following error:Exception in thread "main" java.lang.SecurityException: Invalid signature file digest for Manifest main attributesI\'ve googled for over an hour searching for an explanation and found very little of value. If anyone has seen this error before and could offer some help, I would be obliged.The solution listed here might provide a pointer.Invalid signature file digest for Manifest main attributesBottom line : It\'s probably best to keep the official jar as\n  is and just add it as a dependency in the manifest file for your\n  application jar file.For those who got this error when trying to create an uber-jar with maven-shade-plugin, the solution is to exclude manifest signature files by adding the following lines to the plugin configuration:For those using gradle and trying to create and use a fat jar, the following syntax might help.Some of your dependencies are likely signed jarfiles. When you combine them all into one big jarfile, the corresponding signature files are still present, and no longer match the "big combined" jarfile, so the runtime halts thinking the jar file has been tampered with (which it...has so to speak).You can solve the problem by eliminating the signature files from your jarfile dependencies. Unfortunately, it\'s not possible to do this in one step in ant.However, I was able to get this working with Ant in two steps, without specifically naming each jarfile dependency, by using:The sleep element is supposed to prevent errors about files with modification dates in the future.Other variations I found in the linked threads didn\'t work for me.Please use the following commandI had this problem when using IntelliJ IDEA 14.01. I was able to fix it by:File->Project Structure->Add New (Artifacts)->jar->From Modules With Dependencies on the Create Jar From Module Window:Select you main classJAR File from Libraries\nSelect copy to the output directory and link via manifestAssuming you build your jar file with ant, you can just instruct ant to leave out the META-INF dir. This is a simplified version of my ant target:Compare the folder META-INF in new jar with old jar (before you added new libraries). It is possibility that there will be new files. If yes, you can remove them. It should helps.\nRegards,\n999michalI had a similar problem. The reason was that I was compiling using a JDK with a different JRE than the default one in my Windows box. Using the correct java.exe solved my problem. It\'s possible that two different signers mess up java mind.Try removing META-INF folder from jar, adding manifest and signing JAR again, it helped me: http://jehy.ru/articles/2013/12/13/invalid-signature-file-digest-for-manifest-main-attributes/A strategy would consist in using ANT to simplify the removal of the signature from each Jar file. It would proceed with the following steps:Here is an ANT macrodef doing the work:`The definition can then be called this way in an ANT task:Error: A JNI error has occurred, please check your installation and try again\n  Exception in thread "main" java.lang.SecurityException: Invalid signature file digest for Manifest main attributes\n      at sun.security.util.SignatureFileVerifier.processImpl(SignatureFileVerifier.java:314)\n      at sun.security.util.SignatureFileVerifier.process(SignatureFileVerifier.java:268)\n      at java.util.jar.JarVerifier.processEntry(JarVerifier.java:316)\n      at java.util.jar.JarVerifier.update(JarVerifier.java:228)\n      at java.util.jar.JarFile.initializeVerifier(JarFile.java:383)\n      at java.util.jar.JarFile.getInputStream(JarFile.java:450)\n      at sun.misc.URLClassPath$JarLoader$2.getInputStream(URLClassPath.java:977)\n      at sun.misc.Resource.cachedInputStream(Resource.java:77)\n      at sun.misc.Resource.getByteBuffer(Resource.java:160)\n      at java.net.URLClassLoader.defineClass(URLClassLoader.java:454)\n      at java.net.URLClassLoader.access$100(URLClassLoader.java:73)\n      at java.net.URLClassLoader$1.run(URLClassLoader.java:368)\n      at java.net.URLClassLoader$1.run(URLClassLoader.java:362)\n      at java.security.AccessController.doPrivileged(Native Method)\n      at java.net.URLClassLoader.findClass(URLClassLoader.java:361)\n      at java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n      at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n      at java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n      at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)What helped me (IntelliJ IDEA 2016.3): \nFile -> Project Structure -> Artifacts -> Add JAR -> Select Main Class -> Choose "copy to the output directory and link via manifest" -> OK -> Apply -> Build -> Build Artifacts... -> BuildIf you\'re getting this when trying to bind JAR files for a Xamarin.Android bindings project like so:JARTOXML : warning J2XA006: missing class error was raised while reflecting com.your.class : Invalid signature file digest for Manifest main attributesJust open the JAR files using Winzip and delete the meta-inf directories. Rebuild - job doneSecurity is already a tough topic, but I\'m disappointed to see the most popular solution is to delete the security signatures. JCE requires these signatures. Maven shade explodes the BouncyCastle jar file which puts the signatures into META-INF, but the BouncyCastle signatures aren\'t valid for a new, uber-jar (only for the BC jar), and that\'s what causes the Invalid signature error in this thread.Yes, excluding or deleting the signatures as suggested by @ruhsuzbaykus does indeed make the original error go away, but it can also lead to new, cryptic errors:By explicitly specifying where to find the algorithm like this:I was able to get a different error:JCE can\'t authenticate the provider because we\'ve deleted the cryptographic signatures by following the suggestion elsewhere in this same thread.The solution I found was the executable packer plugin that uses a jar-in-jar approach to preserve the BouncyCastle signature in a single, executable jar.Another way to do this (the correct way?) is to use Maven Jar signer. This allows you to keep using Maven shade without getting security errors. HOWEVER, you must have a code signing certificate (Oracle suggests searching for "Java Code Signing Certificate"). The POM config looks like this:No, there\'s no way to get JCE to recognize a self-signed cert, so if you need to preserve the BouncyCastle certs, you have to either use the jar-in-jar plugin or get a JCE cert. 