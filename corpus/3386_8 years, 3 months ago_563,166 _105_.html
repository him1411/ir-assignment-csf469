How do i declare a 2d array using new?Like, for a "normal" array I would:buta) doesn\'t work/compile and b) doesn\'t accomplish what:does.A dynamic 2D array is basically an array of pointers to arrays. You should initialize it using a loop, like this:The above, for colCount= 5 and rowCount = 4, would produce the following:should be:and then clean up would be:EDIT: as Dietrich Epp pointed out in the comments this is not exactly a light weight solution. An alternative approach would be to use one large block of memory:Although this popular answer will give you your desired indexing syntax, it is doubly inefficient: big and slow both in space and time. There\'s a better way.Why That Answer is Big and SlowThe proposed solution is to create a dynamic array of pointers, then initializing each pointer to its own, independent dynamic array. The advantage of this approach is that it gives you the indexing syntax you\'re used to, so if you want to find the value of the matrix at position x,y, you say:This works because matrix[x] returns a pointer to an array, which is then indexed with [y]. Breaking it down:Convenient, yes? We like our [ x ][ y ] syntax. But the solution has a big disadvantage, which is that it is both fat and slow. Why?The reason that it\'s both fat and slow is actually the same. Each "row" in the matrix is a separately allocated dynamic array. Making a heap allocation is expensive both in time and space. The allocator takes time to make the allocation, sometimes running O(n) algorithms to do it. And the allocator "pads" each of your row arrays with extra bytes for bookkeeping and alignment. That extra space costs...well...extra space. The deallocator will also take extra time when you go to deallocate the matrix, painstakingly free-ing up each individual row allocation. Gets me in a sweat just thinking about it.There\'s another reason it\'s slow. These separate allocations tend to live in discontinuous parts of memory. One row may be at address 1,000, another at address 100,000\xe2\x80\x94you get the idea. This means that when you\'re traversing the matrix, you\'re leaping through memory like a wild person. This tends to result in cache misses that vastly slow down your processing time.So, if you absolute must have your cute [x][y] indexing syntax, use that solution. If you want quickness and smallness (and if you don\'t care about those, why are you working in C++?), you need a different solution.A Different SolutionThe better solution is to allocate your whole matrix as a single dynamic array, then use (slightly) clever indexing math of your own to access cells. The indexing math is only very slightly clever; nah, it\'s not clever at all: it\'s obvious.Given this index() function (which I\'m imagining is a member of a class because it needs to know the m_width of your matrix), you can access cells within your matrix array. The matrix array is allocated like this:So the equivalent of this in the slow, fat solution:...is this in the quick, small solution:Sad, I know. But you\'ll get used to it. And your CPU will thank you.In C++11 it is possible:This way, the memory is not initialized. To initialize it do this instead:Sample program (compile with "g++ -std=c++11"):Output:I presume from your static array example that you want a rectangular array, and not a jagged one. You can use the following:Then you can access elements as:Don\'t forget to use delete[] on ary.There are two general techniques that I would recommend for this in C++11 and above, one for compile time dimensions and one for run time. Both answers assume you want uniform, two-dimensional arrays (not jagged ones).Use a std::array of std::array and then use new to put it on the heap:Again, this only works if the sizes of the dimensions are known at compile time.The best way to accomplish a 2 dimensional array with sizes only known at runtime is to wrap it into a class. The class will allocate a 1d array and then overload operator [] to provide indexing for the first dimension. \nThis works because in C++ a 2D array is row-major:(Taken from http://eli.thegreenplace.net/2015/memory-layout-of-multi-dimensional-arrays/)A contiguous sequence of memory is good for performance reasons and is also easy to clean up. Here\'s an example class that omits a lot of useful methods but shows the basic idea:So we create an array with std::make_unique<int[]>(rows * columns) entries. We overload operator [] which will index the row for us. It returns an int * which can then be dereferenced as normal for the column. Note that make_unique first ships in C++14 but you can polyfill it in C++11 if necessary.Technically I haven\'t used new here, but it\'s trivial to move from std::unique_ptr<int[]> to int * and use new/delete.This question was bugging me - it\'s a common enough problem that a good solution should already exist, something better than the vector of vectors or rolling your own array indexing.When something ought to exist in C++ but doesn\'t, the first place to look is boost.org. There I found the Boost Multidimensional Array Library, multi_array. It even includes a multi_array_ref class that can be used to wrap your own one-dimensional array buffer.Why not use STL:vector? So easy, and you don\'t need to delete the vector.How to allocate a contiguous multidimensional array in GNU C++?  There\'s a GNU extension that allows the "standard" syntax to work.It seems the problem come from operator new []. Make sure you use operator new instead :And that\'s all : you get a C-compatible multidimensional array...I recommend reading what C++ FAQ Lite says on the subject.  Allocating (and more importantly, properly freeing) a multi-dimensional array using new can be tricky.  Also, the next three FAQs in sequence from the one I linked are a good read.  They\'ll give you tips on how to turn your array into its own class (enabling RAII, among other things), and an introduction to genericity using templates.typedef is your friendAfter going back and looking at many of the other answers I found that a deeper explanation is in order, as many of the other answers either suffer from performance problems or force you to use unusual or burdensome syntax to declare the array, or access the array elements ( or all the above ).First off, this answer assumes you know the dimensions of the array at compile time.  If you do, then this is the best solution as it will both give the best performance and allows you to use standard array syntax to access the array elements. The reason this gives the best performance is because it allocates all of the arrays as a contiguous block of memory meaning that you are likely to have less page misses and better spacial locality.  Allocating in a loop may cause the individual arrays to end up scattered on multiple non-contiguous pages through the virtual memory space as the allocation loop could be interrupted ( possibly multiple times ) by other threads or processes, or simply due to the discretion of the allocator filling in small, empty memory blocks it happens to have available.  The other benefits are a simple declaration syntax and standard array access syntax.In C++ using new:Or C style using calloc:A 2D array is basically a 1D array of pointers, where every pointer is pointing to a 1D array, which will hold the actual data.Here N is row and M is column.dynamic allocationfillprintfreeorThis problem has bothered me for 15 years, and all the solutions supplied weren\'t satisfactory for me. How do you create a dynamic multidimensional array contiguously in memory. Today I finally found the answer. Using the following code, you can do just that:When you invoke the program with the values sizeX=20 and sizeY=15, the output will be the following:As you can see, the multidimensional array lies contiguously in memory, and no two memory addresses are overlapping. Even the routine for freeing the array is simpler than the standard way of dynamically allocating memory for every single column (or row, depending on how you view the array). Since the array basically consists of two linear arrays, only these two have to be (and can be) freed.This method can be extended for more than two dimensions with the same concept. I won\'t do it here, but when you get the idea behind it, it is a simple task.I hope this code will help you as much as it helped me.Try doing this:Start by defining the array using pointers (Line 1):If your project is CLI (Common Language Runtime Support), then:You can use the array class, not that one you get when you write:In other words, not the unmanaged array class you get when using the std namespace and when including the array header, not the unmanaged array class defined in the std namespace and in the array header, but the managed class array of the CLI.with this class, you can create an array of any rank you want.The following code below creates new two dimensional array of 2 rows and 3 columns and of type int, and I name it "arr":Now you can access elements in the array, by name it and write only one squared parentheses [], and inside them, add the row and column, and separate them with the comma ,.The following code below access an element in 2nd row and 1st column of the array I already created in previous code above:writing only this line is to read the value in that cell, i.e. get the value in this cell, but if you add the equal = sign, you are about to write the value in that cell, i.e. set the value in this cell.\nYou also can use the +=, -=, *= and /= operators of course, for numbers only (int, float, double, __int16, __int32, __int64 and etc), but sure you know it already.If your project is not CLI, then you can use the unmanaged array class of the std namespace, if you #include <array>, of course, but the problem is that this array class is different than the CLI array. Create array of this type is same like the CLI, except that you will have to remove the ^ sign and the gcnew keyword. But unfortunately the second int parameter in the <> parentheses specifies the length (i.e. size) of the array, not its rank!There is no way to specify rank in this kind of array, rank is CLI array\'s feature only..std array behaves like normal array in c++, that you define with pointer, for example int* and then: new int[size], or without pointer: int arr[size], but unlike the normal array of the c++, std array provides functions that you can use with the elements of the array, like fill, begin, end, size, and etc, but normal array provides nothing.But still std array are one dimensional array, like the normal c++ arrays.\nBut thanks to the solutions that the other guys suggest about how you can make the normal c++ one dimensional array to two dimensional array, we can adapt the same ideas to std array, e.g. according to Mehrdad Afshari\'s idea, we can write the following code:This line of code creates a "jugged array", which is an one dimensional array that each of its cells is or points to another one dimensional array.If all one dimensional arrays in one dimensional array are equal in their length/size, then you can treat the array2d variable as a real two dimensional array, plus you can use the special methods to treat rows or columns, depends on how you view it in mind, in the 2D array, that std array supports.You also can use Kevin Loney\'s solution:but if you use std array, the code must look different:And still have the unique functions of the std array.Note that you still can access the elements of the std array using the [] parentheses, and you don\'t have to call the at function.\nYou also can define and assign new int variable that will calculate and keep the total number of elements in the std array, and use its value, instead of repeating sizeX*sizeYYou can define your own two dimensional array generic class, and define the constructor of the two dimensional array class to receive two integers to specify the number of rows and columns in the new two dimensional array, and define get function that receive two parameters of integer that access an element in the two dimensional array and returns its value, and set function that receives three parameters, that the two first are integers that specify the row and column in the two dimensional array, and the third parameter is the new value of the element. Its type depends on the type you chose in the generic class.You will be able to implement all this by using either the normal c++ array (pointers or without) or the std array and use one of the ideas that other people suggested, and make it easy to use like the cli array, or like the two dimensional array that you can define, assign and use in C#.I have left you with a solution which works the best for me, in certain cases. Especially if one knows [the size of?] one dimension of the array. Very useful for an array of chars, for instance if we need an array of varying size of arrays of char[20].The key is the parentheses in the array declaration.I used this not elegant but FAST,EASY and WORKING system. I do not see why can not work because the only way for the system to allow create a big size array and access parts is without cutting it in parts:Here, I have two options. The first one shows the concept of an array of arrays or pointer of pointers. I prefer the second one because the addresses are contiguous, as you can see in the image.declaring 2D array dynamically:Now in the above code we took a double pointer and assigned it a dynamic memory and gave a value of the columns. Here the memory allocated is only for the columns, now for the rows we just need a for loop and assign the value for every row a dynamic memory. Now we can use the pointer just the way we use a 2D array. In the above example we then assigned random numbers to our 2D array(pointer).Its all about DMA of 2D array.This is not the one in much details, but quite simplified.Remember:1. ONLY THE THE FIRST INDEX CAN BE A RUNTIME VARIABLE. OTHER INDEXES NEED TO BE CONSTANT2. NO INDEX CAN BE LEFT EMPTY.As mentioned in other answers, callto deallocate memory associated with the array when you are done with the array.I\'m using this when creating dynamic array. If you have a class or a struct. And this works. Example: