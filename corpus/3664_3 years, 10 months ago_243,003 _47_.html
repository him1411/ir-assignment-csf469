Note: This is intended to be a canonical answer for a common problem.I have a Spring @Service class (MileageFeeCalculator) that has an @Autowired field (rateService), but the field is null when I try to use it. The logs show that both the MileageFeeCalculator bean and the MileageRateService bean are being created, but I get a NullPointerException whenever I try to call the mileageCharge method on my service bean. Why isn\'t Spring autowiring the field?Controller class:Service class:Service bean that should be autowired in MileageFeeCalculator but it isn\'t:When I try to GET /mileage/3, I get this exception:The field annotated @Autowired is null because Spring doesn\'t know about the copy of MileageFeeCalculator that you created with new and didn\'t know to autowire it.The Spring Inversion of Control (IoC) container has three main logical components: a registry (called the ApplicationContext) of components (beans) that are available to be used by the application, a configurer system that injects objects\' dependencies into them by matching up the dependencies with beans in the context, and a dependency solver that can look at a configuration of many different beans and determine how to instantiate and configure them in the necessary order.The IoC container isn\'t magic, and it has no way of knowing about Java objects unless you somehow inform it of them. When you call new, the JVM instantiates a copy of the new object and hands it straight to you--it never goes through the configuration process. There are three ways that you can get your beans configured.I have posted all of this code, using Spring Boot to launch, at this GitHub project; you can look at a full running project for each approach to see everything you need to make it work. Tag with the NullPointerException: nonworkingThe most preferable option is to let Spring autowire all of your beans; this requires the least amount of code and is the most maintainable. To make the autowiring work like you wanted, also autowire the MileageFeeCalculator like this:If you need to create a new instance of your service object for different requests, you can still use injection by using the Spring bean scopes.Tag that works by injecting the @MileageFeeCalculator service object: working-inject-beanIf you really need objects created with new to be autowired, you can use the Spring @Configurable annotation along with AspectJ compile-time weaving to inject your objects. This approach inserts code into your object\'s constructor that alerts Spring that it\'s being created so that Spring can configure the new instance. This requires a bit of configuration in your build (such as compiling with ajc) and turning on Spring\'s runtime configuration handlers (@EnableSpringConfigured with the JavaConfig syntax). This approach is used by the Roo Active Record system to allow new instances of your entities to get the necessary persistence information injected.Tag that works by using @Configurable on the service object: working-configurableThis approach is suitable only for interfacing with legacy code in special situations. It is nearly always preferable to create a singleton adapter class that Spring can autowire and the legacy code can call, but it is possible to directly ask the Spring application context for a bean.To do this, you need a class to which Spring can give a reference to the ApplicationContext object:Then your legacy code can call getContext() and retrieve the beans it needs:Tag that works by manually looking up the service object in the Spring context: working-manual-lookupIf you are not coding a web application, make sure your class in which @Autowiring is done is a spring bean. Typically, spring container won\'t be aware of the class which we might think of as a spring bean. We have to tell the Spring container about our spring classes.This can be achieved by configuring in appln-contxt or the better way is to annotate class as @Component and please do not create the annotated class using new operator.\nMake sure you get it from Appln-context as below.I once encountered the same issue when I was not quite used to the life in the IoC world. The @Autowired field of one of my beans is null at runtime.The root cause is, instead of using the auto-created bean maintained by the Spring IoC container (whose @Autowired field is indeed properly injected), I am newing my own instance of that bean type and using it. Of course this one\'s @Autowired field is null because Spring has no chance to inject it.Actually you should use either JVM managed Objects or Spring managed Object to invoke methods.\nfrom your above code in your controller class you are creating new object to call your service class which have auto wired object.so it won\'t work that way. solution is make this MileageFeeCalculator as autowired object in Controller itself.Change your Controller class like below.Your problem is new (object creation in java style)With annotation @Service, @Component, @Configuration beans are created in the\n    application context of Spring when server is started. But when we create objects \n    using new operator the object is not registered in  application context which  is already created. For Example Employee.java class i have used.Check this out:I\'m new to Spring, but I discovered this working solution. Please tell me if it\'s a deprecable way.I make Spring inject applicationContext in this bean:You can put this code also in the main application class if you want.Other classes can use it like this:In this way any bean can be obtained by any object in the application (also intantiated with new) and in a static way.I think you have missed to instruct spring to scan classes with annotation. You can use @ComponentScan("packageToScan") on the configuration class of your spring application to instruct spring to scan.@Service, @Component etc annotations add meta description.\n Spring only injects instances of those classes which are either created as bean or marked with annotation.Classes marked with annotation need to be identified by spring before injecting, @ComponentScan instruct spring look for the classes marked with annotation. When Spring finds @Autowired it searches for the related bean, and injects the required instance.Adding annotation only, does not fix or facilitate the dependency injection, Spring needs to know where to look for.Another solution would be putting call:\nSpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this)\nTo MileageFeeCalculator constructor like this:It seems to be rare case but here is what happened to me:We used @inject instead of @autowired which is javaee standard supported by spring. Every places it worked fine and the beans injected correctly, instead of one place. The bean injection seems the sameAt last we found that the error was that we (actually, the eclipse ide out complete feature) imported com.opensymphony.xwork2.Inject instead of javax.inject.Inject !So to summarize, make sure that your annotations (@Autowired, @Inject, @Service ,... ) have correct packages!You can also fix this issue using @Service annotation on service class and passing the required bean classA as a parameter to the other beans classB constructor and annotate the constructor of classB with @Autowired. Sample snippet here :