A question I got on my last interview:Design a function f, such that:Where n is a 32 bit signed integer; you can\'t use complex numbers arithmetic.If you can\'t design such a function for the whole range of numbers, design it for the largest range possible.Any ideas?How about:In Python: \nPython automatically promotes integers to arbitrary length longs. In other languages the largest positive integer will overflow, so it will work for all integers except that one.To make it work for real numbers you need to replace the n in (-1)n with { ceiling(n) if n>0; floor(n) if n<0 }.In C# (works for any double, except in overflow situations):You didn\'t say what kind of language they expected... Here\'s a static solution (Haskell). It\'s basically messing with the 2 most significant bits:It\'s much easier in a dynamic language (Python). Just check if the argument is a number X and return a lambda that returns -X:Here\'s a proof of why such a function can\'t exist, for all numbers, if it doesn\'t use extra information(except 32bits of int):We must have f(0) = 0. (Proof: Suppose f(0) = x. Then f(x) = f(f(0)) = -0 = 0. Now, -x = f(f(x)) = f(0) = x, which means that x = 0.)Further, for any x and y, suppose f(x) = y. We want f(y) = -x then. And f(f(y)) = -y => f(-x) = -y. To summarize: if f(x) = y, then f(-x) = -y, and f(y) = -x, and f(-y) = x.So, we need to divide all integers except 0 into sets of 4, but we have an odd number of such integers; not only that, if we remove the integer that doesn\'t have a positive counterpart, we still have 2(mod4) numbers.If we remove the 2 maximal numbers left (by abs value), we can get the function:Of course another option, is to not comply for 0, and get the 2 numbers we removed as a bonus. (But that\'s just a silly if.)Thanks to overloading in C++:Or, you could abuse the preprocessor:This is true for all negative numbers.Because there is one more negative number than there are positive numbers for twos complement integers, f(n) = abs(n) is valid for one more case than f(n) = n > 0 ? -n : n solution that is the same same as f(n) = -abs(n). Got you by one ... :DUPDATENo, it is not valid for one case more as I just recognized by litb\'s comment ... abs(Int.Min) will just overflow ...I thought about using mod 2 information, too, but concluded, it does not work ... to early. If done right, it will work for all numbers except Int.Min because this will overflow.UPDATEI played with it for a while, looking for a nice bit manipulation trick, but I could not find a nice one-liner, while the mod 2 solution fits in one.In C#, this becomes the following:To get it working for all values, you have to replace Math.Abs() with (n > 0) ? +n : -n and include the calculation in an unchecked block. Then you get even Int.Min mapped to itself as unchecked negation does.UPDATEInspired by another answer I am going to explain how the function works and how to construct such a function.Lets start at the very beginning. The function f is repeatedly applied to a given value n yielding a sequence of values.The question demands f(f(n)) = -n, that is two successive applications of f negate the argument. Two further applications of f - four in total - negate the argument again yielding n again.Now there is a obvious cycle of length four. Substituting x = f(n) and noting that the obtained equation f(f(f(n))) = f(f(x)) = -x holds, yields the following.So we get a cycle of length four with two numbers and the two numbers negated. If you imagine the cycle as a rectangle, negated values are located at opposite corners.One of many solution to construct such a cycle is the following starting from n.A concrete example is of such an cycle is +1 => -2 => -1 => +2 => +1. We are almost done. Noting that the constructed cycle contains an odd positive number, its even successor, and both numbers negate, we can easily partition the integers into many such cycles (2^32 is a multiple of four) and have found a function that satisfies the conditions.But we have a problem with zero. The cycle must contain 0 => x => 0 because zero is negated to itself. And because the cycle states already 0 => x it follows 0 => x => 0 => x. This is only a cycle of length two and x is turned into itself after two applications, not into -x. Luckily there is one case that solves the problem. If X equals zero we obtain a cycle of length one containing only zero and we solved that problem concluding that zero is a fixed point of f.Done? Almost. We have 2^32 numbers, zero is a fixed point leaving 2^32 - 1 numbers, and we must partition that number into cycles of four numbers. Bad that 2^32 - 1 is not a multiple of four - there will remain three numbers not in any cycle of length four.I will explain the remaining part of the solution using the smaller set of 3 bit signed itegers ranging from -4 to +3. We are done with zero. We have one complete cycle +1 => -2 => -1 => +2 => +1. Now let us construct the cycle starting at +3.The problem that arises is that +4 is not representable as 3 bit integer. We would obtain +4 by negating -3 to +3 - what is still a valid 3 bit integer - but then adding one to +3 (binary 011) yields 100 binary. Interpreted as unsigned integer it is +4 but we have to interpret it as signed integer -4. So actually -4 for this example or Int.MinValue in the general case is a second fixed point of integer arithmetic negation - 0  and Int.MinValue are mapped to themselve. So the cycle is actually as follows.It is a cycle of length two and additionally +3 enters the cycle via -4. In consequence -4 is correctly mapped to itself after two function applications, +3 is correctly mapped to -3 after two function applications, but -3 is erroneously mapped to itself after two function applications.So we constructed a function that works for all integers but one. Can we do better? No, we cannot. Why? We have to construct cycles of length four and are able to cover the whole integer range up to four values. The remaining values are the two fixed points 0 and Int.MinValue that must be mapped to themselves and two arbitrary integers x and -x that must be mapped to each other by two function applications.To map x to -x and vice versa they must form a four cycle and they must be located at opposite corners of that cycle. In consequence 0 and Int.MinValue have to be at opposite corners, too. This will correctly map x and -x but swap the two fixed points 0 and Int.MinValue after two function applications and leave us with two failing inputs. So it is not possible to construct a function that works for all values, but we have one that works for all values except one and this is the best we can achieve.Using complex numbers, you can effectively divide the task of negating a number into two steps: The great thing is that you don\'t need any special handling code. Just multiplying by i does the job.But you\'re not allowed to use complex numbers. So you have to somehow create your own imaginary axis, using part of your data range. Since you need exactly as much imaginary (intermediate) values as initial values, you are left with only half the data range.I tried to visualize this on the following figure, assuming signed 8-bit data. You would have to scale this for 32-bit integers. The allowed range for initial n is -64 to +63.\nHere\'s what the function does for positive n:For negative n, the function uses the intermediate range -65..-128.Works except int.MaxValue and int.MinValueThe question doesn\'t say anything about what the input type and return value of the function f have to be (at least not the way you\'ve presented it)... ...just that when n is a 32-bit integer then f(f(n)) = -nSo, how about something likeIf n is a 32-bit integer then the statement f(f(n)) == -n will be true.Obviously, this approach could be extended to work for an even wider range of numbers...for javascript (or other dynamically typed languages) you can have the function accept either an int or an object and return the other. i.e.givingalternatively you could use overloading in a strongly typed language although that may break the rules ieDepending on your platform, some languages allow you to keep state in the function.  VB.Net, for example:IIRC, C++ allowed this as well.  I suspect they\'re looking for a different solution though.Another idea is that since they didn\'t define the result of the first call to the function you could use odd/evenness to control whether to invert the sign:Add one to the magnitude of all even numbers, subtract one from the magnitude of all odd numbers.  The result of two calls has the same magnitude, but the one call where it\'s even we swap the sign.  There are some cases where this won\'t work (-1, max or min int), but it works a lot better than anything else suggested so far.Exploiting JavaScript exceptions.f(f(0)) => 0f(f(1)) => -1For all 32-bit values (with the caveat that -0 is -2147483648)You basically need to pair each -x => x => -x loop with a y => -y => y loop.  So I paired up opposite sides of the split.  e.g. For 4 bit integers:A C++ version, probably bending the rules somewhat but works for all numeric types (floats, ints, doubles) and even class types that overload the unary minus:x86 asm (AT&T style): Code checked, all possible 32bit integers passed, error with -2147483647 (underflow).Uses globals...but so?This Perl solution works for integers, floats, and strings.Try some test data.Output:Nobody ever said f(x) had to be the same type.I would you change the 2 most significant bits.As you can see, it\'s just an addition, leaving out the carried bit.How did I got to the answer? My first thought was just a need for symmetry. 4 turns to get back where I started. At first I thought, that\'s 2bits Gray code. Then I thought actually standard binary is enough.I\'m not actually trying to give a solution to the problem itself, but do have a couple of comments, as the question states this problem was posed was part of a (job?) interview:Oh, this answer assumes the interview was for a C# programming related position. Would of course be a silly answer if the interview was for a math related position. ;-)Here is a solution that is inspired by the requirement or claim that complex numbers can not be used to solve this problem. Multiplying by the square root of -1 is an idea, that only seems to fail because -1 does not have a square root over the integers. But playing around with a program like mathematica gives for example the equation(18494364652+1) mod (232-3) = 0.and this is almost as good as having a square root of -1. The result of the function needs to be a signed integer. Hence I\'m going to use a modified modulo operation mods(x,n) that returns the integer y congruent to x modulo n that is closest to 0. Only very few programming languages have suc a modulo operation, but it can easily be defined. E.g. in python it is:Using the equation above, the problem can now be solved as This satisfies f(f(x)) = -x for all integers in the range [-231-2, 231-2]. The results of f(x) are also in this range, but of course the computation would need 64-bit integers.C# for a range of 2^32 - 1 numbers, all int32 numbers except (Int32.MinValue)prints:Essentially the function has to divide the available range into cycles of size 4, with -n at the opposite end of n\'s cycle. However, 0 must be part of a cycle of size 1, because otherwise 0->x->0->x != -x. Because of 0 being alone, there must be 3 other values in our range (whose size is a multiple of 4) not in a proper cycle with 4 elements.I chose these extra weird values to be MIN_INT, MAX_INT, and MIN_INT+1. Furthermore, MIN_INT+1 will map to MAX_INT correctly, but get stuck there and not map back. I think this is the best compromise, because it has the nice property of only the extreme values not working correctly. Also, it means it would work for all BigInts.Nobody said it had to be stateless.Cheating, but not as much as a lot of the examples. Even more evil would be to peek up the stack to see if your caller\'s address is &f, but this is going to be more portable (although not thread safe... the thread-safe version would use TLS). Even more evil:Of course, neither of these works too well for the case of MIN_INT32, but there is precious little you can do about that unless you are allowed to return a wider type.I could imagine using the 31st bit as an imaginary (i) bit would be an approach that would support half the total range.works for n= [0 .. 2^31-1]The problem states "32-bit signed integers" but doesn\'t specify whether they are twos-complement or ones-complement.If you use ones-complement then all 2^32 values occur in cycles of length four - you don\'t need a special case for zero, and you also don\'t need conditionals.In C:This works byAfter two passes we have the bitwise inverse of the original value.  Which in ones-complement representation is equivalent to negation.Examples::DI\'d like to share my point of view on this interesting problem as a mathematician. I think I have the most efficient solution.If I remember correctly, you negate a signed 32-bit integer by just flipping the first bit. For example, if n = 1001 1101 1110 1011 1110 0000 1110 1010, then -n = 0001 1101 1110 1011 1110 0000 1110 1010.So how do we define a function f that takes a signed 32-bit integer and returns another signed 32-bit integer with the property that taking f twice is the same as flipping the first bit?Let me rephrase the question without mentioning arithmetic concepts like integers.How do we define a function f that takes a sequence of zeros and ones of length 32 and returns a sequence of zeros and ones of the same length, with the property that taking f twice is the same as flipping the first bit?Observation: If you can answer the above question for 32 bit case, then you can also answer for 64 bit case, 100 bit case, etc. You just apply f to the first 32 bit.Now if you can answer the question for 2 bit case, Voila!And yes it turns out that changing the first 2 bits is enough.Here\'s the pseudo-codeRemark: The step 2 and the step 3 together can be summerised as (a,b) --> (-b, a). Looks familiar? That should remind you of the 90 degree rotation of the plane and the multiplication by the squar root of -1.If I just presented the pseudo-code alone without the long prelude, it would seem like a rabbit out of the hat, I wanted to explain how I got the solution.