Is there recommended order in which include files should be specified?For example, the system files, STL, Boost, go before of after local include files?\nIs there a particular reason to choose one or another?  I am assuming include files have proper dependencies specified.I don\'t think there\'s a recommended order, as long as it compiles! What\'s annoying is when some headers require other headers to be included first... That\'s a problem with the headers themselves, not with the order of includes.My personal preference is to go from local to global, each subsection in alphabetical order, i.e.:My rationale for 1. is that it should prove that each header (for which there is a cpp) can be #included without prerequisites. And the rest just seems to flow logically from there.The big thing to keep in mind is that your headers should not be dependent upon other headers being included first. One way to insure this is to include your headers before any other headers."Thinking in C++" in particular mentions this, referencing Lakos\' "Large Scale C++ Software Design":That is to say, include in the following order:If any of the headers have an issue with being included in this order, either fix them (if yours) or don\'t use them. Boycott libraries that don\'t write clean headers.Google\'s C++ style guide (http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml) argues almost the reverse, with really no justification at all; I personally tend to favor the Lakos approach.I follow two simple rules that avoid the vast majority of problems:I also follow the guidelines of:In other words:Although, being guidelines, that\'s a subjective thing. The rules on the other hand, I enforce rigidly, even to the point of providing \'wrapper\' header files with include guards and grouped includes if some obnoxious third-party developer doesn\'t subscribe to my vision :-)I\'m pretty sure this isn\'t a recommended practice anywhere in the sane world, but I like to line system includes up by filename length, sorted lexically within the same length.  Like so:I think it\'s a good idea to include your own headers before other peoples, to avoid the shame of include-order dependency.To add my own brick to the wall.So I usually go like this:Each group separated by a blank line from the next one:Also note that apart from system headers each file is in a folder that with the name of its namespace, just because it\'s easier to track them down this way.I recommend:And of course, alphabetical order within each section, where possible.Always use forward declarations to avoid unnecessary #includes in your header files.  This is not subjective. Make sure your headers don\'t rely on being #included in specific order. You can be sure it doesn\'t matter what order you include STL or Boost headers.First include the header corresponding to the .cpp... in other words, source1.cpp should include source1.h before including anything else. The only exception I can think of is when using MSVC with pre-compiled headers in which case, you are forced to include stdafx.h before anything else.Reasoning: Including the source1.h before any other files ensures that it can stand alone without it\'s dependencies. If source1.h takes on a dependency on a later date, the compiler will immediately alert you to add the required forward declarations to source1.h. This in turn ensures that headers can be included in any order by their dependants.Example:source1.hsource1.cppMSVC users: I strongly recommend using pre-compiled headers. So, move all #include directives for standard headers (and other headers which are never going to change) to stdafx.h.Include from the most specific to the least specific, starting with the corresponding .hpp for the .cpp, if one such exists. That way, any hidden dependencies in header files that are not self-sufficient will be revealed.This is complicated by the use of pre-compiled headers. One way around this is, without making your project compiler-specific, is to use one of the project headers as the precompiled header include file.It is a hard question in C/C++ world, with so many elements beyond the standard.I think header file order is not a serious problem as long as it compiles, like squelart said. My ideas is: If there is no conflict of symbols in all those headers, any order is OK, and the header dependency issue can be fixed later by adding #include lines to the flawed .h.The real hassle arises when some header changes its action(by checking #if conditions) according to what headers are above.For example, in stddef.h in VS2005, there is :Now the problem: If I have a custom header("custom.h") that needs to be used with many compilers, including some older ones that don\'t provide offsetof in their system headers, I should write in my headerand be sure to tell user to #include "custom.h" after all system headers, otherwise, the line of offsetof in stddef.h will assert macro redefinition error.We pray not to meet any more of such case in our career.