I\'m updating an old app with an AdBannerView and when there is no ad, it slides off screen. When there is an ad it slides on screen. Basic stuff.Old style, I set the frame in an animation block.\nNew style, I have a IBOutlet to the constraint which determines the Y position, in this case it\'s distance from the bottom of the superview, and modify the constant.And the banner moves, exactly as expected, but no animation.UPDATE: I re-watched WWDC12 video "Best Practices for Mastering Auto Layout" which covers animation. It discusses how to update constraints using CoreAnimation. \nI\'ve tried with the following code, but get the exact same results.On a side note, I have checked numerous times and this is being executed on the main thread. Two important notes:You need to call layoutIfNeeded within the animation block.  Apple actually recommends you call it once before the animation block to ensure that all pending layout operations have been completed  You need to call it specifically on the parent view (e.g. self.view), not the child view that has the constraints attached to it.  Doing so will update all constrained views, including animating other views that might be constrained to the view that you changed the constraint of (e.g. View B is attached to the bottom of View A and you just changed View A\'s top offset and you want View B to animate with it)Try this:Objective-CSwift 3I appreciate the answer provided, but I think it would be nice to take it a bit further.but really this is a very simplistic scenario. What if I want to animate subview constraints via the  updateConstraints method?The updateConstraints method is overridden in the UIView subclass and must call super at the end of the method.The AutoLayout Guide leaves much to be desired but it is worth reading. I myself am using this as part of a UISwitch that toggles a subview with a pair of UITextFields with a simple and subtle collapse animation (0.2 seconds long). The constraints for the subview are being handled in the UIView subclasses updateConstraints methods as described above.Generally, you just need to update constraints and call layoutIfNeeded inside the animation block. This can be either changing the .constant property of an NSLayoutConstraint, adding remove constraints (iOS 7), or changing the .active property of constraints (iOS 8 & 9).There are some questions about whether the constraint should be changed before the animation block, or inside it (see previous answers).The following is a Twitter conversation between Martin Pilkington who teaches iOS, and Ken Ferry who wrote Auto Layout. Ken explains that though changing constants outside of the animation block may currently work, it\'s not safe and they should really be change inside the animation block.\nhttps://twitter.com/kongtomorrow/status/440627401018466305Here\'s a simple project showing how a view can be animated. It\'s using Objective C and animates the view by changing the .active property of several constraints.\nhttps://github.com/shepting/SampleAutoLayoutAnimationThe other answers are just fine but this one highlights a few fairly important gotchas of animating constraints using a recent example. I went through a lot of variations before I realized the following:Make the constraints you want to target into Class variables to hold a strong reference. In Swift I used lazy variables:After some experimentation I noted that one MUST obtain the constraint from the view ABOVE (aka the superview) the two views where the constraint is defined. In the example below (both MNGStarRating and UIWebView are the two types of items I am creating a constraint between, and they are subviews within self.view).Filter ChainingI take advantage of Swift\'s filter method to separate the desired constraint that will serve as the inflection point. One could also get much more complicated but filter does a nice job here.Animating Constraints Using SwiftNota Bene - This example is the storyboard/code solution and assumes\n  one has made default constraints in the storyboard. One can then\n  animate the changes using code.Assuming you create a property to filter with accurate criteria and get to a specific inflection point for your animation (of course you could also filter for an array and loop through if you need multiple constraints):....Sometime later...These notes are really a set of tips that I wrote for myself. I did all the don\'ts personally and painfully. Hopefully this guide can spare others.Watch out for zPositioning. Sometimes when nothing is apparently\nhappening, you should hide some of the other views or use the view\ndebugger to locate your animated view. I\'ve even found cases where a User Defined Runtime\nAttribute was lost in a storyboard\'s xml and led to the animated\nview being covered (while working).Always take a minute to read the documentation (new and old), Quick\nHelp, and headers. Apple keeps making a lot of changes to better\nmanage AutoLayout constraints (see stack views). Or at least the AutoLayout Cookbook. Keep in mind that sometimes the best solutions are in the older documentation/videos.Play around with the values in the animation and consider using\nother animateWithDuration variants.Don\'t hardcode specific layout values as criteria for determining\nchanges to other constants, instead use values that allow you to\ndetermine the location of the view. CGRectContainsRect is one\nexampleQuick Sample Of Solutions to AVOID when using StoryboardsIf you forget one of these tips or the more simple ones such as where to add the layoutIfNeeded, most likely nothing will happen: In which case you may have a half baked solution like this:NB - Take a moment to read the AutoLayout Section Below and the\n  original guide. There is a way to use these techniques to supplement\n  your Dynamic Animators.Snippet from the AutoLayout Guide (note the second snippet is for using OS X). BTW - This is no longer in the current guide as far as I can see.  The preferred techniques continue to evolve.Animating Changes Made by Auto LayoutIf you need full control over animating changes made by Auto Layout, you must make your constraint changes programmatically. The basic concept is the same for both iOS and OS X, but there are a few minor differences.In an iOS app, your code would look something like the following:In OS X, use the following code when using layer-backed animations:When you aren\xe2\x80\x99t using layer-backed animations, you must animate the constant using the constraint\xe2\x80\x99s animator:For those who learn better visually check out this early video from Apple.Often in documentation there are small notes or pieces of code that lead to bigger ideas. For example attaching auto layout constraints to dynamic animators is a big idea.Good Luck and May the Force be with you.I was trying to animate Constraints and was not really easy to found a good explanation.What other answers are saying is totally true: you need to call [self.view layoutIfNeeded]; inside  animateWithDuration: animations:. However, the other important point is to have pointers for every NSLayoutConstraint you want to animate.I created an example in GitHub.Swift solution:Working Solution 100% Swift 3.1i have read all the answers and want to share the code and hierarchy of lines which i have used in all my applications to animate them correctly, Some solutions here are not working, you should check them on slower devices e.g iPhone 5 at this moment.There is an article talk about this:\nhttp://weblog.invasivecode.com/post/42362079291/auto-layout-and-core-animation-auto-layout-wasIn which, he coded like this:Hope it helps.In the context of constraint animation, I would like to mention a specific situation where I animated a constraint immediately within a keyboard_opened notification. Constraint defined a top space from a textfield to top of the container. Upon keyboard opening, I just divide the constant by 2.I was unable to achieve a conistent smooth constraint animation directly within the keyboard notification. About half the times view would just jump to its new position - without animating.It occured to me there might be some additional layouting happening as result of keyboard opening. \nAdding a simple dispatch_after block with a 10ms delay made the animation run every time - no jumping.Working and just tested solution for Swift 3 with Xcode 8.3.3:Just keep in mind that self.calendarViewHeight is a constraint referred to a customView (CalendarView). I called the .layoutIfNeeded() on self.view and NOT on self.calendarViewHope this help.