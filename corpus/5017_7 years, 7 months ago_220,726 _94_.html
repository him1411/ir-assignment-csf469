I\'m trying to create a thumbnail image on the client side using javascript and a canvas element, but when I shrink the image down, it looks terrible.  It looks as if it was downsized in photoshop with the resampling set to \'Nearest Neighbor\' instead of Bicubic.  I know its possible to get this to look right, because this site can do it just fine using a canvas as well.  I\'ve tried using the same code they do as shown in the "[Source]" link, but it still looks terrible.  Is there something I\'m missing, some setting that needs to be set or something?EDIT:I\'m trying to resize a jpg.  I have tried resizing the same jpg on the linked site and in photoshop, and it looks fine when downsized.Here is the relevant code:EDIT2:Seems I was mistaken, the linked website wasn\'t doing any better of a job of downsizing the image.  I tried the other methods suggested and none of them look any better.  This is what the different methods resulted in:Photoshop:Canvas:Image with image-rendering: optimizeQuality set and scaled with width/height:Image with image-rendering: optimizeQuality set and scaled with -moz-transform:Canvas resize on pixastic:I guess this means firefox isn\'t using bicubic sampling like its supposed to.  I\'ll just have to wait until they actually add it.EDIT3:Original ImageSo what do you do if all the browsers (actually, Chrome 5 gave me quite good one) won\'t give you good enough resampling quality? You implement them yourself then! Oh come on, we\'re entering the new age of Web 3.0, HTML5 compliant browsers, super optimized JIT javascript compilers, multi-core(\xe2\x80\xa0) machines, with tons of memory, what are you afraid of? Hey, there\'s the word java in javascript, so that should guarantee the performance, right? Behold, the thumbnail generating code:...with which you can produce results like these!so anyway, here is a \'fixed\' version of your example:Now it\'s time to pit your best browsers out there and see which one will least likely increase your client\'s blood pressure!Umm, where\'s my sarcasm tag?(since many parts of the code is based on Anrieff Gallery Generator is it also covered under GPL2? I dunno)\xe2\x80\xa0 actually due to limitation of javascript, multi-core is not supported.Fast image resize/resample algorithm using Hermite filter with JavaScript. Support transparency, gives good quality. Preview: \nUpdate: version 2.0 added on GitHub (faster, web workers + transferable objects). Finally i got it working!  Git: https://github.com/viliusle/Hermite-resize\nDemo: http://viliusle.github.io/miniPaint/I know this is an old thread but it might be useful for some people such as myself that months after are hitting this issue for the first time.Here is some code that resizes the image every time you reload the image. I am aware this is not optimal at all, but I provide it as a proof of concept. Also, sorry for using jQuery for simple selectors but I just feel too comfortable with the syntax.My createImage function is called once when the document is loaded and after that it is called every time the window receives a resize event.I tested it in Chrome 6 and Firefox 3.6, both on the Mac. This "technique" eats processor as it if was ice cream in the summer, but it does the trick.Try pica - that\'s a highly optimized resizer with selectable algorythms. See demo. For example, original image from first post is resized in 120ms with Lanczos filter and 3px window or 60ms with Box filter and 0.5px window. For huge 17mb image 5000x3000px resize takes ~1s on desktop and 3s on mobile.All resize principles were described very well in this thread, and pica does not add rocket science. But it\'s optimized very well for modern JIT-s, and is ready to use out of box (via npm or bower). Also, it use webworkers when available to avoid interface freezes.I also plan to add unsharp mask support soon, because it\'s very useful after downscale.I\'ve put up some algorithms to do image interpolation on html canvas pixel arrays that might be useful here:http://jsperf.com/pixel-interpolation/2These can be copy/pasted and can be used inside of web workers to resize images (or any other operation that requires interpolation - I\'m using them to defish images at the moment).I haven\'t added the lanczos stuff above, so feel free to add that as a comparison if you\'d like.If you\'re simply trying to resize an image, I\'d recommend setting width and height of the image with CSS.  Here\'s a quick example:Note that the height and width can also be set using JavaScript.  Here\'s quick code sample:Also, to ensure that the resized image looks good, add the following css rules to image selector:As far as I can tell, all browsers except IE using an bicubic algorithm to resize images by default, so your resized images should look good in Firefox and Chrome.If setting the css width and height doesn\'t work, you may want to play with a css transform:If for whatever reason you need to use a canvas, please note that there are two ways an image can be resize: by resizing the canvas with css or by drawing the image at a smaller size.See this question for more details.Hope this helps!I\'d highly suggest you check out this link and make sure it is set to true.Controlling image scaling behaviorIntroduced in Gecko 1.9.2 (Firefox 3.6\n  / Thunderbird 3.1 / Fennec 1.0)Gecko 1.9.2 introduced the\n  mozImageSmoothingEnabled property to\n  the canvas element; if this Boolean\n  value is false, images won\'t be\n  smoothed when scaled. This property is\n  true by default. view plainprint?This is a javascript function adapted from @Telanor\'s code. When passing a image base64 as first argument to the function, it returns the base64 of the resized image. maxWidth and maxHeight are optional.For resizing to image with width less that original, i use:and it works =).i got this image by right clicking the canvas element in firefox and saving as.so anyway, here is a \'fixed\' version of your example:So something interesting that I found a while ago while working with canvas that might be helpful:To resize the canvas control on its own, you need to use the height="" and width="" attributes (or canvas.width/canvas.height elements). If you use CSS to resize the canvas, it will actually stretch (i.e.: resize) the content of the canvas to fit the full canvas (rather than simply increasing or decreasing the area of the canvas.It\'d be worth a shot to try drawing the image into a canvas control with the height and width attributes set to the size of the image and then using CSS to resize the canvas to the size you\'re looking for. Perhaps this would use a different resizing algorithm.It should also be noted that canvas has different effects in different browsers (and even different versions of different browsers). The algorithms and techniques used in the browsers is likely to change over time (especially with Firefox 4 and Chrome 6 coming out so soon, which will place heavy emphasis on canvas rendering performance).In addition, you may want to give SVG a shot, too, as it likely uses a different algorithm as well.Best of luck!The problem with some of this solutions is that they access directly the pixel data and loop through it to perform the downsampling. Depending on the size of the image this can be very resource intensive, and it would be better to use the browser\'s internal algorithms.The drawImage() function is using a linear-interpolation, nearest-neighbor resampling method. That works well when you are not resizing down more than half the original size.If you loop to only resize max one half at a time, the results would be quite good, and much faster than accessing pixel data.This function downsample to half at a time until reaching the desired size:Credits to this postI have a feeling the module I wrote will produce similar results to photoshop, as it preserves color data by averaging them, not applying an algorithm.  It\'s kind of slow, but to me it is the best, because it preserves all the color data.https://github.com/danschumann/limby-resize/blob/master/lib/canvas_resize.jsIt doesn\'t take the nearest neighbor and drop other pixels, or sample a group and take a random average.  It takes the exact proportion each source pixel should output into the destination pixel.  The average pixel color in the source will be the average pixel color in the destination, which these other formulas, I think they will not be.an example of how to use is at the bottom of \nhttps://github.com/danschumann/limby-resizeI converted @syockit\'s answer as well as the step-down approach into a reusable Angular service for anyone who\'s interested:  https://gist.github.com/fisch0920/37bac5e741eaec60e983I included both solutions because they both have their own pros / cons.  The lanczos convolution approach is higher quality at the cost of being slower, whereas the step-wise downscaling approach produces reasonably antialiased results and is significantly faster.Example usage:Fast and simple Javascript image resizer:https://github.com/calvintwr/Hermite-resizeUse:This is really after many rounds of research, reading and trying. The resizer algorithm uses @ViliusL\'s Hermite script (Hermite resizer is really the fastest and gives reasonably good output). Extended with features you need. Forks 1 worker to do the resizing so that it doesn\'t freeze your browser when resizing, unlike all other JS resizers out there.I just ran a page of side by sides comparisons and unless something has changed recently, I could see no better downsizing (scaling) using canvas vs. simple css. I tested in FF6 Mac OSX 10.7. Still slightly soft vs. the original.I did however stumble upon something that did make a huge difference and that was using image filters in browsers that support canvas. You can actually manipulate images much like you can in Photoshop with blur, sharpen, saturation, ripple, grayscale, etc.I then found an awesome jQuery plug-in which makes application of these filters a snap:\nhttp://codecanyon.net/item/jsmanipulate-jquery-image-manipulation-plugin/428234I simply apply the sharpen filter right after resizing the image which should give you the desired effect. I didn\'t even have to use a canvas element.Thanks @syockit for an awesome answer. however, I had to reformat a little as follows to make it work. Perhaps due to DOM scanning issues:});Looking for another great simple solution?This solution will use the resize algorith of browser! :)