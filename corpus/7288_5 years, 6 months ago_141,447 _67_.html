What are the most basic definitions of "iterable", "iterator" and "iteration" in Python?I\'ve read multiple definitions but their exact meaning still won\'t sink in.Can someone please help me with the basic idea?Iteration is a general term for taking each item of something, one after another. Any time you use a loop, explicit or implicit, to go over a group of items, that is iteration.In Python, iterable and iterator have specific meanings.An iterable is an object that has an __iter__ method which returns an iterator, or which defines a __getitem__ method that can take sequential indexes starting from zero (and raises an IndexError when the indexes are no longer valid). So an iterable is an object that you can get an iterator from.An iterator is an object with a next (Python 2) or __next__ (Python 3) method. Whenever you use a for loop, or map, or a list comprehension, etc. in Python, the next method is called automatically to get each item from the iterator, thus going through the process of iteration.A good place to start learning would be the iterators section of the tutorial and the iterator types section of the standard types page. After you understand the basics, try the iterators section of the Functional Programming HOWTO.Here\'s the explanation I use in teaching Python classes:An ITERABLE is:An ITERATOR is an object:Notes:For example:The above answers are great, but as most of what I\'ve seen, don\'t stress the distinction enough for people like me.Also, people tend to get "too Pythonic" by putting definitions like "X is an object that has __foo__() method" before.  Such definitions are correct--they are based on duck-typing philosophy, but the focus on methods tends to get between when trying to understand the concept in its simplicity.So I add my version.In natural language,In Python,iterable is an object that is, well, iterable, which simply put, means that\nit can be used in iteration, e.g. with a for loop.  How?  By using iterator.\nI\'ll explain below.... while iterator is an object that defines how to actually do the\niteration--specifically what is the next element.  That\'s why it must have\nnext() method. Iterators are themselves also iterable, with the distinction that their __iter__() method returns the same object (self), regardless of whether or not its items have been consumed by previous calls to next().So what does Python interpreter think when it sees for x in obj: statement?Look, a for loop.   Looks like a job for an iterator...  Let\'s get one. ...\n  There\'s this obj guy, so let\'s ask him."Mr. obj, do you have your iterator?" (... calls iter(obj), which calls\n  obj.__iter__(), which happily hands out a shiny new iterator _i.) OK, that was easy... Let\'s start iterating then. (x = _i.next() ... x = _i.next()...)Since Mr. obj succeeded in this test (by having certain method returning a valid iterator), we reward him with adjective: you can now call him "iterable Mr. obj".However, in simple cases, you don\'t normally benefit from having iterator and iterable separately.  So you define only one object, which is also its own iterator.  (Python does not really care that _i handed out by obj wasn\'t all that shiny, but just the obj itself.) This is why in most examples I\'ve seen (and what had been confusing me over and over),\nyou can see:instead ofThere are cases, though, when you can benefit from having iterator separated from the iterable, such as when you want to have one row of items, but more "cursors".  For example when you want to work with "current" and "forthcoming" elements, you can have separate iterators for both.  Or multiple threads pulling from a huge list: each can have its own iterator to traverse over all items. See @Raymond\'s and @glglgl\'s answers above.Imagine what you could do:Notes: I\'ll repeat again: iterator is not iterable.  Iterator cannot be used as\na "source" in for loop.  What for loop primarily needs is __iter__()\n(that returns something with next()).Of course, for is not the only iteration loop, so above applies to some other\nconstructs as well (while...).Iterator\'s next() can throw StopIteration to stop iteration.  Does not have to,\nthough, it can iterate forever or use other means.In the above "thought process", _i does not really exist.  I\'ve made up that name.There\'s a small change in Python 3.x: next() method (not the built-in) now\nmust be called __next__().  Yes, it should have been like that all along.You can also think of it like this: iterable has the data, iterator pulls the next\nitemDisclaimer: I\'m not a developer of any Python interpreter, so I don\'t really know what the interpreter "thinks".  The musings above are solely demonstration of how I understand the topic from other explanations, experiments and real-life experience of a Python newbie.An iterable is a object which has a __iter__() method. It can possibly iterated over several times, such as list()s and tuple()s.An iterator is the object which iterates. It is returned by an __iter__() method, returns itself via its own __iter__() method and has a next() method (__next__() in 3.x).Iteration is the process of calling this next() resp. __next__() until it raises StopIteration.Example:I don\'t think that you can get it much simpler than the documentation, however I\'ll try:You can think Iterator as a helper pseudo-method (or pseudo-attribute) that gives (or holds) the next (or first) item in the iterable. (In practice it is just an object that defines the method next())Iteration is probably best explained by the Merriam-Webster definition of the word :b : the repetition of a sequence of computer instructions a specified\n  number of times or until a condition is met \xe2\x80\x94 compare recursionI don\xe2\x80\x99t know if it helps anybody but I always like to visualize concepts in my head to better understand them. So as I have a little son I visualize iterable/iterator concept with bricks and white paper.Suppose we are in the dark room and on the floor we have bricks for my son. Bricks of different size, color, does not matter now. Suppose we have 5 bricks like those. Those 5 bricks can be described as an object \xe2\x80\x93 let\xe2\x80\x99s say bricks kit. We can do many things with this bricks kit \xe2\x80\x93 can take one and then take second and then third, can change places of bricks, put first brick above the second. We can do many sorts of things with those. Therefore this bricks kit is an iterable object or sequence as we can go through each brick and do something with it. We can only do it like my little son \xe2\x80\x93 we can play with one brick at a time. So again I imagine myself this bricks kit to be an iterable.Now remember that we are in the dark room. Or almost dark. The thing is that we don\xe2\x80\x99t clearly see those bricks, what color they are, what shape etc. So even if we want to do something with them \xe2\x80\x93 aka iterate through them \xe2\x80\x93 we don\xe2\x80\x99t really know what and how because it is too dark.What we can do is near to first brick \xe2\x80\x93 as element of a bricks kit \xe2\x80\x93 we can put a piece of white fluorescent paper in order for us to see where the first brick-element is. And each time we take a brick from a kit, we replace the white piece of paper to a next brick in order to be able to see that in the dark room. This white piece of paper is nothing more than an iterator. It is an object as well. But an object with what we can work and play with elements of our iterable object \xe2\x80\x93 bricks kit.That by the way explains my early mistake when I tried the following in an IDLE and got a TypeError:List X here was our bricks kit but NOT a white piece of paper. I needed to find an iterator first:Don\xe2\x80\x99t know if it helps, but it helped me. If someone could confirm/correct visualization of the concept, I would be grateful. It would help me to learn more.so,iterable is an object that can be looped over. e.g. list , string , tuple etc.using the iter function on our iterable object will return an iterator object.now this iterator object has method named __next__ (in Python 3, or just next in Python 2) by which you can access each element of iterable.so, \n    OUTPUT OF ABOVE CODE WILL BE:12In Python everything is an object. When an object is said to be iterable, it means that you can step through (i.e. iterate) the object as a collection.Arrays for example are iterable. You can step through them with a for loop, and go from index 0 to index n, n being the length of the array object minus 1.Dictionaries (pairs of key/value, also called associative arrays) are also iterable. You can step through their keys.Obviously the objects which are not collections are not iterable. A bool object for example only have one value, True or False. It is not iterable (it wouldn\'t make sense that it\'s an iterable object).Read more. http://www.lepus.org.uk/ref/companion/Iterator.xml