What\'s the best way of checking if an object property in JavaScript is undefined?Use:If an object variable which have some properties you can use same thing like this:I believe there are a number of incorrect answers to this topic. Contrary to common belief, "undefined" is not a keyword in JavaScript and can in fact have a value assigned to it.The most robust way to perform this test is:This will always return the correct result, and even handles the situation where myVar is not declared.Additionally, myVar === undefined will raise an error in the situation where myVar is undeclared.In JavaScript there is null and there is undefined.  They have different meanings.Marijn Haverbeke states, in his free, online book "Eloquent JavaScript" (emphasis mine):There is also a similar value, null, whose meaning is \'this value is defined, but it does not have a value\'. The difference in meaning between undefined and null is mostly academic, and usually not very interesting. In practical programs, it is often necessary to check whether something \'has a value\'. In these cases, the expression something == undefined may be used, because, even though they are not exactly the same value, null == undefined will produce true.So, I guess the best way to check if something was undefined would be:Hope this helps!Edit: In response to your edit, object properties should work the same way.What does this mean: "undefined object property"?Actually it can mean two quite different things! First, it can mean the property that has never been defined in the object and, second, it can mean the property that has an undefined value. Let\'s look at this code:Is o.a undefined? Yes! Its value is undefined. Is o.b undefined? Sure! There is no property \'b\' at all! OK, see now how different approaches behave in both situations:We can clearly see that typeof obj.prop == \'undefined\' and obj.prop === undefined are equivalent, and they do not distinguish those different situations. And \'prop\' in obj can detect the situation when a property hasn\'t been defined at all and doesn\'t pay attention to the property value which may be undefined.1) You want to know if a property is undefined by either the first or second meaning (the most typical situation).2) You want to just know if object has some property and don\'t care about its value.Pluses of obj.prop === undefined:Minuses of obj.prop === undefined:Pluses of typeof obj.prop == \'undefined\':Minuses of typeof obj.prop == \'undefined\':Node.js supports the global variable undefined as global.undefined (it can also be used without the \'global\' prefix). I don\'t know about other implementations of server-side JavaScript.Many of the existing answers are misleading at best.Never use typeof x === "undefined".  (Or == "undefined" for that matter.) As with all \xe2\x80\x9cnever\xe2\x80\x9ds, there are a few exceptional cases, but the majority of the time? If you don\xe2\x80\x99t know whether a real variable is defined in your current scope, you are doing something wrong, and may put your users at risk. The typeof check is really useful if you want to introduce a ton of potential for error by making a typo.Of course, this potential already exists in the case of object properties, which appears to be the topic of this question. Let\xe2\x80\x99s just ignore the typeof check, then, because it\xe2\x80\x99ll do more harm than good, and it\xe2\x80\x99s a pain to read. You\xe2\x80\x99re intuitively checking a value, not a type.The \xe2\x80\x9cdefault value\xe2\x80\x9d of a property on an object is undefined. undefined can also be set as the value on a property. This is the check you will want some of the time.This will check for the existence of the foo property somewhere along obj\xe2\x80\x99s prototype chain, regardless of value (including undefined).This will check for the existence of the foo property at the end of obj\xe2\x80\x99s prototype chain, i.e. for properties directly on obj.This is the same as above, but will use the canonical hasOwnProperty in case obj also has a property named hasOwnProperty for some reason. In practice, if somebody overrode hasOwnProperty, they\xe2\x80\x99d probably be a jerk in a bunch of other places and redefine undefined in scope, or alter Object or Object.prototype or Object.prototype.hasOwnProperty.call.This one also checks for null. To make that clearer, I\xe2\x80\x99d recommend using != null instead.This checks for the other falsy values (I hope that\xe2\x80\x99s obvious) \xe2\x80\x93 0, NaN, false, and the empty string. Certainly practically useful for checking for function support:To sum up: don\xe2\x80\x99t use typeof to check for undefined values. It is prone to error. If you make a typo in the "undefined" part, you will get the wrong answer. If you make a typo in the testing variable (if you are testing a variable \xe2\x80\x93 which you shouldn\xe2\x80\x99t be, ever, use the global object to do that kind of feature test), you will get the wrong answer.If you are paranoid about undefined being redefined, here\xe2\x80\x99s why you shouldn\xe2\x80\x99t be:undefined is read-only in modern browsers. If you\xe2\x80\x99re developing in strict mode as you should be, attempting to assign to it will throw an error. (Even if you don\xe2\x80\x99t develop in strict mode, though, it won\xe2\x80\x99t change.) It\xe2\x80\x99s also a non-configurable property. You will have to worry if you go \xe2\x80\x9csafe mode\xe2\x80\x9d by passing undefined into your IIFE. Never do that, for the reason outlined in this bullet point, and for the fact that\xe2\x80\xa6Anybody who is redefining undefined is either an idiot or joking or something, and either wants to or deserves to have broken code. (In the \xe2\x80\x9cdeserves to\xe2\x80\x9d case, note that their code is already quite broken.)Still paranoid? Compare against void 0. void is a keyword in JavaScript, and it always has been, and it will always give you a canonical undefined.The issue boils down to three cases:This tells us something I consider important:There is a difference between an undefined member and a defined member with an undefined value.But unhappily typeof obj.foo does not tell us which of the three cases we have. However we can combine this with "foo" in obj to distinguish the cases.Its worth noting that these tests are the same for null entries tooI\'d argue that in some cases it makes more sense (and is clearer) to check whether the property is there, than checking whether it is undefined, and the only case where this check will be different is case 2, the rare case of an actual entry in the object with an undefined value.For example: I\'ve just been refactoring a bunch of code that had a bunch of checks whether an object had a given property.Which was clearer when written without a check for undefined.But as has been mentioned these are not exactly the same (but are more than good enough for my needs). This worked for me while the others didn\'t.I\'m not sure where the origin of using === with typeof came from, and as a convention I see it used in many libraries, but the typeof operator returns a string literal, and we know that up front, so why would you also want to type check it too?Crossposting my answer from related question How to check for "undefined" in JavaScript?Specific to this question, see test cases with someObject.<whatever>.Some scenarios illustrating the results of the various answers:\nhttp://jsfiddle.net/drzaus/UVjM4/(Note that the use of var for in tests make a difference when in a scoped wrapper)Code for reference:And results:I didn\'t see (hope I didn\'t miss it) anyone checking the object before the property. So, this is the shortest and most effective (though not necessarily the most clear):If the obj or obj.prop is undefined, null, or "falsy", the if statement will not execute the code block. This is usually the desired behavior in most code block statements (in JavaScript).If you doit will fail when the variable myvar does not exists, because myvar is not defined, so the script is broken and the test has no effect.Because the window object has a global scope (default object) outside a function, a declaration will be \'attached\' to the window object.For example:The global variable myvar is the same as window.myvar or window[\'myvar\']To avoid errors to test when a global variable exists, you better use:The question if a variable really exists doesn\'t matter, its value is incorrect. Otherwise, it is silly to initialize variables with undefined, and it is better use the value false to initialize. When you know that all variables that you declare are initialized with false, you can simply check its type or rely on !window.myvar to check if it has a proper/valid value. So even when the variable is not defined then !window.myvar is the same for myvar = undefined or myvar = false or myvar = 0.When you expect a specific type, test the type of the variable. To speed up testing a condition you better do:When the first and simple condition is true, the interpreter skips the next tests. It is always better to use the instance/object of the variable to check if it got a valid value. It is more stable and is a better way of programming.  (y)In the article Exploring the Abyss of Null and Undefined in JavaScript  I read that frameworks like Underscore.js use this function:Most likely you want if (window.x). This check is safe even if x hasn\'t been declared (var x;) - browser doesn\'t throw an error. window is an object which holds all global variables as its members, and it is legal to try to access a non-existing member. If x hasn\'t been declared or hasn\'t been set then window.x returns undefined. undefined leads to false when if() evaluates it.Reading through this, I\'m amazed I didn\'t see this. I have found multiple algorithms that would work for this.If the value of an object was never defined, this will prevent from returning true if it is defined as null or undefined. This is helpful if you want true to be returned for values set as undefinedIf you want it to result as true for values defined with the value of undefined, or never defined, you can simply use === undefinedCommonly, people have asked me for an algorithm to figure out if a value is either falsy, undefined, or null. The following works.You can get an array all undefined with path using the following code.jsFiddle linkReturns false if variable is set, and true if is undefined.Then use:Here is my situation:I am using the result of a REST call.\nThe result should be parsed from JSON to a JavaScript object.There is one error I need to defend.\nIf the args to the rest call were incorrect as far as the user specifying the args wrong, the rest call comes back basically empty.While using this post to help me defend against this, I tried this.For my situation, if restResult.data[0] === "object", then I can safely start inspecting the rest of the members.  If undefined then throw the error as above.What I am saying is that for my situation, all the suggestions above in this post did not work.  I\'m not saying I\'m right and everyone is wrong.  I am not a JavaScript master at all, but hopefully this will help someone.Compare with void 0, for terseness.It\'s not as verbose as if (typeof foo !== \'undefined\')All the answers are incomplete. This is the right way of knowing that there is a property \'defined as undefined\' :Example:Too bad that this been the right answer is buried in wrong answers >_<So, for anyone who pass by, I will give you undefineds for free!!The solution is incorrect. In JavaScript,will return true, because they both are "casted" to a boolean and are false. The correct way would be to checkwhich is the identity operator...Going through the comments, for those who want to check both is it undefined or its value is null:If you are using jQuery Library then jQuery.isEmptyObject() will suffice for both cases,If you are using Angular: Underscore.js:There is a nice & elegant way to assign a defined property to a new variable if it is defined or assign a default value to it as a fallback if it\xc2\xb4s undefined.It\'s suitable if you have a function, which receives an additional config property:Now executingI use if (this.variable) to test if it is defined. Simple if (variable), recommended above, fails for me. It turns out that it works only when variable is a field of some object, obj.someField to check if it is defined in the dictionary. But we can use this or window as the dictionary object since any variable is a field in current window, as I understand it. Therefore here is a testIt first detects that variable abc is undefined and it is defined after initialization.Also same things can be written shorter:or I would like to show you something I\'m using in order to protect the undefined variable:This forbids anyone to change the window.undefined value therefore destroying the code based on that variable. If using "use strict", anything trying to change its value will end in error, otherwise it would be silently ignored.Simply anything not defined in JavaScript, is undefined, doesn\'t matter if it\'s a property inside an Object/Array or as just a simple variable...JavaScript has typeof which make it very easy to detect an undefined variable.Simply check if typeof whatever === \'undefined\' and it will return a boolean.That\'s how the famous function isUndefined() in AngularJs v.1x is written:So as you see the function receive a value, if that value is defined, it will return false, otherwise for undefined values, return true. So let\'s have a look what gonna be the results when we passing values, including object properties like below, this is the list of variables we have:and we check them as below, you can see the results in front of them as a comment:As you see we can check anything with using something like this in our code, as mentioned you can simply use typeof in your code, but if you are using it over and over, create a function like the angular sample which I share and keep reusing as following DRY code pattern.Also one more thing, for checking property on an object in real application which you not sure even the object exists or not, check if the object exist first.If you check a property on an object and the object doesn\'t exist, will throw an error and stop the whole application running.So simple you can wrap inside an if statement like below:Which also equal to isDefined in Angular 1.x...Also other javascript frameworks like underscore has similar defining check, but I recommend you use typeof if you already not using any frameworks.I also add this section from MDN which has got useful information about typeof, undefined and void(0).Strict equality and undefined  You can use undefined and the strict equality and inequality operators to determine whether a variable has\n  a value. In the following code, the variable x is not defined, and the\n  if statement evaluates to true.Note: The strict equality operator rather than the standard equality\n  operator must be used here, because x == undefined also checks whether\n  x is null, while strict equality doesn\'t. null is not equivalent to\n  undefined. See comparison operators for details.Typeof operator and undefined \n  Alternatively, typeof can be used:One reason to use typeof is that it does not throw an error if the\n  variable has not been declared.However, this kind of technique should be avoided. JavaScript is a\n  statically scoped language, so knowing if a variable is declared can\n  be read by seeing whether it is declared in an enclosing context. The\n  only exception is the global scope, but the global scope is bound to\n  the global object, so checking the existence of a variable in the\n  global context can be done by checking the existence of a property on\n  the global object (using the in operator, for instance).Void operator and undefinedThe void operator is a third alternative.more > hereFrom lodash.js.It creates an variable named undefined which is initialized with the default value -- the real undefined, then compares value with the variable undefined.Use:To check if property is undefined:To check if property is not undefined: