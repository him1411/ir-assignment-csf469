When programming interfaces, I\'ve found I\'m doing a lot of casting or object type conversion.Is there a difference between these two methods of conversion?  If so, is there a cost difference or how does this affect my program?Also, what is "in general" the preferred method?The answer below the line was written in 2008.C# 7 introduced pattern matching, which has largely replaced the as operator, as you can now write:Note that tt is still in scope after this, but not definitely assigned. (It is definitely assigned within the if body.) That\'s slightly annoying in some cases, so if you really care about introducing the smallest number of variables possible in every scope, you might still want to use is followed by a cast.I don\'t think any of the answers so far (at the time of starting this answer!) have really explained where it\'s worth using which.Don\'t do this:Not only is this checking twice, but it may be checking different things, if randomObject is a field rather than a local variable. It\'s possible for the "if" to pass but then the cast to fail, if another thread changes the value of randomObject between the two.If randomObject really should be an instance of TargetType, i.e. if it\'s not, that means there\'s a bug, then casting is the right solution. That throws an exception immediately, which means that no more work is done under incorrect assumptions, and the exception correctly shows the type of bug.If randomObject might be an instance of TargetType and TargetType is a reference type, then use code like this:If randomObject might be an instance of TargetType and TargetType is a value type, then we can\'t use as with TargetType itself, but we can use a nullable type:(Note: currently this is actually slower than is + cast. I think it\'s more elegant and consistent, but there we go.)If you really don\'t need the converted value, but you just need to know whether it is an instance of TargetType, then the is operator is your friend. In this case it doesn\'t matter whether TargetType is a reference type or a value type.There may be other cases involving generics where is is useful (because you may not know whether T is a reference type or not, so you can\'t use as) but they\'re relatively obscure.I\'ve almost certainly used is for the value type case before now, not having thought of using a nullable type and as together :)EDIT: Note that none of the above talks about performance, other than the value type case, where I\'ve noted that unboxing to a nullable value type is actually slower - but consistent.As per naasking\'s answer, is-and-cast or is-and-as are both as fast as as-and-null-check with modern JITs, as shown by the code below:On my laptop, these all execute in about 60ms. Two things to note:So let\'s not worry about the performance. Let\'s worry about correctness and consistency.I maintain that is-and-cast (or is-and-as) are both unsafe when dealing with variables, as the type of the value it refers to may change due to another thread between the test and the cast. That would be a pretty rare situation - but I\'d rather have a convention which I can use consistently.I also maintain that the as-then-null-check gives a better separation of concerns. We have one statement which attempts a conversion, and then one statement which uses the result. The is-and-cast or is-and-as performs a test and then another attempt to convert the value.To put it another way, would anyone ever write:That\'s sort of what is-and-cast is doing - although obviously in a rather cheaper way."as" will return NULL if not possible to cast.casting before will raise an exception.For the performance, raising an exception is usually more costly in time.Here\'s another answer, with some IL comparison. Consider the class:Now look at the IL each method produces. Even if the op codes mean nothing to you, you can see one major difference - isinst is being called followed by castclass in the DirectCast method. So two calls instead of one basically.The isinst keyword versus the castclassThis blog post has a decent comparison between the two ways of doing it. His summary is:I personally always use As, because it\'s easy to read and is recommended by the .NET development team (or Jeffrey Richter anyway)One of the more subtle differences between the two is that the "as" keyword can not be used for casting when a cast operator is involved:This will not compile (although I think it did in previous versions) on the last line since the "as" keywords do not take cast operators into account. The line string cast = (string)f; works just fine though.as never throws an exception if it cannot perform the conversion returning null instead (as operates on reference types only). So using as is basically equivalent toC-style casts, on the other hand, throw an exception when no conversion is possible.Not really an answer to your question, but what I think is an important related point.If you are programming to an interface you shouldn\'t be needing to cast. Hopefully these casts are very rare. If not you likely need to rethink some of your interfaces.Please ignore Jon Skeet\'s advice, re:avoid test-and-cast pattern, ie.:The idea that this costs more than a cast and a null test is a MYTH:It\'s a micro-optimization that does not work. I ran some real tests, and test-and-cast is actually faster than cast-and-null-comparison, and it\'s safer too because you don\'t have the possibility of having a null reference in the scope outside the if should the cast fail.If you want a reason why test-and-cast is faster, or at least not slower, there\'s a simple and complex reason.Simple: even naive compilers will coalesce two similar operations, like test-and-cast, into a single test and branch. cast-and-null-test may force two tests and a branch, one for the type test and conversion to null on failure, one for the null check itself. At the very least, they will both optimize to a single test and branch, so test-and-cast would be neither slower nor faster than cast-and-null-test.Complex: why test-and cast is faster: cast-and-null-test introduces another variable into the outer scope which the compiler must track for liveness, and it may not be able to optimize away that variable depending on how complex your control-flow is. Conversely, test-and-cast introduces a new variable only in a delimited scope so the compiler knows that the variable is dead after the scope exits, and so can optimize register allocation better.So please, PLEASE let this "cast-and-null-test is better than test-and-cast" advice DIE. PLEASE. test-and-cast is both safer and faster.If the cast fails, the \'as\' keyword doesn\'t throw an exception; it sets the variable to null (or to its default value for value types) instead.This is not an answer to the question but comment to the question\'s code example:Usually you should not have to cast an Object from e.g. IMyInterface to MyClass. The great thing about interfaces is that if you take an object as input that implements an interface, than you don\'t have to care what kind of object you are getting.If you cast IMyInterface to MyClass, than you already assume that you get an object of type MyClass and it makes no sense to use IMyInterface, because if you feed your code with other classes that implement IMyInterface, it would break your code...Now, my advice: if your interfaces are well designed you can avoid a lot of typecasting.The as operator can only be used on reference types, it cannot be overloaded, and it will return null if the operation fails. It will never throw an exception.Casting can be used on any compatible types, it can be overloaded, and it will throw an exception if the operation fails.The choice of which to use depends on the circumstances. Primarily, it\'s a matter of whether you want to throw an exception on a failed conversion.My answer is only about speed in cases when we don\'t check the type and we don\'t check nulls after casting. I added two additional tests to Jon Skeet\'s code:Result:Don\'t try to focus on speed (as I did) because all this is very very fast.Besides all what was already exposed here, I just came across a practical difference I think is worth noting, between explicit casting versus using the as operator.Here is the example:Bottom line: GenericCaster2 will not work with struct types. GenericCaster will.The as keyword works the same as an explicit cast between compatible reference types with the major difference that it does not raise an exception if conversion fails. Rather, it yields a null value in the target variable. Since Exceptions are very expensive in terms of performance, it is considered a much better method of casting.What you choose strongly depends on what required.\nI prefer explicit casting because if object should by of IMyInterface type and it is not - it is definitely problem.\nIt is better to get error as early as possible because exact error will be fixed instead of fixing its side effect.But if you deal with methods that accepts object as parameter then you need to check its exact type prior executing any code. In such case as would be useful so you can avoid InvalidCastException.It depends, do you want to check for null after using "as" or would you prefer your app to throw an exception?  My rule of thumb is if I always expect the variable to be of the type I am expecting at the time I want I use a cast.  If it is possible that the variable will not cast to what I want and I am prepared to handle nulls from using as, I will use as.Have a look at these links:they show you some details and performance tests.If you use the Office PIAs targeting the .NET Framework 4.X you should use the as keyword, otherwise it won\'t compile.Casting is OK when targeting .NET 2.0 though:When targeting .NET 4.X the errors are:error CS0656: Missing compiler required member \'Microsoft.CSharp.RuntimeBinder.Binder.Convert\'error CS0656: Missing compiler required member \'Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo.Create\'The OP\'s problem is limited to a specific casting situation. The title covers much more situations.\nHere\'s an overview of all relevant casting situations that I currently can think of: