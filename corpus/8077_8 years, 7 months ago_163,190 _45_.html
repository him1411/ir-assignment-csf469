Today we have built a console application for running the scheduled tasks for our ASP.NET website. But I think this approach is a bit error prone and difficult to maintain. How do you execute your scheduled task (in an windows/IIS/ASP.NET environment)Update: Examples of tasks:All of my tasks (which need to be scheduled) for a website are kept within the website and called from a special page.  I then wrote a simple Windows service which calls this page every so often.  Once the page runs it returns a value.  If I know there is more work to be done, I run the page again, right away, otherwise I run it in a little while.  This has worked really well for me and keeps all my task logic with the web code.  Before writing the simple Windows service, I used Windows scheduler to call the page every x minutes.   Another convenient way to run this is to use a monitoring service like Pingdom.  Point their http check to the page which runs your service code.  Have the page return results which then can be used to trigger Pingdom to send alert messages when something isn\'t right.This technique by Jeff Atwood for Stackoverflow is the simplest method I\'ve come across. It relies on the "cache item removed" callback mechanism build into ASP.NET\'s cache systemUpdate: Stackoverflow has outgrown this method. It only works while the website is running but it\'s a very simple technique that is useful for many people.Also check out Quartz.NETCreate a custom Windows Service.I had some mission-critical tasks set up as scheduled console apps and found them difficult to maintain. I created a Windows Service with a \'heartbeat\' that would check a schedule in my DB every couple of minutes. It\'s worked out really well.Having said that, I still use scheduled console apps for most of my non-critical maintenance tasks. If it ain\'t broke, don\'t fix it.I\'ve found this to be easy for all involved:Using this methodology all of the business logic is contained in your web app, but you have the reliability of the windows task manager, or any other commercial task manager to kick it off and record any return information such as an execution report. Using a web service instead of posting to a page has a bit of an advantage because it\'s easier to get return data from a webservice.Why reinvent the wheel, use the Threading and the Timer class.Use Windows Scheduler to run a web page.To prevent malicous user or search engine spiders to run it, when you setup the scheduled task, simply call the web page with a querystring, ie : mypage.aspx?from=scheduledtaskThen in the page load, simply use a condition :\n    if (Request.Querystring["from"] == "scheduledtask")\n    {\n    //executetask\n    }This way no search engine spider or malicious user will be able to execute your scheduled task.This library works like a charm\nhttp://www.codeproject.com/KB/cs/tsnewlib.aspxIt allows you to manage Windows scheduled tasks directly through your .NET code.I\'m not sure what kind of scheduled tasks you mean. If you mean stuff like "every hour, refresh foo.xml" type tasks, then use the Windows Scheduled Tasks system. (The "at" command, or via the controller.) Have it either run a console app or request a special page that kicks off the process.Edit: I should add, this is an OK way to get your IIS app running at scheduled points too. So suppose you want to check your DB every 30 minutes and email reminders to users about some data, you can use scheduled tasks to request this page and hence get IIS processing things.If your needs are more complex, you might consider creating a Windows Service and having it run a loop to do whatever processing you need. This also has the benefit of separating out the code for scaling or management purposes. On the downside, you need to deal with Windows services.If you own the server you should use the windows task scheduler. Use AT /? from the command line to see the options. Otherwise, from a web based environment, you might have to do something nasty like set up a different machine to make requests to a certain page on a timed interval.I\'ve used Abidar successfully in an ASP.NET project (here\'s some background information).The only problem with this method is that the tasks won\'t run if the ASP.NET web application is unloaded from memory (ie. due to low usage).  One thing I tried is creating a task to hit the web application every 5 minutes, keeping it alive, but this didn\'t seem to work reliably, so now I\'m using the Windows scheduler and basic console application to do this instead.The ideal solution is creating a Windows service, though this might not be possible (ie. if you\'re using a shared hosting environment).  It also makes things a little easier from a maintenance perspective to keep things within the web application.Additionally, if your application uses SQL SERVER you can use the SQL Agent to schedule your tasks.  This is where we commonly put re-occurring code that is data driven (email reminders, scheduled maintenance, purges, etc...).  A great feature that is built in with the SQL Agent is failure notification options, which can alert you if a critical task fails.Here\'s another way: 1) Create a "heartbeat" web script that is responsible for launching the tasks if they are DUE or overdue to be launched. 2) Create a scheduled process somewhere (preferrably on the same web server) that hits the webscript and forces it to run at a regular interval.  (e.g. windows schedule task that quietly launches the heatbeat script using IE or whathaveyou)The fact that the task code is contained within a web script is purely for the sake of keeping the code within the web application code-base (the assumption is that both are dependent on each other), which would be easier for web developers to manage.The alternate approach is to create an executable server script / program that does all the schedule work itself and run the executable itself as a scheduled task. This can allow for fundamental decoupling between the web application and the scheduled task. Hence if you need your scheduled tasks to run even in the even that the web app / database might be down or inaccessible, you should go with this approach. You can easily create a Windows Service that runs code on interval using the \'ThreadPool.RegisterWaitForSingleObject\' method. It is really slick and quite easy to get set up. This method is a more streamlined approach then to use any of the Timers in the Framework.Have a look at the link below for more information:Running a Periodic Process in .NET using a Windows Service:\nhttp://allen-conway-dotnet.blogspot.com/2009/12/running-periodic-process-in-net-using.htmlWe use console applications also.  If you use logging tools like Log4net you can properly monitor their execution.  Also, I\'m not sure how they are more difficult to maintain than a web page, given you may be sharing some of the same code libraries between the two if it is designed properly.If you are against having those tasks run on a timed basis, you could have a web page in your administrative section of your website that acts as a queue.  User puts in a request to run the task, it in turn inserts a blank datestamp record on MyProcessQueue table and your scheduled task is checking every X minutes for a new record in MyProcessQueue.  That way, it only runs when the customer wants it to run.Hope those suggestions help.One option would be to set up a windows service and get that to call your scheduled task.In winforms I\'ve used Timers put don\'t think this would work well in ASP.NETA New Task Scheduler Class Library for .NET Note: Since this library was created, Microsoft has introduced a new task scheduler (Task Scheduler 2.0) for Windows Vista. This library is a wrapper for the Task Scheduler 1.0 interface, which is still available in Vista and is compatible with Windows XP, Windows Server 2003 and Windows 2000.http://www.codeproject.com/KB/cs/tsnewlib.aspx