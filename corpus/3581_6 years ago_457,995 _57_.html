If there is an Javascript object: Suppose, it has more than 50 properties, without knowing the property names (that\'s without knowing the \'keys\') how to get each property value in a loop?By using a simple for..in loop:Depending on which browsers you have to support, this can be done in a number of ways. The overwhelming majority of browsers in the wild support ECMAScript 5 (ES5), but be warned that many of the examples below use Object.keys, which is not available in IE < 9. See the compatibility table.If you have to support older versions of IE, then this is the option for you:The nested if makes sure that you don\'t enumerate over properties in the prototype chain of the object (which is the behaviour you almost certainly want). You must userather thanbecause ECMAScript 5+ allows you to create prototypeless objects with Object.create(null), and these objects will not have the hasOwnProperty method. Naughty code might also produce objects which override the hasOwnProperty method.You can use these methods in any browser that supports ECMAScript 5 and above. These get values from an object and avoid enumerating over the prototype chain. Where obj is your object:If you want something a little more compact or you want to be careful with functions in loops, then Array.prototype.forEach is your friend:The next method builds an array containing the values of an object. This is convenient for looping over.If you want to make those using Object.keys safe against null (as for-in is), then you can do Object.keys(obj || {})....Object.keys returns enumerable properties. For iterating over simple objects, this is usually sufficient. If you have something with non-enumerable properties that you need to work with, you may use Object.getOwnPropertyNames in place of Object.keys.Arrays are easier to iterate with ECMAScript 2015. You can use this to your advantage when working with values one-by\xe2\x80\x93one in a loop:Using ECMAScript 2015 fat-arrow functions, mapping the object to an array of values becomes a one-liner:ECMAScript 2015 introduces Symbol, instances of which may be used as property names. To get the symbols of an object to enumerate over, use Object.getOwnPropertySymbols (this function is why Symbol can\'t be used to make private properties). The new Reflect API from ECMAScript 2015 provides Reflect.ownKeys, which returns a list of property names (including non-enumerable ones) and symbols.Array comprehensions were removed from ECMAScript 6 before publication. Prior to their removal, a solution would have looked like:ECMAScript 2016 adds features which do not impact this subject. The ECMAScript 2017 specification adds Object.values and Object.entries. Both return arrays (which will be surprising to some given the analogy with Array.entries). Object.values can be used as is or with a for-of loop.If you want to use both the key and the value, then Object.entries is for you. It produces an array filled with [key, value] pairs. You can use this as is, or (note also the ECMAScript 2015 destructuring assignment) in a for-of loop:Finally, as noted in the comments and by teh_senaus in another answer, it may be worth using one of these as a shim. Don\'t worry, the following does not change the prototype, it just adds a method to Object (which is much less dangerous). Using fat-arrow functions, this can be done in one line too:which you can now use likeIf you want to avoid shimming when a native Object.values exists, then you can do:Be aware of the browsers/versions you need to support. The above are correct where the methods or language features are implemented. For example, support for ECMAScript 2015 was switched off by default in V8 until recently, which powered browsers such as Chrome. Features from ECMAScript 2015 should be be avoided until the browsers you intend to support implement the features that you need. If you use babel to compile your code to ECMAScript 5, then you have access to all the features in this answer.Here\'s a reusable function for getting the values into an array. It takes prototypes into account too.If you have access to underscore.js, you can use the _.values function like this:If you really want an array of Values, I find this cleaner than building an array with a for ... in loop.ECMA 5.1+It\'s worth noting that in most cases you don\'t really need an array of values, it will be faster to do this:This iterates over the keys of the Object o. In each iteration k is set to a key of o.You can loop through the keys:will output:For those early adapting people on the CofeeScript era, here\'s another equivalent for it.Which may be better than this because the objects can be reduced to be typed again and decreased readability.Apparently - as I recently learned - this is the fastest way to do it:use a polyfill like:then use3) profit!You can use this object-values component I wrote to get all object values. Examples:Here is how it works:This MPM micro package can also do the trick.Here\'s a function similar to PHP\'s array_values()Here\'s how to get the object\'s values if you\'re using ES6 or higher:A much better approach is that you attach some function to the Object prototype so that you may get properties of every object on which you call upon properties().Since , Object.values(<object>) will be built-in in ES7 &Until waiting all browsers to support it , you could wrap it inside a function : Then : I realize I\'m a little late but here\'s a shim for the new firefox 47 Object.values methodin ECMAScript5 useOtherwise if you\'re browser does not support it, use the well-known for..in loopSorry for my old answer :Dnow i use dojotokit becouse older browser not suport (Object.values)out put :[\'1\', \'2\', \'3\']use and if you using google chrome open Console by using Ctrl+Shift+jGoto >> Console