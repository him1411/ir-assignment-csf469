I would like to plot y1 and y2 in the same plot.But when I do it like this, they are not plotted in the same plot together.In Matlab one can do hold on, but does anyone know how to do this in R?lines() or points() will add to the existing graph, but will not create a new window. So you\'d need to doYou can also use par and plot on the same graph but different axis. Something as follows:If you read in detail about par in R, you will be able to generate really interesting graphs.  Another book to look at is Paul Murrel\'s R Graphics.When constructing multilayer plots one should consider ggplot package. The idea is to   create a graphical object with basic aesthetics and enhance it incrementally.ggplot style requires data to be packed in data.frame.Basic solution:Here + operator is used to add extra layers to basic object.With ggplot you have access to graphical object on every stage of plotting. Say, usual step-by-step setup can look like this:g produces the plot, and you can see it at every stage (well, after creation of at least one layer). Further enchantments of the plot are also made with created object. For example, we can add labels for axises:Final g looks like:UPDATE (2013-11-08):As pointed out in comments, ggplot\'s philosophy suggests using data in long format.\nYou can refer to this answer https://stackoverflow.com/a/19039094/1796914 in order to see corresponding code.I think that the answer you are looking for is:Use the matplot function:use this if y1 and y2 are evaluated at the same x points. It scales the Y-axis to fit whichever is bigger (y1 or y2), unlike some of the other answers here that will clip y2 if it gets bigger than y1 (ggplot solutions mostly are okay with this).Alternatively, and if the two lines don\'t have the same x-coordinates, set the axis limits on the first plot and add:Am astonished this Q is 4 years old and nobody has mentioned matplot or x/ylim...If you are using base graphics (i.e. not lattice/ grid graphics), then you can mimic MATLAB\'s hold on feature by using the points/lines/polygons functions to add additional details to your plots without starting a new plot. In the case of a multiplot layout, you can use par(mfg=...) to pick which plot you add things to.tl;dr: You want to use curve (with add=TRUE) or lines.I disagree with par(new=TRUE) because that will double-print tick-marks and axis labels. EgThe output of plot(sin); par(new=T); plot( function(x) x**2 ).Look how messed up the vertical axis labels are! Since the ranges are different you would need to set ylim=c(lowest point between the two functions, highest point between the two functions), which is less easy than what I\'m about to show you---and way less easy if you want to add not just two curves, but many.What always confused me about plotting is the difference between curve and lines. (If you can\'t remember that these are the names of the two important plotting commands, just sing it.)curve will plot a function, like curve(sin). lines plots points with x and y values, like: lines( x=0:10, y=sin(0:10) ).And here\'s a minor difference: curve needs to be called with add=TRUE for what you\'re trying to do, while lines already assumes you\'re adding to an existing plot.Here\'s the result of calling plot(0:2); curve(sin).Behind the scenes, check out methods(plot). And check body( plot.function )[[5]]. When you call plot(sin) R figures out that sin is a function (not y values) and uses the plot.function method, which ends up calling curve. So curve is the tool meant to handle functions.As described by @redmode, you may plot the two lines in the same graphical device using ggplot. However, the data in that answer was in a \'wide\' format, whereas in ggplot it is generally most convenient to keep the data in a data frame in a \'long\' format. Then, by using different \'grouping variables\' in the aesthetics arguments, properties of the line, such as linetype or colour, will vary according to the grouping variable, and corresponding legends will appear. In this case we can use the colour aessthetics, which matches colour of the lines to different levels of a variable in the data set (here: y1 vs y2). But first we need to melt the data from wide to long format, using the function \'melt\' from reshape2 package. if you want to split the screen, you can do it like this:(for example for 2 plots next together)Reference LinkYou can use points for the overplot, that is.Rather than keeping the values to be plotted in an array, store them in a matrix.  By default the entire matrix will be treated as one data set.  However if you add the same number of modifiers to the plot, e.g. the col(), as you have rows in the matrix, R will figure out that each row should be treated independently.  For example:This should work unless your data sets are of differing sizes.You could use the Plotly R API to style this. Below is the code to do so, and the live version of this graph is here.Full disclosure: I\'m on the Plotly team.You can also create your plot using ggvis:This will create the following plot: