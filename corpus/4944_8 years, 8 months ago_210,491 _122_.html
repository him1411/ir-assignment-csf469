What is meant by "object serialization"? Can you please explain it with some examples? Serialization is the conversion of an object to a series of bytes, so that the object can be easily saved to persistent storage or streamed across a communication link. The byte stream can then be deserialized - converted into a replica of the original object.You can think of serialization as the process of converting an object instance into a sequence of bytes (which may be binary or not depending on the implementation).It is very useful when you want to transmit one object data across the network, for instance from one JVM to another.In Java, the serialization mechanism is built into the platform, but you need to implement the Serializable interface to make an object serializable.You can also prevent some data in your object from being serialized by marking the attribute as transient.Finally you can override the default mechanism, and provide your own; this may be suitable in some special cases. To do this, you use one of the hidden features in java.It is important to notice that what gets serialized is the "value" of the object, or the contents, and not the class definition. Thus methods are not serialized.Here is a very basic sample with comments to facilitate its reading:When we run this program, the file "o.ser" is created and we can see what happened behind.If we change the value of: someInteger to, for example Integer.MAX_VALUE, we may compare the output to see what the difference is.Here\'s a screenshot showing precisely that difference:Can you spot the differences? ;)There is an additional relevant field in Java serialization: The serialversionUID but I guess this is already too long to cover it.Daring to answer 6 year old question, adding just a very high level understanding for people new to Java What is Serialization?Converting an object to bytes and bytes back to object (Deserialization).when is serialization used?When we want to Persist the Object.\nWhen we want the object to exist beyond the lifetime of the JVM.Real World Example:ATM: When the account holder tries to withdraw money from the server through ATM, the account holder information like  withdrawl details will be serialized and sent to server where the details are deserialized and used to perform operations.How serialization is performed in java.Implement java.io.Serializable interface (marker interface so no method to implement).Persist the object: Use java.io.ObjectOutputStream class, a filter stream which is a wrapper around a lower-level byte stream (to write Object to file systems or transfer a flattened object across a network wire and rebuilt on the other side).Remember:When you serialize an object, only the object\'s state will be saved, not the object\'s class file or methods.When you serialized a 2 byte object, you see 51 bytes serialized file.Steps how the object is serialized and de-serialized.Answer for:  How did it convert to 51 bytes file? If you are interested in more in dept information about Java Serialization please check this link.Edit : One more good link to read.This will answer a few frequent questions:How not to serialize any field in class.\nAns: use transient keywordWhen child class is serialized does parent class get serialized?\nAns: No, If parent is not extending Serializable interface parents field don\'t get serialized.When parent is serialized does child class get serialized?\nAns: Yes, by default child class also get serialized.How to avoid child class from getting serialized?\nAns: a. Override writeObject and readObject method and throw NotSerializableException.b. also you can mark all fields transient in child class.Serialization is taking a "live" object in memory and converting it to a format that can be stored somewhere (eg. in memory, on disk) and later "deserialized" back into a live object.I liked the way @OscarRyz presents. Although here i am continuing the story of serialization which was originally written by @amitgupta.Even though knowing about the robot class structure and having serialized data Earth\'s scientist were not able to deserialize the data which can make robots working.Mars\'s scientists were waiting for the complete payment. Once the payment was done Mars\'s scientists shared the serialversionUID with Earth\'s scientists. Earth\'s scientist set it to robot class and everything became fine.Serialization means persisting objects in java. If you want to save the state of the object and want to rebuild the state later (may be in another JVM) serialization can be used.Note that the properties of an object is only going to be saved. If you want to resurrect the object again you should have the class file, because the member variables only will be stored and not the member functions.eg: The Searializable is a marker interface which marks that your class is serializable. Marker interface means that it is just an empty interface and using that interface will notify the JVM that this class can be made serializable.Serialization is the process of converting an object\'s state to bits so that it can be stored on a hard drive. When you deserialize the same object, it will retain its state later.  It lets you recreate objects without having to save the objects\' properties by hand.http://en.wikipedia.org/wiki/SerializationSerialization is the process of saving an object in a storage medium (such as a file, or a memory buffer) or to transmit it over a network connection  in binary form.  The serialized objects are JVM independent and can be re-serialized by any JVM. In this case the "in memory" java objects state are converted into a byte stream. This type of the file can not be understood by the user. It is a special types of object i.e. reused by the JVM (Java Virtual Machine). This process of serializing an object is also called deflating or marshalling an object.The object to be serialized must implement java.io.Serializable Interface. \nDefault serialization mechanism for an object writes the class of the object, the class signature, and the values of all non-transient and non-static fields.ObjectOutput interface extends the DataOutput interface and adds methods for serializing objects and writing bytes to the file. The ObjectOutputStream extends java.io.OutputStream and  implements ObjectOutput  interface. It serializes objects, arrays, and other values to a stream. Thus the constructor of  ObjectOutputStream is written as:Above code has been used to create the instance of the ObjectOutput class with the ObjectOutputStream( ) constructor which takes the instance of the FileOuputStream as a parameter. The ObjectOutput interface is used by implementing the ObjectOutputStream class. The ObjectOutputStream is constructed to serialize the object. Deserializing an Object in javaThe opposite operation of the serialization is called deserialization i.e. to extract the data from a series of bytes is s known as deserialization which is also called inflating or unmarshalling.ObjectInputStream extends java.io.InputStream and  implements ObjectInput  interface. It deserializes objects, arrays, and other values from an input stream. Thus the constructor of  ObjectInputStream is written as:Above code of the program creates the instance of the ObjectInputStream class to deserialize that file which had been serialized by the ObjectInputStream class. The above code creates the instance using the instance of the FileInputStream class which holds the specified file object which has to be deserialized because the ObjectInputStream() constructor needs the input stream.Serialization is the process of turning a Java object into byte array and then back into object again with its preserved state. Useful for various things like sending objects over network or caching things to disk.Read more from this short article which explains programming part of the process quite well and then move over to to Serializable javadoc. You may also be interested in reading this related question.My Two cents from my own blog:Here is a detailed explanation of the Serialization: (my own blog)Serialization:Serialization is the process of persisting the state of an object. It is represented and stored in the form of a sequence of bytes. This can be stored in a file. The process to read the state of the object from the file and restoring it is called deserialization.What is the need of Serialization?In modern day architecture, there is always a need to store object state and then retrieve it. For example in Hibernate, to store a object we should make the class Serializable. What it does, is that once the object state is saved in the form of bytes it can be transferred to another system which can then read from the state and retrieve the class. The object state can come from a database or a different jvm or from a separate component. With the help of Serialization we can retrieve the Object state.  Code Example and explanation:First let\'s have a look at the Item Class:In the above code it can be seen that Item class implements Serializable. This is the interface that enables a class to be serializable. Now we can see a variable called serialVersionUID is initialized to Long variable. This number is calculated by the compiler based on the state of the class and the class attributes. This is the number that will help the jvm identify the state of an object when it reads the state of the object from file. For that we can have a look at the official Oracle Documentation:The serialization runtime associates with each serializable class a\n  version number, called a serialVersionUID, which is used during\n  deserialization to verify that the sender and receiver of a serialized\n  object have loaded classes for that object that are compatible with\n  respect to serialization. If the receiver has loaded a class for the\n  object that has a different serialVersionUID than that of the\n  corresponding sender\'s class, then deserialization will result in an\n  InvalidClassException. A serializable class can declare its own\n  serialVersionUID explicitly by declaring a field named\n  "serialVersionUID" that must be static, final, and of type long:\n  ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L; If a\n  serializable class does not explicitly declare a serialVersionUID,\n  then the serialization runtime will calculate a default\n  serialVersionUID value for that class based on various aspects of the\n  class, as described in the Java(TM) Object Serialization\n  Specification. However, it is strongly recommended that all\n  serializable classes explicitly declare serialVersionUID values, since\n  the default serialVersionUID computation is highly sensitive to class\n  details that may vary depending on compiler implementations, and can\n  thus result in unexpected InvalidClassExceptions during\n  deserialization. Therefore, to guarantee a consistent serialVersionUID\n  value across different java compiler implementations, a serializable\n  class must declare an explicit serialVersionUID value. It is also\n  strongly advised that explicit serialVersionUID declarations use the\n  private modifier where possible, since such declarations apply only to\n  the immediately declaring class--serialVersionUID fields are not\n  useful as inherited members.If you have noticed there is another keyword we have used which is transient.If a field is not serializable, it must be marked transient. Here we marked the itemCostPrice as transient and don\'t want it to be written in a fileNow let\'s have a look on how to write the state of an object in the file and then read it from there.In the above we can see an example of serialization and deserialization of an object. For that we used two classes. For serializing the object we have used ObjectOutputStream. We have used the method writeObject to write the object in the file. For Deserializing we have used ObjectInputStream which reads from the object from the file. It uses readObject to read the object data from the file. The output of the above code would be like:Notice that itemCostPrice from deserialized object is null as it was not written.We have already discussed the basics of Java Serialization in part I of this article. Now let\'s discuss it deeply and how it works.First let\'s start with the serialversionuid.The serialVersionUID is used as a version control in a Serializable class. If you do not explicitly declare a serialVersionUID, JVM will do it for you automatically, based on various properties of the Serializable class. Java\'s Algorithm of Calculating serialversionuid (Read more details here)Java\'s serialization algorithmThe algorithm to serialize an object is described as below:\n  1. It writes out the metadata of the class associated with an instance.\n  2. It recursively writes out the description of the superclass until it finds java.lang.object.\n  3. Once it finishes writing the metadata information, it then starts with the actual data associated with the instance. But this time, it\n  starts from the topmost superclass.\n  4. It recursively writes the data associated with the instance, starting from the least superclass to the most-derived class.Things To Keep In Mind:Static fields in a class cannot be serialized. If the serialversionuid is different in the read class it will throw a InvalidClassException exception.  If a class implements serializable then all its sub classes will also be serializable.  If a class has a reference of another class, all the references must be Serializable otherwise serialization process will not be performed. In such case, NotSerializableException is thrown at runtime.Eg:Return the file as an Object : http://www.tutorialspoint.com/java/java_serialization.htmJava provides a mechanism, called object serialization where an object can be represented as a sequence of bytes that includes the object\'s data as well as information about the object\'s type and the types of data stored in the object. It is mainly used to travel object\'s state on the network (known as marshaling).Serialization (Of an Object)In the context of data storage and transmission, serialization is the process of converting a data structure or object state into a format that can be stored (for example, in a file or memory buffer, or transmitted across a network connection link) and "resurrected" (de-serialized) later in the same or another computer environment.serializationClass impements Serializable InterfaceMain ClassThis question can also make you understand a tip about Serialization:What will go wrong if we make all java objects Serializable Since Serializable is an empty interface and Java\n  provides robust serialization once you add implements Serializable -\n  why didn\'t they make everything serializable and that\'s it?The answer could be found at "Why Java needs Serializable interface?" which describes this could lead to security problems and also encapsulation breaks.|*| Serializing a class : Converting an object to bytes and bytes back to object (Deserialization).|=> Object-Serialization is process of converting the state of an object into steam of bytes.|=> Object-Deserialization is the process of getting the state of an object and store it into an object(java.lang.Object).|=> A Java object is only serializable, if its class or any of its superclasses|=> Static fields in a class cannot be serialized.|=> If you do not want to serialise a variable of a class use transient keyword|=> If a class implements serializable then all its sub classes will also be serializable.|=> If a class has a reference of another class, all the references must be Serializable otherwise serialization process will not be performed. In such case,NotSerializableException is thrown at runtime.I found this good answer from here :-Imagine you want to save the state of one or more objects. If Java didn\xe2\x80\x99t have serialization, you\xe2\x80\x99d have to use one of the I/O classes to write out the state of the instance variables of all the objects you want to save. The worst part would be trying to reconstruct new objects that were virtually identical to the objects you were trying to save. You\xe2\x80\x99d need your own protocol for the way in which you wrote and restored the state of each object, or you could end up setting variables with the wrong values. For example, imagine you stored an object that has instance variables for height and weight. At the time you save the state of the object, you could write out the height and weight as two ints in a file, but the order in which you write them is crucial. It would be all too easy to re-create the object but mix up the height and weight values\xe2\x80\x94using the saved height as the value for the new object\xe2\x80\x99s weight and vice versa.\n  The purpose of Serialization is to help us achieve whatever complicated scenario we just witnessed in an easier manner. Working with ObjectOutputStream and ObjectInputStreamThe magic of basic serialization happens with just two methods: one to serialize objects and write them to a stream, and a second to read from the stream and deserialize the object.The java.io.ObjectOutputStream and java.io.ObjectInputStream classes are considered to be higher-level classes in the java.io package, and as we learned in the previous chapter that means that you\xe2\x80\x99ll wrap them around lower-level classes, such as java.io.FileOutputStream and java.io.FileInputStream. Here\xe2\x80\x99s a small program that creates an object, serializes it, and then deserializes it:Let\xe2\x80\x99s take a look at the key points in this example:We declare that the Car class implements the Serializable interface. Serializable is a marker interface; it has no methods to implement. We make a new Car object, which as we know is serializable.We serialize the Car object c by invoking the writeObject() method. First, we had to put all of our I/O-related code in a try/Catch block. Next we had to create a FileOutputStream to write the object to. Then we wrapped the FileOutputStream in an ObjectOutputStream, which is the class that has the magic serialization method that we need. Remember that the invocation of writeObject() performs two tasks: it serializes the object, and then it writes the serialized object to a file.We de-serialize the Car object by invoking the readObject() method. The readObject() method returns an Object, so we have to cast the deserialized object back to a Car. Again, we had to go through the typical I/O hoops to set this up. - See more