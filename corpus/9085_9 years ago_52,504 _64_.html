Take the following two lines of code:And this:I\'m told that the second way is preferred.  Why exactly is this?The first form is efficient only if vector.size() is a fast operation.  This is true for vectors, but not for lists, for example.  Also, what are you planning to do within the body of the loop?  If you plan on accessing the elements as inthen you\'re making the assumption that the container has operator[](std::size_t) defined.  Again, this is true for vector but not for other containers.The use of iterators bring you closer to container independence.  You\'re not making assumptions about random-access ability or fast size() operation, only that the container has iterator capabilities.You could enhance your code further by using standard algorithms.  Depending on what it is you\'re trying to achieve, you may elect to use std::for_each(), std::transform() and so on.  By using a standard algorithm rather than an explicit loop you\'re avoiding re-inventing the wheel.  Your code is likely to be more efficient (given the right algorithm is chosen), correct and reusable.because you are not tying your code to the particular implementation of the some_vector list. if you use array indices, it has to be some form of array; if you use iterators you can use that code on any list implementation.It\'s part of the modern C++ indoctrination process.  Iterators are the only way to iterate most containers, so you use it even with vectors just to get yourself into the proper mindset.  Seriously, that\'s the only reason I do it - I don\'t think I\'ve ever replaced a vector with a different kind of container.\nI think the array index is more readable. It matches the syntax used in other languages, and the syntax used for old-fashioned C arrays.  It\'s also less verbose.  Efficiency should be a wash if your compiler is any good, and there are hardly any cases where it matters anyway.Even so, I still find myself using iterators frequently with vectors.  I believe the iterator is an important concept, so I promote it whenever I can.Imagine some_vector is implemented with a linked-list. Then requesting an item in the i-th place requires i operations to be done to traverse the list of nodes. Now, if you use iterator, generally speaking, it will make its best effort to be as efficient as possible (in the case of a linked list, it will maintain a pointer to the current node and advance it in each iteration, requiring just a single operation).So it provides two things:I\'m going to be the devils advocate here, and not recommend iterators. The main reason why, is all the source code I\'ve worked on from Desktop application development to game development have i nor have i needed to use iterators. All the time they have not been required and secondly the hidden assumptions and code mess and debugging nightmares you get with iterators make them a prime example not to use it in any applications that require speed. Even from a maintence stand point they\'re a mess. Its not because of them but because of all the aliasing that happen behind the scene. How do i know that you haven\'t implemented your own virtual vector or array list that does something completely different to the standards. Do i know what type is currently now during runtime? Did you overload a operator I didn\'t have time to check all your source code. Hell do i even know what version of the STL your using?The next problem you got with iterators is leaky abstraction, though there are numerous web sites that discuss this in detail with them.Sorry, I have not and still have not seen any point in iterators. If they abstract the list or vector away from you, when in fact you should know already what vector or list your dealing with if you don\'t then your just going to be setting yourself up for some great debugging sessions in the future.You might want to use an iterator if you are going to add/remove items to the vector while you are iterating over it.If you were using indices you would have to shuffle items up/down in the array to handle the insertions and deletions.It\'s very nice to separate the iteration code from the \'core\' concern of the loop.  It\'s almost a design decision.Indeed, iterating by index ties you to the implementation of the container.  Asking the container for a begin and end iterator, enables the loop code for use with other container types.Also, in the std::for_each way, you TELL the collection what to do, instead of ASKing it something about its internalsThe 0x standard is going to introduce closures, which will make this approach much more easy to use - have a look at the expressive power of e.g. Ruby\'s [1..6].each { |i| print i; }...But maybe a much overseen issue is that, using the for_each approach yields an opportunity to have the iteration parallelized - the intel threading blocks can distribute the code block over the number of processors in the system!Note: after discovering the algorithms library, and especially foreach, I went through two or three months of writing ridiculously small \'helper\' operator structs which will drive your fellow developers crazy.  After this time, I went back to a pragmatic approach - small loop bodies deserve no foreach no more :)A must read reference on iterators is the book "Extended STL".The GoF have a tiny little paragraph in the end of the Iterator pattern, which talks about this brand of iteration; it\'s called an \'internal iterator\'.  Have a look here, too.Because it is more object-oriented.  if you are iterating with an index you are assuming:a) that those objects are ordered\nb) that those objects can be obtained by an index\nc) that the index increment will hit every item\nd) that that index starts at zeroWith an iterator, you are saying "give me everything so I can work with it" without knowing what the underlying implementation is. (In Java, there are collections that cannot be accessed through an index)Also, with an iterator, no need to worry about going out of bounds of the array.Another nice thing about iterators is that they better allow you to express (and enforce) your const-preference.  This example ensures that you will not be altering the vector in the midst of your loop:Aside from all of the other excellent answers... int may not be large enough for your vector.  Instead, if you want to use indexing, use the size_type for your container:I probably should point out you can also callstd::for_each(some_vector.begin(), some_vector.end(), &do_stuff);STL iterators are mostly there so that the STL algorithms like sort can be container independent. If you just want to loop over all the entries in a vector just use the index loop style. It is less typing and easier to parse for most humans. It would be nice if C++ had a simple foreach loop without going overboard with template magic.I don\'t think it makes much difference for a vector. I prefer to use an index myself as I consider it to be more readable and you can do random access like jumping forward 6 items or jumping backwards if needs be.I also like to make a reference to the item inside the loop like this so there are not a lot of square brackets around the place:Using an iterator can be good if you think you might need to replace the vector with a list at some point in the future and it also looks more stylish to the STL freaks but I can\'t think of any other reason.The second form represents what you\'re doing more accurately. In your example, you don\'t care about the value of i, really - all you want is the next element in the iterator.After having learned a little more on the subject of this answer, I realize it was a bit of an oversimplification.  The difference between this loop:And this loop:Is fairly minimal.  In fact, the syntax of doing loops this way seems to be growing on me:Iterators do unlock some fairly powerful declarative features, and when combined with the STL algorithms library you can do some pretty cool things that are outside the scope of array index administrivia.Indexing requires an extra mul operation.  For example, for vector v, the compiler converts v[i] into &v + sizeof(int) * i.During iteration you don\'t need to know number of item to be processed. You just need the item and iterators do such things very good.Several good points already. I have a few additional comments:Assuming we are talking about the C++ standard library, "vector" implies a random access container that has the guarantees of C-array (random access, contiguos memory layout etc). If you had said \'some_container\', many of the above answers would have been more accurate (container independence etc).To eliminate any dependencies on compiler optimization, you could move some_vector.size() out of the loop in the indexed code, like so:Always pre-increment iterators and treat post-increments as exceptional cases.So assuming and indexable std::vector<> like container, there is no good reason to prefer one over other, sequentially going through the container. If you have to refer to older or newer elemnent indexes frequently, then the indexed version is more appropropriate.In general, using the iterators is preferred because algorithms make use of them and behavior can be controlled (and implicitly documented) by changing the type of the iterator. Array locations can be used in place of iterators, but the syntactical difference will stick out.I don\'t use iterators for the same reason I dislike foreach-statements. When having multiple inner-loops it\'s hard enough to keep track of global/member variables without having to remember all the local values and iterator-names as well. What I find useful is to use two sets of indices for different occasions:I don\'t even want to abbreviate things like "animation_matrices[i]" to some random "anim_matrix"-named-iterator for example, because then you can\'t see clearly from which array this value is originated.Even better than "telling the CPU what to do" (imperative) is "telling the libraries what you want" (functional).So instead of using loops you should learn the algorithms present in stl.For container independenceI always use array index because many application of mine require something like "display thumbnail image". So I wrote something like this:Both the implementations are correct, but I would prefer the \'for\' loop. As we have decided to use a Vector and not any other container, using indexes would be the best option. Using iterators with Vectors would lose the very benefit of having the objects in continuous memory blocks which help ease in their access.Really, that\'s all there is to it. It\'s not as if you\'re going to gain more brevity either way on average, and if brevity really is your goal, you can always fall back on macros.No one mentioned yet that one advantage of indices is that they are not become invalid when you append to a contiguous container like std::vector, so you can add items to the container during iteration.This is also possible with iterators, but you must call reserve(), and therefore need to know how many items you\'ll append.