I need the following function:Input: a listOutput: Performance: of course, I prefer not to incur any unnecessary overhead.I feel it would be best to: But I\'m not sure what\'s the most Pythonic way to do that.EDIT:Thank you for all the great answers. I rated up several, and it was really hard to choose between @KennyTM and @Ivo van der Wijk solutions.The lack of short-circuit feature only hurts on a long input (over ~50 elements) that have unequal elements early on. If this occurs often enough (how often depends on how long the lists might be), the short-circuit is required. The best short-circuit algorithm seems to be @KennyTM checkEqual1. It pays, however, a significant cost for this:If the long inputs with early unequal elements don\'t happen (or happen sufficiently rarely), short-circuit isn\'t required. Then, by far the fastest is @Ivo van der Wijk solution.General method:One-liner:Also one-liner:The difference between the 3 versions are that:timeit result, for Python 2.7 and (only s1, s4, s7, s9 should return True)we getNote:A solution faster than using set() that works on sequences (not iterables) is to simply count the first element. This assumes the list is non-empty (but that\'s trivial to check, and decide yourself what the outcome should be on an empty list)some simple benchmarks:The simplest and most elegant way is as follows:(Yes, this even works with the null list! This is because this is one of the few cases where python has lazy semantics.)Regarding performance, this will fail at the earliest possible time, so it is asymptotically optimal.You can convert the list to a set. A set cannot have duplicates. So if all the elements in the original list are identical, the set will have just one element.this should work:len(set(the_list))==1the set method removes all duplicate elements in a listThis is another option, faster than len(set(x))==1 for long lists (uses short circuit)For what it\'s worth, this came up on the python-ideas mailing list recently.  It turns out that there is an itertools recipe for doing this already:1Supposedly it performs very nicely and has a few nice properties.1In other words, I can\'t take the credit for coming up with the solution -- nor can I take credit for even finding it.Doubt this is the "most Pythonic", but something like:would do the trick.This is a simple way of doing it:This is slightly more complicated, it incurs function call overhead, but the semantics are more clearly spelled out:I\'d do:as any stops searching the iterable as soon as it finds a True condition.If you\'re interested in something a little more readable (but of course not as efficient,) you could try:Regarding using reduce() with lambda. Here is a working code that I personally think is way nicer than some of the other answers.Returns a truple where the first value is the boolean if all items are same or not.Works in Python 2.4, which doesn\'t have "all".Convert the list into the set and then find the number of elements in the set. If the result is 1, it has identical elements and if not, then the elements in the list are not identical.Check if all elements equal to the first.np.allclose(array, array[0])Can use map and lambdaYou can do:It is fairly annoying that python makes you import the operators like operator.and_. As of python3, you will need to also import functools.reduce.(You should not use this method because it will not break if it finds non-equal values, but will continue examining the entire list. It is just included here as an answer for completeness.)The next one will short short circuit: