How can I do this in git:My current branch is branch1 and I have made some local changes. However I now realize that I actually meant to be applying these changes to branch2. Is there a way to apply/merge these changes so that they become local changes on branch2 without committing them on branch1?Since your files are not yet committed in branch1:orAs commented by benjohn (see git stash man page):To also stash currently untracked (newly added) files, add the argument -u, so: Stashing, temporary commits and rebasing may all be overkill. If you haven\'t added the changed files to the index, yet, then you may be able to just checkout the other branch.This will work so long as no files that you are editing are different between branch1 and branch2. It will leave you on branch2 with you working changes preserved. If they are different then you can specify that you want to merge your local changes with the changes introduced by switching branches with the -m option to checkout.If you\'ve added changes to the index then you\'ll want to undo these changes with a reset first. (This will preserve your working copy, it will just remove the staged changes.)Here is a shorter alternative to the previosly mentioned stash approach:Temporarily move the changes to a stash.git stash Create and switch to a new branch and then pop the stash to it in just one step.git stash branch new_branch_nameThen add and commit the changes to this new branch.WARNING: Not for git newbies.This comes up enough in my workflow that I\'ve almost tried to write a new git command for it. The usual git stash flow is the way to go but is a little awkward. I usually make a new commit first since if I have been looking at the changes, all the information is fresh in my mind and it\'s better to just start git commit-ing what I found (usually a bugfix belonging on master that I discover while working on a feature branch) right away.It is also helpful\xe2\x80\x94if you run into situations like this a lot\xe2\x80\x94to have another working directory alongside your current one that always have the master branch checked out.So how I achieve this goes like this:Sometimes later (asynchronously), or immediately in another terminal window:Optionally (still asynchronous) you can then rebase (or merge) your feature branch to get the bugfix, usually when you are about to submit a PR and have cleaned your feature branch and WD already:This way I can keep working on the feature uninterrupted and not have to worry about git stash-ing anything or having to clean my WD before a git checkout (and then having the check the feature branch backout again.) and still have all my bugfixes goes to master instead of hidden in my feature branch.IMO git stash and git checkout is a real PIA when you are in the middle of working on some big feature.If it were about committed changes, you should have a look at git-rebase, but as pointed out in comment by VonC, as you\'re talking about local changes, git-stash would certainly be the good way to do this.The answers given so far are not ideal because they require a lot of needless work resolving merge conflicts, or they make too many assumptions which are frequently false. This is how to do it perfectly. The link is to my own site.You have uncommited changes on my_branch that you want to commit to master, without committing all the changes from my_branch.Start by merging master into your branch, since you\'ll have to do that eventually anyway, and now is the best time to resolve any conflicts.The -u option (aka --include-untracked) in git stash -u prevents you from losing untracked files when you later do git clean -f -d within master.After git checkout master it is important that you do NOT git stash pop, because you will need this stash later. If you pop the stash created in my_branch and then do git stash in master, you will cause needless merge conflicts when you later apply that stash in my_branch.git reset unstages everything resulting from git stash apply. For example, files that have been modified in the stash but do not exist in master get staged as "deleted by us" conflicts.git checkout . and git clean -f -d discard everything that isn\'t committed: all changes to tracked files, and all untracked files and directories. They are already saved in the stash and if left in master would cause needless merge conflicts when switching back to my_branch.The last git stash pop will be based on the original my_branch, and so will not cause any merge conflicts. However, if your stash contains untracked files which you have committed to master, git will complain that it "Could not restore untracked files from stash". To resolve this conflict, delete those files from your working tree, then git stash pop, git add ., and git reset.