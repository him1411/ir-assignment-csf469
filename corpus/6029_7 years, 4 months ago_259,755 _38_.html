I\'ve been fiddling with WebGL lately, and have gotten a Collada reader working. Problem is it\'s pretty slow (Collada is a very verbose format), so I\'m going to start converting files to a easier to use format (probably JSON). Thing is, I already have the code to parse the file in Javascript, so I may as well use it as my exporter too! The problem is saving.Now, I know that I can parse the file, send the result to the server, and have the browser request the file back from the server as a download. But in reality the server has nothing to do with this particular process, so why get it involved? I already have the contents of the desired file in memory. Is there any way that I could present the user with a download using pure javascript? (I doubt it, but might as well ask...)And to be clear: I am not trying to access the filesystem without the users knowledge! The user will provide a file (probably via drag and drop), the script will transform the file in memory, and the user will be prompted to download the result. All of which should be "safe" activities as far as the browser is concerned.[EDIT]: I didn\'t mention it upfront, so the posters who answered "Flash" are valid enough, but part of what I\'m doing is an attempt to highlight what can be done with pure HTML5... so Flash is right out in my case. (Though it\'s a perfectly valid answer for anyone doing a "real" web app.) That being the case it looks like I\'m out of luck unless I want to involve the server. Thanks anyway!OK, creating a data:URI definitely does the trick for me, thanks to Matthew and Dennkster pointing that option out! Here is basically how I do it:1) get all the content into a string called "content" (e.g. by creating it there initially or by reading innerHTML of the  tag of an already built page).2) Build the data URI:There will be length limitations depending on browser type etc., but e.g. Firefox 3.6.12 works until at least 256k. Encoding in Base64 instead using encodeURIComponent might make things more efficient, but for me that was ok.3) open a new window and "redirect" it to this URI prompts for a download location of my JavaScript generated page:That\'s it.Simple solution for HTML5 ready browsers...UsageHTML5 defined a window.saveAs(blob, filename) method. It isn\'t supported by any browser right now. But there is a compatibility library called FileSaver.js that adds this function to most modern browsers (including Internet Explorer 10+). Internet Explorer 10 supports a navigator.msSaveBlob(blob, filename) method (MSDN), which is used in FileSaver.js for Internet Explorer support.I wrote a blog posting with more details about this problem.Take a look at Doug Neiner\'s Downloadify which is a Flash based JavaScript interface to do this.Downloadify is a tiny JavaScript + Flash library that enables the generation and saving of files on the fly, in the browser, without server interaction. Long data URIs can give performance problems in browsers. Another option to save client-side generated files, is to put their contents in a Blob (or File) object and create a download link using URL.createObjectURL(blob). This returns an URL that can be used to retrieve the contents of the blob. The blob is stored inside the browser until either URL.revokeObjectURL() is called on the URL or the document that created it is closed. Most web browsers have support for object URLs, Opera Mini is the only one that does not support them.If the data is text or an image, the browser can open the file, instead of saving it to disk. To cause the file to be downloaded upon clicking the link, you can use the the download attribute. However, not all web browsers have support for the download attribute. Another option is to use application/octet-stream as the file\'s mime-type, but this causes the file to be presented as a binary blob which is especially user-unfriendly if you don\'t or can\'t specify a filename. See also \'Force to open "Save As..." popup open at text link click for pdf in HTML\'.If the blob is created with the File constructor, you can also set a filename, but only a few web browsers (including Chrome & Firefox) have support for the File constructor. The filename can also be specified as the argument to the download attribute, but this is subject to a ton of security considerations. Internet Explorer 10 and 11 provides its own method, msSaveBlob, to specify a filename.You can generate a data URI.  However, there are browser-specific limitations.Works in all Modern browsers (See DEMO).p.s. href can be set with Javascript too: \'data:application/octet-stream,\' + encodeURIComponent(content);I\'ve used FileSaver (https://github.com/eligrey/FileSaver.js) and it works just fine.\nFor example, I did this function to export logs displayed on a page.\nYou have to pass an array for the instanciation of the Blob, so I just maybe didn\'t write this the right way, but it works for me.\nJust in case, be careful with the replace: this is the syntax to make this global, otherwise it will only replace the first one he meets.I found two simple approaches that work for me. First, using an already clicked a element and injecting the download data. And second, generating an a element with the download data, executing a.click() and removing it again. But the second approach works only if invoked by a user click action as well. (Some) Browser block click() from other contexts like on loading or triggered after a timeout (setTimeout).Here is a link to the data URI method Mathew suggested, it worked on safari, but not well because I couldn\'t set the filetype, it gets saved as "unknown" and then i have to go there again later and change it in order to view the file...http://www.nihilogic.dk/labs/canvas2image/You can use localStorage. This is the Html5 equivalent of cookies. It appears to work on Chrome and Firefox BUT on Firefox, I needed to upload it to a server. That is, testing directly on my home computer didn\'t work.I\'m working up HTML5 examples. Go to http://faculty.purchase.edu/jeanine.meyer/html5/html5explain.html\nand scroll to the maze one. The information to re-build the maze is stored using localStorage.I came to this article looking for HTML5 JavaScript for loading and working with xml files. Is it the same as older html and JavaScript????As previously mentioned the File API, along with the FileWriter and FileSystem APIs can be used to store files on a client\'s machine from the context of a browser tab/window.However, there are several things pertaining to latter two APIs which you should be aware of: Here are simple examples of how the APIs are used, directly and indirectly, in tandem to do this:BakedGoods*Using the raw File, FileWriter, and FileSystem APIsThough the FileSystem and FileWriter APIs are no longer on the standards track, their use can be justified in some cases, in my opinion, because:Whether "some cases" encompasses your own, however, is for you to decide.*BakedGoods is maintained by none other than this guy right here :)