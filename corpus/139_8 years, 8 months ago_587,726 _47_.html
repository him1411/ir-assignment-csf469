Is there a way to make the following return true?There doesn\'t seem to be an overload that allows me to set the case sensitivity.. Currently I UPPERCASE them both, but that\'s just silly.UPDATE\nThe sillyness I refer to is the i18n issues that come with up- and down casing.UPDATE\nThis question is ancient and since then I have realized I asked for a simple answer for a really vast and difficult topic if you care to investigate it fully.\nFor most cases, in mono-lingual, English code bases this answer will suffice. I\'m suspecting because most people coming here fall in this category this is the most popular answer.\nThis answer however brings up the inherent problem that we can\'t compare text case insensitive until we know both texts are the same culture and we know  what that culture is. This is maybe a less popular answer, but I think it is more correct and that\'s why I marked it as such.To test if the string paragraph contains the string word (thanks @QuarterMeister)Where culture is the instance of CultureInfo describing the language that the text is written in.This solution is transparent about the definition of case-insensitivity, which is language dependent. For example, the English language uses the characters I and i for the upper and lower case versions of the ninth letter, whereas the Turkish language uses these characters for the eleventh and twelfth letters of its 29 letter-long alphabet. The Turkish upper case version of \'i\' is the unfamiliar character \'\xc4\xb0\'.Thus the strings tin and TIN are the same word in English, but different words in Turkish. As I understand, one means \'spirit\' and the other is an onomatopoeia word. (Turks, please correct me if I\'m wrong, or suggest a better example)To summarise, you can only answer the question \'are these two strings the same but in different cases\' if you know what language the text is in. If you don\'t know, you\'ll have to take a punt. Given English\'s hegemony in software, you should probably resort to CultureInfo.InvariantCulture, because it\'ll be wrong in familiar ways.You could use the String.IndexOf Method and pass StringComparison.OrdinalIgnoreCase as the type of search to use:Even better is defining a new extension method for string:You can use IndexOf() like this:Since 0 (zero) can be an index, you check against -1.MSDNThe zero-based index position of value if that string is found, or -1\n  if it is not. If value is String.Empty, the return value is 0.Alternate solution using Regex:NoticeAs @cHao has pointed out in his comment, there are scenario\'s that will cause this solution to return incorrect results. Make sure you know what you\'re doing before you implement this solution haphazardly.You could always just up or downcase the strings first.  Oops, just saw that last bit.  A case insensitive compare would *probably* do the same anyway, and if performance is not an issue, I don\'t see a problem with creating uppercase copies and comparing those.  I could have sworn that I once saw a case-insensitive compare once...One issue with the answer is that it will throw an exception if a string is null. You can add that as a check so it won\'t:StringExtension class is the way forward, I\'ve combined a couple of the posts above to give a complete code example:This is clean and simple.OrdinalIgnoreCase, CurrentCultureIgnoreCase or InvariantCultureIgnoreCase?Since this is missing, here are some recommendations about when to use which one:Based on these rules you should use:whereas [YourDecision] depends on the recommendations from above.link of source: http://msdn.microsoft.com/en-us/library/ms973919.aspxJust like this:I know that this is not the C#, but in the framework (VB.NET) there is already such a functionC# variant:The InStr method from the VisualBasic assembly is the best if you have a concern about internationalization (or you could reimplement it).  Looking at in it dotNeetPeek shows that not only does it account for caps and lowercase, but also for kana type and full- vs. half-width characters (mostly relevant for Asian languages, although there are full-width versions of the Roman alphabet too).  I\'m skipping over some details, but check out the private method InternalInStrText:Use this:Ultimately, a generic "contains" operation comes down to a function like this,this can be trivially wrapped in a extension version accepting IEnumerable like this,Now, this will work for the ordinal comparison of any sequences, including strings, since string implements IEnumerable<char>,However, as we know, strings are not generic, they are specialized. There are two key factors at play.The net effect is the same. Strings that you might assert are linguistically equal can be validly represented by different combinations of chars. Whats more, the rules for validity change between cultures.All this leads to a specialized string based "Contains" implementation like this.This function can be used to perform a case insensitive, culture specific "contains" that will work, whatever the normalization of the strings. e.g.Using a RegEx is a straight way to do this:This is quite similar to other example here, but I\'ve decided to simplify enum to bool, primary because other alternatives are normally not needed. Here is my example:And usage is something like:The trick here is to look for the string, ignoring case, but to keep it exactly the same (with the same case).Output is "Reset"You can use string.indexof () function. This will be case insensitiveSimple way for newbie: