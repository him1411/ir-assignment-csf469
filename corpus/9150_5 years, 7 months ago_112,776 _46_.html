Following is my code and I want to understand that why #firstDiv is being pushed downward by all browsers. I really want to understand the inner workings of the fact that why its being pushed downward rather than pulling it upward by one way or another. (and I know how to align their tops :))And I know that its overflow:hidden which is causing it but not sure that why its pushing that div downward.http://jsfiddle.net/WGCyu/.Basically you have added more clutter in your code which is creating more confusion so first I try to remove clutter which hinders understanding the real issue.First of all we have to establish that what\'s the real question?\nIts that why "inline-block" element is pushed downward.Now we start to understand it and remove the clutter first.1 - \nWhy not give all three divs same border width?\nLet\'s give it.2 - Does floating element has any connection with inline-block element being pushed downward?\nNo, it has nothing to do with it.So, we have removed that div altogether. And you are witnessing same behavior of inline-block element being pushed downward.Here comes the turn of some literature to grasp the idea of line boxes and how they are lined in the same line esp read last paragraph carefully because there lies the answer of your question.The baseline of an \'inline-block\' is the baseline of its last line box in the normal flow, unless it has either no in-flow line boxes or if its \'overflow\' property has a computed value other than \'visible\', in which case the baseline is the bottom margin edge.If you are not sure about baseline then here is brief explanation in simple words.All characters except \'gjpqy\' are written on the baseline you can think of baseline as  if you draw a simple horizontal line same as underlining right below these "random characters" then it will be the baseline but now if you write any of \'gjpqy\' character(s) on the same line then lower part of these characters would fall below the line. So, we can say that all characters except \'gjpqy\' are written completely above the baseline while some part of these characters are written below the baseline.3 - Why not check where is the baseline of our line?\nI have added few characters which show the baseline of our line.4 - Why not add some characters in our divs too to find their baselines in the div?\nHere, some characters added in divs to clarify baseline.Now when you understand about baseline, read the following simplified version about baseline of inline-blocks.i) If inline-block in question has its overflow property set to visible (which is by default so no need to set though). \nThen its baseline would be the baseline of the containing block of the line.ii) If inline-block in question has its overflow property set to OTHER THAN visible. \nThen its bottom margin would be on the baseline of the line of containing box.Now look at this again to clarify your concept that what\'s happening with green div.\nIf yet any confusion then here is added more characters close to green div to establish the baseline of the containing block and green div baseline is aligned.Well, I am now claiming that they have same baseline? RIGHT?5 - Then why not overlap them and see if they are fit right one on another?\nSo, I bring third div -left: 35px; to check if they have same baseline now?Now, we have got our first point proved.Well, after explanation of first point second point is easily digestible and you see that first div which has overflow property set to other than visible (hidden) has its bottom margin on the base line of the line.Now, you can do couple of experiments to further illustrate it.Now bring back your clutter and see if everything is looking to fine to you.And now we are back to where we started from.Hopefully I have answered your question.The default value for vertical-align in CSS is baseline & this rule is also apply with inline-block read this http://www.brunildo.org/test/inline-block.htmlWrite vertical-align:top in your inline-block DIV.Check this http://jsfiddle.net/WGCyu/1/Just use vertical-align:top;DemoView this alternative example. The reason for such behavior is described in CSS3 module: line: 3.2. Line Box wrapping [1]:In general, the start edge of a line box touches the start edge of its containing block and the end edge touches the end edge of its containing block. However, floating boxes may come between the containing block edge and the line box edge. Thus, although line boxes in the same inline formatting context generally have the same inline progression advance (that of the containing block), they may vary if available inline-progression space is reduced due to floats[...]As you can see, the third element is pushed downward, although it does not have a overflow property. The reason must be somewhere else to find. The second behavior you notice is described in Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification: 9.5 Floats [2]:Since a float is not in the flow, non-positioned block boxes created before and after the float box flow vertically as if the float did not exist. However, the current and subsequent line boxes created next to the float are shortened as necessary to make room for the margin box of the float.All your display:inline-block; divs are using a special kind of baseline in this case 10.8 Line height calculations: the \'line-height\' and \'vertical-align\' properties (very end) [3]:The baseline of an \'inline-block\' is the baseline of its last line box in the normal flow, unless it has either no in-flow line boxes or if its \'overflow\' property has a computed value other than \'visible\', in which case the baseline is the bottom margin edge.So when you\'re using floating elements and inline-block elements, the floating element will be pushed to the side and the inline formatting will be recalculated according to 1. On the other hand, the next elements are shortened if they won\'t fit. Since you\'re already working with a minimum amount of space, there\'s no other way to modify your elements then pushing them 2. In this case, the highest element will define the size of your wrapping div, thus defining the baseline 3, while on the other hand the modification of position and width stated in 2 can\'t be applied to such minimal spaced maximum height elements. In this case a behavior as in my very first demo will result.Lastly, the reason your overflow:hidden will prevent #firstDiv to be pushed to the lower edge of your #container, although I couldn\'t find a reason in section 11. Without overflow:hidden it works as excepted and defined by 2 and 3. DemoTL;DR: Have a very close look on the W3 recommendations and the implementations in the browser. In my humble opinion floating elements are determined to show unexpected behavior if you don\'t know all the changes they do to your surrounding elements. Here\'s another demo which shows a common problem with floats.the problem is because you have applied float:left on the second div. which makes the second div to come on the left side and your first div drops and comes after your second div.\nIf you apply float:left on the first div also, your problem will be gone.overflow:hidden is causing no problem to your layout, overflow:hidden affects only inner elements of a div, it has nothing to do with other elements which are outside.Try adding padding:0; to the body and removing the margin of your divs.Add background-color:*any color aside from background* to check the difference.