In my humble opinion the answers to the famous question "What is a monad?", especially the most voted ones, try to explain what is a monad without clearly explaining why monads are really necessary.  Can they be explained as the solution to a problem?Then, we have a first big problem. This is a program:f(x) = 2 * xg(x,y) = x / yHow can we say  what is to be executed first? How can we form an ordered sequence of functions (i.e. a program) using no more than functions?Solution: compose functions. If you want first g and then f, just write f(g(x,y)). This way, "the program" is a function as well: main = f(g(x,y)). OK, but ...More problems: some functions might fail (i.e. g(2,0), divide by 0). We have no "exceptions" in FP (an exception is not a function). How do we solve it?Solution: Let\'s allow functions to return two kind of things: instead of having g : Real,Real -> Real (function from two reals into a real), let\'s allow g : Real,Real -> Real | Nothing (function from two reals into (real or nothing)). But functions should (to be simpler) return only one thing. Solution: let\'s create a new type of data to be returned, a "boxing type" that encloses maybe a real or be simply nothing. Hence, we can have g : Real,Real -> Maybe Real. OK, but ...What happens now to f(g(x,y))? f is not ready to consume a Maybe Real. And, we don\'t want to change every function we could connect with g to consume a Maybe Real.Solution: let\'s have a special function to "connect"/"compose"/"link" functions. That way, we can, behind the scenes, adapt the output of one function to feed the following one. In our case:  g >>= f (connect/compose g to f). We want >>= to get g\'s output, inspect it and, in case it is Nothing just don\'t call f and return Nothing; or on the contrary, extract the boxed Real and feed f with it. (This algorithm is just the implementation of >>= for the Maybe type). Also note that >>= must be written only once per "boxing type" (different box, different adapting algorithm).Many other problems arise which can be solved using this same pattern: 1. Use a "box" to codify/store different meanings/values, and have functions like g that return those "boxed values". 2. Have a composer/linker g >>= f to help connecting g\'s output to f\'s input, so we don\'t have to change any f at all.Remarkable problems that can be solved using this technique are: having a global state that every function in the sequence of functions ("the program") can share: solution StateMonad. We don\'t like "impure functions": functions that yield different output for same input. Therefore, let\'s mark those functions, making them to return a tagged/boxed value: IO monad.Total happiness!The answer is, of course, "We don\'t". As with all abstractions, it isn\'t necessary.Haskell does not need a monad abstraction. It isn\'t necessary for performing IO in a pure language. The IO type takes care of that just fine by itself. The existing monadic desugaring of do blocks could be replaced with desugaring to bindIO, returnIO, and failIO as defined in the GHC.Base module. (It\'s not a documented module on hackage, so I\'ll have to point at its source for documentation.) So no, there\'s no need for the monad abstraction.So if it\'s not needed, why does it exist? Because it was found that many patterns of computation form monadic structures. Abstraction of a structure allows for writing code that works across all instances of that structure. To put it more concisely - code reuse.In functional languages, the most powerful tool found for code reuse has been composition of functions. The good old (.) :: (b -> c) -> (a -> b) -> (a -> c) operator is exceedingly powerful. It makes it easy to write tiny functions and glue them together with minimal syntactic or semantic overhead.But there are cases when the types don\'t work out quite right.  What do you do when you have foo :: (b -> Maybe c) and bar :: (a -> Maybe b)? foo . bar doesn\'t typecheck, because b and Maybe b aren\'t the same type.But.. It\'s almost right. You just want a bit of leeway. You want to be able to treat Maybe b as if it was basically b. It\'s a poor idea to just flat-out treat them as the same type, though. That\'s more or less the same thing as null pointers, which Tony Hoare famously called the billion-dollar mistake. So if you can\'t treat them as the same type, maybe you can find a way to extend the composition mechanism (.) provides.In that case, it\'s important to really examine the theory underlying (.). Fortunately, someone has already done this for us. It turns out that the combination of (.) and id form a mathematical construct known as a category. But there are other ways to form categories. A Kleisli category, for instance, allows the objects being composed to be augmented a bit. A Kleisli category for Maybe would consist of (.) :: (b -> Maybe c) -> (a -> Maybe b) -> (a -> Maybe c) and id :: a -> Maybe a. That is, the objects in the category augment the (->) with a Maybe, so (a -> b) becomes (a -> Maybe b).And suddenly, we\'ve extended the power of composition to things that the traditional (.) operation doesn\'t work on. This is a source of new abstraction power. Kleisli categories work with more types than just Maybe. They work with every type that can assemble a proper category, obeying the category laws.As long as you can prove that your type obeys those three laws, you can turn it into a Kleisli category. And what\'s the big deal about that? Well, it turns out that monads are exactly the same thing as Kleisli categories. Monad\'s return is the same as Kleisli id. Monad\'s (>>=) isn\'t identical to Kleisli (.), but it turns out to be very easy to write each in terms of the other. And the category laws are the same as the monad laws, when you translate them across the difference between (>>=) and (.).So why go through all this bother? Why have a Monad abstraction in the language? As I alluded to above, it enables code reuse. It even enables code reuse along two different dimensions.The first dimension of code reuse comes directly from the presence of the abstraction. You can write code that works across all instances of the abstraction. There\'s the entire monad-loops package consisting of loops that work with any instance of Monad.The second dimension is indirect, but it follows from the existence of composition. When composition is easy, it\'s natural to write code in small, reusable chunks. This is the same way having the (.) operator for functions encourages writing small, reusable functions.So why does the abstraction exist? Because it\'s proven to be a tool that enables more composition in code, resulting in creating reusable code and encouraging the creation of more reusable code. Code reuse is one of the holy grails of programming. The monad abstraction exists because it moves us a little bit towards that holy grail.Benjamin Pierce said in TAPLA type system can be regarded as calculating a kind of static\n  approximation to the run-time behaviours of the terms in a program.That\'s why a language equipped with a powerful type system is strictly more expressive, than a poorly typed language. You can think about monads in the same way.As @Carl and sigfpe point, you can equip a datatype with all operations you want without resorting to monads, typeclasses or whatever other abstract stuff. However monads allow you not only to write reusable code, but also to abstract away all redundant detailes.As an example, let\'s say we want to filter a list. The simplest way is to use the filter function: filter (> 3) [1..10], which equals [4,5,6,7,8,9,10].A slightly more complicated version of filter, that also passes an accumulator from left to right, isTo get all i, such that i <= 10, sum [1..i] > 4, sum [1..i] < 25, we can writewhich equals [3,4,5,6].Or we can redefine the nub function, that removes duplicate elements from a list, in terms of filterAccum:nub\' [1,2,4,5,4,3,1,8,9,4] equals [1,2,4,5,3,8,9]. A list is passed as an accumulator here. The code works, because it\'s possible to leave the list monad, so the whole computation stays pure (notElem doesn\'t use >>= actually, but it could). However it\'s not possible to safely leave the IO monad (i.e. you cannot execute an IO action and return a pure value \xe2\x80\x94 the value always will be wrapped in the IO monad). Another example is mutable arrays: after you have leaved the ST monad, where a mutable array live, you cannot update the array in constant time anymore. So we need a monadic filtering from the Control.Monad module:filterM executes a monadic action for all elements from a list, yielding elements, for which the monadic action returns True.A filtering example with an array:prints [1,2,4,5,3,8,9] as expected.And a version with the IO monad, which asks what elements to return:E.g.And as a final illustration, filterAccum can be defined in terms of filterM:with the StateT monad, that is used under the hood, being just an ordinary datatype.This example illustrates, that monads not only allow you to abstract computational context and write clean reusable code (due to the composability of monads, as @Carl explains), but also to treat user-defined datatypes and built-in primitives uniformly.I don\'t think IO should be seen as a particularly outstanding monad, but it\'s certainly one of the more astounding ones for beginners, so I\'ll use it for my explanation.The simplest conceivable IO system for a purely-functional language (and in fact the one Haskell started out with) is this:With lazyness, that simple signature is enough to actually build interactive terminal programs â€“ very limited, though. Most frustrating is that we can only output text. What if we added some more exciting output possibilities?cute, but of course a much more realistic \xe2\x80\x9calterative output\xe2\x80\x9d would be writing to a file. But then you\'d also want some way to read from files. Any chance?Well, when we take our main\xe2\x82\x81 program and simply pipe a file to the process (using operating system facilities), we have essentially implemented file-reading. If we could trigger that file-reading from within the Haskell language...This would use an \xe2\x80\x9cinteractive program\xe2\x80\x9d String->[Output], feed it a string obtained from a file, and yield a non-interactive program that simply executes the given one.There\'s one problem here: we don\'t really have a notion of when the file is read. The [Output] list sure gives a nice order to the outputs, but we don\'t get an order for when the inputs will be done.Solution: make input-events also items in the list of things to do.Ok, now you may spot an imbalance: you can read a file and make output dependent on it, but you can\'t use the file contents to decide to e.g. also read another file. Obvious solution: make the result of the input-events also something of type IO, not just Output. That sure includes simple text output, but also allows reading additional files etc..That would now actually allow you to express any file operation you might want in a program (though perhaps not with good performance), but it\'s somewhat overcomplicated:main\xe2\x82\x83 yields a whole list of actions. Why don\'t we simply use the signature :: IO\xe2\x82\x81, which has this as a special case?The lists don\'t really give a reliable overview of program flow anymore: most subsequent computations will only be \xe2\x80\x9cannounced\xe2\x80\x9d as the result of some input operation. So we might as well ditch the list structure, and simply cons a \xe2\x80\x9cand then do\xe2\x80\x9d to each output operation.Not too bad!In practice, you wouldn\'t want to use plain constructors to define all your programs. There would need to be a good couple of such fundamental constructors, yet for most higher-level stuff we would like to write a function with some nice high-level signature. It turns out most of these would look quite similar: accept some kind of meaningfully-typed value, and yield an IO action as the result.There\'s evidently a pattern here, and we\'d better write it asNow that starts to look familiar, but we\'re still only dealing with thinly-disguised plain functions under the hood, and that\'s risky: each \xe2\x80\x9cvalue-action\xe2\x80\x9d has the responsibility of actually passing on the resulting action of any contained function (else the control flow of the entire program is easily disrupted by one ill-behaved action in the middle). We\'d better make that requirement explicit. Well, it turns out those are the monad laws, though I\'m not sure we can really formulate them without the standard bind/join operators.At any rate, we\'ve now reached a formulation of IO that has a proper monad instance:Obviously this is not an efficient implementation of IO, but it\'s in principle usable.You need monads if you have a type constructor and functions that returns values of that type family. Eventually, you would like to combine these kind of functions together. These are the three key elements to answer why.Let me elaborate. You have Int, String and Real and functions of type Int -> String, String -> Real and so on. You can combine these functions easily, ending with Int -> Real. Life is good. Then, one day, you need to create a new family of types. It could be because you need to consider the possibility of returning no value (Maybe), returning an error (Either), multiple results (List) and so on.Notice that Maybe is a type constructor. It takes a type, like Int and returns a new type Maybe Int. First thing to remember, no type constructor, no monad. Of course, you want to use your type constructor in your code, and soon you end with functions like Int -> Maybe String and String -> Maybe Float. Now, you can\'t easily combine your functions. Life is not good anymore.And here\'s when monads come to the rescue. They allow you to combine that kind of functions again. You just need to change the composition . for >==. Monads are just a convenient framework for solving a class of recurring problems. First, monads must be functors (i.e. must support mapping without looking at the elements (or their type)), they must also bring a binding (or chaining) operation and a way to create a monadic value from an element type (return). Finally, bind and return must satisfy two equations (left and right identities), also called the monad laws. (Alternatively one could define monads to have a flattening operation instead of binding.)The list monad is commonly used to deal with non-determinism. The bind operation selects one element of the list (intuitively all of them in parallel worlds), lets the programmer to do some computation with them, and then combines the results in all worlds to single list (by concatenating, or flattening, a nested list). Here is how one would define a permutation function in the monadic framework of Haskell:Here is an example repl session:It should be noted that the list monad is in no way a side effecting computation. A mathematical structure being a monad (i.e. conforming to the above mentioned interfaces and laws) does not imply side effects, though side-effecting phenomena often nicely fit into the monadic framework.Monads serve basically to compose functions together in a chain. Period.Now the way they compose differs across the existing monads, thus resulting in different behaviors (e.g., to simulate mutable state in the state monad).The confusion about monads is that being so general, i.e., a mechanism to compose functions, they can be used for many things, thus leading people to believe that monads are about state, about IO, etc, when they are only about "composing functions".Now, one interesting thing about monads, is that the result of the composition is always of type "M a", that is, a value inside an envelope tagged with "M". This feature happens to be really nice to implement, for example, a clear separation between pure from impure code: declare all impure actions as functions of type "IO a" and provide no function, when defining the IO monad, to take out the "a" value from inside the "IO a". The result is that no function can be pure and at the same time take out a value from an "IO a", because there is no way to take such value while staying pure (the function must be inside the "IO" monad to use such value). (NOTE: well, nothing is perfect, so the "IO straitjacket" can be broken using "unsafePerformIO : IO a -> a" thus polluting what was supposed to be a pure function, but this should be used very sparingly and when you really know to be not introducing any impure code with side-effects.