All of us who work with relational databases have learned (or are learning) that SQL  is different. Eliciting the desired results, and doing so efficiently, involves a tedious process partly characterized by learning unfamiliar paradigms, and finding out that some of our most familiar  programming patterns don\'t work here. What are the common antipatterns you\'ve seen (or yourself committed)?I am consistently disappointed by most programmers\' tendency to mix their UI-logic in the data access layer:Normally, programmers do this because they intend to bind their dataset directly to a grid, and its just convenient to have SQL Server format server-side than format on the client.Queries like the one shown above are extremely brittle because they tightly couple the data layer to the UI layer. On top of that, this style of programming thoroughly prevents stored procedures from being reusable.Here are my top 3.Number 1. Failure to specify a field list. (Edit: to prevent confusion: this is a production code rule.  It doesn\'t apply to one-off analysis scripts - unless I\'m the author.)should be Number 2. Using a cursor and while loop, when a while loop with a loop variable will do.Number 3. DateLogic through string types.Should beI\'ve seen a recent spike of "One query is better than two, amiright?"This query requires two or three different execution plans depending on the values of the parameters.  Only one execution plan is generated and stuck into the cache for this sql text.  That plan will be used regardless of the value of the parameters.  This results in intermittent poor performance.  It is much better to write two queries (one query per intended execution plan).Human readable password fields, egad. Self explanatory.Using LIKE against indexed\ncolumns, and I\'m almost tempted to\njust say LIKE in general.Recycling SQL-generated PK values.Surprise nobody mentioned the\ngod-table yet. Nothing says\n"organic" like 100 columns of bit\nflags, large strings and integers.Then there\'s the "I miss .ini\nfiles" pattern: storing CSVs, pipe\ndelimited strings or other parse\nrequired data in large text fields.And for MS SQL server the use of\ncursors at all. There\'s a better\nway to do any given cursor task.Edited because there\'s so many!Don\'t have to dig deep for it: Not using prepared statements.Using meaningless table aliases:Makes reading a large SQL statement so much harder than it needs to beMy bugbears are the 450 column Access tables that have been put together by the 8 year old son of the Managing Director\'s best friends dog groomer and the dodgy lookup table that only exists because somebody doesn\'t know how to normalise a datastructure properly.Typically, this lookup table looks like this:I\'ve lost count of the number of clients I\'ve seen who have systems that rely on abominations like this.The ones that I dislike the most are Using spaces when creating tables, sprocs etc. I\'m fine with CamelCase or under_scores and singular or plurals and UPPERCASE or lowercase but having to refer to a table or column [with spaces], especially if [ it is  oddly spaced] (yes, I\'ve run into this) really irritates me.Denormalized data.  A table doesn\'t have to be perfectly normalized, but when I run into a table of employees that has information about their current evaluation score or their primary anything, it tells me that I will probably need to make a separate table at some point and then try to keep them synced.  I will normalize the data first and then if I see a place where denormalization helps, I\'ll consider it. Overuse of either views or cursors.  Views have a purpose, but when each table is wrapped in a view it\'s too much.  I\'ve had to use cursors a few times, but generally you can use other mechanisms for this.Access.  Can a program be an anti-pattern?  We have SQL Server at my work, but a number of people use access due to it\'s availabilty, "ease of use" and "friendliness" to non-technical users.  There is too much here to go into, but if you\'ve been in a similar environment, you know.Overuse of temporary tables and cursors.use SP as the prefix of the store procedure name because it will first search in the System procedures location rather than the custom ones.For storing time values, only UTC timezone should be used.  Local time should not be used.and assuming that the result will be sorted by some_column.  I\'ve seen this a bit with Sybase where the assumption holds (for now).using @@IDENTITY instead of SCOPE_IDENTITY()Quoted from this answer :Re-using a \'dead\' field for something it wasn\'t intended for (e.g. storing user data in a \'Fax\' field) - very tempting as a quick fix though!Or, cramming everything into one line.The FROM TableA, TableB WHERE syntax for JOINS rather than FROM TableA INNER JOIN TableB ONMaking assumptions that a query will be returned sorted a certain way without putting an ORDER BY clause in, just because that was the way it showed up during testing in the query tool.I need to put my own current favorite here, just to make the list complete. My favorite antipattern is not testing your queries.  This applies when:And any tests run against atypical or insufficient data don\'t count. If it\'s a stored procedure, put the test statement into a comment and save it, with the results. Otherwise, put it into a comment in the code with the results.Contrarian view:  over-obsession with normalization.  Most SQL/RBDBs systems give one lots of features (transactions, replication) that are quite useful, even with unnormalized data.  Disk space is cheap, and sometimes it can be simpler (easier code, faster development time) to manipulate / filter / search  fetched data, than it is to write up 1NF schema, and deal with all the hassles therein (complex joins, nasty subselects, etc).   I have found the over-normalized systems are often premature optimization, especially during early development stages.  (more thoughts on it... http://writeonly.wordpress.com/2008/12/05/simple-object-db-using-json-and-python-sqlite/)Learning SQL in the first six months of their career and never learning anything else for the next 10 years.  In particular not learning or effectively using windowing/analytical SQL features.  In particular the use of over() and partition by.Window functions, like aggregate\n  functions, perform an aggregation on a\n  defined set (a group) of rows, but\n  rather than returning one value per\n  group, window functions can return\n  multiple values for each group.See O\'Reilly SQL Cookbook Appendix A for a nice overview of windowing functions.Temporary Table abuse.Specifically this sort of thing:Don\'t build a temporary table from a query, only to delete the rows you don\'t need.And yes, I have seen pages of code in this form in production DBs.1) I don\'t know it\'s an "official" anti-pattern, but I dislike and try to avoid string literals as magic values in a database column.An example from MediaWiki\'s table \'image\':(I just notice different casing, another thing to avoid)I design such cases as int lookups into tables ImageMediaType and ImageMajorMime with int primary keys.2) date/string conversion that relies on specific NLS settingswithout format identifierIdentical subqueries in a query.I just put this one together, based on some of the SQL responses here on SO.It is a serious antipattern to think that triggers are to databases as event handlers are to OOP. There\'s this perception that just any old logic can be put into triggers, to be fired off when a transaction (event) happens on a table.Not true. One of the big differences are that triggers are synchronous - with a vengeance, because they are synchronous on a set operation, not on a row operation. On the OOP side, exactly the opposite - events are an efficient way to implement asynchronous transactions.The Altered View - A view that is altered too often and without notice or reason. The change will either be noticed at the most inappropriate time or worse be wrong and never noticed.  Maybe your application will break because someone thought of a better name for that column.  As a rule views should extend the usefulness of base tables while maintaining a contract with consumers.  Fix problems but don\'t add features or worse change behavior, for that create a new view.  To mitigate do not share views with other projects and, use CTEs when platforms allow.  If your shop has a DBA you probably can\'t change views but all your views will be outdated and or useless in that case.The  !Paramed - Can a query have more than one purpose?  Probably but the next person who reads it won\'t know until deep meditation.  Even if you don\'t need them right now chances are you will, even if it\'s "just" to debug.  Adding parameters lowers maintenance time and keep things DRY.  If you have a where clause you should have parameters.The case for no CASE -  Stored Procedures or Functions without any comments...Putting stuff in temporary tables, especially people who switch from SQL Server to Oracle have a habit of overusing temporary tables. Just use nested select statements. Developers who write queries without having a good idea about what makes SQL applications (both individual queries and multi-user systems) fast or slow. This includes ignorance about:The two I find the most, and can have a significant cost in terms of performance are:Using cursors instead of a set based\nexpression. I guess this one occurs frequently when the programmer is thinking procedurely.Using correlated sub-queries, when a\njoin to a derived table can do the\njob.Using SQL as a glorified ISAM (Indexed Sequential Access Method) package.  In particular, nesting cursors instead of combining SQL statements into a single, albeit larger, statement.  This also counts as \'abuse of the optimizer\' since in fact there isn\'t much the optimizer can do.  This can be combined with non-prepared statements for maximum inefficiency:The correct solution (almost always) is to combine the two SELECT statements into one:The only advantage to the double loop version is that you can easily spot the breaks between values in Table1 because the inner loop ends.  This can be a factor in control-break reports.Also, sorting in the application is usually a no-no.I just came across view definition like this:There are 50 or so columns in the view. Some developers take a small pride torturing others by not providing column aliases, so one have to count column offset in both places in order to be able to figure out what column in a view corresponds to. 