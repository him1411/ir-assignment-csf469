I often have at least 3 remote branches: master, staging and production. I have 3 local branches that track those remote branches.Updating all my local branches is tedious:I\'d love to be able to just do a "git pull -all", but I haven\'t been able to get it to work. It seems to do a "fetch --all", then updates (fast forward or merges) the current working branch, but not the other local branches.I\'m still stuck manually switching to each local branch and updating.The behavior you describe for pull --all is exactly as expected, though not necessarily useful. The option is passed along to git fetch, which then fetches all refs from all remotes, instead of just the needed one; pull then merges (or in your case, rebases) the appropriate single branch.If you want to check out other branches, you\'re going to have to check them out. And yes, merging (and rebasing) absolutely require a work tree, so they cannot be done without checking out the other branches. You could wrap up your described steps into a script/alias if you like, though I\'d suggest joining the commands with && so that should one of them fail, it won\'t try to plow on.git-up automates this. From the README:So git pull merges by default, when it should really rebase. You can ask it to rebase automatically instead, but it still won\'t touch anything other than the currently checked-out branch. If you\'re tracking a bunch of remote branches, you\'ll get non-fast-forward complaints next time you push.Solve it once and for all:Note: Even though I posted my own solution, I would recommend using git-up, which is also the accepted answer.I know this question is almost 3 years old, but I asked myself the very same question and did not found any ready made solution. So, I created a custom git command shell script my self.Here it goes, the git-ffwd-update script does the following...the script can be called like:The full script, should be saved as git-ffwd-update and needs to be on the PATH.It\'s not so hard to automate:This still isn\'t automatic, as I wish there was an option for - and there should be some checking to make sure that this can only happen for fast-forward updates (which is why manually doing a pull is far safer!!), but caveats aside you can:to update the position of your local branch without having to check it out.Note: you will be losing your current branch position and moving it to where the origin\'s branch is, which means that if you need to merge you will lose data!This issue is not solved (yet), at least not easily / without scripting: see this post on git mailing list by Junio C Hamano explaining situation and providing call for a simple solution.The major reasoning is that you shouldn\'t need this:With git that is not ancient (i.e. v1.5.0 or newer), there is no reason to\n  have local "dev" that purely track the remote anymore.  If you only want\n  to go-look-and-see, you can check out the remote tracking branch directly\n  on a detached HEAD with "git checkout origin/dev".Which means that the only cases we need to make it convenient for users\n  are to handle these local branches that "track" remote ones when you do\n  have local changes, or when you plan to have some.If you do have local changes on "dev" that is marked to track the remove\n  "dev", and if you are on a branch different from "dev", then we should not\n  do anything after "git fetch" updates the remote tracking "dev".  It\n  won\'t fast forward anywayThe call for a solution was for an option or external script to prune local branches that follow now remote-tracking branches, rather than to keep them up-to-date by fast-forwarding, like original poster requested.So how about "git branch --prune --remote=<upstream>" that iterates over\n  local branches, and if(1) it is not the current branch; and\n  (2) it is marked to track some branch taken from the <upstream>; and\n  (3) it does not have any commits on its own;then remove that branch?  "git remote --prune-local-forks <upstream>" is\n  also fine; I do not care about which command implements the feature that\n  much.Note: as of git 2.10 no such solution exists.  Note that the git remote prune subcommand, and git fetch --prune are about removing remote-tracking branch for branch that no longer exists on remote, not about removing local branch that tracks remote-tracking branch (for which remote-tracking branch is upstream branch).There are plenty of acceptable answers here, but some of the plumbing may be be a little opaque to the uninitiated. Here\'s a much simpler example that can easily be customized:If you add ~/bin/git to your PATH (assuming the file is ~/bin/git/git-update-all), you can just run:Here is a good answer: How to fetch all git branchesThere are a lot of answers here but none that use git-fetch to update the local ref directly, which is a lot simpler than checking out branches, and safer than git-update-ref.Here we use git-fetch to update non-current branches and git pull --ff-only for the current branch. It:and here it is:From the manpage for git-fetch:By specifying git fetch <remote> <ref>:<ref> (without any +) we get a fetch that updates the local ref only when it can be fast-forwarded.Note: this assumes the local and remote branches are named the same (and that you want to track all branches), it should really use information about which local branches you have and what they are set up to track.Add this script to .profile on Mac OS X:A script I wrote for my GitBash.  Accomplishes the following:** I use this but have not tested thoroughly, use at own risk.  See an example of this script in a .bash_alias file here.If refs/heads/master can be fast-forwarded to refs/remotes/foo/master, the output ofshould return the SHA1 id that refs/heads/master points to. With this, you can put together a script that automatically updates all local branches that have had no diverting commits applied to them.This little shell script (I called it git-can-ff) illustrates how it can be done.If you\'re on Windows you can use PyGitUp which is a clone of git-up for Python. You can install it using pip with pip install --user git-up or through Scoop using scoop install git-up[To complete the answer by Matt Connolly, this is a safer way to update local branch references that can be fast-forwarded, without checking out the branch. It does not update branches that cannot be fast-forwarded (i.e. that have diverged), and it does not update the branch that is currently checked out (because then the working copy should be updated as well). The script from @larsmans, a bit improved:This, after it finishes, leaves working copy checked out from the same branch as it was before the script was called.The git pull version:Just posting an updated answer. git-up is no longer maintained and if you read the documentation, they mention the functionality is now available in git.As of Git 2.9, git pull --rebase --autostash does basically the same thing.Accordingly, if you update to Git 2.9 or later, you can use this alias instead of installing git-up:git config --global alias.up \'pull --rebase --autostash\'You can also set this for every git pull as of Git 2.9 as well (thanks @VonC please see his answer here)A slightly different script that only fast-forwards branches who\'s names matches their upstream branch. It also updates the current branch if fast-forward is possible.Make sure all your branches\' upstream branches are set correctly by running git branch -vv. Set the upstream branch with git branch -u origin/yourbanchnameCopy-paste into a file and chmod 755:It looks like many others have contributed similar solutions, but I thought I\'d share what I came up with and invite others to contribute.  This solution has a nice colorful output, gracefully handles your current working directory, and is fast because it doesn\'t do any checkouts, and leaves your working directory in tact.  Also, it is just a shell script with no dependencies other than git.  (only tested on OSX so far)https://github.com/davestimpert/gitupSorry I also seem to have come up with the same name as the other tool above.As of git 2.9:git pull --rebase --autostashSee https://git-scm.com/docs/git-rebaseAutomatically create a temporary stash before the operation begins,\n  and apply it after the operation ends. This means that you can run\n  rebase on a dirty worktree. However, use with care: the final stash\n  application after a successful rebase might result in non-trivial\n  conflicts.