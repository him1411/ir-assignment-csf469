I find that my constructors are starting to look like this:with ever increasing parameter list. Since "Container" is my dependency injection container, why can\'t I just do this:for every class? What are the downsides? If I do this, it feels like I\'m using a glorified static. Please share your thoughts on IoC and Dependency Injection madness.You are right that if you use the container as a Service Locator, it\'s more or less a glorified static factory. For lots of reasons I consider this an anti-pattern.One of the wonderful benefits of Constructor Injection is that it makes violations of the Single Responsibility Principle glaringly obvious.When that happens, it\'s time to refactor to Facade Services. In short, create a new, more coarse-grained interface that hides the interaction between some or all of the fine-grained dependencies you currently require.I don\'t think your class constructors should have a reference to your IOC container period. This represents an unnecessary dependency between your class and the container (the type of dependency IOC is trying to avoid!). The difficulty of passing in the parameters is not the problem.  The problem is that your class is doing too much, and should be broken down more.Dependency Injection can act as an early warning for classes getting too big, specifically because of the increasing pain of passing in all of the dependencies.I came across a similar question about constructor based dependency Injection and how complex it was getting to pass in all the dependencies.One of the approach, I have used in past is to use the application facade pattern using a service layer. This would have a coarse API. If this service depends on repositories, It would use a setter injection of the private properties. This requires creating an abstract factory and moving the logic of creating the repositories into a factory.Detailed code with explanation can be found hereBest practices for IoC in complex service layerThis is the approach I useHere is a crude approach how to perform the injections and run constructor after injecting values. This is fully functional program.I am currently working on a hobby project which works like this\nhttps://github.com/Jokine/ToolProject/tree/CoreProblem : 1) Constructor with ever increasing parameter list.2) If class is inherited (Ex: RepositoryBase) then changing constructor \nsignature causes change in the derived classes.Solution 1Pass IoC Container to constructor WhyWhy notSolution 2Create a class which groups all service and pass it to constructorDerived class WhyWhy notSolution 2 is just a raw though, if there is solid argument against it, then descriptive comment would be appreciatedWhat dependency injection framework are you using?  Have you tried using setter based injection instead?The benefit for constructor based injection is that it looks natural for Java programmers who don\'t use DI frameworks.  You need 5 things to initialize a class then you have 5 arguments for your constructor.  The downside is what you have noticed, it gets unwieldy when you have lots of dependencies.With Spring you could pass the required values with setters instead and you could use @required annotations to enforce that they are injected.  The downside is that you need to move the initialization code from the constructor to another method and have Spring call that after all the dependencies are injected by marking it with @PostConstruct.  I\'m not sure about other frameworks but I assume they do something similar.Both ways work, its a matter of preference.