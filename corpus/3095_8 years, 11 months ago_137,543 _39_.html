A little-used feature of C++ is the ability to create unnamed (anonymous) namespaces, like so:You would think that such a feature would be useless -- since you can\'t specify the name of the namespace, it\'s impossible to access anything within it from outside. But these unnamed namespaces are accessible within the file they\'re created in, as if you had an implicit using-clause to them.My question is, why or when would this be preferable to using static functions? Or are they essentially two ways of doing the exact same thing?The C++ Standard reads in section 7.3.1.1 Unnamed namespaces, paragraph 2:\nThe use of the static keyword is\n  deprecated when declaring objects in a\n  namespace scope, the unnamed-namespace\n  provides a superior alternative.\n  Static only applies to names of objects, functions, and anonymous unions, not to type declarations.Edit:The decision to deprecate this use of the static keyword (affect visibility of a variable declaration in a translation unit) has been reversed (ref).  In this case using a static or an unnamed namespace are back to being essentially two ways of doing the exact same thing.  For more discussion please see this SO question.Unnamed namespaces still have the advantage of allowing you to define translation-unit-local types.  Please see this SO question for more details.Credit goes to Mike Percy for bringing this to my attention.Putting methods in an anonymous namespace prevents you from accidentally violating the One Definition Rule, allowing you to never worry about naming your helper methods the same as some other method you may link in.And, as pointed out by luke, anonymous namespaces are preferred by the standard over static members.There is one edge case where static has a surprising affect (at least it was to me).  The C++03 Standard states in 14.6.4.2/1:For a function call that depends on a template parameter, if the function name is an unqualified-id but not a template-id, the candidate functions are found using the usual lookup rules (3.4.1, 3.4.2) except that:...The below code will call foo(void*) and not foo(S const &) as you might expect.In itself this is probably not that big a deal, but it does highlight that for a fully compliant C++ compiler (ie. one with support for export) the static keyword will still have functionality that is not available in any other way.The only way to ensure that the function in our unnamed namespace will not be found in templates using ADL is to make it static.Update for Modern C++As of C++ \'11, members of an unnamed namespace have internal linkage implicitly (3.5/4):An unnamed namespace or a namespace declared directly or indirectly within an unnamed namespace has internal linkage.But at the same time, 14.6.4.2/1 was updated to remove mention of linkage (this taken from C++ \'14):For a function call where the postfix-expression is a dependent name, the candidate functions are found using\n  the usual lookup rules (3.4.1, 3.4.2) except that:For the part of the lookup using unqualified name lookup (3.4.1), only function declarations from the template definition context are found.For the part of the lookup using associated namespaces (3.4.2), only function declarations found in either the template definition context or the template instantiation context are found.The result is that this particular difference between static and unnamed namespace members no longer exists.I recently began replacing static keywords with anonymous namespaces in my code but immediately ran into a problem where the variables in the namespace were no longer available for inspection in my debugger. I was using VC60, so I don\'t know if that is a non-issue with other debuggers. My workaround was to define a \'module\' namespace, where I gave it the name of my cpp file.For example, in my XmlUtil.cpp file, I define a namespace XmlUtil_I { ... } for all of my module variables and functions. That way I can apply the XmlUtil_I:: qualification  in the debugger to access the variables. In this case, the \'_I\' distinguishes it from a public namespace such as XmlUtil that I may want to use elsewhere.I suppose a potential disadvantage of this approach compared to a truly anonymous one is that someone could violate the desired static scope by using the namespace qualifier in other modules. I don\'t know if that is a major concern though.Use of static keyword for that purpose is deprecated by the C++98 standard. The problem with static is that it doesn\'t apply to type definition. It\'s also an overloaded keyword used in different ways in different contexts, so unnamed namespaces simplify things a bit.From experience I\'ll just note that while it is the C++ way to put formerly-static functions into the anonymous namespace, older compilers can sometimes have problems with this. I currently work with a few compilers for our target platforms, and the more modern Linux compiler is fine with placing functions into the anonymous namespace.But an older compiler running on Solaris, which we are wed to until an unspecified future release, will sometimes accept it, and other times flag it as an error. The error is not what worries me, it\'s what it might be doing when it accepts it. So until we go modern across the board, we are still using static (usually class-scoped) functions where we\'d prefer the anonymous namespace.Having learned of this feature only just now while reading your question, I can only speculate. This seems to provide several advantages over a file-level static variable:I\'d be interested in learning if anyone has used anonymous namespaces in real code.In addition if one uses static keyword on a variable like this example:It would not be seen in the mapping fileA compiler specific difference between anonymous namespaces and static functions can be seen compiling the following code.Compiling this code with VS 2017 (specifying the level 4 warning flag /W4 to enable warning C4505: unreferenced local function has been removed) and gcc 4.9 with the -Wunused-function or -Wall flag shows that VS 2017 will only produce a warning for the unused static function. gcc 4.9 and higher, as well as clang 3.3 and higher, will produce warnings for the unreferenced function in the namespace and also a warning for the unused static function.Live demo of gcc 4.9 and MSVC 2017