Does anyone know if there is a good equivalent to Java\'s Set collection in C#? I know that you can somewhat mimic a set using a Dictionary or a HashTable by populating but ignoring the values, but that\'s not a very elegant way. If you\'re using .NET 3.5, you can use HashSet<T>. It\'s true that .NET doesn\'t cater for sets as well as Java does though.The Wintellect PowerCollections may help too.The HashSet<T> data structure:The Framework Class Library\'s HashSet<T> data structure was introduced in the .NET Framework 3.5. A full list of its members can be found at the MSDN reference page for HashSet<T>.HashSet<T> is more or less modeled after a mathematical set, which means that:It may contain no duplicate values.Its elements are in no particular order; therefore the type does not implement the IList<T> interface, but the more basic ICollection<T>. As a consequence, elements inside a hash set cannot be randomly accessed through indices; they can only be iterated over through an enumerator.Certain set functions such as Union, Intersection, IsSubsetOf, IsSupersetOf are available. These can come in handy when working with multiple sets.Another difference between HashSet<T> and List<T> is that calling a hash set\'s Add(item) method returns a Boolean value: true if the item was added, and false otherwise (because it was already found in the set).Why not List<T>?Since a HashSet<T> is simply a collection of unique objects, you might wonder why it has to be a data structure. A normal List<T> could have the same behavior by checking if an object is found in the list before adding it.The short answer is speed. Searching through a normal List<T> gets very slow very fast as more elements are added. A HashSet<T> requires a structure design that will allow for fast searching and insertion speeds.Benchmarks:Let\'s compare the performance speed of a HashSet<T> vs. a List<T>.Each trial consisted of adding integers from 0 to 9,999 to each collection. However, mod 25 was applied to each integer. Mod 25 makes the maximum types of items 25. Since 10,000 elements were added, this forced 400 collisions to occur, giving the data structures a chance to use their searching algorithms. Times were measured 3 times after 10,000 trials and averaged out.Don\'t pay too much attention to the specific running times of the tests since they are dependent on my hardware, but look at how they compare to each other.Now let\'s make elements objects instead of primitive types. I wrote a quick Person class with three fields: Name, LastName, and ID. Since I did not include any specific way to compare objects, all the elements will be added without collisions. This time 1,000 Person objects were added to each collection for a single trial. The total times of 3 sets of 1,000 trials were averaged out.As you can see, the difference in running times becomes astronomical when using objects, making the HashSet<T> advantageous.Try HashSet:The HashSet(Of\xe2\x80\x82T) class provides high-performance set operations. A set is a collection that contains no duplicate elements, and whose elements are in no particular order...The capacity of a HashSet(Of\xe2\x80\x82T) object is the number of elements that the object can hold. A HashSet(Of\xe2\x80\x82T) object\'s capacity automatically increases as elements are added to the object.The HashSet(Of\xe2\x80\x82T) class is based on the model of mathematical sets and provides high-performance set operations similar to accessing the keys of the Dictionary(Of\xe2\x80\x82TKey,\xe2\x80\x82TValue) or Hashtable collections. In simple terms, the HashSet(Of\xe2\x80\x82T) class can be thought of as a Dictionary(Of\xe2\x80\x82TKey,\xe2\x80\x82TValue) collection without values.A HashSet(Of\xe2\x80\x82T) collection is not sorted and cannot contain duplicate elements...I use Iesi.Collections http://www.codeproject.com/KB/recipes/sets.aspxIt\'s used in lot of OSS projects, I first came across it in NHibernateI use a wrapper around a Dictionary<T, object>, storing nulls in the values. This gives O(1) add, lookup and remove on the keys, and to all intents and purposes acts like a set.Have a look at PowerCollections over at CodePlex. Apart from Set and OrderedSet it has a few other usefull collection types such as Deque, MultiDictionary, Bag, OrderedBag, OrderedDictionary and OrderedMultiDictionary.For more collections, there is also the C5 Generic Collection Library.If you\'re using .NET 4.0 or later:In the case where you need sorting then use SortedSet<T>. Otherwise if you don\'t, then use HashSet<T> since it\'s O(1) for search and manipulate operations. Whereas SortedSet<T> is O(log n) for search and manipulate operations.You could implement your own workable set implementation in a couple of hours.  I used this when I had to do it (sorry, I don\'t have the code handy): http://java.sun.com/j2se/1.4.2/docs/api/java/util/Set.htmlI know this is an old thread, but I was running into the same problem and found HashSet to be very unreliable because given the same seed, GetHashCode() returned different codes.  So, I thought, why not just use a List and hide the add method like thisBecause List uses the Equals method solely to determine equality, you can define the Equals method on your T type to make sure you get the desired results.