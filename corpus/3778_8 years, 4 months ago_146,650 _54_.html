I\'m trying to create a new object of type T via its constructor when adding to the list.I\'m getting a compile error: The error message is:\'T\': cannot provide arguments when creating an instance of a variableBut my classes do have a constructor argument! How can I make this work?In order to create an instance of a generic type in a function you must constrain it with the "new" flag.  However that will only work when you want to call the constructor which has no parameters.  Not the case here.  Instead you\'ll have to provide another parameter which allows for the creation of object based on parameters.  The easiest is a function.  You can then call it like soin .Net 3.5 and after you could use the activator class:Since nobody bothered to post the \'Reflection\' answer (which I personally think is the best answer), here goes:Edit: This answer is deprecated due to .NET 3.5\'s Activator.CreateInstance, however it is still useful in older .NET versions.Object initializerIf your constructor with the parameter isn\'t doing anything besides setting a property, you can do this in C# 3 or better using an object initializer rather than calling a constructor (which is impossible, as has been mentioned):Using this, you can always put any constructor logic in the default (empty) constructor, too.Activator.CreateInstance()Alternatively, you could call Activator.CreateInstance() like so:Note that Activator.CreateInstance can have some performance overhead that you may want to avoid if execution speed is a top priority and another option is maintainable to you.This will not work in your situation. You can only specify the constraint that it has an empty constructor:What you could do is use property injection by defining this interface:Then you could alter your method to be this:The other alternative is the Func method described by JaredPar.You need to add where T: new() to let the compiler know that T is guaranteed to provide a default constructor. Very old question, but new answer ;-)The ExpressionTree version: (I think the fastests and cleanest solution)Like Welly Tambunan said, "we could also use expression tree to build the object"This will generate a \'constructor\' (function) for the type/parameters given. It returns a delegate and accept the parameter types as an array of objects.Here it is:Example MyClass:Usage:Another example: passing the types as an arrayDebugView of ExpressionThis is equivalent to the code that is generated:Small downsideAll valuetypes parameters are boxed when they are passed like an object array.Simple performance test:Results:Using Expressions is +/- 8 times faster than Invoking the ConstructorInfo and +/- 20 times faster than using the ActivatorIf you simply want to initialise a member field or property with the constructor parameter, in C# >= 3 you can do it very easier:This is the same thing Garry Shutler said, but I\'d like to put an aditional note.Of course you can use a property trick to do more stuff than just setting a field value.\nA property "set()" can trigger any processing needed to setup its related fields and any other need for the object itself, including a check to see if a full initialization is to take place before the object is used, simulating a full contruction (yes, it is an ugly workaround, but it overcomes M$\'s new() limitation).I can\'t be assure if it is a planned hole or an accidental side effect, but it works.It is very funny how M$ people adds new features to the language and seems to not do a full side effects analysis.\nThe entire generic thing is a good evidence of this...I found that I was getting an error "cannot provide arguments when creating an instance of type parameter T" so I needed to do this:I sometimes use an approach that resembles to the answers using property injection, but keeps the code cleaner.\nInstead of having a base class/interface with a set of properties, it only contains a (virtual) Initialize()-method that acts as a "poor man\'s constructor".\nThen you can let each class handle it\'s own initialization just as a constructor would, which also adds a convinient way of handling inheritance chains.If often find myself in situations where I want each class in the chain to initialize its unique properties, and then call its parent\'s Initialize()-method which in turn initializes the parent\'s unique properties and so forth. This is especially useful when having different classes, but with a similar hierarchy, for example business objects that are mapped to/from DTO:s.Example that uses a common Dictionary for initialization:This is kind of mucky, and when I say kind of mucky I may mean revolting, but supposing you can furnish your parameterised type with an empty constructor, then:Will effectively allow you to construct an object from a parameterised type with an argument. In this case I am assuming the constructor I want has a single argument of type object. We create a dummy instance of T using the constraint permitted empty constructor and then use reflection to get one of its other constructors.If have access to the class you\'re going to use, you can use this approach which I used.Create an interface that has an alternative creator:Make your classes with an empty creator and implement this method:Now use your generic methods:I believe you have to constraint T with a where statement to only allow objects with a new constructor.RIght now it accepts anything including objects without it.