I have inserted records into a SQL Server database table. The table had a primary key defined and the auto increment identity seed is set to \xe2\x80\x9cYes\xe2\x80\x9d. This is done primarily because in SQL Azure, each table has to have a primary key and identity defined. But since I have to delete some records from the table, the identity seed for those tables will be disturbed and the index column (which is auto-generated with an increment of 1) will get disturbed.How can I reset the identity column after I deleted the records so that the column has sequence in ascending numerical order?The identity column is not used as a foreign key anywhere in database.The DBCC CHECKIDENT management command is used to reset identity counter. Example: It was not supported in a previous versions of Azure SQL Database, but is supported now.Where 0 is identity Start valueI tried @anil shahs answer and it reseted the identity. But when a new row was inserted it got the identity = 2. So instead I changed it the syntax to:Then the first row will get the identity = 1.It should be noted that IF all of the data is being removed from the table via the DELETE (i.e. no WHERE clause), then as long as a) permissions allow for it, and b) there are no FKs referencing the table (which appears to be the case here), using TRUNCATE TABLE would be preferred as it does a more efficient DELETE and resets the IDENTITY seed at the same time. The following details are taken from the MSDN page for TRUNCATE TABLE:Compared to the DELETE statement, TRUNCATE TABLE has the following advantages:Less transaction log space is used.The DELETE statement removes rows one at a time and records an entry in the transaction log for each deleted row. TRUNCATE TABLE removes the data by deallocating the data pages used to store the table data and records only the page deallocations in the transaction log.Fewer locks are typically used.When the DELETE statement is executed using a row lock, each row in the table is locked for deletion. TRUNCATE TABLE always locks the table (including a schema (SCH-M) lock) and page but not each row.Without exception, zero pages are left in the table.After a DELETE statement is executed, the table can still contain empty pages. For example, empty pages in a heap cannot be deallocated without at least an exclusive (LCK_M_X) table lock. If the delete operation does not use a table lock, the table (heap) will contain many empty pages. For indexes, the delete operation can leave empty pages behind, although these pages will be deallocated quickly by a background cleanup process.If the table contains an identity column, the counter for that column is reset to the seed value defined for the column. If no seed was defined, the default value 1 is used. To retain the identity counter, use DELETE instead.So the following:Becomes just:Please see the TRUNCATE TABLE documentation (linked above) for additional information on restrictions, etc.Although most answers are suggesting RESEED to 0, But many a times we  need to just reseed to next Id availableThis will check the table and reset to the next ID.Although most answers are suggesting RESEED to 0, and while some see this as a flaw for TRUNCATED tables, Microsoft has a solution that excludes the IDThis will check the table and reset to the next ID. This has been available since MS SQL 2005 to current.https://msdn.microsoft.com/en-us/library/ms176057.aspxTo explicitly supply a value for identity columnAfter, you have the gaps in the identity column filled, and if you wish SQL server to calculate the value, turn off Identity_Insert.=============================If you have deleted all the rows in a table, and you want to reset the identity column value.USe DBCC CHECKIDENT command.This command will reset PersonId identity column.This is a common question and the answer is always the same: don\'t do it. Identity values should be treated as arbitrary and, as such, there is no "correct" order.@jacobWorked for me, I just had to clear all entries first from the table, then added the above in a trigger point after delete. Now whenever i delete an entry is taken from there.issuing 2 command can do the trickthe first reset the identity to zero , and the next will set it to the next available value\n -- jacobRun this script to reset the identity column.  You will need to make two changes.  Replace tableXYZ with whatever table you need to update.  Also, the name of the identity column needs dropped from the temp table.  This was instantaneous on a table with 35,000 rows & 3 columns.  Obviously, backup the table and first try this in a test environment. Truncate table is preferred because it clears the records, resets the counter and reclaims the dis space. Delete and CheckIdent should be used only where foreign keys prevent you from truncatingThis will set the current identity value to 0.On inserting the next value, the identity value get incremented to 1.Reset identity column with new id...DECLARE @MAX INT\nSELECT @MAX=MAX(ISNULL(Id,0)) FROM [TestTable]DBCC CHECKIDENT (\'[TestTable]\', RESEED,@MAX)First : Identity Specification Just : "No" >> Save Database Execute ProjectAfter then : Identity Specification Just : "YES" >> Save Database Execute ProjectYour Database ID, PK Start from 1 >>Its always better to use  TRUNCATE when possible instead of deleting all records as it doesn\'t use log space also.In case we need delete and need to reset the seed, always remember that if table was never populated and you used DBCC CHECKIDENT(\'tablenem\',RESEED,0) \nthen first record will get identity = 0 \nas stated on  msdn documentationIn your case only rebuild the index and don\'t worry about losing the\n  series of identity as this is a common scenario.