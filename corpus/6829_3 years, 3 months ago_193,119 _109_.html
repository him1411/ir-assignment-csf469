I have not yet been able to figure out how to get a substring of a String in Swift:I\'m not able to create a Range in Swift. Autocomplete in the Playground isn\xe2\x80\x99t super helpful - this is what it suggests:I haven\'t found anything in the Swift Standard Reference Library that helps. Here was another wild guess:And this:I\'ve seen other answers (Finding index of character in Swift String) that seem to suggest that since String is a bridge type for NSString, the "old" methods should work, but it\'s not clear how - e.g., this doesn\'t work either (doesn\'t appear to be valid syntax):Thoughts?You can use the substringWithRange method. It takes a start and end String.Index.To change the start and end index, use advancedBy(n).You can also still use the NSString method with NSRange, but you have to make sure you are using an NSString like this:Note: as JanX2 mentioned, this second method is not safe with unicode strings.SimpleNOTE: @airspeedswift makes some very insightful points on the trade-offs of this approach, particularly the hidden performance impacts. Strings are not simple beasts, and getting to a particular index may take O(n) time, which means a loop that uses a subscript can be O(n^2). You have been warned.You just need to add a new subscript function that takes a range and uses advancedBy() to walk to where you want:(This should definitely be part of the language. Please dupe rdar://17158813)For fun, you can also add a + operator onto the indexes:(I don\'t know yet if this one should be part of the language or not.)At the time I\'m writing, no extension is perfectly Swift 3 compatible, so here is one that covers all the needs I could think of:And then, you can use:string.substring(from: 1, to: 7)gets you: ello,Wostring.substring(to: 7)gets you: Hello,Wostring.substring(from: 3)gets you: lo,World!string.substring(from: 1, length: 4)gets you: ellostring.substring(length: 4, to: 7)gets you: o,WoUpdated substring(from: Int?, length: Int) to support starting from zero.SWIFT 2.0simple:SWIFT 3.0SWIFT 4.0Substring operations return an instance of the Substring type, instead of String.It is much more simple than any of the answers here, once you find the right syntax.I want to take away the [ and ]result will be "ABCDEFGHI"\nthe startIndex and endIndex could also be used in and so on!PS: As indicated in the remarks, there are some syntax changes in swift 2 which comes with xcode 7 and iOS9!Please look at this page For example to find the first name (up to the first space) in my full name:start and end are of type String.Index here and are used to create a Range<String.Index> and used in the subscript accessor (if a space is found at all in the original string).It\'s hard to create a String.Index directly from an integer position as used in the opening post. This is because in my name each character would be of equal size in bytes. But characters using special accents in other languages could have used several more bytes (depending on the encoding used). So what byte should the integer refer to?It\'s possible to create a new String.Index from an existing one using the methods succ and pred which will make sure the correct number of bytes are skipped to get to the next code point in the encoding. However in this case it\'s easier to search for the index of the first space in the string to find the end index.Since String is a bridge type for NSString, the "old" methods should work, but it\'s not clear how - e.g., this doesn\'t work either (doesn\'t appear to be valid syntax):To me, that is the really interesting part of your question. String is bridged to NSString, so most NSString methods do work directly on a String. You can use them freely and without thinking. So, for example, this works just as you expect:But, as so often happens, "I got my mojo workin\' but it just don\'t work on you." You just happened to pick one of the rare cases where a parallel identically named Swift method exists, and in a case like that, the Swift method overshadows the Objective-C method. Thus, when you say str.substringWithRange, Swift thinks you mean the Swift method rather than the NSString method \xe2\x80\x94 and then you are hosed, because the Swift method expects a Range<String.Index>, and you don\'t know how to make one of those. The easy way out is to stop Swift from overshadowing like this, by casting explicitly:Note that no significant extra work is involved here. "Cast" does not mean "convert"; the String is effectively an NSString. We are just telling Swift how to look at this variable for purposes of this one line of code.The really weird part of this whole thing is that the Swift method, which causes all this trouble, is undocumented. I have no idea where it is defined; it is not in the NSString header and it\'s not in the Swift header either.The short answer is that this is really hard in Swift right now. My hunch is that there is still a bunch of work for Apple to do on convenience methods for things like this.String.substringWithRange() is expecting a Range<String.Index> parameter, and as far as I can tell there isn\'t a generator method for the String.Index type. You can get String.Index values back from aString.startIndex and aString.endIndex and call .succ() or .pred() on them, but that\'s madness.How about an extension on the String class that takes good old Ints?Update: Swift beta 4 resolves the issues below!As it stands [in beta 3 and earlier], even Swift-native strings have some issues with handling Unicode characters. The dog icon above worked, but the following doesn\'t:Output:In new Xcode 7.0 useYou can use this extensions to improve substringWithRangeSwift 2.3Swift 3Usage:Sample Code for how to get substring in Swift 2.0 (i) Substring from starting indexInput:-Output:-(ii) Substring from particular indexInput:- Output:-I hope it will help you!Updated for Xcode 7. Adds String extension:Use:Implementation:This works in my playground :) Easy solution with little code.Make an extension that includes basic subStringing that nearly all other languages have:Simply call this withtry this in playgroundit will give you "ello, p"However where this gets really interesting is that if you make the last index bigger than the string in playground it will show any strings that you defined after str :oRange() appears to be a generic function so that it needs to know the type it is dealing with.You also have to give it the actual string your interested in playgrounds as it seems to hold all stings in a sequence one after another with their variable name afterwards.Sogives "ello, playground\xef\xbf\xbdstr\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbdI\'m the next string\xef\xbf\xbdstr2\xef\xbf\xbd"works even if str2 is defined with a let:)Rob Napier had already given a awesome answer using subscript. But i felt one drawback in that as there is no check for out of bound conditions. This can tend to crash. So i modified the extension and here it isOutput belowSo i suggest always to check for the if letTaking a page from Rob Napier, I developed these Common String Extensions, two of which are:Usage:This is how you get a range from a string:The key point is that you are passing a range of values of type String.Index (this is what advance returns) instead of integers. The reason why this is necessary, is that strings in Swift don\'t have random access (because of variable length of Unicode characters basically). You also can\'t do str[1]. String.Index is designed to work with their internal structure. You can create an extension with a subscript though, that does this for you, so you can just pass a range of integers (see e.g. Rob Napier\'s answer). In Swift3For ex: a variable "Duke James Thomas", we need to get  "James".    First create the range, then the substring. You can use fromIndex..<toIndex syntax like so:here is a example to get video-Id only .i.e (6oL687G0Iso) from the whole URL in swiftI tried to come up with something Pythonic.All the subscripts here are great, but the times I really need something simple is usually when I want to count from back, e.g. string.endIndex.advancedBy(-1)It supports nil values, for both start and end index, where nil would mean index at 0 for start, string.characters.count for end.EDITA more elegant solution:http://www.learnswiftonline.com/reference-guides/string-reference-guide-for-swift/\nshows that this works well:Well, I had the same issue and solved with the "bridgeToObjectiveC()" function:Please note that in the example, substringWithRange in conjunction with NSMakeRange take the part of the string starting at index 6 (character "W") and finishing at index 6 + 6 positions ahead (character "!")Cheers.You can use any of the substring methods in a Swift String extension I wrote https://bit.ly/JString.If you have an NSRange, bridging to NSString works seamlessly. For example, I was doing some work with UITextFieldDelegate and I quickly wanted to compute the new string value when it asked if it should replace the range. Simple extension for String:Full sample you can see hereSwift 3.0I decided to have a little fun with this and produce an extension on String. I might not be using the word truncate properly in what I\'m having the function actually do.