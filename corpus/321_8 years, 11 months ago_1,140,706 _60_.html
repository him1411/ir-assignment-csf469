Using Bash, I have a string:How can I test if it contains another string?Where ?? is my unknown operator. Do I use echo and grep?That looks a bit clumsy.You can use Marcus\'s answer (* wildcards) outside a case statement, too, if you use double brackets:Note that spaces in the needle string need to be placed between double quotes, and the * wildcards should be outside.If you prefer the regex approach:I am not sure about using an if statement, but you can get a similar effect with a case statement:As there is already a lot of answers using Bash-specific features, there is a way working under poorer-featured shells, like busybox:In practice, this could give:This was tested under bash, dash, ksh and ash (busybox), and the result is always:As asked by @EeroAaltonen here is a version of same demo, tested under the same shells:Then:Notice: you have to escape or double enclose quotes and/or double quotes:This was tested under busybox, dash and, of course bash:That\'s all folks!Then now:... Or if the submitted string could be empty, as pointed by @Sjlver, the function would become:With empty strings: You should remember that shell scripting is less of a language and more of a collection of commands. Instinctively you think that this "language" requires you to follow an if with a [ or a [[. Both of those are just commands that return an exit status indicating success or failure (just like every other command). For that reason I\'d use grep, and not the [ command. Just do:Now that you are thinking of if as testing the exit status of the command that follows it (complete with semi-colon). Why not reconsider the source of the string you are testing?The -q option makes grep not output anything, as we only want the return code. <<< makes the shell expand the next word and use it as the input to the command, a one-line version of the << here document (I\'m not sure whether this is standard or a bashism).The accepted answer is best, but since there\'s more than one way to do it, here\'s another solution:${var/search/replace} is $var with the first instance of search replaced by replace, if it is found (it doesn\'t change $var).  If you try to replace foo by nothing, and the string has changed, then obviously foo was found.So there are lots of useful solutions to the question - but which is fastest / uses the least resource?Repeated tests using this frame:Replacing TEST each time:(doContain was in F. Houri\'s answer)And for giggles:So the simple substituion option predicatbly wins whether in an extended test or a case. The case is portable.Piping out to 100000 greps is predictably painful! The old rule about using external utilities without need holds true.This also works:And the negative test is:I suppose this style is a bit more classic -- less dependent upon features of Bash shell.The -- argument is pure POSIX paranoia, used to protected against input strings similar to options, such as --abc or -a.Note: In a tight loop this code will be much slower than using internal Bash shell features, as one (or two) separate processes will be created and connected via pipes.How about this:One is:This StackÂ Overflow answer was the only one to trap space and dash chars:As Paul mentioned in his performance comparison:This is POSIX compliant like the \'case "$string" in\' answer provided by Marcus, but is slightly easier to read than the case statement answer. Also note that this will be much much slower than using a case statement, as Paul pointed out, don\'t use it in a loop.grep -q is useful for this purpose.The same using awk:Output:Not FoundOutput:FoundOriginal source: http://unstableme.blogspot.com/2008/06/bash-search-letter-in-string-awk.htmlI like sed.Edit, Logic:Use sed to remove instance of substring from stringIf new string differs from old string, substring existsTry oobash it is an OO-style string library for bash 4. It has support for German umlauts. It is written in bash. Many functions are available: -base64Decode, -base64Encode, -capitalize, -center, -charAt, -concat, -contains, -count, -endsWith, -equals, -equalsIgnoreCase, -reverse, -hashCode, -indexOf, -isAlnum, -isAlpha, -isAscii, -isDigit, -isEmpty, -isHexDigit, -isLowerCase, -isSpace, -isPrintable, -isUpperCase, -isVisible, -lastIndexOf, -length, -matches, -replaceAll, -replaceFirst, -startsWith, -substring, -swapCase, -toLowerCase, -toString, -toUpperCase, -trim, and -zfill.Look at the contains example:oobash is available at Sourceforge.net.My .bash_profile and how I used grep \nif the PATH included my 2 bin dirs, don\'t append them I found to need this functionality quite frequently, so I\'m using a home-made shell function in my .bashrc like this which allows me to re-use it as often as I need to, with an easy to remember name:To test if $string1 (say, abc) is contained in $string2 (say, 123abcABC) I just need to run stringinstring "$string1" "$string2" and check for the return value, for exampleExact word match: