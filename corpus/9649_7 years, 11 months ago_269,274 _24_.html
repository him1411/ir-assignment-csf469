I have a C# application that has users login to it, and because the hashing algorithm is expensive, it takes a little while to do. How can I display the Wait/Busy Cursor (usually the hourglass) to the user to let them know the program is doing something?The project is in C#.You can use Cursor.Current.However, if the hashing operation is really lengthy (MSDN defines this as more than 2-7 seconds), you should probably use a visual feedback indicator other than the cursor to notify the user of the progress. For a more in-depth set of guidelines, see this article.Edit:\nAs @Am pointed out, you may need to call Application.DoEvents(); after Cursor.Current = Cursors.WaitCursor; to ensure that the hourglass is actually displayed. Actually, temporarily sets the Wait cursor, but doesn\xe2\x80\x99t ensure that the Wait cursor shows until the end of your operation. Other programs or controls within your program can easily reset the cursor back to the default arrow as in fact happens when you move mouse while operation is still running. A much better way to show the Wait cursor is to set the UseWaitCursor property in a form to true:This will display wait cursor for all controls on the form until you set this property to false.\nIf you want wait cursor to be shown on Application level you should use:Building on the previous, my preferred approach (since this is a frequently performed action) is to wrap the wait cursor code in an IDisposable helper class so it can be used with using() (one line of code), take optional parameters, run the code within, then clean up (restore cursor) afterwards.Usage:It is easier to use UseWaitCursor at the Form or Window level.\nA typical use case can look like below:For a better UI experience you should use Asynchrony from a different thread.My approach would be to make all the calculations in a background worker.Then change the cursor like this:And in the thread\'s finish event restore the cursor:Note, this can also be done for specific controls, so the cursor will be the hourglass only when the mouse is above them.OK so I created a static async method.  That disabled the control that launches the action and changes the application cursor.  It runs the action as a task and waits for to finish.  Control returns to the caller while it waits.  So the application remains responsive, even while the busy icon spins.Here\'s the code form the main formI had to use a separate logger for the dummy action (I am using Nlog) and my main logger is writing to the UI (a rich text box).   I wasn\'t able to get the busy cursor show only when over a particular container on the form (but I didn\'t try very hard.)  All controls have a UseWaitCursor property, but it doesn\'t seem have any effect on the controls I tried (maybe because they weren\'t on top?)Here\'s the main log, which shows things happening in the order we expect:With the class below you can make the suggestion of Donut "exception safe".the class CursorHandlerOkey,Other people\'s view are very clear, but I would like to do some added, as follow: