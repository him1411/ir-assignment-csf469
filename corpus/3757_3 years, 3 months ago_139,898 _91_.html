For example, how can I do something like:Resulting example:I made a utility function iterateEnum() for iterating cases for arbitrary enum types.Here is the example usage:outputs:But, this is only for debug or test purpose: This relies on several undocumented current(Swift1.1) compiler behaviors. So, use it at your own risk :)Here is the code:The underlying idea is:ADDED:Revised for Swift2 and implemented casting ideas from @Kametrixom\'s answerADDED:\nRevised for Swift3ADDED:\nRevised for Swift3.0.1This post is relevant here http://www.swift-studies.com/blog/2014/6/10/enumerating-enums-in-swiftEssentially the proposed solution isThe other solutions work but they all make assumptions of for example the number of possible ranks and suits, or what the first and last rank may be. True, the layout of a deck of cards probably isn\'t going to change much in the foreseeable future. In general, however, it\'s neater to write code which makes as little assumptions as possible. My solution:I\'ve added a raw type to the suit enum, so I can use Suit(rawValue:) to access the Suit cases:Below the implementation of Card\'s createDeck() method. init(rawValue:) is a failable initializer and returns an optional. By unwrapping and checking it\'s value in both while statements, there\'s no need to assume the number of Rank or Suit cases:Here is how to call the createDeck method:So I stumbled around in the bits and bytes and created an extension (that I later found out works very similar to @rintaro\'s answer). It\'s usable like this:Remarkable is that it\'s usable on any enum (without associated values). Note that this doesn\'t work for enums that have no cases.As with @rintaro\'s answer, this code uses the underlying representation of an enum. This representation isn\'t documented and might change in the future, which would break it -> I don\'t recommend the usage of this in production. EDIT: It\'s been about a year and this still works.(I have no idea why I need the typealias, but the compiler complains without it)(I made big modification to this answer, look at edits for past versions)You could iterate through an enum by implementing the ForwardIndexType protocol.The ForwardIndexType protocol requires you to define a successor() function to step through the elements.Iterating over an open or closed range (..< or ...) will internally call the successor() function which allows you to write this:In principle it is possible to do it this way assuming that you don\'t use raw values assignment for enum\'s cases:Updated to Swift 2.2+it\'s updated code to Swift 2.2 form @Kametrixom\'s answerFor Swift 3.0+ (many thanks to @Philip)If you give the enum a raw Int value it will make looping much easier.For example, you can use anyGenerator to get a generator that can enumerate across your values:However, this looks like a fairly common pattern, wouldn\'t it be nice if we could make any enum type enumerable by simply conforming to a protocol? Well with Swift 2.0 and protocol extensions, now we can!Simply add this to your project:Now any time you create an enum (so long as it has an Int raw value), you can make it enumerable by conforming to the protocol:If your enum values don\'t start with 0 (the default), override the firstRawValue method:The final Suit class, including replacing simpleDescription with the more standard CustomStringConvertible protocol, will look like this:EDIT:Swift 3 syntax:I like this solution which I put together after finding this page:\nList comprehension in Swift It uses Int raws instead of Strings but it avoids typing twice, it allows customizing the ranges, and doesn\'t hard code raw values.How about this?I found myself doing .allValues alot throughout my code. I finally figured out a way to simply conform to an Iteratable protocol and have an rawValues() method.This is what I ended up going with; I think it strikes the right balance of readability and maintainability.There are lots of good solutions in this thread and others however some of them are very complicated. I like to simplify as much as possible. Here is a solution which may or may not work for different needs but I think it works well in most cases: To iterate:Sorry, my answer was specific to how I used this post in what I needed to do.  For those who stumble upon this question, looking for a way to find a case within an enum, this is the way to do it (new in Swift 2):Edit: lowercase camelCase is now the standard for Swift 3 enum valuesFor those wondering about the enumerating on an enum, the answers given on this page that include a static var/let containing an array of all enum values are correct.  The latest Apple example code for tvOS contains this exact same technique.That being said, they should build a more convenient mechanism into the language (Apple, are you listening?)!Call it like this:Prints:[0, 1, 2, 3, 4]Call itPrints:["Salary", "Experience", "Technology", "Unutilized", "Unutilized High Value"]In Swift 3, when the underlying enum has {rawValue}s, you could implement the {Strideable} protocol.  The advantages are that no arrays of values are created like in some other suggestions, and that the standard Swift "for i in ..." statement works, which makes for nice syntax.Another solution: Enums have toRaw() and fromRaw() methods so if your raw value is an Int, you can iterate from the first to last enum:One gotcha is that you need to test for optional values before running the simpleDescription method, so we set convertedSuit to our value first and then set a constant to convertedSuit.simpleDescription()This seems like a hack but if you use raw values you can do something like thisI did it using computed property, which returns the array of all values (thanks to this post http://natecook.com/blog/2014/10/loopy-random-enum-ideas/). However it also uses int raw-values, but I don\'t need to repeat all members of enumeration in separate property. UPDATE Xcode 6.1 changed a bit a way how to get enum member using raw value, so I fixed listing. Also fixed small error with wrong first raw valueThe experiment was: \nEXPERIMENTAdd a method to Card that creates a full deck of cards, with one card of each combination of rank and suit.So without modifying or enhancing the given code other than adding the method (and without using stuff that hasn\'t been taught yet), I came up with this solution:Based on Rick answer: this is 5 times fasterHere\'s my suggested approach. It\'s not completely satisfactory (I\'m very new to Swift and OOP!) but maybe someone can refine it. The idea is to have each enum provide its own range information as .first and .last properties. It adds just two lines of code to each enum: still a bit hard-coded, but at least it\'s not duplicating the whole set. It does require modifying the Suit enum to be an Int like the Rank enum is, instead of untyped. Rather than echo the whole solution, here\'s the code I added to the Rank enum, somewhere after the case statements (Suit enum is similar):and the loop I used to build the deck as an array of String. (The problem definition did not state how the deck was to be structured.)It\'s unsatisfactory because the properties are associated to an element rather than to the enum. But it does add clarity to the \'for\' loops. I\'d like it to say Rank.first instead of Rank.Ace.first. It works (with any element), but it\'s ugly. Can someone show how to elevate that to the enum level?And to make it work, I lifted the createDeck method out of the Card struct... could not figure out how to get a [String] array returned from that struct, and that seems a bad place to put such a method anyway.While dealing with Swift 2.0 here is my suggestion:I have added the raw type to Suit enum then:As with @Kametrixom answer here I believe returning an array would be better than returning AnySequence, since you can have access to all of Array\'s goodies such as count, etc.Here\'s the re-write:This is yet another approach based on @Peymmankh\'s answer, adapted to Swift 3.I have used the below method, the assumption is that I know which is the last value in the Rank enum and all the ranks have incremental values after AceI prefer this way as it is clean and small, easy to understandThere is a clever way, and frustrating as it is it illustrates the difference between the two different kinds of enums.Try this:The deal is that an enum backed by numbers (raw values) is implicitly explicitly ordered, whereas an enum that isn\'t backed by numbers is explicitly implicitly unordered.E.g. when we give the enum values numbers, the language is cunning enough to figure out what order the numbers are in.\nIf on the other hand we don\'t give it any ordering, when we try to iterate over the values the language throws its hands up in the air and goes "yes, but which one do you want to go first???"Other languages which can do this (iterating over unordered enums) might be the same languages where everything is \'under the hood\' actually a map or dictionary, and you can iterate over the keys of a map, whether there\'s any logical ordering or not.So the trick is to provide it with something that is explicitly ordered, in this case instances of the suits in an array in the order we want.  As soon as you give it that, Swift is like "well why didn\'t you say so in the first place?"The other shorthand trick is to use the forcing operator on the fromRaw function.  This illustrates another \'gotcha\' about enums, that the range of possible values to pass in is often larger than the range of enums.  For instance if we said Rank.fromRaw(60) there wouldn\'t be a value returned, so we\'re using the optional feature of the language, and where we start using optionals, forcing will soon follow.  (Or alternately the if let construction which still seems a bit weird to me)It took me a little more then just one method in the struct like the swift book called for but i set up next functions in the enum. I would have used a protocol I\'m not sure why but having rank set as int messes it uphope this helps basically I used a little general knowledge but that can be easily rectified by multiplying suits by rank (if you aren\'t using a standard deck of cards and you\'d have to change the enums accordingly  and if basically just steps through the different enums note to save time I used ranks raw values you could do the same for suits if you wanted however the example did not have it so I decided to figure it out without changing suits raw valueSometimes, you may deal with an enumerated type with an underlying raw integer type that changes throughout the software development lifecycle.  Here is an example that works well for that case: