I have very large tables (30 million rows) that I would like to load as a dataframes in R.  read.table() has a lot of convenient features, but it seems like there is a lot of logic in the implementation that would slow things down.  In my case, I am assuming I know the types of the columns ahead of time, the table does not contain any column headers or row names, and does not have any pathological characters that I have to worry about.I know that reading in a table as a list using scan() can be quite fast, e.g.:But some of my attempts to convert this to a dataframe appear to decrease the performance of the above by a factor of 6:Is there a better way of doing this?  Or quite possibly completely different approach to the problem?An update, several years laterThis answer is old, and R has moved on.  Tweaking read.table to run a bit faster has precious little benefit.  Your options are:Using fread in data.table for importing data from csv/tab-delimited files directly into R. See mnel\'s answer.Using read_table in readr (on CRAN from April 2015).  This works much like fread above.  The readme in the link explains the difference between the two functions (readr currently claims to be "1.5-2x slower" than data.table::fread).read.csv.raw from iotools provides a third option for quickly reading CSV files.Trying to store as much data as you can in databases rather than flat files.  (As well as being a better permanent storage medium, data is passed to and from R in a binary format, which is faster.) read.csv.sql in the sqldf package, as described in JD Long\'s answer, imports data into a temporary SQLite database and then reads it into R.  See also: the RODBC package, and the reverse depends section of the DBI package page. MonetDB.R gives you a data type that pretends to be a data frame but is really a MonetDB underneath, increasing performance.  Import data with its monetdb.read.csv function.  dplyr allows you to work directly with data stored in several types of database.Storing data in binary formats can also be useful for improving performance.  Use saveRDS/readRDS (see below), or the h5 or rhdf5 packages for HDF5 format.The original answerThere are a couple of simple things to try, whether you use read.table or scan.Set nrows=the number of records in your data (nmax in scan).Make sure that comment.char="" to turn off interpretation of comments.Explicitly define the classes of each column using colClasses in read.table.Setting multi.line=FALSE may also improve performance in scan.If none of these thing work, then use one of the profiling packages to determine which lines are slowing things down.  Perhaps you can write a cut down version of read.table based on the results.The other alternative is filtering your data before you read it into R.Or, if the problem is that you have to read it in regularly, then use these methods to read the data in once, then save the data frame as a binary blob with save saveRDS, then next time you can retrieve it faster with load readRDS.Here is an example that utilizes fread from data.table 1.8.7The examples come from the help page to fread, with the timings on my windows XP Core 2 duo E8400.I didn\'t see this question initially and asked a similar question a few days later. I am going to take my previous question down, but I thought I\'d add an answer here to explain how I used sqldf() to do this.There\'s been little bit of discussion as to the best way to import 2GB or more of text data into an R data frame. Yesterday I wrote a blog post about using sqldf() to import the data into SQLite as a staging area, and then sucking it from SQLite into R. This works really well for me. I was able to pull in 2GB (3 columns, 40mm rows) of data in < 5 minutes. By contrast, the read.csv command ran all night and never completed. Here\'s my test code:Set up the test data:I restarted R before running the following import routine:I let the following line run all night but it never completed:Strangely, no one answered the bottom part of the question for years even though this is an important one -- data.frames are simply lists with the right attributes, so if you have large data you don\'t want to use as.data.frame or similar for a list. It\'s much faster to simply "turn" a list into a data frame in-place:This makes no copy of the data so it\'s immediate (unlike all other methods). It assumes that you have already set names() on the list accordingly.[As for loading large data into R -- personally, I dump them by column into binary files and use readBin() - that is by far the fastest method (other than mmapping) and is only limited by the disk speed. Parsing ASCII files is inherently slow (even in C) compared to binary data.]This was previously asked on R-Help, so that\'s worth reviewing.One suggestion there was to use readChar() and then do string manipulation on the result with strsplit() and substr().  You can see the logic involved in readChar is much less than read.table.I don\'t know if memory is an issue here, but you might also want to take a look at the HadoopStreaming package.  This uses Hadoop, which is a MapReduce framework designed for dealing with large data sets.  For this, you would use the hsTableReader function.  This is an example (but it has a learning curve to learn Hadoop):The basic idea here is to break the data import into chunks.  You could even go so far as to use one of the parallel frameworks (e.g. snow) and run the data import in parallel by segmenting the file, but most likely for large data sets that won\'t help since you will run into memory constraints, which is why map-reduce is a better approach.A minor additional points worth mentioning. If you have a very large file you can on the fly calculate the number of rows (if no header) using (where bedGraph is the name of your file in your working directory):You can then use that either in read.csv , read.table ...Often times I think it is just good practice to keep larger databases inside a database (e.g. Postgres). I don\'t use anything too much larger than (nrow * ncol) ncell = 10M, which is pretty small; but I often find I want R to create and hold memory intensive graphs only while I query from multiple databases. In the future of 32 GB laptops, some of these types of memory problems will disappear. But the allure of using a database to hold the data and then using R\'s memory for the resulting query results and graphs still may be useful. Some advantages are: (1) The data stays loaded in your database. You simply reconnect in pgadmin to the databases you want when you turn your laptop back on.(2) It is true R can do many more nifty statistical and graphing operations than SQL. But I think SQL is better designed to query large amounts of data than R.Instead of the conventional read.table I feel fread is a faster function. \nSpecifying additional attributes like select only the required columns, specifying colclasses and string as factors will reduce the time take to import the file.