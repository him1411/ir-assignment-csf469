What is the difference between doing:or:When is it a good idea to use calloc over malloc or vice versa?calloc() zero-initializes the buffer, while malloc() leaves the memory uninitialized.EDIT:Zeroing out the memory may take a little time, so you probably want to use malloc() if that performance is an issue.  If initializing the memory is more important, use calloc().  For example, calloc() might save you a call to memset().A less known difference is that in operating systems with optimistic memory allocation, like Linux, the pointer returned by malloc isn\'t backed by real memory until the program actually touches it.calloc does indeed touch the memory (it writes zeroes on it) and thus you\'ll be sure the OS is backing the allocation with actual RAM (or swap). This is also why it is slower than malloc (not only does it have to zero it, the OS must also find a suitable memory area by possibly swapping out other processes)See for instance this SO question for further discussion about the behavior of mallocOne often-overlooked advantage of calloc is that (conformant implementations of) it will help protect you against integer overflow vulnerabilities. Compare:vs.The former could result in a tiny allocation and subsequent buffer overflows, if count is greater than SIZE_MAX/sizeof *bar. The latter will automatically fail in this case since an object that large cannot be created.Of course you may have to be on the lookout for non-conformant implementations which simply ignore the possibility of overflow... If this is a concern on platforms you target, you\'ll have to do a manual test for overflow anyway.There\'s no difference in the size of the memory block allocated. calloc just fills the memory block with physical all-zero-bits pattern. In practice it is often assumed that the objects located in the memory block allocated with calloc have initilial value as if they were initialized with literal 0, i.e. integers should have value of 0, floating-point variables - value of 0.0, pointers - the appropriate null-pointer value, and so on.From the pedantic point of view though, calloc (as well as memset(..., 0, ...)) is only guaranteed to properly initialize (with zeroes) objects of type unsigned char. Everything else is not guaranteed to be properly initialized and may contain so called trap representation, which causes undefined behavior. In other words, for any type other than unsigned char the aforementioned all-zero-bits patterm might represent an illegal value, trap representation. Later, in one of the Technical Corrigenda to C99 standard, the behavior was defined for all integer types (which makes sense). I.e. formally, in the current C language you can initialize only integer types with calloc (and memset(..., 0, ...)). Using it to initialize anything else in general case leads to undefined behavior, from the point of view of C language.In practice, calloc works, as we all know :), but whether you\'d want to use it (considering the above) is up to you. I personally prefer to avoid it completely, use malloc instead and perform my own initialization.Finally, another important detail is that calloc is required to calculate the final block size internally, by multiplying element size by number of elements. While doing that, calloc must watch for possible arithmetic overflow. It will result in unsuccessful allocation (null pointer) if the requested block size cannot be correctly calculated. Meanwhile, your malloc version makes no attempt to watch for overflow. It will allocate some "unpredictable" amount of memory in case overflow happens.The documentation makes the calloc look like malloc, which just does zero-initialize the memory; this is not the primary difference! The idea of calloc is to abstact copy-on-write semantics for memory allocation. When you allocate memory with calloc it all maps to same physical page which is initialized to zero. When any of the pages of the allocated memory is written into a physical page is allocated. This is often used to make HUGE hash tables, for example since the parts of hash which are empty aren\'t backed by any extra memory (pages); they happily point to the single zero-initialized page, which can be even shared between processes.Any write to virtual address is mapped to a page, if that page is the zero-page, another physical page is allocated, the zero page is copied there and the control flow is returned to the client process. This works same way memory mapped files, virtual memory, etc. work.. it uses paging. Here is one optimization story about the topic:\nhttp://blogs.fau.de/hager/2007/05/08/benchmarking-fun-with-calloc-and-zero-pages/from an article Benchmarking fun with calloc() and zero pages on Georg Hager\'s Blog When allocating memory using calloc(), the amount of memory requested is not allocated right away. Instead, all pages that belong to the memory block are connected to a single page containing all zeroes by some MMU magic (links below). If such pages are only read (which was true for arrays b, c and d in the original version of the benchmark), the data is provided from the single zero page, which \xe2\x80\x93 of course \xe2\x80\x93 fits into cache. So much for memory-bound loop kernels. If a page gets written to (no matter how), a fault occurs, the \xe2\x80\x9creal\xe2\x80\x9d page is mapped and the zero page is copied to memory. This is called copy-on-write, a well-known optimization approach (that I even have taught multiple times in my C++ lectures). After that, the zero-read trick does not work any more for that page and this is why performance was so much lower after inserting the \xe2\x80\x93 supposedly redundant \xe2\x80\x93 init loop.calloc is generally malloc+memset to 0It is generally slightly better to use malloc+memset explicitly, especially when you are doing something like:That is better because sizeof(Item) is know to the compiler at compile time and the compiler will in most cases replace it with the best possible instructions to zero memory. On the other hand if memset is happening in calloc, the parameter size of the allocation is not compiled in in the calloc code and real memset is often called, which would typically contain code to do byte-by-byte fill up until long boundary, than cycle to fill up memory in sizeof(long) chunks and finally byte-by-byte fill up of the remaining space. Even if the allocator is smart enough to call some aligned_memset it will still be a generic loop.One notable exception would be when you are doing malloc/calloc of a very large chunk of memory (some power_of_two kilobytes) in which case allocation may be done directly from kernel. As OS kernels will typically zero out all memory they give away for security reasons, smart enough calloc might just return it withoud additional zeroing. Again - if you are just allocating something you know is small, you may be better off with malloc+memset performance-wise.malloc() allocates memory block of given size (in bytes) and returns a pointer to the beginning of the block.malloc() doesn\xe2\x80\x99t initialize the allocated memory.calloc() allocates the memory and also initializes the allocates memory to all bits zero.Difference 1:\nmalloc() usually allocates the memory block and it is initialized memory segment.\ncalloc() allocates the memory block and initialize all the memory block to 0. Difference 2:\nIf you consider malloc() syntax, it will take only 1 argument. Consider the following example below:ptr data_type = (cast_type *)malloc( sizeof(data_type)*no_of_blocks );Ex: If you want to allocate 10 block of memory for int type,If you consider calloc() syntax, it will take 2 arguments. Consider the following example below:ptr data_type = (cast_type *)calloc(no_of_blocks, (sizeof(data_type)));Ex: if you want to allocate 10 blocks of memory for int type and Initialize all that to ZERO,Similarity:Both malloc() and calloc() will return void* by default if they are not type casted .!There are two differences. \nFirst, is in the number of arguments. malloc() takes a single argument (memory required in bytes), while calloc() needs two arguments. \nSecondly, malloc() does not initialize the memory allocated, while calloc() initializes the allocated memory to ZERO. Syntax: ptr_var=(cast_type *)calloc(no_of_blocks , size_of_each_block);\ni.e. ptr_var=(type *)calloc(n,s);Syntax: ptr_var=(cast_type *)malloc(Size_in_bytes);\nThe malloc() function take one argument, which is the number of bytes to allocate, while the calloc() function takes two arguments, one being the number of elements, and the other being the number of bytes to allocate for each of those elements. Also, calloc() initializes the allocated space to zeroes, while malloc() does not.The calloc() function that is declared in the <stdlib.h> header offers a couple of advantages over the malloc() function.An difference not yet mentioned: size limitvoid *malloc(size_t size) can only allocate up to SIZE_MAX.void *calloc(size_t nmemb, size_t size); can allocate up about SIZE_MAX*SIZE_MAX.This ability is not often used in many platforms with linear addressing.  Such systems limit calloc() with nmemb * size <= SIZE_MAX.Consider a type of 512 bytes called disk_sector and code wants to use lots of sectors.  Here, code can only use up to SIZE_MAX/sizeof disk_sector sectors.Consider the following which allows an even larger allocation.Now if such a system can supply such a large allocation is another matter.  Yet it has occurred for many years when SIZE_MAX was 65535.  Given Moore\'s law, suspect this will be occurring again soon with certain memory models with SIZE_MAX == 4294967295 and memory pools in the 100 of GBytes.malloc():   Allocates requested size of bytes and returns a pointer first byte of allocated spacecalloc():   Allocates space for an array elements, initializes to zero and then returns a pointer to memoryThe major differences between malloc and calloc are:malloc takes only one argument, the size of the block whereas calloc takes two arguments, number of blocks to be allocated and size of each block.ptr = (cast-type*) malloc(byte-size)                         // mallocptr = (cast-type*)calloc(no of blocks, block-size);          // callocmalloc doesn\'t perform memory initialisation and all the addresses store garbage value whereas calloc performs memory initialisation and addresses are initialised to either Zero or Null values.The name malloc and calloc() are library functions that allocate memory dynamically. It means that memory is allocated during runtime(execution of the program) from heap segment.Initialization: malloc() allocates a memory block of given size (in bytes) and returns a pointer to the beginning of the block.A number of arguments: Unlike malloc(), calloc() takes two arguments:\n  1) A number of blocks to be allocated. 2) Size of each block.Most Important : It would be better to use malloc over calloc, unless we want the zero-initialization because malloc is faster than calloc. So if we\n  just want to copy some stuff or do something that doesn\xe2\x80\x99t require\n  filling of the blocks with zeros, then malloc would be a better\n  choice.The malloc() takes a single argument, while calloc() takess two. Second, malloc() does not initialize the memory allocated, while calloc() initializes the allocated memory to ZERO. Both malloc and calloc are used in C language for dynamic memory allocation they obtain blocks of memory dynamically.just allocates n bytes of memory without any initialization (ie; those memory bytes will contain any garbage values).However, calloc() method in c does the initialization to 0 for all the occupied memory bytes in addition to the function that malloc() does.