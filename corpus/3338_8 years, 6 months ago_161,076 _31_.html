I have below a command which will print the output of aaa.sh to the screen while also writing stdout to bbb.out; however I would also like to write stderr to a file named ccc.out.  Any suggestions on how to modify the piece below?Update: stdout and stderr should still both be printed to the screen, regardless.I\'m assuming you want to still see STDERR and STDOUT on the terminal.  You could go for Josh Kelley\'s answer, but I find keeping a tail around in the background which outputs your log file very hackish and cludgy.  Notice how you need to keep an exra FD and do cleanup afterward by killing it and technically should be doing that in a trap \'...\' EXIT.There is a better way to do this, and you\'ve already discovered it: tee.Only, instead of just using it for your stdout, have a tee for stdout and one for stderr.  How will you accomplish this?  Process substitution and file redirection:Let\'s split it up and explain:>(...) (process substitution) creates a FIFO and lets tee listen on it.  Then, it uses > (file redirection) to redirect the STDOUT of command to the FIFO that your first tee is listening on.Same thing for the second:We use process substitution again to make a tee process that reads from STDIN and dumps it into stderr.log.  tee outputs its input back on STDOUT, but since its input is our STDERR, we want to redirect tee\'s STDOUT to our STDERR again.  Then we use file redirection to redirect command\'s STDERR to the FIFO\'s input (tee\'s STDIN).See http://mywiki.wooledge.org/BashGuide/InputAndOutputProcess substitution is one of those really lovely things you get as a bonus of choosing bash as your shell as opposed to sh (POSIX or Bourne).In sh, you\'d have to do things manually:why not simply:This simply redirects stderr to stdout, so tee echoes both to log and to screen.  Maybe I\'m missing something, because some of the other solutions seem really complicated.Note: Since bash version 4 you may use |& as an abbreviation for 2>&1 |:This may be useful for people finding this via google.  Simply uncomment the example you want to try out.  Of course, feel free to rename the output files.To redirect stderr to a file, display stdout to screen, and also save stdout to a file:EDIT:  To display both stderr and stdout to screen and also save both to a file, you can use bash\'s I/O redirection:In other words, you want to pipe stdout into one filter (tee bbb.out) and stderr into another filter (tee ccc.out). There is no standard way to pipe anything other than stdout into another command, but you can work around that by juggling file descriptors.See also How to grep standard error stream (stderr)? and When would you use an additional file descriptor?In bash (and ksh and zsh), but not in other POSIX shells such as dash, you can use process substitution:Beware that in bash, this command returns as soon as ./aaa.sh finishes, even if the tee commands are still executed (ksh and zsh do wait for the subprocesses). This may be a problem if you do something like ./aaa.sh > >(tee bbb.out) 2> >(tee ccc.out); process_logs bbb.out ccc.out. In that case, use file descriptor juggling or ksh/zsh instead.If using bash:Credit (not answering from the top of my head) goes here: http://www.cygwin.com/ml/cygwin/2003-06/msg00772.htmlIn my case, a script was running command while redirecting both stdout and stderr to a file, something like:I needed to update it such that when there is a failure, take some actions based on the error messages. I could of course remove the dup 2>&1 and capture the stderr from the script, but then the error messages won\'t go into the log file for reference. While the accepted answer from @lhunath is supposed to do the same, it redirects stdout and stderr to different files, which is not what I want, but it helped me to come up with the exact solution that I need:With the above, log will have a copy of both stdout and stderr and I can capture stderr from my script without having to worry about stdout.The following will work for KornShell(ksh) where the process substitution is not available,The real trick here, is the sequence of the 2>&1 1>&3 which in our case redirects the stderr to stdout and redirects the stdout to descriptor 3. At this point the stderr and stdout are not combined yet.In effect, the stderr(as stdin) is passed to tee where it logs to stderr.log and also redirects to descriptor 3.And descriptor 3 is logging it to combined.log all the time. So the combined.log contains both stdout and stderr.