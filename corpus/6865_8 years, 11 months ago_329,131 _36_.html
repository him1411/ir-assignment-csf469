Shouldn\'t this be a pretty straightforward operation? However, I see there\'s neither a size() nor length() method.resultSet.last() followed by resultSet.getRow() will give you the row count, but it may not be a good idea as it can mean reading the entire table over the network and throwing away the data.  Do a SELECT COUNT(*) FROM ... query instead.Well, if you have a ResultSet of type ResultSet.TYPE_FORWARD_ONLY you want to keep it that way (and not to switch to a ResultSet.TYPE_SCROLL_INSENSITIVE or ResultSet.TYPE_SCROLL_INSENSITIVE in order to be able to use .last()).I suggest a very nice and efficient hack, where you add a first bogus/phony row at the top containing the number of rows.ExampleLet\'s say your query is the followingand your output looks likeSimply refactor your code to something like this:Your query output will now be something likeSo you just have toI got an exception when using rs.last():it\'s due to by default it is ResultSet.TYPE_FORWARD_ONLY, which means you can only use rs.next()the solution is:It is a simple way to do rows-count.    The way of getting size of ResultSet, No need of using ArrayList etcNow You will get size, And if you want print the ResultSet, before printing use following line of code too,I checked the runtime value of the ResultSet interface and found out it was pretty much a ResultSetImpl all the time. ResultSetImpl has a method called getUpdateCount() which returns the value you are looking for.This code sample should suffice:\nResultSet resultSet = executeQuery(sqlQuery);\ndouble rowCount = ((ResultSetImpl)resultSet).getUpdateCount()I realize that downcasting is generally an unsafe procedure but this method hasn\'t yet failed me.[Speed consideration]Lot of ppl here suggests ResultSet.last() but for that you would need to open connection as a ResultSet.TYPE_SCROLL_INSENSITIVE which for Derby embedded database is up to 10 times SLOWER than ResultSet.TYPE_FORWARD_ONLY.According to my micro-tests for embedded Derby and H2 databases it is significantly faster to call SELECT COUNT(*) before your SELECT. Here is in more detail my code and my benchmarksI was having the same problem. Using ResultSet.first() in this way just after the execution solved it:Documentation (link):Moves the cursor to the first row in this ResultSet object. Returns: true if the cursor is on a valid\n  row; false if there are no rows in the result set Throws: SQLException - if a database access error occurs; this method is called on a closed result set or the result set type is TYPE_FORWARD_ONLYSQLFeatureNotSupportedException - if the JDBC driver does not support\n  this method Since:1.2Similar to Garret\'s method,Nice and simple, and we don\'t have a potentially giant integer being generated.  This of course assumes we want to iterate over our result set.  If we don\'t want to iterate over it, then doing a count should suffice.