If you\'ve got a string, and you expect it to always be an integer (say, if some web service is handing you an integer in string format), you\'d use Int32.Parse().  If you\'re collecting input from a user, you\'d generally use Int32.TryParse(), since it allows you more fine-grained control over the situation when the user enters in invalid input. Convert.ToInt32() takes an object as its argument.  (See Chris S\'s answer for how it works)Convert.ToInt32() also does not throw ArgumentNullException when it\'s argument is null the way Int32.Parse() does. That also means that Convert.ToInt32() is probably a wee bit slower than Int32.Parse(), though in practice, unless you\'re doing a very large number of iterations in a loop, you\'ll never notice it.Have a look in reflector:int.Parse("32"):which is a call to:Convert.ToInt32("32"):As the first (Dave M\'s) comment says.No difference as such.\nConvert.ToInt32() calls int.Parse() internallyExcept for one thing Convert.ToInt32() returns 0 when argument is nullOtherwise both work the same wayThe difference is this:Int32.Parse() and Int32.TryParse() can only convert strings. Convert.ToInt32() can take any class that implements IConvertible. If you pass it a string, then they are equivalent, except that you get extra overhead for type comparisons, etc. If you are converting strings, then TryParse() is probably the better option.Try this code below.....TryParse is faster...The first of these functions, Parse, is one that should be familiar to\n  any .Net developer. This function will take a string and attempt to\n  extract an integer out of it and then return the integer. If it runs\n  into something that it can\xe2\x80\x99t parse then it throws a FormatException or\n  if the number is too large an OverflowException. Also, it can throw an\n  ArgumentException if you pass it a null value.TryParse is a new addition to the new .Net 2.0 framework that addresses some issues with the original Parse function. The main\n  difference is that exception handling is very slow, so if TryParse is\n  unable to parse the string it does not throw an exception like Parse\n  does. Instead, it returns a Boolean indicating if it was able to\n  successfully parse a number. So you have to pass into TryParse both\n  the string to be parsed and an Int32 out parameter to fill in. We will\n  use the profiler to examine the speed difference between TryParse and\n  Parse in both cases where the string can be correctly parsed and in\n  cases where the string cannot be correctly parsed.The Convert class contains a series of functions to convert one base class into another. I believe that\n  Convert.ToInt32(string) just checks for a null string (if the string\n  is null it returns zero unlike the Parse) then just calls\n  Int32.Parse(string). I\xe2\x80\x99ll use the profiler to confirm this and to see\n  if using Convert as opposed to Parse has any real effect on\n  performance.Source with examplesHope this helps.Int32.parse(string)--->Int32.Parse (string s) method converts the string representation of a number to its 32-bit signed integer equivalent. When s is a null reference, it will throw ArgumentNullException. If s is other than integer value, it will throw FormatException. When s represents a number less than MinValue or greater than MaxValue, it will throw OverflowException. For example:Convert.ToInt32(string) -->\nConvert.ToInt32(string s) method converts the specified string representation of 32-bit signed integer equivalent. This calls in turn Int32.Parse () method. When s is a null reference, it will return 0 rather than throw ArgumentNullException. If s is other than integer value, it will throw FormatException. When s represents a number less than MinValue or greater than MaxValue, it will throw OverflowException.For example:has 19 overloads or 19 different ways that you can call it. Maybe more in 2010 versions.It will attempt to convert from the following TYPES;Object, Boolean, Char, SByte, Byte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Decimal, String, Dateand it also has a number of other methods; one to do with a number base and 2 methods involve a System.IFormatProviderParse on the other hand only has 4 overloads or 4 different ways you can call the method.It depends on the parameter type.  For example, I just discovered today that it will convert a char directly to int using its ASCII value.  Not exactly the functionality I intended...YOU HAVE BEEN WARNED!Convert.ToInt32 allows null value, it doesn\'t throw any errors\nInt.parse does not allow null value, it throws an ArgumentNullException error.for clarification open console application, just copy below code and paste it in  static void Main(string[] args) method, I hope you can  understand   