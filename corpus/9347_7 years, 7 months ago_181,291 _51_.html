I want to run a thread for some fixed amount of time. If it is not completed within that time, I want to either kill it, throw some exception, or handle it in some way. How can it be done?One way of doing it as I figured out from this thread\nis to use a TimerTask inside the run() method of the Thread.Are there any better solutions for this? \nEDIT: Adding a bounty as I needed a clearer answer. The ExecutorService code given below does not address my problem. Why should I sleep() after executing (some code - I have no handle over this piece of code)? If the code is completed and the sleep() is interrupted, how can that be a timeOut?The task that needs to be executed is not in my control. It can be any piece of code. The problem is this piece of code might run into an infinite loop. I don\'t want that to happen. So, I just want to run that task in a separate thread. The parent thread has to wait till that thread finishes and needs to know the status of the task (i.e whether it timed out or some exception occured or if its a success). If the task goes into an infinite loop, my parent thread keeps on waiting indefinitely, which is not an ideal situation.Indeed rather use ExecutorService instead of Timer, here\'s an SSCCE:Play a bit with the timeout argument in Future#get() method, e.g. increase it to 5 and you\'ll see that the thread finishes. You can intercept the timeout in the catch (TimeoutException e) block.Update: to clarify a conceptual misunderstanding, the sleep() is not required. It is just used for SSCCE/demonstration purposes. Just do your long running task right there in place of sleep(). Inside your long running task, you should be checking if the thread is not interrupted as follows:There isn\'t a 100% reliable way to do this for any old task. The task has to be written with this ability in mind.Core Java libraries like ExecutorService cancel asynchronous tasks with interrupt() calls on the worker thread. So, for example, if the task contains some sort of loop, you should be checking its interrupt status on each iteration. If the task is doing I/O operations, they should be interruptible too—and setting that up can be tricky. In any case, keep in mind that code has to actively check for interrupts; setting an interrupt doesn\'t necessarily do anything.Of course, if your task is some simple loop, you can just check the current time at each iteration and give up when a specified timeout has elapsed. A worker thread isn\'t needed in that case.Consider using an instance of ExecutorService.  Both invokeAll() and invokeAny() methods are available with a timeout parameter.  The current thread will block until the method completes (not sure if this is desirable) either because the task(s) completed normally or the timeout was reached.  You can inspect the returned Future(s) to determine what happened.Assuming the thread code is out of your control:From the Java documentation mentioned above:What if a thread doesn\'t respond to Thread.interrupt?In some cases, you can use application specific tricks. For example,\n  if a thread is waiting on a known socket, you can close the socket to\n  cause the thread to return immediately. Unfortunately, there really\n  isn\'t any technique that works in general. It should be noted that in\n  all situations where a waiting thread doesn\'t respond to\n  Thread.interrupt, it wouldn\'t respond to Thread.stop either. Such\n  cases include deliberate denial-of-service attacks, and I/O operations\n  for which thread.stop and thread.interrupt do not work properly.Bottom Line:Make sure all threads can be interrupted, or else you need specific knowledge of the thread - like having a flag to set. Maybe you can require that the task be given to you along with the code needed to stop it - define an interface with a stop() method. You can also warn when you failed to stop a task.BalusC said:Update: to clarify a conceptual misunderstanding, the sleep() is not required. It is just used for SSCCE/demonstration purposes. Just do your long running task right there in place of sleep().But if you replace Thread.sleep(4000); with for (int i = 0; i < 5E8; i++) {} then it doesn\'t compile, because the empty loop doesn\'t throw an InterruptedException.And for the thread to be interruptible, it needs to throw an InterruptedException. This seems like a serious problem to me. I can\'t see how to adapt this answer to work with a general long-running task. Edited to add: I reasked this as a new question: [ interrupting a thread after fixed time, does it have to throw InterruptedException? ]I think you should take a look at proper concurrency handling mechanisms (threads running into infinite loops doesn\'t sound good per se, btw). Make sure you read a little about the "killing" or "stopping" Threads topic.What you are describing,sound very much like a "rendezvous", so you may want to take a look at the CyclicBarrier.There may be other constructs (like using CountDownLatch for example) that can resolve your problem (one thread waiting with a timeout for the latch, the other should count down the latch if it has done it\'s work, which would release your first thread either after a timeout or when the latch countdown is invoked).I usually recommend two books in this area: Concurrent Programming in Java and Java Concurrency in Practice.I created a helper class just for this some time ago. Works great: It is called like this:I post you a piece of code which show a way how to solve the problem.\nAs exemple I\'m reading a file.\nYou could use this method for another operation, but you need to implements the kill() method so that the main operation will be interrupted.hope it helpsRegardsThe following snippet will start an operation in a separate thread, then wait for up to 10 seconds for the operation to complete. If the operation does not complete in time, the code will attempt to cancel the operation, then continue on its merry way. Even if the operation cannot be cancelled easily, the parent thread will not wait for the child thread to terminate.The getExecutorService() method can be implemented in a number of ways. If you do not have any particular requirements, you can simply call Executors.newCachedThreadPool() for thread pooling with no upper limit on the number of threads.One thing that I\'ve not seen mentioned is that killing threads is generally a Bad Idea.  There are techniques for making threaded methods cleanly abortable, but that\'s different to just killing a thread after a timeout.The risk with what you\'re suggesting is that you probably don\'t know what state the thread will be in when you kill it - so you risk introducing instability. A better solution is to make sure your threaded code either doesn\'t hang itself, or will respond nicely to an abort request.I think the answer mainly depends on the task itself.If the first answer is yes and the second is no, you could keep it as simple as this:If this isn\'t an option, please narrow your requirements - or show some code.Here is my really simple to use helper class to run or call piece of Java code :-)This is based on the excellent answer from BalusC Great answer by BalusC\'s:   but Just to add that the timeout itself does not interrupt the thread itself. even if you are checking with while(!Thread.interrupted()) in your task. if you want to make sure thread is stopped you should also make sure future.cancel() is invoked when timeout exception is catch.I was looking for an ExecutorService that can interrupt all timed out Runnables executed by it, but found none. After a few hours I created one as below. This class can be modified to enhance robustness.Usage:Now , l meet a issue like this. It happens to decode picture. The process of decode takes too much time that the screen keep black. l add a time controler: when the time is too long, then pop up from the current Thread.\nThe following is the diff:I had the same problem. So i came up with a simple solution like this. Guarantees that if block didn\'t execute within the time limit. the process will terminate and throws an exception.example :