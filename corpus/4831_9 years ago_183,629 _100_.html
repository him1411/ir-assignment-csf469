Is there an easier way to step through the code than to start the service through the Windows Service Control Manager and then attaching the debugger to the thread? It\'s kind of cumbersome and I\'m wondering if there is a more straightforward approach.If I want to quickly debug the service, I just drop in a Debugger.Break() in there. When that line is reached, it will drop me back to VS. Don\'t forget to remove that line when you are done.UPDATE: As an alternative to #if DEBUG pragmas, you can also use Conditional("DEBUG_SERVICE") attribute.On your OnStart, just call this method:There, the code will only be enabled during Debug builds. While your at it, it might be useful to create a separate Build Configuration for service debugging.I also think having a separate "version" for normal execution and as a service is the way to go, but is it really required to dedicate a separate command line switch for that purpose?Couldn\'t you just do:That would have the "benefit", that you can just start your app via doubleclick (OK, if you really need that) and that you can just hit F5 in Visual Studio (without the need to modify the project settings to include that /console Option).Technically, the Environment.UserInteractive checks if the WSF_VISIBLE Flag is set for the current window station, but is there any other reason where it would return false, apart from being run as a (non-interactive) service?When I set up a new service project a few weeks ago I found this post. While there are many great suggestions, I still didn\'t find the solution I wanted: The possibility to call the service classes\' OnStart and OnStop methods without any modification to the service classes.The solution I came up with uses the Environment.Interactive the select running mode, as suggested by other answers to this post.The RunInteractive helper uses reflection to call the protected OnStart and OnStop methods:This is all the code required, but I also wrote walkthrough with explanations.What I usually do is encapsulate the logic of the service in a separate class and start that from a \'runner\' class. This runner class can be the actual service or just a console application. So your solution has (atleast) 3 projects:Sometimes it is important to analyze what\'s going on during the start up of the service. Attaching to the process does not help here, because you are not quick enough to attach the debugger while the service is starting up.The short answer is, I am using the following 4 lines of code to do this:These are inserted into the OnStart method of the service as follows:For those who haven\'t done it before, I have included detailed hints below, because you can easily get stuck. The following hints refer to Windows 7x64 and Visual Studio 2010 Team Edition, but should be valid for other environments, too. Important: Deploy the service in "manual" mode (using either the InstallUtil utility from the VS command prompt or run a service installer project you have prepared). Open Visual Studio before you start the service and load the solution containing the service\'s source code - set up additional breakpoints as you require them in Visual Studio - then start the service via the Service Control Panel.Because of the Debugger.Launch code, this will cause a dialog "An unhandled Microsoft .NET Framework exception occured in Servicename.exe." to appear. Click  Yes, debug Servicename.exe as shown in the screenshot: \nAfterwards, escpecially in Windows 7 UAC might prompt you to enter admin credentials. Enter them and proceed with Yes:After that, the well known Visual Studio Just-In-Time Debugger window appears. It asks you if you want to debug using the delected debugger. Before you click Yes, select that you don\'t want to open a new instance (2nd option) - a new instance would not be helpful here, because the source code wouldn\'t be displayed. So you select the Visual Studio instance you\'ve opened earlier instead:\nAfter you have clicked Yes, after a while Visual Studio will show the yellow arrow right in the line where the Debugger.Launch statement is and you are able to debug your code (method MyInitOnStart, which contains your initialization). \nPressing F5 continues execution immediately, until the next breakpoint you have prepared is reached.Hint: To keep the service running, select Debug -> Detach all. This allows you to run a client communicating with the service after it started up correctly and you\'re finished debugging the startup code. If you press Shift+F5 (stop debugging), this will terminate the service. Instead of doing this, you should use the Service Control Panel to stop it.Note that If you build a Release, then the debug code is automatically removed and the service runs normally.I am using Debugger.Launch(), which starts and attaches a debugger. I have tested Debugger.Break() as well, which did not work, because there is no debugger attached on start up of the service yet (causing the "Error 1067: The process terminated unexpectedly.").RequestAdditionalTime sets a longer timeout for the startup of the service (it is not delaying the code itself, but will immediately continue with the Debugger.Launch statement). Otherwise the default timeout for starting the service is too short and starting the service fails if you don\'t call base.Onstart(args) quickly enough from the debugger. Practically, a timeout of 10 minutes avoids that you see the message "the service did not respond..." immediately after the debugger is started.Once you get used to it, this method is very easy because it just requires you to add 4 lines to an existing service code, allowing you quickly to gain control and debug.This YouTube video by Fabio Scopel explains how to debug a Windows service quite nicely... the actual method of doing it starts at 4:45 in the video...Here is the code explained in the video... in your Program.cs file, add the stuff for the Debug section... In your Service1.cs file, add the OnDebug() method...UPDATEThis approach is by far the easiest:http://www.codeproject.com/KB/dotnet/DebugWinServices.aspxI leave my original answer below for posterity.My services tend to have a class that encapsulates a Timer as I want the service to check at regular intervals whether there is any work for it to do.We new up the class and call StartEventLoop() during the service start-up. (This class could easily be used from a console app too.)The nice side-effect of this design is that the arguments with which you set up the Timer can be used to have a delay before the service actually starts working, so that you have time to attach a debugger manually.p.s. How to attach the debugger manually to a running process...?Also I used to do the following (already mentioned in previous answers but with the conditional compiler [#if] flags to help avoid it firing in a Release build).I stopped doing it this way because sometimes we\'d forget to build in Release and have a debugger break in an app running on a client demo (embarrasing!).You can also start the service through the command prompt (sc.exe).Personally, I\'d run the code as a stand-alone program in the debugging phase, and when most bugs are ironed out, change to running as service.What I used to do was to have a command line switch which would start the program either as a service or as a regular application. Then, in my IDE I would set the switch so that I could step through my code.With some languages you can actually detect if it\'s running in an IDE, and perform this switch automatically.What language are you using?I think it depends on what OS you are using, Vista is much harder to attach to Services, because of the separation between sessions.The two options I\'ve used in the past are:Hope this helps.When I write a service I put all the service logic in a dll project and create two "hosts" that call into this dll, one is a Windows service and the other is a command line application.I use the command line application for debugging and attach the debugger to the real service only for bugs I can\'t reproduce in the command line application.I you use this approach just remember that you have to test all the code while running in a real service, while the command line tool is a nice debugging aid it\'s a different environment and it doesn\'t behave exactly like a real service.When developing and debugging a Windows service I typically run it as a console application by adding a /console startup parameter and checking this. Makes life much easier.How about Debugger.Break() in the first line?I like to be able to debug every aspect of my service, including any initialization in OnStart(), while still executing it with full service behavior within the framework of the SCM... no "console" or "app" mode. I do this by creating a second service, in the same project, to use for debugging. The debug service, when started as usual (i.e. in the services MMC plugin), creates the service host process. This gives you a process to attach the debugger to even though you haven\'t started your real service yet. After attaching the debugger to the process, start your real service and you can break into it anywhere in the service lifecycle, including OnStart().Because it requires very minimal code intrusion, the debug service can easily be included in your service setup project, and is easily removed from your production release by commenting out a single line of code and deleting a single project installer.Details:1) Assuming you are implementing MyService, also create MyServiceDebug. Add both to the ServiceBase array in Program.cs like so:2) Add the real service AND the debug service to the project installer for the service project:Both services (real and debug) get included when you add the service project output to the setup project for the service. After installation, both services will appear in the service.msc MMC plugin.3) Start the debug service in MMC.4) In Visual Studio, attach the debugger to the process started by the debug service.5) Start the real service and enjoy debugging.Use the TopShelf library.Create a console application then configure setup in your MainTo debug your service, just hit F5 in visual studio.To install service, type in cmd "console.exe install"You can then start and stop service in the windows service manager.To debug Windows Services I combine GFlags and a .reg file created by regedit.Or save the following snippets and replace servicename.exe with the desired executable name.debugon.reg:debugoff.reg:For routine small-stuff programming I\'ve done a very simple trick to easily debug my service:On start of the service, I check for a command line parameter "/debug". If the service is called with this parameter, I don\'t do the usual service startup, but instead start all the listeners and just display a messagebox "Debug in progress, press ok to end".So if my service is started the usual way, it will start as service, if it is started with the command line parameter /debug it will act like a normal program.In VS I\'ll just add /debug as debugging parameter and start the service program directly.This way I can easily debug for most small kind problems. Of course, some stuff still will need to be debugged as service, but for 99% this is good enough.I use a variation on JOP\'s answer. Using command line parameters you can set the debugging mode in the IDE with project properties or through the Windows service manager.This is quite a bit after the question, but might be useful for future reference.  If you can, I\'d suggest using the excellent TopShelf project.  It makes development and debugging of a Windows Service much easier and adds makes deployment somewhat easier too.  Check it out: http://topshelf-project.com/For trouble-shooting on existing Windows Service program, use \'Debugger.Break()\' as other guys suggested.For new Windows Service program, I would suggest using James Michael Hare\'s method http://geekswithblogs.net/BlackRabbitCoder/archive/2011/03/01/c-toolbox-debug-able-self-installable-windows-service-template-redux.aspx Just put your debugger lunch anywhere and attach Visualstudio on startupAlso you need to start VS as Administatrator and you need to allow, that a process can automatically be debugged by a diffrent user (as explained here):Use Windows Service Template C# project to create a new service app https://github.com/HarpyWar/windows-service-templateThere are console/service mode automatically detected, auto installer/deinstaller of your service and several most used features are included.Here is the simple method which I used to test the service, without any additional "Debug" methods and with integrated VS Unit Tests.What you need is thinking of Simplifying Windows ServicesYou have two options to do the debugging.Please refer THIS blog post that i created for the topic. Just pasteany where in you code.For Example , It will hit Debugger.Break(); when you run your program.