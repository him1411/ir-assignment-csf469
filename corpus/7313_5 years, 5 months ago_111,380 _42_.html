Edit: This question looks like it might be the same problem, but has no responses...Edit: In test case 5 the task appears to be stuck in WaitingForActivation state.I\'ve encountered some odd behaviour using the System.Net.Http.HttpClient in .NET 4.5 - where "awaiting" the result of a call to (e.g.) httpClient.GetAsync(...) will never return.This only occurs in certain circumstances when using the new async/await language functionality and Tasks API - the code always seems to work when using only continuations.Here\'s some code which reproduces the problem - drop this into a new "MVC 4 WebApi project" in Visual Studio 11 to expose the following GET endpoints:Each of the endpoints here return the same data (the response headers from stackoverflow.com) except for /api/test5 which never completes.Code to reproduce:You are misusing the API.Here\'s the situation: in ASP.NET, only one thread can handle a request at a time. You can do some parallel processing if necessary (borrowing additional threads from the thread pool), but only one thread would have the request context (the additional threads do not have the request context).This is managed by the ASP.NET SynchronizationContext.By default, when you await a Task, the method resumes on a captured SynchronizationContext (or a captured TaskScheduler, if there is no SynchronizationContext). Normally, this is just what you want: an asynchronous controller action will await something, and when it resumes, it resumes with the request context.So, here\'s why test5 fails:Here\'s why the other ones work:And here\'s the best practices:That way, you get both benefits: the continuation (the remainder of the AsyncAwait_GetSomeDataAsync method) is run on a basic thread pool thread that doesn\'t have to enter the ASP.NET request context; and the controller itself is async (which doesn\'t block a request thread).More information:Update 2012-07-13: Incorporated this answer into a blog post.Quick fix from here. Instead of writing:Try:Or if you need a result:From the source (edited to match the above example): AsyncOperation will now be invoked on the ThreadPool, where there\n  won\xe2\x80\x99t be a SynchronizationContext, and the continuations used inside\n  of AsyncOperation won\xe2\x80\x99t be forced back to the invoking thread.For me this looks like a great approach since I won\'t have to use ConfigureAwait all over the place (which as far as I can tell could also break proper async behavior in GUI), nor do I have to make it async all the way in my application (which is not currently an option anyway).From the source:Ensure that the await in the FooAsync method doesn\xe2\x80\x99t find a context to\n  marshal back to. The simplest way to do that is to invoke the\n  asynchronous work from the ThreadPool, such as by wrapping the\n  invocation in a Task.Run, e.g.int Sync()  { \n      return Task.Run(() => Library.FooAsync()).Result;  }FooAsync will now be invoked on the ThreadPool, where there won\xe2\x80\x99t be a\n  SynchronizationContext, and the continuations used inside of FooAsync\n  won\xe2\x80\x99t be forced back to the thread that\xe2\x80\x99s invoking Sync().I\'m looking here:http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.taskawaiter(v=vs.110).aspxAnd here:http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.taskawaiter.getresult(v=vs.110).aspxAnd seeing:This type and its members are intended for use by the compiler.Considering the await version works, and is the \'right\' way of doing things, do you really need an answer to this question?My vote is: Misusing the API.These two schools are not really excluding.Here is the scenario where you simply have to useor something likeI have a MVC action that is under database transaction attribute. The idea was (probably) to roll back everything done in the action if something goes wrong. This does not allow context switching, otherwise transaction rollback or commit is going to fail itself.The library I need is async as it is expected to run async.The only option. Run it as a normal sync call.I am just saying to each its own.