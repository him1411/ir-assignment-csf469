How do I get a method\'s execution time?  Is there a Timer utility class for things like timing how long a task takes, etc?  Most of the searches on Google return results for timers that schedule threads and tasks, which is not what I want.There is always the old-fashioned way:I go with the simple answer. Works for me.It works quite well. The resolution is obviously only to the millisecond, you can do better with System.nanoTime(). There are some limitations to both (operating system schedule slices, etc.) but this works pretty well.Average across a couple of runs (the more the better) and you\'ll get a decent idea.Come on guys! Nobody mentioned the Guava way to do that (which is arguably awesome):The nice thing is that Stopwatch.toString() does a good job of selecting time units for the measurement. I.e. if the value is small, it\'ll output 38 ns, if it\'s long, it\'ll show 5m 3sEven nicer:Note: Google Guava requires Java 1.6+Using Instant and Duration from Java 8\'s new API,outputs,Use a profiler (JProfiler, Netbeans Profiler, Visual VM, Eclipse Profiler, etc). You\'ll get the most accurate results and is the least intrusive. They use the built-in JVM mechanism for profiling which can also give you extra information like stack traces, execution paths, and more comprehensive results if necessary.When using a fully integrated profiler, it\'s faily trivial to profile a method. Right click, Profiler -> Add to Root Methods. Then run the profiler just like you were doing a test run or debugger.This probably isn\'t what you wanted me to say, but this is a good use of AOP. Whip an proxy interceptor around your method, and do the timing in there.The what, why and how of AOP is rather beyond the scope of this answer, sadly, but that\'s how I\'d likely do it. Edit: Here\'s a link to Spring AOP to get you started, if you\'re keen. This is the most accessible implementation of AOP that Iive come across for java.Also, given everyone else\'s very simple suggestions, I should add that AOP is for when you don\'t want stuff like timing to invade your code. But in many cases, that sort of simple and easy approach is fine.Gathered all possible ways together into one place.DateSystemApache-StopWatchGoogle-StopWatchHuman Readable FormatJODA-TIMEJava 8 using Instant and DurationSystem.currentTimeMillis(); IS NOT a good approach for measuring the performance of your algorithms. It measures the total time you experience as a user watching the computer screen. It includes also time consumed by everything else running on your computer in the background. This could make a huge difference in case you have a lot of programs running on your workstation.Proper approach is  using java.lang.management package.From http://nadeausoftware.com/articles/2008/03/java_tip_how_get_cpu_and_user_time_benchmarking website:getCpuTime() method gives you sum of those:Also We can use StopWatch class of Apache commons for measuring the time.Sample codeWith Java 8 you can do also something like this with every normal methods:with TimeIt like:With this methode you can make easy time measurement anywhere in your code without breaking it. In this simple example i just print the time. May you add a Switch for TimeIt, e.g. to only print the time in DebugMode or something.If you are working with Function you can do somthing like this:We are using AspectJ and Java annotations for this purpose. If we need to know to execution time for a method, we simple annotate it. A more advanced version could use an own log level that can enabled and disabled at runtime.Just a small twist, if you don\'t use tooling and want to time methods with low execution time: execute it many times, each time doubling the number of times it is executed until you reach a second, or so. Thus, the time of the Call to System.nanoTime and so forth, nor the accuracy of System.nanoTime does affect the result much.Of course, the caveats about using the wall clock apply: influences of JIT-compilation, multiple threads / processes etc. Thus, you need to first execute the method a lot of times first, such that the JIT compiler does its work, and then repeat this test multiple times and take the lowest execution time.Really good code.http://www.rgagnon.com/javadetails/java-0585.htmlYou can use Perf4j. Very cool utility. Usage is simpleMore information can be found in Developer GuideEdit: Project seems deadFYI, JEP 230: Microbenchmark Suite is an OpenJDK proposal to:Add a basic suite of microbenchmarks to the JDK source code, and make it easy for developers to run existing microbenchmarks and create new ones.This proposal did not make the cut for Java 9 but may be added later.In the meantime you may want to look at the Java Microbenchmark Harness (JMH) project on which the proposal is based.I basically do variations of this, but considering how hotspot compilation works, if you want to get accurate results you need to throw out the first few measurements and make sure you are using the method in a real world (read application specific) application.  If the JIT decides to compile it your numbers will vary heavily.  so just be awareThere are a couple of ways to do that. I normally fall back to just using something like this: or the same thing with System.nanoTime();For something more on the benchmarking side of things there seems also to be this one: http://jetm.void.fm/ Never tried it though.Using AOP/AspectJ and @Loggable annotation from jcabi-aspects you can do it easy and compact:Every call to this method will be sent to SLF4J logging facility with DEBUG logging level. And every log message will include execution time.If you want wall-clock timeAs "skaffman" said, use AOP OR you can use run time bytecode weaving, just like unit test method coverage tools use to transparently add timing info to methods invoked.You can look at code used by open source tools tools like Emma (http://downloads.sourceforge.net/emma/emma-2.0.5312-src.zip?modtime=1118607545&big_mirror=0). The other opensource coverage tool is http://prdownloads.sourceforge.net/cobertura/cobertura-1.9-src.zip?download.If you eventually manage to do what you set out for, pls. share it back with the community here with your ant task/jars.I modified the code from correct answer to get result in seconds: Spring provides a utility class org.springframework.util.StopWatch, as per JavaDoc:Simple stop watch, allowing for timing of a number of tasks, exposing\n  total running time and running time for each named task.Usage:Output:With Aspects:You can try this way if just want know the time.    Ok, this is a simple class to be used for simple simple timing of your functions. There is an example below it.Sample of use:Sample of console output:System.nanoTime() is a pretty precise system utility to measure execution time. But be careful, if you\'re running on pre-emptive scheduler mode (default), this utility actually measures wall-clock time and not CPU time. Therefore, you may notice different execution time values from run to run, depending on system loads. If you look for CPU time, I think that running your program in real-time mode will do the trick. You have to use RT linux. link: Real-time programming with Linux Performance measurements on my machineAs mentioned, System.nanoTime() is thought to measure elapsed time. Just be aware of the cost if used insied a loop or the like.It would be nice if java had a better functional support, so that the action, that needs to be measured, could be wrapped into a block: In java this could be done by anonymous functions, that look too verboseIn Java 8 a new class named Instant is introduced. As per doc:Instant represents the start of a nanosecond on the time line. This\n  class is useful for generating a time stamp to represent machine time.\n  The range of an instant requires the storage of a number larger than a\n  long. To achieve this, the class stores a long representing\n  epoch-seconds and an int representing nanosecond-of-second, which will\n  always be between 0 and 999,999,999. The epoch-seconds are measured\n  from the standard Java epoch of 1970-01-01T00:00:00Z where instants\n  after the epoch have positive values, and earlier instants have\n  negative values. For both the epoch-second and nanosecond parts, a\n  larger value is always later on the time-line than a smaller value.This can be used as:It prints PT7.001S.