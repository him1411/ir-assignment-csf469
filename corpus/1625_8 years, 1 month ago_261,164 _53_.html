Just wondering if any of you guys use Count(1) over Count(*) and if there is a noticeable difference in performance or if this is just a legacy habit that has been brought forward from days gone past?(The specific database is SQL Server 2005.)There is no difference.Reason:Books on-line says "COUNT ( { [ [ ALL | DISTINCT ] expression ] | * } )""1" is a non-null expression: so it\'s the same as COUNT(*).\nThe optimizer recognizes it for what it is: trivial.The same as EXISTS (SELECT * ... or EXISTS (SELECT 1 ...Example:Same IO, same plan, the worksEdit, Aug 2011Similar question on DBA.SE.Edit, Dec 2011COUNT(*) is mentioned specifically in ANSI-92 (look for "Scalar expressions 125")Case:a) If COUNT(*) is specified, then the result is the cardinality of T.That is, the ANSI standard recognizes it as bleeding obvious what you mean. COUNT(1) has been optimized out by RDBMS vendors because of this superstition. Otherwise it would be evaluated as per ANSIb) Otherwise, let TX be the single-column table that is the\n                result of applying the <value expression> to each row of T\n                and eliminating null values. If one or more null values are\n                eliminated, then a completion condition is raised: warning-In SQL Server, these statements yield the same plans.Contrary to the popular opinion, in Oracle they do too.SYS_GUID() in Oracle is quite computation intensive function.In my test database, t_even is a table with 1,000,000 rowsThis query:runs for 48 seconds, since the function needs to evaluate each SYS_GUID() returned to make sure it\'s not a NULL.However, this query:runs for but 2 seconds, since it doen\'t even try to evaluate SYS_GUID() (despite * being argument to COUNT(*))Clearly, COUNT(*) and COUNT(1) will always return the same result.  Therefore, if one were slower than the other it would effectively be due to an optimiser bug.  Since both forms are used very frequently in queries, it would make no sense for a DBMS to allow such a bug to remain unfixed.  Hence you will find that the performance of both forms is (probably) identical in all major SQL DBMSs.In the SQL-92 Standard, COUNT(*) specifically means "the cardinality of the table expression" (could be a base table, `VIEW, derived table, CTE, etc).I guess the idea was that COUNT(*) is easy to parse. Using any other expression requires the parser to ensure it doesn\'t reference any columns (COUNT(\'a\') where a is a literal and COUNT(a) where a is a column can yield different results).In the same vein, COUNT(*) can be easily picked out by a human coder familiar with the SQL Standards, a useful skill when working with more than one vendor\'s SQL offering.Also, in the special case SELECT COUNT(*) FROM MyPersistedTable;, the thinking is the DBMS is likely to hold statistics for the cardinality of the table. Therefore, because COUNT(1) and COUNT(*) are semantically equivalent, I use COUNT(*).COUNT(*) and COUNT(1) are same in case of result and performance.I would expect the optimiser to ensure there is no real difference outside weird edge cases.As with anything, the only real way to tell is to measure your specific cases.That said, I\'ve always used COUNT(*).SQL Server Execution Times: \n  CPU time = 31 ms,  elapsed time = 36 ms.SQL Server Execution Times:\n  CPU time = 46 ms,  elapsed time = 37 ms.I\'ve ran this hundreds of times, clearing cache every time..  The results vary from time to time as server load varies, but almost always count(*) has higher cpu time. I ran a quick test on SQL Server 2012 on an 8 GB RAM hyper-v box. You can see the results for yourself. I was not running any other windowed application apart from SQL Server Management Studio while running these tests.My table schema:Total number of records in Employee table: 178090131 (~ 178 million rows)First Query:Result of First Query:Second Query:Result of Second Query:You can notice there is a difference of 83 (= 70265 - 70182) milliseconds which can easily be attributed to exact system condition at the time queries are run. Also I did a single run, so this difference will become more accurate if I do several runs and do some averaging. If for such a huge data-set the difference is coming less than 100 milliseconds, then we can easily conclude that the two queries do not have any performance difference exhibited by the SQL Server Engine.Note : RAM hits close to 100% usage in both the runs. I restarted SQL Server service before starting both the runs.As this question comes up again and again, here is one more answer. I hope to add something for beginners wondering about "best practice" here.SELECT COUNT(*) FROM something counts records which is an easy task.SELECT COUNT(1) FROM something retrieves a 1 per record and than counts the 1s that are not null, which is essentially counting records, only more complicated.Having said this: Good dbms notice that the second statement will result in the same count as the first statement and re-interprete it accordingly, as not to do unnecessary work. So usually both statements will result in the same execution plan and take the same amount of time.However from the point of readability you should use the first statement. You want to count records, so count records, not expressions. Use COUNT(expression) only when you want to count non-null occurences of something.Easy to demo COUNT(*) vs COUNT(<some col>)--