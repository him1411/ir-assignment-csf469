I\'m trying to make a Python program that interfaces with a different crashy process (that\'s out of my hands). Unfortunately the program I\'m interfacing with doesn\'t even crash reliably! So I want to make a quick C++ program that crashes on purpose but I don\'t actually know the best and shortest way to do that, does anyone know what to put between my:to make my C++ program crash reliablyThe abort() function is probably your best bet. It\'s part of the C standard library, and is defined as "causing abnormal program termination" (e.g, a fatal error or crash).Try:Found in: Dividing by zero will crash the application:Well, are we on stackoverflow, or not?(Not guaranteed to crash by any standards, but neither are any of the suggested answers including the accepted one since SIGABRT could have been caught anyway. In practice, this will crash everywhere.)Just the answer... :)assert(false); is pretty good too.According to ISO/IEC 9899:1999 it is guaranteed to crash when NDEBUG is not defined:If NDEBUG is defined [...] the assert macro is defined simply asThe assert macro is redefined according to the current state of NDEBUG each time that  is included.[...]The assert macro puts diagnostic tests into programs; [...] if expression (which shall have a scalar type) is false [...]. It\n  then calls the abort function.Since a crash is a symptom of invoking undefined behaviour, and since invoking undefined behaviour can lead to anything, including a crash, I don\'t think you want to really crash your program, but just have it drop into a debugger. The most portable way to do so is probably abort(). While raise(SIGABRT) has the same effect, it is certainly more to write. Both ways however can be intercepted by installing a signal handler for SIGABRT. So depending on your situation, you might want/need to raise another signal. SIGFPE, SIGILL, SIGINT, SIGTERM or SIGSEGV might be the way to go, but they all can be intercepted.When you can be unportable, your choices might be even broader, like using SIGBUS on linux.The only flash I had is abort() function:It aborts the process with an abnormal program termination.It generates the SIGABRT signal, which by default causes the program to terminate returning an unsuccessful termination error code to the host environment.The program is terminated without executing destructors for objects of automatic or static storage duration, and without calling any atexit( which is called by exit() before the program terminates)function. It never returns to its caller.The answer is platform specific and depends on your goals. But here\'s the Mozilla Javascript crash function, which I think illustrates a lot of the challenges to making this work:What about stack overflow by a dead loop recursive method call?See Original example on Microsoft KBC++ is can be crashed deterministically by having 2 exceptions in parallel! The standard says never throw any exception from a destructor OR never use any function in a destructor which may throw exception.we have to make a function so lets leave the destructor etc etc.An example from ISO/IEC 14882 \xc2\xa715.1-7. Should be a crash as per C++ standard. Ideone example can be found here.ISO/IEC 14882 \xc2\xa715.1/9 mentions throw without try block resulting in implicit call to abort:If no exception is presently being handled, executing a\n  throw-expression with no operand calls std::terminate()Others include : \nthrow from destructor: ISO/IEC 14882 \xc2\xa715.2/3This will produce a segmentation fault.Your compiler will probably warn you about this, but it compiles just fine under GCC 4.4.3\nThis will probably cause a SIGFPE (floating-point exception), which perhaps is not as likely in a real application as SIGSEGV (memory segmentation violation) as the other answers cause, but it\'s still a crash. In my opinion, this is much more readable.Another way, if we\'re going to cheat and use signal.h, is:This is guaranteed to kill the subprocess, to contrast with SIGSEGV.This is a more guaranteed version of abort presented in above answers.It takes care of the situation when sigabrt is blocked.You can infact use any signal instead of abort that has the default action of crashing the program.  This crashes on my Linux system, because string literals are stored in read only memory:By the way, g++ refuses to compile this. Compilers are getting smarter and smarter :)This one is missing:This should crash too. On Windows it crashes with AccessViolation and it should do the same on all OS-es I guess.Although this question already has an accepted answer...Or... void main(){throw 1;}Or another way since we\'re on the band wagon.A lovely piece of infinite recursion. Guaranteed to blow your stack.Prints out:Segmentation fault (core dumped)Writing to a read-only memory will cause segmentation fault unless your system don\'t support read-only memory blocks.I have tested it with MingGW 5.3.0 on Windows 7 and GCC on Linux Mint. I suppose that other compilers and systems will give a similar effect.One that has not been mentioned yet:This will treat the null pointer as a function pointer and then call it.  Just like most methods, this is not guaranteed to crash the program, but the chances of the OS allowing this to go unchecked and of the program ever returning are negligible.very short, it crashes!Hope this crashes. Cheers.recurse() will keep allocating on the stack, until finally, there is a stack overflow.Freeing an uninitialized pointer is undefined behavior. On many platforms/compilers, freeThis will have a random value (whatever was at that memory location before). Freeing it will ask the system to free the memory at that address, which will usually cause a segmentation fault and make the program crash.A stylish way of doing this is a pure virtual function call:Compiled with gcc, this prints:pure virtual method calledterminate called without an active exceptionAborted (core dumped)This is the snippet provided by Google in Breakpad.