I\'ve created a small test app which represents my problem.\nI\'m using ActionBarSherlock to implement tabs with (Sherlock)Fragments.My code:\nTestActivity.javaTabListener.javaMyFragment.javaI\'ve added the Thread.sleep part to simulate downloading data. The code in the onPostExecute is to simulate use of the Fragment.When I rotate the screen very fast between landscape and portrait, I get an Exception at the onPostExecute code: java.lang.IllegalStateException: Fragment MyFragment{410f6060} not\n  attached to ActivityI think it\'s because a new MyFragment has been created in the meantime, and was attached to the Activity before the AsyncTask finished. The code in onPostExecute calls upon a unattached MyFragment.But how can I fix this?I\'ve found the very simple answer: isAdded():Return true if the fragment is currently added to its activity.To avoid onPostExecute from being called when the Fragment is not attached to the Activity is to cancel the AsyncTask when pausing or stopping the Fragment. Then isAdded() would not be necessary anymore. However, it is advisable to keep this check in place.I\'ve faced two different scenarios here:1) When I want the asynchronous task to finish anyway: imagine my onPostExecute does store data received and then call a listener to update views so, to be more efficient, I want the task to finish anyway so I have the data ready when user cames back. In this case I usually do this:2) When I want the asynchronous task only to finish when views can be updated: the case you\'re proposing here, the task only updates the views, no data storage needed, so it has no clue for the task to finish if views are not longer being showed. I do this:I\'ve found no problem with this, although I also use a (maybe) more complex way that includes launching tasks from the activity instead of the fragments.Wish this helps someone! :)The problem with your code is the way the you are using the AsyncTask, because when you rotate the screen during your sleep thread: the AsyncTask is still working, it is because you didn\'t cancel the AsyncTask instance properly in onDestroy() before the fragment rebuilds (when you rotate) and when this same AsyncTask instance (after rotate) runs onPostExecute(), this tries to find the resources with getResources() with the old fragment instance(an invalid instance): which is equivalent to:So the final solution is manage the AsyncTask instance (to cancel if this is still working) before the fragment rebuilds when you rotate the screen, and if canceled during the transition, restart the AsyncTask after reconstruction by the aid of a boolean flag:The problem is that you are trying to access resources (in this case, strings) using getResources().getString(), which will try to get the resources from the Activity. See this source code of the Fragment class:mHost is the object that holds your Activity.Because the Activity might not be attached, your getResources() call will throw an Exception.The accepted solution IMHO is not the way to go as you are just hiding the problem. The correct way is just to get the resources from somewhere else that is always guaranteed to exist, like the application context:I faced the same problem i just add the singletone instance to get resource as referred by Erick you can also use I hope this will help.Their are quite trick solution for this and leak of fragment from activity.So in case of getResource or anything one which is depending on activity context accessing from Fragment it is always check activity status and fragments status as follows I faced similar issues when the application settings activity with the loaded preferences was visible. If I would change one of the preferences and then make the display content rotate and change the preference again, it would crash with a message that the fragment (my Preferences class) was not attached to an activity.When debugging it looked like the onCreate() Method of the PreferencesFragment was being called twice when the display content rotated. That was strange enough already. Then I added the isAdded() check outside of the block where it would indicate the crash and it solved the issue.Here is the code of the listener that updates the preferences summary to show the new entry. It is located in the onCreate() method of my Preferences class which extends the PreferenceFragment class:I hope this will help others!works also in some cases. Just breaks the code execution from it and make sure the app not crashIn my case fragment methods have been called afterAn old post, but I was surprised about the most up-voted answer.The proper solution for this should be to cancel the asynctask in onStop (or wherever appropriate in your fragment). This way you don\'t introduce a memory leak (an asynctask keeping a reference to your destroyed fragment) and you have better control of what is going on in your fragment.If you extend the Application class and maintain a static \'global\' Context object, as follows, then you can use that instead of the activity to load a String resource.If you use this, you can get away with Toast and resource loading without worrying about lifecycles.