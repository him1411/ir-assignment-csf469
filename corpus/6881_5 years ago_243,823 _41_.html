I recently posted a detailed description of the issue I am facing here at SO. As I couldn\'t send an actual $http request, I used timeout to simulate asynchronous behavior. Data binding from my model to view is working correct, with the help of @GloopyNow, when I use $http instead of $timeout (tested locally), I could see the asynchronous request was successful and data is filled with json response in my service. But, my view is not updating.updated Plunkr hereHere is a Plunk that does what you want: http://plnkr.co/edit/TTlbSv?p=previewThe idea is that you work with promises directly and their "then" functions to manipulate and access the asynchronously returned responses.Here is a slightly more complicated version that caches the request so you only make it first time (http://plnkr.co/edit/2yH1F4IMZlMS8QsV9rHv?p=preview):Let it be simple. It\'s as simple as Demo. http://plnkr.co/edit/cbdG5p?p=previewBecause it is asynchronous, the $scope is getting the data before the ajax call is complete.You could use $q in your service to create promise and give it back to\ncontroller, and controller obtain the result within then() call against promise.In your service,Then, in your controller:tosh shimayama have a solution but you can simplify a lot if you use the fact that $http returns promises and that promises can return a value:A little demonstration in coffeescript: http://plunker.no.de/edit/ksnErx?live=previewYour plunker updated with my method: http://plnkr.co/edit/mwSZGK?p=previewA much better way I think would be something like this:Service:And in the controller you can simply use:Angular will automatically put the resolved awesomeFruits into the $scope.fruits.When binding the UI to your array you\'ll want to make sure you update that same array directly by setting the length to 0 and pushing the data into the array.Instead of this (which set a different array reference to data which your UI won\'t know about):try this:Here is a fiddle that shows the difference between setting a new array vs emptying and adding to an existing one. I couldn\'t get your plnkr working but hopefully this works for you!Related to this I went through a similar problem, but not with get or post made by Angular but with an extension made by a 3rd party (in my case Chrome Extension).\nThe problem that I faced is that the Chrome Extension won\'t return then() so I was unable to do it the way in the solution above but the result is still Asynchronous.\nSo my solution is to create a service and to proceed to a callbackThen in my controllerHope this can help others getting the same issue.I\'ve read http://markdalgleish.com/2013/06/using-promises-in-angularjs-views/\n[AngularJS allows us to streamline our controller logic by placing a promise directly on the scope, rather than manually handing the resolved value in a success callback.]so simply and handy :)Hope this helpI had the same problem, but when I was surfing on the internet I understood that $http return back by default a promise, then I could use it with "then" after return the "data". look at the code:I really don\'t like the fact that, because of the "promise" way of doing things, the consumer of the service that uses $http has to "know" about how to unpack the response. I just want to call something and get the data out, similar to the old $scope.items = Data.getData(); way, which is now deprecated.I tried for a while and didn\'t come up with a perfect solution, but here\'s my best shot (Plunker). It may be useful to someone.Then controller:Flaws I can already spot areNevertheless, it provides a pattern which removes controller "promise unwrap" boilerplate, and might be useful in cases when you want to use certain data obtained from $http in more than one place while keeping it DRY.As far as caching the response in service is concerned , here\'s another version that seems more straight forward than what I\'ve seen so far:this service will return either the cached data or $http.get;Please try the below CodeYou can split the controller (PageCtrl) and service (dataService)