Are there any best-practice guidelines on when to use case classes (or case objects) vs extending Enumeration in Scala?They seem to offer some of the same benefits.One big difference is that Enumerations come with support for instantiating them from some name String. For example:Then you can do:This is useful when wishing to persist enumerations (for example, to a database) or create them from data residing in files. However, I find in general that enumerations are a bit clumsy in Scala and have the feel of an awkward add-on, so I now tend to use case objects. A case object is more flexible than an enum:So now I have the advantage of...As @chaotic3quilibrium pointed out (with some corrections to ease reading):Regarding "UnknownCurrency(code)" pattern, there are other ways to handle not finding a currency code string than "breaking" the closed set nature of the Currency type. UnknownCurrency being of type Currency can now sneak into other parts of an API.It\'s advisable to push that case outside Enumeration and make the client deal with an Option[Currency] type that would clearly indicate there is really a matching problem and "encourage" the user of the API to sort it out him/herself.To follow up on the other answers here, the main drawbacks of case objects over Enumerations are:Can\'t iterate over all instances of the "enumeration". This is certainly the case, but I\'ve found it extremely rare in practice that this is required.Can\'t instantiate easily from persisted value. This is also true but, except in the case of huge enumerations (for example, all currencies), this doesn\'t present a huge overhead.Case objects already return their name for their toString methods, so passing it in separately is unnecessary.  Here is a version similar to jho\'s (convenience methods omitted for brevity):Objects are lazy; by using vals instead we can drop the list but have to repeat the name:If you don\'t mind some cheating, you can pre-load your enumeration values using the reflection API or something like Google Reflections.  Non-lazy case objects give you the cleanest syntax:Nice and clean, with all the advantages of case classes and Java enumerations.  Personally, I define the enumeration values outside of the object to better match idiomatic Scala code:UPDATE:\nA new macro based solution has been created which is far superior to the solution I outline below. I strongly recommend using this new macro based solution. And it appears plans for Dotty will make this style of enum solution part of the language. Whoohoo!Summary:\nThere are three basic patterns for attempting to reproduce the Java Enum within a Scala project. Two of the three patterns; directly using Java Enum and scala.Enumeration, are not capable of enabling Scala\'s exhaustive pattern matching. And the third one; "sealed trait + case object", does...but has JVM class/object initialization complications resulting in inconsistent ordinal index generation.  I have created a solution with two classes; Enumeration and EnumerationDecorated, located in this Gist. I didn\'t post the code into this thread as the file for Enumeration was quite large (+400 lines - contains lots of comments explaining implementation context).\n\n\nDetails:\nThe question you\'re asking is pretty general; "...when to use caseclassesobjects vs extending [scala.]Enumeration". And it turns out there are MANY possible answers, each answer depending on the subtleties of the specific project requirements you have. The answer can be reduced down to three basic patterns.  To start, let\'s make sure we are working from the same basic idea of what an enumeration is. Let\'s define an enumeration mostly in terms of the Enum provided as of Java 5 (1.5):Next, let\'s look at boiled down versions of the three most common solution patterns posted:\n\n\nA) Actually directly using Java Enum pattern (in a mixed Scala/Java project):\nThe following items from the enumeration definition are not available:  For my current projects, I don\'t have the benefit of taking the risks around the Scala/Java mixed project pathway. And even if I could choose to do a mixed project, item 7 is critical for allowing me to catch compile time issues if/when I either add/remove enumeration members, or am writing some new code to deal with existing enumeration members.\n\n\nB) Using the "sealed trait + case objects" pattern:\nThe following items from the enumeration definition are not available:  It\'s arguable it really meets enumeration definition items 5 and 6. For 5, it\'s a stretch to claim it\'s efficient. For 6, it\'s not really easy to extend to hold additional associated singleton-ness data.\n\n\nC) Using the scala.Enumeration pattern (inspired by this StackOverflow answer):\nThe following items from the enumeration definition are not available (happens to be identical to the list for directly using the Java Enum):  Again for my current projects, item 7 is critical for allowing me to catch compile time issues if/when I either add/remove enumeration members, or am writing some new code to deal with existing enumeration members.  So, given the above definition of an enumeration, none of the above three solutions work as they do not provide everything outlined in the enumeration definition above:  Each of these solutions can be eventually reworked/expanded/refactored to attempt to cover some of each one\'s missing requirements. However, neither the Java Enum nor the scala.Enumeration solutions can be sufficiently expanded to provide item 7. And for my own projects, this is one of the more compelling values of using a closed type within Scala. I strongly prefer compile time warnings/errors to indicate I have a gap/issue in my code as opposed to having to glean it out of a production runtime exception/failure.In that regard, I set about working with the case object pathway to see if I could produce a solution which covered all of the enumeration definition above. The first challenge was to push through the core of the JVM class/object initialization issue (covered in detail in this StackOverflow post). And I was finally able to figure out a solution.As my solution is two traits; Enumeration and EnumerationDecorated, and since the Enumeration trait is over +400 lines long (lots of comments explaining context), I am forgoing pasting it into this thread (which would make it stretch down the page considerbly). For details, please jump directly to the Gist.Here\'s what the solution ends up looking like using the same data idea as above (fully commented version available here) and implemented in EnumerationDecorated.\nThis is an example usage of a new pair of enumeration traits I created (located in this Gist) to implement all of the capabilities desired and outlined in the enumeration definition.  One concern expressed is that the enumeration member names must be repeated (decorationOrderedSet in the example above). While I did minimize it down to a single repetition, I couldn\'t see how to make it even less due to two issues:  Given these two issues, I had to give up trying to generate an implied ordering and had to explicitly require the client define and declare it with some sort of ordered set notion. As the Scala collections do not have an insert ordered set implementation, the best I could do was use a List and then runtime check that it was truly a set. It\'s not how I would have preferred to have achieved this.  And given the design required this second list/set ordering val, given the ChessPiecesEnhancedDecorated example above, it was possible to add case object PAWN2 extends Member and then forget to add Decoration(PAWN2,\'P2\', 2) to decorationOrderedSet. So, there is a runtime check to verify that the list is not only a set, but contains ALL of the case objects which extend the sealed trait Member. That was a special form of reflection/macro hell to work through.\n\n\nPlease leave comments and/or feedback on the Gist.The advantages of using case classes over Enumerations are:The advantages of using Enumerations instead of case classes are:So in general, if you just need a list of simple constants by name, use enumerations.  Otherwise, if you need something a bit more complex or want the extra safety of the compiler telling you if you have all matches specified, use case classes.UPDATE: The code below has a bug, described here.  The test program below works, but if you were to use DayOfWeek.Mon (for example) before DayOfWeek itself, it would fail because DayOfWeek has not been initialized (use of an inner object does not cause an outer object to be initialized).  You can still use this code if you do something like val enums = Seq( DayOfWeek ) in your main class, forcing initialization of your enums, or you can use chaotic3quilibrium\'s modifications.  Looking forward to a macro-based enum!If you wantthen the following may be of interest.  Feedback welcome.In this implementation there are abstract Enum and EnumVal base classes, which you extend.  We\'ll see those classes in a minute, but first, here\'s how you would define an enum:Note that you have to use each enum value (call its apply method) to bring it to life.  [I wish inner objects weren\'t lazy unless I specifically ask for them to be.  I think.]We could of course add methods/data to DayOfWeek, Val, or the individual case objects if we so desired.And here\'s how you would use such an enum:Here\'s what you get when you compile it:You can replace "day match" with "( day: @unchecked ) match" where you don\'t want such warnings, or simply include a catch-all case at the end.When you run the above program, you get this output:Note that since the List and Maps are immutable, you can easily remove elements to create subsets, without breaking the enum itself.Here is the Enum class itself (and EnumVal within it):And here is a more advanced use of it which controls the IDs and adds data/methods to the Val abstraction and to the enum itself:I have a nice simple lib here that allows you to use sealed traits/classes as enum values without having to maintain your own list of values. It relies on a simple macro that is not dependent on the buggy knownDirectSubclasses.https://github.com/lloydmeta/enumeratumAnother disadvantage of case classes versus Enumerations when you will need to iterate or filter across all instances. This is a built-in capability of Enumeration (and Java enums as well) while case classes don\'t automatically support such capability.In other words: "there\'s no easy way to get a list of the total set of enumerated values with case classes".If you are serious about maintaining interoperability with other JVM languages (e.g. Java) then the best option is to write Java enums.  Those work transparently from both Scala and Java code, which is more than can be said for scala.Enumeration or case objects.  Let\'s not have a new enumerations library for every new hobby project on GitHub, if it can be avoided!I\'ve seen various versions of making a case class mimic an enumeration.  Here is my version:Which allows you to construct case classes that look like the following:Maybe someone could come up with a better trick than simply adding a each case class to the list like I did.  This was all I could come up with at the time.Update March 2017: as commented by Anthony Accioly, the scala.Enumeration/enum PR has been closed.Dotty (next generation compiler for Scala) will take the lead, though dotty issue 1970 and Martin Odersky\'s PR 1958.Note: there is now (August 2016, 6+ years later) a proposal to remove scala.Enumeration: PR 5352The syntaxis a possible implementation example, intention is to also support ADTs that conform to certain restrictions (no nesting, recursion or varying constructor parameters), e. g.:Deprecates the unmitigated disaster that is scala.Enumeration.This addresses the issue of not being able to have one codebase that\n  supports Scala-JVM, Scala.js and Scala-Native (Java source code not supported on Scala.js/Scala-Native, Scala source code not able to define enums that are accepted by existing APIs on Scala-JVM).I\'ve been going back and forth on these two options the last few times I\'ve needed them.  Up until recently, my preference has been for the sealed trait/case object option.1) Scala Enumeration Declaration2) Sealed Traits + Case ObjectsWhile neither of these really meet all of what a java enumeration gives you, below are the pros and cons:Scala EnumerationPros:\n-Functions for instantiating with option or directly assuming accurate (easier when loading from a persistent store)\n-Iteration over all possible values is supported Cons:\n-Compilation warning for non-exhaustive search is not supported (makes pattern matching less ideal)Case Objects/Sealed traitsPros:\n-Using sealed traits, we can pre-instantiate some values while others can be injected at creation time\n-full support for pattern matching (apply/unapply methods defined)Cons:\n-Instantiating from a persistent store - you often have to use pattern matching here or define your own list of all possible \'enum values\'What ultimately made me change my opinion was something like the following snippet:The .get calls were hideous - using enumeration instead I can simply call the withName method on the enumeration as follows:So I think my preference going forward is to use Enumerations when the values are intended to be accessed from a repository and case objects/sealed traits otherwise.I prefer case objects (it\'s a matter of personal preference). To cope with the problems inherent to that approach (parse string and iterate over all elements), I\'ve added a few lines that are not perfect, but are effective.I\'m pasting you the code here expecting it could be useful, and also that others could improve it.For those still looking how to get GatesDa\'s answer to work:\nYou can just reference the case object after declaring it to instantiate it: