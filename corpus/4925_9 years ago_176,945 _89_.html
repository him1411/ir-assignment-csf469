How is it possible to read/write to the Windows Registry using java?I know this question is old, but it is the first search result on google to "java read/write to registry".  Recently I found this amazing piece of code which:This is pure, Java code.It uses reflection to work, by actually accessing the private methods in the java.util.prefs.Preferences class. The internals of this class are complicated, but the class itself is very easy to use.For example, the following code obtains the exact windows distribution from the registry:Here is the original class. Just copy paste it and it should work:I was unable to find and give credit to the original author of this code. If you find any details, please add a comment and I will add it here.You don\'t actually need a 3rd party package. Windows has a reg utility for all registry operations. To get the command format, go to the DOS propmt and type:You can invoke reg through the Runtime class:Editing keys and adding new ones is straightforward using the command above. To read the registry, you need to get reg\'s output, and it\'s a little tricky. Here\'s the code:Java Native Access (JNA) is an excellent project for working with native libraries and has support for the Windows registry in the platform library (platform.jar) through Advapi32Util and Advapi32.Update: Here\'s a snippet with some examples of how easy it is to use JNA to work with the Windows registry using JNA 3.4.1,I\'ve done this before using jRegistryKey. It is an LGPL Java/JNI library that can do what you need. Here\'s an example of how I used it to enabled Registry editing through regedit and also the "Show Folder Options" option for myself in Windows via the registry.I\'ve incremented the Pure java code originally posted by David to allow acessing the 32-bits section of the registry from a 64-bit JVM, and vice-versa. I don\'t think any of the other answers address this.Here it is:Yes, using the java.util.Preferences API, since the Windows implementation of it uses the Registry as a backend.In the end it depends on what you\'re wanting to do: storing preferences for your app is what the Preferences does just great. If you\'re wanting to actually change registry keys not having to do with your app, you\'ll need some JNI app, as described by Mark (shameless steal here):From a quick google:\n  Check the WinPack for JNIWrapper. It has full Windows Registry access support including Reading and Writing.The WinPack Demo has Registry Viewer implemented as an example.Check at http://www.teamdev.com/jniwrapper/winpack/#registry_accessAnd...There is also try JNIRegistry @ http://www.trustice.com/java/jnireg/There is also the option of invoking an external app, which is responsible for reading / writing the registry.From a quick google:Check the WinPack for JNIWrapper. It\n  has full Windows Registry access\n  support including Reading and Writing.The WinPack Demo has Registry Viewer\n  implemented as an example.Check at\n  http://www.teamdev.com/jniwrapper/winpack/#registry_accessAnd...There is also try JNIRegistry @\n  http://www.trustice.com/java/jnireg/There is also the option of invoking an external app, which is responsible for reading / writing the registry.Here\'s a modified version of Oleg\'s solution.  I noticed that on my system (Windows server 2003), the output of "reg query" is not separated by tabs (\'\\t\'), but by 4 spaces.I also simplified the solution, as a thread is not required.}As has been noted, the Preferences API uses the registry to store preferences, but cannot be used to access the whole registry.However, a pirate called David Croft has worked out that it\'s possible to use methods in Sun\'s implementation of the Preferences API for reading the Windows registry from Java without JNI. There are some dangers to that, but it is worth a look.Thanks to original post. I have reskinned this utility class and come up over the flaws which it had earlier, thought it might help others so posting here. I have also added some extra utility methods. Now it is able to read any file in windows registry(including REG_DWORD, REG_BINARY, REG_EXPAND_SZ etc.). All the methods work like a charm. Just copy and paste it and it should work. Here is the reskinned and modified class:  Sample of using the methods is as follows: Below method retrieves the value of the key from the given path:  String hex = WinRegistry.valueForKey(WinRegistry.HKEY_LOCAL_MACHINE, "SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\WindowsUpdate\\\\Auto Update", "AUOptions"); This method retrieves all data for the specified path(in form of keys and values) :  Map<String, String> map = WinRegistry.valuesForPath(WinRegistry.HKEY_LOCAL_MACHINE, "SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\WSMAN"); This method retrieves value recursively for the key from the given path:  String val = WinRegistry.valueForKeyPath(WinRegistry.HKEY_LOCAL_MACHINE, "System", "TypeID"); and this one retrieves all values recursively for a key from the given path:  List<String> list = WinRegistry.valuesForKeyPath(\n                       WinRegistry.HKEY_LOCAL_MACHINE,                  //HKEY                               "SOFTWARE\\\\Wow6432Node\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall",   //path                 "DisplayName"         //Key\n                );\nHere in above code I retrieved all installed software names in windows system.\nNote: See the documentation of these methods And this one retrieves all subkeys of the given path:\nList<String> list3 = WinRegistry.subKeysForPath(WinRegistry.HKEY_CURRENT_USER, "Software"); Important Note: I have modified only reading purpose methods in this process, not the writing purpose methods like createKey, deleteKey etc. They still are same as I recieved them. The Preferences API approach does not give you access to all the branches of the registry. In fact, it only gives you access to where the Preferences API stores its, well, preferences. It\'s not a generic registry handling API, like .NET\'sTo read/write every key I guess JNI or an external tool would be the approach to take, as Mark shows.There are few JNDI service providers to work with windows registry.One could observe http://java.sun.com/products/jndi/serviceproviders.html.You could try WinRun4J. This is a windows java launcher and service host but it also provides a library for accessing the registry.(btw I work on this project so let me know if you have any questions)The best way to write to the register probably is using the reg import native Windows command and giving it the file path to the .reg file which has been generated by exporting something from the registry.Reading is done with the reg query command. Also see the documentation:\nhttps://technet.microsoft.com/en-us/library/cc742028.aspxTherefore the following code should be self-explanatory:My previous edit to @David\'s answer was rejected.  Here is some useful information about it.This "magic" works because Sun implements the Preferences class for Windows as part of JDK, but it is package private.  Parts of the implementation use JNI.The implementation is selected at runtime using a factory method here: http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/util/prefs/Preferences.java#Preferences.0factoryThe real question: Why doesn\'t OpenJDK expose this API to public?Yet another library...https://code.google.com/p/java-registry/This one launches reg.exe under the covers, reading/writing to temporary files. I didn\'t end up using it, but it looks like a pretty comprehensive implementation. If I did use it, I might dive in and add some better management of the child processes.Although this is pretty old, but i guess the better utility to use on windows platform would be regini :A single call to process: will do all the magic. I have tried it, while making jar as windows service using servany.exe which requires changes to made in registry for adding javaw.exe arguments and it works perfectly. You might want to read this: http://support.microsoft.com/kb/264584This was crazy... I took the code from one of the posts here, failed to see there were 18 more comments in which one stated that it does not read a dword value...In any case, I\'ve refactored the hell of that code into something with less ifs and methods... The Enum could be refined a bit, but as soon as I\'ve fought my way to read a numeric value or byte array and failed, I\'ve given up...So here it is:NOTE: THIS DOES NOT READ ANYTHING ELSE BUT STRINGS!!!!!The WinPack Demo has Registry Viewer\n  implemented as an example.Check at\n  http://www.jniwrapper.com/winpack_features.jsp#registryBTW, WinPack has been moved to the following address:http://www.teamdev.com/jniwrapper/winpack/The java.util.prefs package provides a way for applications to store and retrieve user and system preferences and data configuration. These preference data will be stored persistently in an implementation-dependent backing stored. For example in Windows operating system in will stored in Windows registry.To write and read these data we use the java.util.prefs.Preferences class. Below code shows how to read and write to the HKCU and HKLM in the registry.I prefer using java.util.prefs.Preferences class.A simple example would be In response to David answer - I would do some enhancements:You can execute these "REG QUERY" command using java code.Try to execute this from command prompt and execute command from java code.HKEY_LOCAL_MACHINE "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"To Search details like productname version etc.. use /v amd "name". HKEY_LOCAL_MACHINE "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion" /v "ProductName"This uses the same Java internal APIs as in in David\'s answer, but I\'ve rewritten it completely. It\'s shorter now and nicer to use. I also added support for HKEY_CLASSES_ROOT and other hives. It still has some of the other limitations though (such as no DWORD support and no Unicode support) which are due to the underlying API and are sadly unavoidable with this approach. Still, if you only need basic string reading/writing and don\'t want to load a native DLL, it\'s handy.I\'m sure you can figure out how to use it.Public domain. Have fun.One day, Java will have a built-in foreign function interface for easy access to native APIs, and this sort of hack will be unnecessary.