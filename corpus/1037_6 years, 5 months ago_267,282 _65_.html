When writing shell programs, we often use /bin/sh and /bin/bash. I usually use bash, but I don\'t know what\'s the difference between them. What\'s main difference between bash and sh?What do we need to be aware of when programming in bash and sh?sh (or the Shell Command Language) is a programming language described by the POSIX\nstandard.\nIt has many implementations (ksh88, dash, ...). bash can also be\nconsidered an implementation of sh (see below).Because sh is a specification, not an implementation, /bin/sh is a symlink\n(or a hard link) to an actual implementation on most POSIX systems.bash started as an sh-compatible implementation (although it predates the POSIX standard by a few years), but as time passed it has acquired many extensions. Many of these extensions may change the behavior of valid POSIX shell scripts, so by itself bash is not a valid POSIX shell. Rather, it is a dialect of the POSIX shell language.bash supports a --posix switch, which makes it more POSIX-compliant. It also tries to mimic POSIX if invoked as sh.For a long time, /bin/sh used to point to /bin/bash on most GNU/Linux systems. As a result, it had almost become safe to ignore the difference between the two. But that started to change recently.Some popular examples of systems where /bin/sh does not point to /bin/bash (and on some of which /bin/bash may not even exist) are:How can you find out what /bin/sh points to on your system?The complication is that /bin/sh could be a symbolic link or a hard link.\nIf it\'s a symbolic link, a portable way to resolve it is:If it\'s a hard link, tryIn fact, the -L flag covers both symlinks and hardlinks,\nbut the disadvantage of this method is that it is not portable \xe2\x80\x94\nPOSIX does not require find to support the -samefile option,\nalthough both GNU find and FreeBSD find support it.Ultimately, it\'s up to you to decide which one to use, by writing the \xc2\xabshebang\xc2\xbb line.E.g.will use sh (and whatever that happens to point to),will use /bin/bash if it\'s available (and fail with an error message if it\'s not). Of course, you can also specify another implementation, e.g.For my own scripts, I prefer sh for the following reasons:There are advantages to using bash as well. Its features make programming more convenient and similar to programming in other modern programming languages. These include things like scoped local variables and arrays. Plain sh is a very minimalistic programming language.sh: http://man.cx/sh\nbash: http://man.cx/bashTL;DR: bash is a superset of sh with a more elegant syntax and more functionality. It is safe to use a bash shebang line in almost all cases as it\'s quite ubiquitous on modern platforms.NB: in some environments, sh is bash. Check sh --version.Post from UNIX.COMShell featuresThis table below lists most features that I think would make you choose one shell over another. It is not intended to be a definitive list and does not include every single possible feature for every single possible shell. A feature is only considered to be in a shell if in the version that comes with the operating system, or if it is available as compiled directly from the standard distribution. In particular the C shell specified below is that available on SUNOS 4.*, a considerable number of vendors now ship either tcsh or their own enhanced C shell instead (they don\'t always make it obvious that they are shipping tcsh.Code:Key to the table above.Y      Feature can be done using this shell.N      Feature is not present in the shell.F      Feature can only be done by using the shells function\n          mechanism.L      The readline library must be linked into the shell to enable\n          this Feature.Notes to the table aboveTERMINAL SHELLSH Vs. BASHSHBASHREFERENCE MATERIAL:SHELL\ngnu.org:At its base, a shell is simply a macro processor that executes\n  commands. The term macro processor means functionality where text and\n  symbols are expanded to create larger expressions.A Unix shell is both a command interpreter and a programming language.\n  As a command interpreter, the shell provides the user interface to the\n  rich set of GNU utilities. The programming language features allow\n  these utilities to be combined. Files containing commands can be\n  created, and become commands themselves. These new commands have the\n  same status as system commands in directories such as /bin, allowing\n  users or groups to establish custom environments to automate their\n  common tasks.Shells may be used interactively or non-interactively. In interactive\n  mode, they accept input typed from the keyboard. When executing\n  non-interactively, shells execute commands read from a file.A shell allows execution of GNU commands, both synchronously and\n  asynchronously. The shell waits for synchronous commands to complete\n  before accepting more input; asynchronous commands continue to execute\n  in parallel with the shell while it reads and executes additional\n  commands. The redirection constructs permit fine-grained control of\n  the input and output of those commands. Moreover, the shell allows\n  control over the contents of commands\xe2\x80\x99 environments.Shells also provide a small set of built-in commands (builtins)\n  implementing functionality impossible or inconvenient to obtain via\n  separate utilities. For example, cd, break, continue, and exec cannot\n  be implemented outside of the shell because they directly manipulate\n  the shell itself. The history, getopts, kill, or pwd builtins, among\n  others, could be implemented in separate utilities, but they are more\n  convenient to use as builtin commands. All of the shell builtins are\n  described in subsequent sections.While executing commands is essential, most of the power (and\n  complexity) of shells is due to their embedded programming languages.\n  Like any high-level language, the shell provides variables, flow\n  control constructs, quoting, and functions.Shells offer features geared specifically for interactive use rather\n  than to augment the programming language. These interactive features\n  include job control, command line editing, command history and\n  aliases. Each of these features is described in this manual.BASH gnu.org:Bash is the shell, or command language interpreter, for the GNU\n  operating system. The name is an acronym for the \xe2\x80\x98Bourne-Again SHell\xe2\x80\x99,\n  a pun on Stephen Bourne, the author of the direct ancestor of the\n  current Unix shell sh, which appeared in the Seventh Edition Bell Labs\n  Research version of Unix.Bash is largely compatible with sh and incorporates useful features\n  from the Korn shell ksh and the C shell csh. It is intended to be a\n  conformant implementation of the IEEE POSIX Shell and Tools portion of\n  the IEEE POSIX specification (IEEE Standard 1003.1). It offers\n  functional improvements over sh for both interactive and programming\n  use.While the GNU operating system provides other shells, including a\n  version of csh, Bash is the default shell. Like other GNU software,\n  Bash is quite portable. It currently runs on nearly every version of\n  Unix and a few other operating systems - independently-supported ports\n  exist for MS-DOS, OS/2, and Windows platforms.Other answers generally pointed out the difference between Bash and a POSIX shell standard. However, when writing portable shell scripts and being used to Bash syntax, a list of typical bashisms and corresponding pure POSIX solutions is very handy. Such list has been compiled when Ubuntu switched from Bash to Dash as default system shell and can be found here:\nhttps://wiki.ubuntu.com/DashAsBinShMoreover, there is a great tool called checkbashisms that checks for bashisms in your script and comes handy when you want to make sure that your script is portable.This question has frequently been nominated as a canonical for people who try to use sh and are surprised that it\'s not behaving the same as bash.  Here\'s a quick rundown of common misunderstandings and pitfalls.Having a correct shebang and running the script by typing just the script name (possibly with a relative or full path) is generally the preferred solution.  In addition to a correct shebang, this requires the script file to have execute permission (chmod a+x scriptname).The Bash Reference manual has a section which attempts to enumerate the differences but some common sources of confusion includeRemember, this is an abridged listing.  Refer to the reference manual for the full scoop, and http://mywiki.wooledge.org/Bashism for many good workarounds; and/or try http://shellcheck.net/ which warns for many Bash-only features.A common error is to have a #!/bin/bash shebang line, but then nevertheless using sh scriptname to actually run the script. This basically disables any Bash-only functionality, so you get syntax errors e.g. for trying to use arrays.Unfortunately, Bash will not warn when you try to use these constructs when it is invoked as sh. It doesn\'t completely disable all Bash-only functionality, either, so running Bash by invoking it as sh is not a proper way to check if your script is portable to ash/dash/POSIX sh.Shell is an interface between a user and OS to access to an operating system\'s services. It can be either GUI or CLI (Command Line interface).sh (Bourne shell) is a shell command-line interpreter, for Unix/Unix-like operating systems. It provides some built-in commands. In scripting language we denote interpreter as #!/bin/sh. It was one most widely supported by other shells like bash (free/open), kash (not free).Bash (Bourne again shell) is a shell replacement for the Bourne shell. Bash is superset of sh. Bash supports sh. POSIX is a set of standards defining how POSIX-compliant systems should work.  Bash is not actually a POSIX compliant shell. In a scripting language we denote the interpreter as #!/bin/bash.Analogy: /bin/sh may or may not invoke the same program as /bin/bash.sh supports at least the features required by POSIX (assuming a correct implementation). It may support extensions as well.bash, the "Bourne Again Shell", implements the features required for sh plus bash-specific extensions. The full set of extensions is too long to describe here, and it varies with new releases. The differences are documented in the bash manual. Type info bash and read the "Bash Features" section (section 6 in the current version), or read the current documentation online.