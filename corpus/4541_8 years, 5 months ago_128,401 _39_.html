There are some posts that asks what the difference between those two are already.\n(why do I have to even mention this...)But my question is different in a way that I am calling "throw ex" in another error god-like handling method.If try & catch were used in the Main, then I would use throw; to rethrow the error.\nBut in the above simplied code, all exceptions go through HandleExceptionDoes throw ex; has the same effect as calling throw when called inside HandleException?Yes, there is a difference;(I posted earlier, and @Marc Gravell has corrected me)Here\'s a demonstration of the difference:and here is the output:You can see that in Exception 1, the stack trace goes back to the DivByZero() method, whereas in Exception 2 it does not.Take note, though, that the line number shown in ThrowException1() and ThrowException2() is the line number of the throw statement, not the line number of the call to DivByZero(), which probably makes sense now that I think about it a bit...Exception 1:Exception 2:Is it maintains the original stackTrace in debug mode only? The other answers are entirely correct, but this answer provides some extra detalis, I think.Consider this example:If you uncomment the throw arithExc; line, your output is:Certainly, you have lost information about where that exception happened. If instead you use the throw; line, this is what you get:This is a lot better, because now you see that it was the Program.Div method that caused you problems. But it\'s still hard to see if this problem comes from line 35 or line 37 in the try block.If you use the third alternative, wrapping in an outer exception, you lose no information:In particular you can see that it\'s line 35 that leads to the problem. However, this requires people to search the InnerException, and it feels somewhat indirect to use inner exceptions in simple cases.In this blog post they preserve the line number (line of the try block) by calling (through reflection) the internal intance method InternalPreserveStackTrace() on the Exception object. But it\'s not nice to use reflection like that (the .NET Framework might change their internal members some day without warning).No, this will cause the exception to have a different stack trace. Only using a throw without any exception object in the catch handler will leave the stack trace unchanged.You may want to return a boolean from HandleException whether the exception shall be rethrown or not.When you do throw ex, that exception thrown becomes the "original" one. So all previous stack trace will not be there.If you do throw, the exception just goes down the line and you\'ll get the full stack trace.Look at here: http://blog-mstechnology.blogspot.de/2010/06/throw-vs-throw-ex.htmlThrow:It preserve the Stack information with ExceptionThis is called as "Rethrow"If want to throw new exception,Throw Ex:It Won\'t Send Stack information with ExceptionThis is called as "Breaking the Stack"If want to throw new exception,To give you a different perspective on this, using throw is particularly useful if you\'re providing an API to a client and you want to provide verbose stack trace information for your internal library.  By using throw here, I\'d get the stack trace in this case of the System.IO.File  library for File.Delete.  If I use throw ex, then that information will not be passed to my handler.  if all Line 1 ,2 and 3 are commented - \nOutput - inner exif all Line 2 and 3 are commented - \nOutput - inner ex\n          System.DevideByZeroException: {"Attempted to divide by zero."}---------if all Line 1 and 2 are commented - \nOutput - inner ex\n          System.Exception: devide by 0 ----if all Line 1 and 3 are commented - \nOutput - inner ex\n          System.DevideByZeroException: {"Attempted to divide by zero."}---------\nand StackTrace will be reset in case of throw ex;