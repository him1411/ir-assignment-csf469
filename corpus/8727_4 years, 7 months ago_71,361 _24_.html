How can I avoid this warning in xcode. Here is the code snippet:The capture of self here is coming in with your implicit property access of self.timerDisp - you can\'t refer to self or properties on self from within a block that will be strongly retained by self.You can get around this by creating a weak reference to self before accessing timerDisp inside your block:And one very important thing to remember:\ndo not use instance variables directly in block, use it as a properties of weak object, sample:and don\'t forget to do:another issue can appear if you will pass weak copy of not retained by anybody object:if vcToGo will be deallocated and then this block fired I believe you will get crash with unrecognized selector to a trash which is contains vcToGo_ variable now. Try to control it.Create a strong reference to that weak version as the first line in your block. If self still exists when the block starts to execute and hasn\xe2\x80\x99t fallen back to nil, this line ensures it persists throughout the block\xe2\x80\x99s execution lifetime.So the whole thing would be like this:I have read this article many times. This is an excellent article by Erica Sadun on \nHow To Avoid Issues When Using Blocks And NSNotificationCenterFor example, in swift a simple method with success block would be:When we call this method and need to use self in the success block. We\'ll be using the [weak self] and guard let features. This so-called strong-weak dance is used by popular open source project Alamofire. For more info check out swift-style-guideIn another answer, Tim said:you can\'t refer to self or properties on self from within a block that will be strongly retained by self.This isn\xe2\x80\x99t quite true. It\xe2\x80\x99s OK for you to do this so long as you break the cycle at some point. For example, let\xe2\x80\x99s say you have a timer that fires that has a block that retains self and you also keep a strong reference to the timer in self. This is perfectly fine if you always know that you will destroy the timer at some point and break the cycle.In my case just now, I had this warning for code that did:Now I happen to know that clang will only produce this warning if it detects the method starts with \xe2\x80\x9cset\xe2\x80\x9d (and one other special case that I won\xe2\x80\x99t mention here). For me, I know there is no danger of there being a retain loop, so I changed the method name to \xe2\x80\x9cuseY:\xe2\x80\x9d Of course, that might not be appropriate in all cases and usually you will want to use a weak reference, but I thought it worth noting my solution in case it helps others.Adding two cents on improving precision and style. In most cases you will only use one or a couple of members of self in this block, most likely just to update a slider. Casting self is overkill. Instead, it\'s better to be explicit and cast only the objects that you truly need inside the block. For example, if it\'s an instance of UISlider*, say, _timeSlider, just do the following before the block declaration: Then just use slider inside the block. Technically this is more precise as it narrows down the potential retain cycle to only the object that you need, not all the objects inside self.Full example:Additionally, most likely the object being cast to a weak pointer is already a weak pointer inside self as well minimizing or eliminating completely the likelihood of a retain cycle. In the example above, _timeSlider is actually a property stored as a weak reference, e.g:In terms of coding style, as with C and C++, variable declarations are better read from right to left. Declaring SomeType* __weak variable in this order reads more naturally from right to left as: variable is a weak pointer to SomeType.