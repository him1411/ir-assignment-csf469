I have a function foo which makes an Ajax request. How can I return the response from foo?I tried to return the value from the success callback as well as assigning the response to a local variable inside the function and return that one, but none of those ways actually return the response.-> For a more general explanation of async behavior with different examples, please see Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference -> If you already understand the problem, skip to the possible solutions below.The A in Ajax stands for asynchronous. That means sending the request (or rather receiving the response) is taken out of the normal execution flow. In your example, $.ajax returns immediately and the next statement, return result;, is executed before the function you passed as success callback was even called.Here is an analogy which hopefully makes the difference between synchronous and asynchronous flow clearer: Imagine you make a phone call to a friend and ask him to look something up for you. Although it might take a while, you wait on the phone and stare into space, until your friend gives you the answer you needed.The same is happening when you make a function call containing "normal" code:Even though findItem might take a long time to execute, any code coming after var item = findItem(); has to wait until the function returns the result.You call your friend again for the same reason. But this time you tell him that you are in a hurry and he should call you back on your mobile phone. You hang up, leave the house and do whatever you planned to do. Once your friend calls you back, you are dealing with the information he gave to you.That\'s exactly what\'s happening when you do an Ajax request. Instead of waiting for the response, the execution continues immediately and the statement after the Ajax call is executed. To get the response eventually, you provide a function to be called once the response was received, a callback (notice something? call back ?). Any statement coming after that call is executed before the callback is called.Embrace the asynchronous nature of JavaScript! While certain asynchronous operations provide synchronous counterparts (so does "Ajax"), it\'s generally discouraged to use them, especially in a browser context.Why is it bad do you ask?JavaScript runs in the UI thread of the browser and any long running process will lock the UI, making it unresponsive. Additionally, there is an upper limit on the execution time for JavaScript and the browser will ask the user whether to continue the execution or not. All of this is really bad user experience. The user won\'t be able to tell whether everything is working fine or not. Furthermore the effect will be worse for users with a slow connection.In the following we will look at three different solutions that are all building on top of each other:All three are available in current browsers, and node 7+. The new ECMAScript version released in 2017 introduced syntax level support for asynchronous functions. With the help of async and await, you can write asynchronous in a "synchronous style". Make no mistake though: The code is still asynchronous, but it\'s easier to read/understand.async/await builds on top of promises: an async function always returns a promise. await "unwraps" a promise and either results in the value the promise was resolved with or throws an error if the promise was rejected.Important: You can only use await inside an async function. That means that at the very top level, you still have to work directly with the promise.You can read more about async and await on MDN.Here is an example that builds on top of delay above:Newer browser and node versions support async/await. You can also support older environments by transforming your code to ES5 with the help of regenerator (or tools that use regenerator, such as Babel).A callback is simply a function passed to another function. That other function can call the function passed whenever it is ready. In the context of asynchronous process, the callback will be called whenever the asynchronous process is done. Usually the result is passed to the callback.In the example in the question, you can make foo accept a callback and use it as success callback. So thisbecomesHere we defined the function "inline" but you can pass any function reference:foo itself is defined as follows:callback will refer to the function we pass to foo when we call it and we simply pass it on to success. I.e. once the Ajax request is successful, $.ajax will call callback and pass the response to the callback (which can be referred to with result, since this is how we defined the callback).You can also process the response before passing it to the callback:It\'s easier to write code using callbacks than it may seem. After all, JavaScript in the browser is heavily event driven (DOM events). Receiving the Ajax response is nothing else but an event.\nDifficulties could arise when you have to work with third party code, but most problems can be solved by just thinking through the application flow.The Promise API is a new feature of ECMAScript 6 (ES2015), but it has good browser support already. There are also many libraries which implement the standard Promises API and provide additional methods to ease the use and composition of asynchronous functions (e.g. bluebird).Promises are containers for future values. When the promise receives the value (it is resolved) or when it is cancelled (rejected), it notifies all of its "listeners" who want to access this value.The advantage over plain callbacks is that they allow you do decouple your code and they are easier to compose.Here is a simple example of using a promise:Applied to our Ajax call we could use promises like this:Describing all the advantages that promises offer is beyond the scope of this answer, but if you write new code, you should seriously consider them. They provide a great abstraction and separation of your code.More information about promises: HTML5 rocks - JavaScript PromisesDeferred objects are jQuery\'s custom implementation of promises (before the Promise API was standardized). They behave almost like promises, but expose a slightly different API.Every Ajax method of jQuery already returns a "deferred object" (actually a promise of a deferred object) which you can just return from your function:Keep in mind that promises and deferred objects are just containers for a future value, they are not the value itself. For example, suppose you had the following:This code misunderstands the above asynchrony issues. Specifically, $.ajax() doesn\'t freeze the code while it checks the \'/password\' page on your server - it sends a request to the server and while it waits, immediately returns a jQuery Ajax Deferred object, not the response from the server. That means the if statement is going to always get this Deferred object, treat it as true, and proceed as though the user is logged in. Not good.But the fix is easy:As I mentioned, some(!) asynchronous operations have synchronous counterparts. I don\'t advocate their use, but for completeness\' sake, here is how you would perform a synchronous call:If you directly use a XMLHTTPRequest object, pass false as third argument to .open.If you use jQuery, you can set the async option to false. Note that this option is deprecated since jQuery 1.8.\nYou can then either still use a success callback or access the responseText property of the jqXHR object:If you use any other jQuery Ajax method, such as $.get, $.getJSON, etc., you have to change it to $.ajax (since you can only pass configuration parameters to $.ajax).Heads up! It is not possible to make a synchronous JSONP request. JSONP by its very nature is always asynchronous (one more reason to not even consider this option).Your code should be something along the lines of this:Felix Kling did a fine job writing an answer for people using jQuery for AJAX, I\'ve decided to provide an alternative for people who aren\'t.(Note, for those using the new fetch API, Angular or promises I\'ve added another answer below)This is a short summary of "Explanation of the problem" from the other answer, if you\'re not sure after reading this, read that.The A in AJAX stands for asynchronous. That means sending the request (or rather receiving the response) is taken out of the normal execution flow. In your example, .send returns immediately and the next statement, return result;, is executed before the function you passed as success callback was even called.This means when you\'re returning, the listener you\'ve defined did not execute yet, which means the value you\'re returning has not been defined. Here is a simple analogy(Fiddle)The value of a returned is undefined since the a=5 part has not executed yet. AJAX acts like this, you\'re returning the value before the server got the chance to tell your browser what that value is.One possible solution to this problem is to code re-actively , telling your program what to do when the calculation completed.This is called CPS. Basically, we\'re passing getFive an action to perform when it completes, we\'re telling our code how to react when an event completes (like our AJAX call, or in this case the timeout).Usage would be:Which should alert "5" to the screen. (Fiddle).There are basically two ways how to solve this:As for synchronous AJAX, don\'t do it! Felix\'s answer raises some compelling arguments about why it\'s a bad idea. To sum it up, it\'ll freeze the user\'s browser until the server returns the response and create a very bad user experience. Here is another short summary taken from MDN on why:XMLHttpRequest supports both synchronous and asynchronous communications. In general, however, asynchronous requests should be preferred to synchronous requests for performance reasons.In short, synchronous requests block the execution of code... ...this can cause serious issues...If you have to do it, you can pass a flag: Here is how:Let your function accept a callback. In the example code foo can be made to accept a callback. We\'ll be telling our code how to react when foo completes. So:Becomes:Here we passed an anonymous function, but we could just as easily pass a reference to an existing function, making it look like:For more details on how this sort of callback design is done, check Felix\'s answer. Now, let\'s define foo itself to act accordingly(fiddle)We have now made our foo function accept an action to run when the AJAX completes successfully, we can extend this further by checking if the response status is not 200 and acting accordingly (create a fail handler and such). Effectively solving our issue.If you\'re still having a hard time understanding this read the AJAX getting started guide at MDN.XMLHttpRequest 2 (first of all read the answers from Benjamin Gruenbaum & Felix Kling)If you don\'t use jQuery, and want a nice short XMLHttpRequest 2 which works on the modern browsers and also on the mobile browsers I suggest to use it this way:As you can see:There are two ways to get the response of this Ajax call (three using the XMLHttpRequest var name):The simplest:Or if for some reason you bind() the callback to a class:Example:Or (the above one is better anonymous functions are always a problem):Nothing easier.Now some people will probably say that it\'s better to use onreadystatechange or the even the XMLHttpRequest variable name. That\'s wrong.Check out XMLHttpRequest advanced featuresIt supported on all *modern browsers. And I can confirm as I\'m using this approach since XMLHttpRequest 2 exists. I never had any type of problem on all browsers I use.onreadystatechange is only useful if you want to get the headers on state 2.Using the XMLHttpRequest variable name is another big error as you need to execute the callback inside the onload/oreadystatechange closures else you lost it.Now if you want something more complex using post and FormData you can easily extend this function:Again ... it\'s a very short function, but it does get & post.Examples of usage:Or pass a full form element (document.getElementsByTagName(\'form\')[0]):Or set some custom values:As you can see I didn\'t implemented sync... it\'s a bad thing.Having said that ... why don\'t do it the easy way?As mentioned in the comment the use of error && synchronous does completely break the point of the answer. Which is a nice short way to use Ajax in the proper way.Error handlerIn the above script you have an error handler which is statically defined so it does not compromise the function. The error handler can be used for other functions too.But to really get out an error the only way is to write a wrong URL in which case every browsers throws an error.Error handlers are maybe useful if you set custom headers, set the responseType to blob arraybuffer or whatever....Even if you pass \'POSTAPAPAP\' as the method it won\'t throw an error.Even if you pass \'fdggdgilfdghfldj\' as formdata it won\'t throw an error.In the first case the error is inside the displayAjax() under this.statusText as Method not Allowed.In the second case it simply works. You have to check at the server side if you passed the right post data.crossdomain not allowed throws error automatically.In the error response there are no error codes.There is only the this.type which is set to error.Why add an errorhandler if you totally have no control over errors?\nMost of the errors are returned inside this in the callback function displayAjax().So: No need for error checks if you\'re able to copy and paste the URL properly. ;)PS: As the first test I wrote x(\'x\', displayAjax)..., and it totally got a response...??? So I checked the folder where the HTML is located, and there was a file called \'x.xml\'. So even if you forget the extension of your file XMLHttpRequest 2 WILL FIND IT. I LOL\'dRead a file synchronousDon\'t do that.If you want to block the browser for a while load a nice big txt file synchronous.Now you can doThere is no other way to do this in a non-asynchronous way. (Yeah, with setTimeout loop... but seriously?)Another point is... if you work with APIs or just you own list\'s files or whatever you always use different functions for each request...Only if you have a page where you load always the same XML/JSON or whatever you need only one function. In that case, modify a little the Ajax function and replace b with your special function.The functions above are for basic use.If you want to EXTEND the function...Yes, you can.I\'m using a lot of APIs and one of the first functions I integrate in every HTML page is the first Ajax function in this answer, with GET only...But you can do a lot of stuff with XMLHttpRequest 2:I made a download manager (using ranges on both sides with resume, filereader, filesystem), various image resizers converters using canvas, populate websql databases with base64images and much more... But in these cases you should create a function only for that purpose... sometimes you need a blob, arraybuffers, you can set headers, override mimetype and there is a lot more...But the question here is how to return an Ajax response... (I added an easy way.)You are using Ajax incorrectly. The idea is not to have it return anything, but instead hand off the data to something called a callback function, which handles the data.That is:Returning anything in the submit handler will not do anything. You must instead either hand off the data, or do what you want with it directly inside the success function.The simplest solution is create a JavaScript function and call it for the Ajax success callback.I will answer with a horrible-looking, hand-drawn comic. The second image is the reason why result is undefined in your code example.For people who are using AngularJS, can handle this situation using Promises.Here it says,Promises can be used to unnest asynchronous functions and allows one to chain multiple functions together.You can find a nice explanation here also.Example found in docs mentioned below.In Angular2 with look at the following example, but its recommended to use Observables with Angular2.}You can consume that in this way,See the original post here. But Typescript does not support native es6 Promises, if you want to use it, you might need plugin for that.Additionally here is the promises spec define here.Have a look at this example:As you can see getJoke is returning a resolved promise (it is resolved when returning res.data.value). So you wait until the $http.get request is completed and then console.log(res.joke) is executed (as a normal asynchronous flow).This is the plnkr:http://embed.plnkr.co/XlNR7HpCaIhJxskMJfSg/Most of the answers here give useful suggestions for when you have a single async operation, but sometimes, this comes up when you need to do an asynchronous operation for each entry in an array or other list-like structure. The temptation is to do this:Example:The reason that doesn\'t work is that the callbacks from doSomethingAsync haven\'t run yet by the time you\'re trying to use the results.So, if you have an array (or list of some kind) and want to do async operations for each entry, you have two options: Do the operations in parallel (overlapping), or in series (one after another in sequence).You can start all of them and keep track of how many callbacks you\'re expecting, and then use the results when you\'ve gotten that many callbacks:Example:(We could do away with expecting and just use results.length === theArray.length, but that leaves us open to the possibility that theArray is changed while the calls are outstanding...)Notice how we use the index from forEach to save the result in results in the same position as the entry it relates to, even if the results arrive out of order (since async calls don\'t necessarily complete in the order in which they were started).But what if you need to return those results from a function? As the other answers have pointed out, you can\'t; you have to have your function accept and call a callback (or return a Promise). Here\'s a callback version:Example:Or here\'s a version returning a Promise instead:Of course, if doSomethingAsync passed us errors, we\'d use reject to reject the promise when we got an error.)Example:(Or alternately, you could make a wrapper for doSomethingAsync that returns a promise, and then do the below...)If doSomethingAsync gives you a Promise, you can use Promise.all:Example:Note that Promise.all resolves its promise with an array of the results of all of the promises you give it when they are all resolved, or rejects its promise when the first of the promises you give it rejects.Suppose you don\'t want the operations to be in parallel? If you want to run them one after another, you need to wait for each operation to complete before you start the next. Here\'s an example of a function that does that and calls a callback with the result:(Since we\'re doing the work in series, we can just use results.push(result) since we know we won\'t get results out of order. In the above we could have used results[index] = result;, but in some of the following examples we don\'t have an index to use.)Example:(Or, again, build a wrapper for doSomethingAsync that gives you a promise and do the below...)If doSomethingAsync gives you a Promise, if you can use ES2017+ syntax (perhaps with a transpiler like Babel), you can use an async function with for-of and await:Example:If you can\'t use ES2017+ syntax (yet), you can use a variation on the "Promise reduce" pattern (this is more complex than the usual Promise reduce because we\'re not passing the result from one into the next, but instead gathering up their results in an array):Example:...which is less cumbersome with ES2015+ arrow functions:Example:Another approach to return a value from an asynchronous function, is to pass in an object that will store the result from the asynchronous function.Here is an example of the same:I am using the result object to store the value during the asynchronous operation. This allows the result be available even after the asynchronous job.I use this approach a lot. I would be interested to know how well this approach works where wiring the result back through consecutive modules is involved.While promises and callbacks work fine in many situations, it is a pain in the rear to express something like:You\'d end up going through async1; check if name is undefined or not and call the callback accordingly.While it is okay in small examples it gets annoying when you have a lot of similar cases and error handling involved.Fibers helps in solving the issue.You can checkout the project here.Short answer is, you have to implement a callback like this:You can use this custom library (written using Promise) to make a remote call.Simple usage example:The following example I have written shows how toThis working example is self-contained. It will define a simple request object that uses the window XMLHttpRequest object to make calls. It will define a simple function to wait for a bunch of promises to be completed.Context. The example is querying the Spotify Web API endpoint in order to search for playlist objects for a given set of query strings:For each item, a new Promise will fire a block - ExecutionBlock, parse the result, schedule a new set of promises based on the result array, that is a list of Spotify user objects and execute the new HTTP call within the ExecutionProfileBlock asynchronously.You can then see a nested Promise structure, that lets you spawn multiple and completely asynchronous nested HTTP calls, and join the results from each subset of calls through Promise.all.NOTE\nRecent Spotify search APIs will require an access token to be specified in the request headers:So, you to run the following example you need to put your access token in the request headers:I have extensively discussed this solution here.Another solution is to execute code via sequential executor nsynjs.nsynjs will evaluate all promises sequentially, and put promise result into data property:Step 1. Wrap function with callback into nsynjs-aware wrapper (if it has promisified version, you can skip this test):Step 2. Put synchronous logic into function:Step 3. Run function in synchronous manner via nnsynjs:Nsynjs will evaluate all operators and expressions step-by-step, pausing execution in case if result of some slow function is not ready.More examples here: https://github.com/amaksr/nsynjs/tree/master/examplesThis is one of the places which two ways data binding that\'s used in many new JavaScript frameworks will work greatly!So if you are using Angular, React or any other frameworks which do two ways data binding, this issue is simply fixed, so in easy word, your result is undefined at the first stage, so you have got result = undefined before you recieve the data, then as soon as you get the result, it will updated and get assigned to the new value which is respond of your Ajax call...But how you can do it in pure javascript or jQuery for example as you asked in this question?You can use a callback, promise and recently observable to handle it for you, for example in promises we have some function like success() or then() which will be executed when your data is ready for you, same with callback or subscribe function on observable.For example in your case which you are using jQuery, you can do something like this:For more information study about promises and observables which are newer ways to do this async stuffs.Short answer: Your foo() method returns immediately, while the $ajax() call executes asynchronously after the function returns. The problem is then how or where to store the results retrieved by the async call once it returns.Several solutions have been given in this thread. Perhaps the easiest way is to pass an object to the foo() method, and to store the results in a member of that object after the async call completes.Note that the call to foo() will still return nothing useful. However, the result of the async call will now be stored in result.response.This is quite simple:Here\'s a working version of your code:await is supported in all current browsers and node 8Use a callback() function inside the foo() success.\nTry in this way. It is simple and easy to understand.Of course there are many approaches like synchronous request, promise, but from my experience I think you should use the callback approach. It\'s natural to asynchronous behavior of Javascript.\nSo, your code snippet can be rewrite a little different: