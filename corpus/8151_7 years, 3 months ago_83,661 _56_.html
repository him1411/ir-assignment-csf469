All activities in my application require a user to be logged-in to view. Users can log out from almost any activity. This is a requirement of the application. At any point if the user logs-out, I want to send the user to the Login Activity. At this point I want this activity to be at the bottom of the history stack so that pressing the "back" button returns the user to Android\'s home screen.I\'ve seen this question asked a few different places, all answered with similar answers (that I outline here), but I want to pose it here to collect feedback.I\'ve tried opening the Login activity by setting its Intent flags to FLAG_ACTIVITY_CLEAR_TOP which seems to do as is outlined in the documentation, but does not achieve my goal of placing the Login activity at the bottom of the history stack, and preventing the user from navigating back to previously-seen logged-in activities. I also tried using android:launchMode="singleTop" for the Login activity in the manifest, but this does not accomplish my goal either (and seems to have no effect anyway).I believe I need to either clear the history stack, or finish all previously- opened activities.One option is to have each activity\'s onCreate check logged-in status, and finish() if not logged-in. I do not like this option, as the back button will still be available for use, navigating back as activities close themselves.The next option is to maintain a LinkedList of references to all open activities that is statically accessible from everywhere (perhaps using weak references). On logout I will access this list and iterate over all previously-opened activities, invoking finish() on each one. I\'ll probably begin implementing this method soon.I\'d rather use some Intent flag trickery to accomplish this, however. I\'d be beyond happy to find that I can fulfill my application\'s requirements without having to use either of the two methods that I\'ve outlined above.Is there a way to accomplish this by using Intent or manifest settings, or is my second option, maintaining a LinkedList of opened activities the best option? Or is there another option that I\'m completely overlooking?I can suggest you another approach IMHO more robust.\nBasically you need to broadcast a logout message to all your Activities needing to stay under a logged-in status. So you can use the sendBroadcast and install a BroadcastReceiver in all your Actvities.\nSomething like this:The receiver (secured Activity):It seems a rite of passage that a new Android programmer spends a day researching this issue and reading all of these StackOverflow threads. I am now newly initiated and I leave here trace of my humble experience to help a future pilgrim.First, there is no obvious or immediate way to do this per my research (as of September 2012). You\'d think you could simple startActivity(new Intent(this, LoginActivity.class), CLEAR_STACK) but no.You CAN do startActivity(new Intent(this, LoginActivity.class)) with FLAG_ACTIVITY_CLEAR_TOP - and this will cause the framework to search down the stack, find your earlier original instance of LoginActivity, recreate it and clear the rest of the (upwards) stack. And since Login is presumably at the bottom of the stack, you now have an empty stack and the Back button just exits the application.BUT - this only works if you previously left that original instance of LoginActivity alive at the base of your stack. If, like many programmers, you chose to finish() that LoginActivity once the user has successfully logged in, then it\'s no longer on the base of the stack and the FLAG_ACTIVITY_CLEAR_TOP semantics do not apply ... you end up creating a new LoginActivity on top of the existing stack. Which is almost certainly NOT what you want (weird behavior where the user can \'back\' their way out of login into a previous screen).So if you have previously finish()\'d the LoginActivity, you need to pursue some mechanism for clearing your stack and then starting a new LoginActivity. It seems like the answer by @doreamon in this thread is the best solution (at least to my humble eye):https://stackoverflow.com/a/9580057/614880I strongly suspect that the tricky implications of whether you leave LoginActivity alive are causing a lot of this confusion.Good Luck.UPDATEthe super finishAffinity() method will help to reduce the code but achieve the same. It will finish the current activity as well as all activities in the stack, use getActivity().finishAffinity() if you are in a fragment.   ORIGINAL ANSWERAssume that LoginActivity --> HomeActivity --> ... --> SettingsActivity call signOut(): HomeActivity: This works for me, hope that it is helpful for you too. :) If you are using API 11 or higher you can try this: FLAG_ACTIVITY_CLEAR_TASK--it seems to be addressing exactly the issue you\'re having.  Obviously the pre-API 11 crowd would have to use some combination of having all activities check an extra, as @doreamon suggests, or some other trickery.(Also note: to use this you have to pass in FLAG_ACTIVITY_NEW_TASK)I spent a few hours on this too ... and agree that FLAG_ACTIVITY_CLEAR_TOP sounds like what you\'d want: clear the entire stack, except for the activity being launched, so the Back button exits the application. Yet as Mike Repass mentioned, FLAG_ACTIVITY_CLEAR_TOP only works when the activity you\'re launching is already in the stack; when the activity\'s not there, the flag doesn\'t do anything. What to do? Put the activity being launching in the stack with FLAG_ACTIVITY_NEW_TASK, which makes that activity the start of a new task on the history stack. Then add the FLAG_ACTIVITY_CLEAR_TOP flag. Now, when FLAG_ACTIVITY_CLEAR_TOP goes to find the new activity in the stack, it\'ll be there and be pulled up before everything else is cleared.Here\'s my logout function; the View parameter is the button to which the function\'s attached.Lots of answers. May be this one will also help-Use this it should be helpful to you. Slightly modified xbakesx answer.Accepted solution is not correct, it has problems as using a broadcast receiver is not a good idea for this problem. If your activity has already called onDestroy() method, you will not get receiver. Best solution is having a boolean value on your shared preferences, and checking it in your activty\'s onCreate() method. If it should not be called when user is not logged in, then finish activity. Here is sample code for that. So simple and works for every condition.The selected answer is clever and tricky. Here\'s how I did it:LoginActivity is the root activity of the task, set android:noHistory="true" to it in Manifest.xml;\nSay you want to logout from SettingsActivity, you can do it as below:Here is the solution I came up with in my app.In my LoginActivity, after successfully processing a login, I start the next one differently depending on the API level.Then in my LoginActivity\'s onActivityForResult method:Finally, after processing a logout in any other Activity:When on Gingerbread, makes it so if I press the back button from MainActivity, the LoginActivity is immediately hidden.  On Honeycomb and later, I just finish the LoginActivity after processing a login and it is properly recreated after processing a logout.Start you activity with StartActivityForResult and while you logout set your result and according to you result finish your activity The solution @doreamon provided works fine for all the cases except one:If After login, Killing Login screen user navigated direct to a middle screen. e.g.\nIn a flow of A->B->C, navigate like : Login -> B -> C -> Press shortcut to home. Using FLAG_ACTIVITY_CLEAR_TOP clears only C activity, As the Home(A) is not on stack history.\nPressing Back on A screen will lead us back to B. To tackle this problem, We can keep an activity stack(Arraylist) and when home is pressed, we have to kill all the activities in this stack.It is possible by managing a flag in SharedPreferences or in Application Activity.On starting of app (on Splash Screen) set the flag = false; On Logout Click event just set the flag true and in OnResume() of every activity, check if flag is true then call finish().It works like a charm :) on click of Logout you may call thisonActivityResult() of previous Activity call this above code again until you finished the all activities.This worked for me:Sometime finish() not workingI have solved that issue with finishAffinity()One option is to have each activity\'s onCreate check logged-in status, and finish() if not logged-in. I do not like this option, as the back button will still be available for use, navigating back as activities close themselves.What you want to do is call logout() and finish() on your onStop() or onPause() methods. This will force Android to call onCreate() when the activity is brought back on since it won\'t have it in its activity\'s stack any longer. Then do as you say, in onCreate() check logged in status and forward to login screen if not logged in.Another thing you could do is check logged in status in onResume(), and if not logged in, finish() and launch login activity.