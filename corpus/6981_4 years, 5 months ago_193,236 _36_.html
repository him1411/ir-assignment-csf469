I\'m using Spring MVC for a simple JSON API, with @ResponseBody based approach like the following. (I already have a service layer producing JSON directly.)Question is, in the given scenario, what is the simplest, cleanest way to respond with a HTTP 400 error?I did come across approaches like:...but I can\'t use it here since my method\'s return type is String, not ResponseEntity.change your return type to ResponseEntity<>, then you can use below for 400and for correct requestUPDATE 1after spring 4.1 there are helper methods in ResponseEntity could be used asandSomething like this should work, I\'m not sure whether or not there is a simpler way:Not necessarily the most compact way of doing this, but quite clean IMOEdit you can use @ResponseBody in the exception handler method if using Spring 3.1+, otherwise use a ModelAndView or something.https://jira.springsource.org/browse/SPR-6902I would change the implementation slightly:First, I create a UnknownMatchException: Note the use of @ResponseStatus, which will be recognized by Spring\'s ResponseStatusExceptionResolver. If the exception is thrown, it will create a response with the corresponding response status. (I also took the liberty of changing the status code to 404 - Not Found which I find more appropriate for this use case, but you can stick to HttpStatus.BAD_REQUEST if you like.)Next, I would change the MatchService to have the following signature:Finally, I would update the controller and delegate to Spring\'s MappingJackson2HttpMessageConverter to handle the JSON serialization automatically (it is added by default if you add Jackson to the classpath and add either @EnableWebMvc or <mvc:annotation-driven /> to your config, see the reference docs):Note, it is very common to separate the domain objects from the view objects or DTO objects. This can easily be achieved by adding a small DTO factory that returns the serializable JSON object:Here\'s a different approach. Create a custom Exception annotated with @ResponseStatus, like the following one.And throw it when needed.Check out the Spring documentation here: http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#mvc-ann-annotated-exceptions.I m using this in my spring boot application As mentioned in some answers, there is the ability to create an exception class for each HTTP status that you want to return.  I don\'t like the idea of having to create a class per status for each project.  Here is what I came up with instead.Let\'s get to the codeThen I create a controller advice classTo use ithttp://javaninja.net/2016/06/throwing-exceptions-messages-spring-mvc-controller/With Spring Boot, I\'m not entirely sure why this was necessary (I got the /error fallback even though @ResponseBody was defined on an @ExceptionHandler), but the following in itself did not work:It still threw an exception, apparently because no producible media types were defined as a request attribute:So I added them.And this got me through to have a "supported compatible media type", but then it still didn\'t work, because my ErrorMessage was faulty:JacksonMapper did not handle it as "convertable", so I had to add getters/setters, and I also added @JsonProperty annotationThen I received my message as intendedI think this thread actually has the easiest, cleanest solution, that does not sacrifice the JSON martialing tools that Spring provides:https://stackoverflow.com/a/16986372/1278921