How can I achieve this?Everything I have tried so far always returns type Object rather than the specific type used.As others mentioned, it\'s only possible via reflection in certain circumstances.If you really need the type, this is the usual (type-safe) workaround pattern:I have seen something like thisin the hibernate GenericDataAccessObjects ExampleGenerics are not reified at run-time. This means the information is not present at run-time.Adding generics to Java while mantaining backward compatibility was a tour-de-force (you can see the seminal paper about it: Making the future safe for the past: adding genericity to the Java programming language).There is a rich literature on the subject, and some people are dissatisfied with the current state, some says that actually it\'s a lure and there is no real need for it. You can read both links, I found them quite interesting.Sure, you can.Java does not use the information at run time, for backwards compatibility reasons.  But the information is actually present as metadata and can be accessed via reflection (but it is still not used for type-checking).From the official API:http://download.oracle.com/javase/6/docs/api/java/lang/reflect/ParameterizedType.html#getActualTypeArguments%28%29However, for your scenario I would not use reflection.  I\'m personally more inclined to use that for framework code.  In your case I would just add the type as a constructor param.Use Guava.A while back, I posted some full-fledge examples including abstract classes and subclasses here.Note: this requires that you instantiate a subclass of GenericClass so it can bind the type parameter correctly. Otherwise it\'ll just return the type as T.Java generics are mostly compile time, this means that the type information is lost at runtime.will be compiled to something likeTo get the type information at runtime you have to add it as an argument of the ctor.Example:Technique described in this article by Ian Robertson works for me.In short quick and dirty example:I dont think you can, Java uses type erasure when compiling so your code is compatible with applications and libraries that were created pre-generics.From the Oracle Docs:Type ErasureGenerics were introduced to the Java language to provide tighter type\n  checks at compile time and to support generic programming. To\n  implement generics, the Java compiler applies type erasure to:Replace all type parameters in generic types with their bounds or\n  Object if the type parameters are unbounded. The produced bytecode,\n  therefore, contains only ordinary classes, interfaces, and methods.\n  Insert type casts if necessary to preserve type safety. Generate\n  bridge methods to preserve polymorphism in extended generic types.\n  Type erasure ensures that no new classes are created for parameterized\n  types; consequently, generics incur no runtime overhead.http://docs.oracle.com/javase/tutorial/java/generics/erasure.htmlI used follow approach:This is my solution:Here is working solution!!!NOTES:\nCan be used only as superclass\n 1. Has to be extended with typed class  (Child extends Generic<Integer>)\nOR\n 2. Has to be created as anonymous implementation (new Generic<Integer>() {};)   I think there is another elegant solution.What you want to do is (safely) "pass" the type of the generic type parameter up from the concerete class to the superclass.If you allow yourself to think of the class type as "metadata" on the class, that suggests the Java method for encoding metadata in at runtime:  annotations.First define a custom annotation along these lines:You can then have to add the annotation to your subclass.Then you can use this code to get the class type in  your base class:Some limitations of this approach are:You can\'t.  If you add a member variable of type T to the class (you don\'t even have to initialise it), you could use that to recover the type.Just in case you use store a variable using the generic type you can easily solve this problem adding a getClassType method as follows:I use the provided class object later to check if it is an instance of a given class, as follows:Here is my trick:To complete some of the answers here, I had to get the ParametrizedType of MyGenericClass, no matter how high is the hierarchy, with the help of recursion:Here is my solutionNo matter how many level does your class hierarchy has,\nthis solution still works, for example:In this case, getMyType() = java.lang.StringHere\'s one way, which I\'ve had to use once or twice:Along withI found this to be a simple understandable and easily explainable  solutionYou don\'t need a constructor.