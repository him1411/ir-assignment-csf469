Eclipse issues warnings when a serialVersionUID is missing.  The serializable class Foo does not declare a static final\n  serialVersionUID field of type longWhat is serialVersionUID and why is it important?  Please show an example where missing serialVersionUID will cause a problem.The docs for java.io.Serializable are probably about as good an explanation as you\'ll get:The serialization runtime associates\n  with each serializable class a version\n  number, called a serialVersionUID,\n  which is used during deserialization\n  to verify that the sender and receiver\n  of a serialized object have loaded\n  classes for that object that are\n  compatible with respect to\n  serialization. If the receiver has\n  loaded a class for the object that has\n  a different serialVersionUID than that\n  of the corresponding sender\'s class,\n  then deserialization will result in an\n  InvalidClassException. A serializable\n  class can declare its own\n  serialVersionUID explicitly by\n  declaring a field named\n  "serialVersionUID" that must be\n  static, final, and of type long:If a\n  serializable class does not explicitly\n  declare a serialVersionUID, then the\n  serialization runtime will calculate a\n  default serialVersionUID value for\n  that class based on various aspects of\n  the class, as described in the\n  Java(TM) Object Serialization\n  Specification. However, it is strongly\n  recommended that all serializable\n  classes explicitly declare\n  serialVersionUID values, since the\n  default serialVersionUID computation\n  is highly sensitive to class details\n  that may vary depending on compiler\n  implementations, and can thus result\n  in unexpected InvalidClassExceptions\n  during deserialization. Therefore, to\n  guarantee a consistent\n  serialVersionUID value across\n  different java compiler\n  implementations, a serializable class\n  must declare an explicit\n  serialVersionUID value. It is also\n  strongly advised that explicit\n  serialVersionUID declarations use the\n  private modifier where possible, since\n  such declarations apply only to the\n  immediately declaring\n  class--serialVersionUID fields are not\n  useful as inherited members.If you\'re serializing just because you have to serialize for the implementation\'s sake (who cares if you serialize for an HTTPSession, for instance...if it\'s stored or not, you probably don\'t care about de-serializing a form object), then you can ignore this.If you\'re actually using serialization, it only matters if you plan on storing and retrieving objects using serialization directly.  The serialVersionUID represents your class version, and you should increment it if the current version of your class is not backwards compatible with its previous version.Most of the time, you will probably not use serialization directly.  If this is the case, generate a default serializable uid by clicking the quick fix option and don\'t worry about it.I can\'t pass up this opportunity to plug Josh Bloch\'s book Effective Java (2nd Edition).  Chapter 11 is an indispensible resource on Java serialization.Per Josh, the automatically-generated UID is generated based on a class name, implemented interfaces, and all public and protected members.  Changing any of these in any way will change the serialVersionUID.  So you don\'t need to mess with them only if you are certain that no more than one version of the class will ever be serialized (either across processes or retrieved from storage at a later time).If you ignore them for now, and find later that you need to change the class in some way but maintain compatibility w/ old version of the class, you can use the JDK tool serialver to generate the serialVersionUID on the old class, and explicitly set that on the new class.  (Depending on your changes you may need to also implement custom serialization by adding writeObject and readObject methods - see Serializable javadoc or aforementioned chapter 11.)You can tell Eclipse to ignore these serialVersionUID  warnings:Window > Preferences > Java > Compiler > Errors / Warnings > Potential Programming ProblemsIn case you didn\'t know, there are a lot of other warnings you can enable in this section (or even have some reported as errors), many are very useful:and many more.serialVersionUID facilitates versioning of serialized data. Its value is stored with the data when serializing. When de-serializing, the same version is checked to see how the serialized data matches the current code. If you want to version your data, you normally start with a serialVersionUID of 0, and bump it with every structural change to your class which alters the serialized data (adding or removing non-transient fields). The built-in de-serialization mechanism (in.defaultReadObject()) will refuse to de-serialize from old versions of the data. But if you want to you can define your own readObject()-function which can read back old data. This custom code can then check the serialVersionUID in order to know which version the data is in and decide how to de-serialize it. This versioning technique is useful if you store serialized data which survives several versions of your code.But storing serialized data for such a long time span is not very common. It is far more common to use the serialization mechanism to temporarily write data to for instance a cache or send it over the network to another program with the same version of the relevant parts of the codebase. In this case you are not interested in maintaining backwards compatibility. You are only concerned with making sure that the code bases which are communicating indeed have the same versions of relevant classes. In order to facilitate such a check, you must maintain the serialVersionUID just like before and not forget to update it when making changes to your classes. If you do forget to update the field, you might end up with two different versions of a class with different structure but with the same serialVersionUID. If this happens, the default mechanism (in.defaultReadObject()) will not detect any difference, and try to de-serialize incompatible data. Now you might end up with a cryptic runtime error or silent failure (null fields). These types of errors might be hard to find.So to help this usecase, the Java platform offers you a choice of not setting the serialVersionUID manually. Instead, a hash of the class structure will be generated at compile-time and used as id. This mechanism will make sure that you never have different class structures with the same id, and so you will not get these hard-to-trace runtime serialization failures mentioned above.But there is a backside to the auto-generated id strategy. Namely that the generated ids for the same class might differ between compilers (as mentioned by Jon Skeet above). So if you communicate serialized data between code compiled with different compilers, it is recommended to maintain the ids manually anyway. And if you are backwards-compatible with your data like in the first use case mentioned, you also probably want to maintain the id yourself. This in order to get readable ids and have greater control over when and how they change.What is a serialVersionUID and why should I use it?SerialVersionUID is a unique identifier for each class, JVM uses it to compare the versions of the class ensuring that the same class was used during Serialization is loaded during Deserialization.Specifying one gives more control, though JVM does generate one if you don\'t specify. The value generated can differ between different compilers. Furthermore, sometimes you just want for some reason to forbid deserialization of old serialized objects [backward incompatibility], and in this case you just have to change the serialVersionUID. Java docs says:"the default serialVersionUID computation is highly sensitive to class\n  details that may vary depending on compiler implementations, and can\n  thus result in unexpected InvalidClassExceptions during\n  deserialization".You must declare serialVersionUID because it give us more control.This article has some good points on the topic.Original question has asked for \'why is it important\' and \'example\' where this Serial Version ID would be useful. Well I have found one.Say you create a Car class, instantiate it, and write it out to an object stream. The flattened car object sits in the file system for some time. Meanwhile, if the Car class is modified by adding a new field. Later on, when you try to read (i.e. deserialize) the flattened Car object, you get the java.io.InvalidClassException \xe2\x80\x93 because all serializable classes are automatically given a unique identifier. This exception is thrown when the identifier of the class is not equal to the identifier of the flattened object. If you really think about it, the exception is thrown because of the addition of the new field. You can avoid this exception being thrown by controlling the versioning yourself by declaring an explicit serialVersionUID. There is also a small performance benefit in explicitly declaring your serialVersionUID (because does not have to be calculated). So, it is best practice to add your own serialVersionUID to your Serializable classes as soon as you create them as shown below:If you get this warning on a class you don\'t ever think about serializing, and that you didn\'t declare yourself implements Serializable, it is often because you inherited from a superclass, which implements Serializable. Often then it would be better to delegate to such a object instead of using inheritance.So, instead of doand in the relevant methods call myList.foo() instead of this.foo() (or super.foo()). (This does not fit in all cases, but still quite often.)I often see people extending JFrame or such, when they really only need to delegate to this. (This also helps for auto-completing in a IDE, since JFrame has hundreds of methods, which you don\'t need when you want to call your custom ones on your class.)One case where the warning (or the serialVersionUID) is unavoidable is when you extend from AbstractAction, normally in a anonymous class, only adding the actionPerformed-method. I think there shouldn\'t be a warning in this case (since you normally can\'t reliable serialize and deserialize such anonymous classes anyway accross different versions of your class), but I\'m not sure how the compiler could recognize this.If you will never need to serialize your objects to byte array and send/store them, then you don\'t need to worry about it. If you do, then you must consider your serialVersionUID since the deserializer of the object will match it to the version of object its classloader has. Read more about it in the Java Language Specification.To understand the significance of field serialVersionUID, one should understand how Serialization/Deserialization works.When a Serializable class object is serialized Java Runtime associates a serial version no.(called as serialVersionUID) with this serialized object. At the time when you deserialize this serialized object Java Runtime matches the serialVersionUID of serialized object with the serialVersionUID of the class. If both are equal then only it proceeds with the further process of deserialization else throws InvalidClassException.So we conclude that to make Serialization/Deserialization process successful the serialVersionUID of serialized object must be equivalent to the serialVersionUID of the class. In case if programmer specifies the serialVersionUID value explicitly in the program then the same value will be associated with the serialized object and the class, irrespective of the serialization and deserialzation platform(for ex. serialization might be done on platform like windows by using sun or MS JVM and Deserialization might be on different platform Linux using Zing JVM).But in case if serialVersionUID is not specified by programmer then while doing Serialization\\DeSerialization  of any object, Java runtime uses its own algorithm to calculate it. This serialVersionUID calculation algorithm varies from one JRE to another. It is also possible that the environment where the object is serialized is using one JRE (ex: SUN JVM) and the environment where deserialzation happens is using Linux Jvm(zing). In such cases serialVersionUID associated with serialized object will be different than the serialVersionUID of class calculated at deserialzation environment. In turn deserialization will not be successful. So to avoid such situations/issues programmer must always specify serialVersionUID of Serializable class.Don\'t bother, the default calculation is really good and suffice for 99,9999% of the cases. And if you run into problems, you can - as already stated - introduce UID\'s as the need arrise (which is highly unlikely)As for an example where the missing serialVersionUID might cause a problem:I\'m working on this Java EE application that is composed of a Web module that uses an EJB module. The web module calls the EJB module remotely and passes a POJO that implements Serializable as an argument.This POJO\'s class was packaged inside the EJB jar and inside it\'s own jar in the WEB-INF/lib of the web module. They\'re actually the same class, but when I package the EJB module I unpack this POJO\'s jar to pack it together with the EJB module.The call to the EJB was failing with the Exception below because I hadn\'t declared its serialVersionUID:The serialization runtime associates with each serializable class a version number, called a serialVersionUID, which is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a different serialVersionUID than that of the corresponding sender\'s class, then deserialization will result in an InvalidClassException. A serializable class can declare its own serialVersionUID explicitly by declaring a field named serialVersionUID that must be static, final, and of type long:I generally use serialVersionUID in one context:  When I know it will be leaving the context of the Java VM.  I would know this when I to use ObjectInputStream and ObjectOutputStream for my application or if I know a library/framework I use will use it.  The serialVersionID ensures different Java VMs of varying versions or vendors will inter-operate correctly or if it is stored and retrieved outside the VM for example HttpSession the session data can remain even during a restart and upgrade of the application server.For all other cases, I use since most of the time the default serialVersionUID is sufficient.  This includes Exception, HttpServlet.It would be nice if CheckStyle could verify that the serialVersionUID on a class that implements Serializable has a good value, i.e. that it matches what the serial version id  generator would produce.  If you have a project with lots of serializable DTOs, for example, remembering to delete the existing serialVersionUID and regenerate it is a pain, and currently the only way (that I know of) to verify this is to regenerate for each class and compare to the old one.  This is very very painful.Field data represents some information stored in the class.\nClass implements the Serializable interface, \nso eclipse automatically offered  to declare the serialVersionUID field. Lets start with value 1 set there.If you don\'t want that warning to come, use this:SerialVersionUID is used for version control of object. you can specify serialVersionUID in your class file also. Consequence of not specifying serialVersionUID is that when you add or modify any field in class then already serialized class will not be able to recover because serialVersionUID generated for new class and for old serialized object will be different. Java serialization process relies on correct serialVersionUID for recovering state of serialized object and throws java.io.InvalidClassException in case of serialVersionUID mismatchRead more: http://javarevisited.blogspot.com/2011/04/top-10-java-serialization-interview.html#ixzz3VQxnpOPZIf you want to amend a huge number of classes which had no serialVersionUID set in the first place while maintain the compatibility with the old classes, tools like IntelliJ Idea, Eclipse fall short as they generate random numbers and does not work on a bunch of files in one go. I come up the following bash script(I\'m sorry for Windows users, consider buy a Mac or convert to Linux) to make amending serialVersionUID issue with ease:you save the this script, say add_serialVersionUID.sh to you ~/bin. Then you run it in the root directory of your Maven or Gradle project like:This .lst includes the list of java files to add the serialVersionUID in the following format:This script uses the JDK serialVer tool under hood. So make sure your $JAVA_HOME/bin is in the PATH.This question is very well documented in Effective Java by Joshua Bloch. A very good book and a must read. I will outline some of the reasons below :The serialization runtime comes up with a number called Serial version for each serializable class. This number is called serialVersionUID. Now there is some Math behind this number and it comes out based on the fields/methods that are defined in the class. For the same class the same version is generated every time. This number is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a different serialVersionUID than that of the corresponding sender\'s class, then deserialization will result in an InvalidClassException.If the class is serializable you can also declare your own serialVersionUID explicitly  by declaring a field named "serialVersionUID" that must be static, final, and of type long. Most IDE\'s like Eclipse help you generate that long string.Each time an object is serialized the object is stamped with a version ID number for the object\'s class.This ID is called serialVersionUID and it is computed based on information about the class structure. Suppose you made an Employee class and it has version id #333 (assigned by JVM),Now when you will serialize the object of that class (Suppose Employee object), JVM will assign UID to it as #333.Consider a situation - in the future you need to edit or change your class and in that case when you modify it, JVM will assign it a new UID (Suppose #444).\nNow when you try to deserialize the employee object, JVM will compare serialized object\'s (Employee object) version ID(#333) with that of the class i.e #444(Since it was changed). On comparison JVM will find both version UID are different and hence Deserialization will fail.\nHence if serialVersionID for each class is defined by programmer itself. It will be same even if the class is evolved in future and hence JVM will always find that class is compatible with serialized object even though the class is changed. For more Info you can refer chapter 14 of HEAD FIRST JAVA.Why use SerialVersionUID inside Serializable class in Java?During serialization, Java runtime creates a version number for a class, so that it can de-serialize it later. This version number is known as SerialVersionUID in Java.SerialVersionUID is used to version serialized data. You can only de-serialize a class if it\'s SerialVersionUID matches with the serialized instance. When we don\'t declare SerialVersionUID in our class, Java runtime generates it for us but its not recommended. It\'s recommended to declare SerialVersionUID as private static final long variable to avoid default mechanism. When you declare a class as Serializable by implementing marker interface java.io.Serializable, Java runtime persist instance of that class into disk by using default Serialization mechanism, provided you have not customized the process using Externalizable interface.see also Why use SerialVersionUID inside Serializable class in JavaCode :  javassist.SerialVersionUID