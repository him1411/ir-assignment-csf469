I found an example in the VS2008 Examples for Dynamic LINQ that allows you to use a sql-like string (e.g. OrderBy("Name, Age DESC")) for ordering. Unfortunately, the method included only works on IQueryable<T>;. Is there any way to get this functionality on IEnumerable<T>?Just stumbled into this oldie...To do this without the dynamic LINQ library, you just need the code as below. This covers most common scenarios including nested properties.To get it working with IEnumerable<T> you could add some wrapper methods that go via AsQueryable - but the code below is the core Expression logic needed.Edit: it gets more fun if you want to mix that with dynamic - although note that dynamic only applies to LINQ-to-Objects (expression-trees for ORMs etc can\'t really represent dynamic queries - MemberExpression doesn\'t support it). But here\'s a way to do it with LINQ-to-Objects. Note that the choice of Hashtable is due to favorable locking semantics:Too easy without any complication:I found the answer. I can use the .AsQueryable<>() extension method to convert my list to IQueryable, then run the dynamic order by against it.Just stumbled across this question.Using Marc\'s ApplyOrder implementation from above, I slapped together an Extension method that handles SQL-like strings like:Details can be found here: http://aonnull.blogspot.com/2010/08/dynamic-sql-like-linq-orderby-extension.htmlI guess it would work to use reflection to get whatever property you want to sort on:Note that using reflection is considerably slower than accessing the property directly, so the performance would have to be investigated.Just building on what others have said. I found that the following works quite well.I\'ve stumble this question looking for Linq multiple orderby clauses\nand maybe this was what the author was looking forHere\'s how to do that:I was trying to do this but having problems with Kjetil Watnedal\'s solution because I don\'t use the inline linq syntax - I prefer method-style syntax. My specific problem was in trying to do dynamic sorting using a custom IComparer.My solution ended up like this:Given an IQueryable query like so:And given a run-time sort field argument:The dynamic OrderBy looks like so:And that\'s using a little helper method called GetReflectedPropertyValue():One last thing - I mentioned that I wanted the OrderBy to use custom IComparer - because I wanted to do Natural sorting.To do that, I just alter the OrderBy to:See this post for the code for NaturalSortComparer().You could add it:The GetPropertyValue function is from Kjetil Watnedal\'s answerThe issue would be why? Any such sort would throw exceptions at run-time, rather than compile time (like D2VIANT\'s answer).If you\'re dealing with Linq to Sql and the orderby is an expression tree it will be converted into SQL for execution anyway.Here\'s something else I found interesting.\nIf your source is a DataTable, you can use dynamic sorting without using Dynamic Linqreference: http://msdn.microsoft.com/en-us/library/bb669083.aspx (Using DataSetExtensions)Here is one more way to do it by converting it to a DataView:Thanks to Maarten (Query a collection using PropertyInfo object in LINQ) I got this solution:In my case I was working on a "ColumnHeaderMouseClick" (WindowsForm) so just found the specific Column pressed and its correspondent PropertyInfo:OR(be sure to have your column Names matching the object Properties)CheersAfter a lot of searching this worked for me:You can convert the IEnumerable to IQueryable.An alternate solution uses the following class/interface.  It\'s not truly dynamic, but it works.Convert List to IEnumerable or Iquerable, add using System.LINQ.Dynamic namespace, then u can mention the property names in comma seperated string to OrderBy Method which comes by default from System.LINQ.Dynamic.