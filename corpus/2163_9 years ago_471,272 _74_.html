Table: I want to get the UserId, Value for the max(Date) for each UserId. That is, the Value for each UserId that has the latest date. Is there a way to do this simply in SQL? (Preferably Oracle)Update: Apologies for any ambiguity: I need to get ALL the UserIds. But for each UserId, only that row where that user has the latest date.This will retrieve all rows for which the my_date column value is equal to the maximum value of my_date for that userid. This may retrieve multiple rows for the userid where the maximum date is on multiple rows."Analytic functions rock"Edit: With regard to the first comment ..."using analytic queries and a self-join defeats the purpose of analytic queries"There is no self-join in this code. There is instead a predicate placed on the result of the inline view that contains the analytic function -- a very different matter, and completely standard practice."The default window in Oracle is from the first row in the partition to the current one"The windowing clause is only applicable in the presence of the order by clause. With no order by clause, no windowing clause is applied by default and none can be explicitly specified.The code works.I see many people use subqueries or else vendor-specific features to do this, but I often do this kind of query without subqueries in the following way.  It uses plain, standard SQL so it should work in any brand of RDBMS.In other words: fetch the row from t1 where no other row exists with the same UserId and a greater Date.(I put the identifier "Date" in delimiters because it\'s an SQL reserved word.)In case if t1."Date" = t2."Date", doubling appears. Usually tables has auto_inc(seq) key, e.g. id.\nTo avoid doubling can be used follows:Re comment from @Farhan:Here\'s a more detailed explanation:An outer join attempts to join t1 with t2.  By default, all results of t1 are returned, and if there is a match in t2, it is also returned.  If there is no match in t2 for a given row of t1, then the query still returns the row of t1, and uses NULL as a placeholder for all of t2\'s columns.  That\'s just how outer joins work in general.The trick in this query is to design the join\'s matching condition such that t2 must match the same userid, and a greater date.  The idea being if a row exists in t2 that has a greater date, then the row in t1 it\'s compared against can\'t be the greatest date for that userid.  But if there is no match -- i.e. if no row exists in t2 with a greater date than the row in t1 -- we know that the row in t1 was the row with the greatest date for the given userid.In those cases (when there\'s no match), the columns of t2 will be NULL -- even the columns specified in the join condition.  So that\'s why we use WHERE t2.UserId IS NULL, because we\'re searching for the cases where no row was found with a greater date for the given userid.I don\'t know your exact columns names, but it would be something like this:Not being at work, I don\'t have Oracle to hand, but I seem to recall that Oracle allows multiple columns to be matched in an IN clause, which should at least avoid the options that use a correlated subquery, which is seldom a good idea.Something like this, perhaps (can\'t remember if the column list should be parenthesised or not):EDIT: Just tried it for real:So it works, although some of the new-fangly stuff mentioned elsewhere may be more performant.I know you asked for Oracle, but in SQL 2005 we now use this:Wouldn\'t a QUALIFY clause be both simplest and best?For context, on Teradata here a decent size test of this runs in 17s with this QUALIFY version and in 23s with the \'inline view\'/Aldridge solution #1.I don\'t have Oracle to test it, but the most efficient solution is to use analytic queries.  It should look something like this:I suspect that you can get rid of the outer query and put distinct on the inner, but I\'m not sure.  In the meantime I know this one works.If you want to learn about analytic queries, I\'d suggest reading http://www.orafaq.com/node/55 and http://www.akadia.com/services/ora_analytic_functions.html.  Here is the short summary.Under the hood analytic queries sort the whole dataset, then process it sequentially.  As you process it you partition the dataset according to certain criteria, and then for each row looks at some window (defaults to the first value in the partition to the current row - that default is also the most efficient) and can compute values using a number of analytic functions (the list of which is very similar to the aggregate functions).In this case here is what the inner query does.  The whole dataset is sorted by UserId then Date DESC.  Then it processes it in one pass.  For each row you return the UserId and the first Date seen for that UserId (since dates are sorted DESC, that\'s the max date).  This gives you your answer with duplicated rows.  Then the outer DISTINCT squashes duplicates.This is not a particularly spectacular example of analytic queries.  For a much bigger win consider taking a table of financial receipts and calculating for each user and receipt, a running total of what they paid.  Analytic queries solve that efficiently.  Other solutions are less efficient.  Which is why they are part of the 2003 SQL standard.  (Unfortunately Postgres doesn\'t have them yet.  Grrr...)With PostgreSQL 9, you can use this:Just had to write a "live" example at work :)This one supports multiple values for UserId on the same date.Columns:\nUserId, Value, DateYou can use FIRST_VALUE instead of MAX and look it up in the explain plan. I didn\'t have the time to play with it.Of course, if searching through huge tables, it\'s probably better if you use FULL hints in your query.I think something like this. (Forgive me for any syntax mistakes; I\'m used to using HQL at this point!)EDIT: Also misread the question! Corrected the query...(T-SQL) First get all the users and their maxdate. Join with the table to find the corresponding values for the users on the maxdates.results:The answer here is Oracle only. Here\'s a bit more sophisticated answer in all SQL:Who has the best overall homework result (maximum sum of homework points)?And a more difficult example, which need some explanation, for which I don\'t have time atm:Give the book (ISBN and title) that is most popular in 2008, i.e., which is borrowed most often in 2008.Hope this helps (anyone).. :)Regards,\nGuusAssuming Date is unique for a given UserID, here\'s some TSQL:I\'m quite late to the party but the following hack will outperform both correlated subqueries and any analytics function but has one restriction: values must convert to strings. So it works for dates, numbers and other strings. The code does not look good but the execution profile is great. The reason why this code works so well is that it only needs to scan the table once. It does not require any indexes and most importantly it does not need to sort the table, which most analytics functions do. Indexes will help though if you need to filter the result for a single userid.i thing you shuold make this variant to previous query:IMHO this works. HTH    I think this should work?First try I misread the question, following the top answer, here is a complete example with correct results:----This will also take care of duplicates (return one row for each user_id):Just tested this and it seems to work on a logging tableThis should be as simple as:If you\'re using Postgres, you can use array_agg likeI\'m not familiar with Oracle. This is what I came up withBoth queries return the same results as the accepted answer. See SQLFiddles:check this link if your questions seems similar to that page then i would suggest you the following query which will give the solution for that linkselect distinct  sno,item_name,max(start_date) over(partition by sno),max(end_date) over(partition by sno),max(creation_date)  over(partition by sno),\nmax(last_modified_date)  over(partition by sno) \nfrom uniq_select_records\norder by sno,item_name asc;will given accurate results related to that linkIn Oracle 12c+, you can use Top n queries along with analytic function rank to achieve this very concisely without subqueries:The above returns all the rows with max my_date per user. If you want only one row with max date, then replace the rank with row_number:If (UserID, Date) is unique, i.e. no date appears twice for the same user then:Solution for MySQL which doesn\'t have concepts of partition KEEP, DENSE_RANK. Reference:  http://benincampus.blogspot.com/2013/08/select-rows-which-have-maxmin-value-in.html 