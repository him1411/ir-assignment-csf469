Microsoft recently (12-29-2011) released an update to address several serious security vulnerabilities in the .NET Framework.  One of the fixes introduced by MS11-100 temporarily mitigates a potential DoS attack involving hash table collisions.  It appears this fix breaks pages that contain a lot of POST data.  In our case, on pages that have very large checkbox lists.  Why would this be the case?Some non-official sources seem to indicate that MS11-100 places a limit of 500 on postback items.  I can\'t find a Microsoft source that confirms this.  I know that View State and other framework features eat up some of this limit.  Is there any configuration setting that controls this new limit?  We could switch away from using checkboxes but it works rather well for our particular situation.  We\'d also like to apply the patch because it protects against some other nasty things.Unofficial source discussing the 500 limit:The bulletin fixes the DOS attack vector by providing a limit to the\n  number of variables that can be submitted for a single HTTP POST\n  request. The default limit is 500 which should be enough for normal\n  web applications, but still low enough to neutralize the attack as\n  described by the security researchers in Germany.EDIT: Source code with example of limit (which appears to be 1,000, not 500)\nCreate a standard MVC app and add the following code to the main index view:This code worked before the patch.  It doesn\'t work after.  The error is:[InvalidOperationException: Operation is not valid due to the current\n  state of the object.]\n  System.Web.HttpValueCollection.ThrowIfMaxHttpCollectionKeysExceeded()\n  +82    System.Web.HttpValueCollection.FillFromEncodedBytes(Byte[] bytes, Encoding encoding) +111\n  System.Web.HttpRequest.FillInFormCollection() +307Try adding this setting in web.config. I just tested this on .NET 4.0 with an ASP.NET MVC 2 project and with this setting your code doesn\'t throw:That should work now (after you have applied the security update) to change the limit.I hadn\'t updated my machine yet, so using Reflector I checked the HttpValueCollection class, and it didn\'t have the ThrowIfMaxHttpCollectionKeysExceeded method:I installed KB2656351 (update for .NET 4.0), reloaded the assemblies in Reflector and the method appeared:So that method is definitely new. I used the Disassemble option in Reflector, and from what I can tell from the code it checks an AppSetting:If it doesn\'t find the value in the web.config file, it will set it to 1000 in System.Web.Util.AppSettings.EnsureSettingsLoaded (an internal static class):Also, Alexey Gusarov tweeted about this setting two days ago:And here is an official answer from a Q&A with Jonathan Ness (Security Development Manager, MSRC) and Pete Voss (Sr. Response Communications Manager, Trustworthy Computing):Q: Is AppSettings.MaxHttpCollectionKeys the new parameter that\n  contains the maximum number of form entries? A: Yes it is.For those of you still using .NET 1.1, this setting is not configured via web.config - it is a registry setting (hat tip to michielvoo, as I only discovered this through Reflector the same way he found the answer). The example below sets MaxHttpCollectionKeys to 5000 on 32-bit editions of Windows:For a 64-bit Windows edition, set the key under the Wow6432Node:I just want to add my $0.02 here for people seeing the weirdness.If your application stashes page information into ASP.NET ViewState, and exceeds the web server threshold, you\'re going to run into this problem.  Rather than applying the web.config fix problem straight away you might want to take a look at optimizing your code first.  View Source, and look for 1000+ viewstate hidden fields, and you\'ve got your problem.ThrowIfMaxHttpCollectionKeysExceeded() has also been added to the System.Web.HttpCookieCollection.It looks like when HttpCookieCollection.Get() is called, it\'s internally calling HttpCookieCollection.AddCookie(), which then is calling ThrowIfMaxHttpCollectionKeysExceeded().  What we\'re seeing is that over a period of a couple of hours the website gets progressively slower and buggier, until it starts throwing the InvalidOperationExcpetion. We then recycle the app-pool, which fixes the issue for a few more hours.