Coming from C++ to Java, the obvious unanswered question is why didn\'t Java include operator overloading?Isn\'t Complex a, b, c; a = b + c; much simpler than Complex a, b, c; a=b.add(c);?Is there a known reason for this, valid arguments for not allowing operator overloading? Is the reason arbitrary, or lost to time?Assuming you wanted to overwrite the previous value of the object referred to by \'a\', then a member function would have to be invoked.In C++, this expression tells the compiler to create 3 objects on the stack, perform addition, and copy the resultant value from the temporary object into the existing object \'a\'.However, in java, operator= doesn\'t perform value copy for reference types, and users can only create new reference types, not value types.  So for a user-defined type named \'Complex\', assignment means to copy a reference to an existing value.consider instead:In C++, this copies the value, so the comparison will result not-equal.  In Java, operator= performs reference copy, so \'a\' and \'b\' are now referring to the same value.  As a result, the comparison will produce \'equal\', since the object will compare equal to itself.The difference between copies and references only adds to the confusion of operator overloading.  As Sebastian mentioned, Java and C# both have to deal with value and reference equality separately -- operator+ would likely deal with values and objects, but operator= is already implemented to deal with references.In C++, you should only be dealing with one kind of comparison at a time, so it can be less confusing.  For example, on Complex, operator= and operator== are both working on values -- copying values and comparing values respectively.  There are a lot of posts complaining about operator overloading.I felt I had to clarify the "operator overloading" concepts, offering an alternative viewpoint on this concept.This argument is a fallacy.It is as easy to obfuscate code in C or Java through functions/methods as it is in C++ through operator overloads:For another example, let\'s see the Cloneable interface in Java:You are supposed to clone the object implementing this interface. But you could lie. And create a different object. In fact, this interface is so weak you could return another type of object altogether, just for the fun of it:As the Cloneable interface can be abused/obfuscated, should it be banned on the same grounds C++ operator overloading is supposed to be?We could overload the toString() method of a MyComplexNumber class to have it return the stringified hour of the day. Should the toString() overloading be banned, too? We could sabotage MyComplexNumber.equals to have it return a random value, modify the operands... etc. etc. etc..In Java, as in C++, or whatever language, the programmer must respect a minimum of semantics when writing code. This means implementing a add function that adds, and Cloneable implementation method that clones, and a ++ operator than increments.Now that we know that code can be sabotaged even through the pristine Java methods, we can ask ourselves about the real use of operator overloading in C++?We\'ll compare below, for different cases, the "same" code in Java and C++, to have an idea of which kind of coding style is clearer.Please note that A and B could be of any type in C++, as long as the operator overloads are provided. In Java, when A and B are not primitives, the code can become very confusing, even for primitive-like objects (BigInteger, etc.)...In Java, we see that for each container to do the same thing (access its content through an index or identifier), we have a different way to do it, which is confusing.In C++, each container uses the same way to access its content, thanks to operator overloading.The examples below use a Matrix object, found using the first links found on Google for "Java Matrix object" and "c++ Matrix object":And this is not limited to matrices. The BigInteger and BigDecimal classes of Java suffer from the same confusing verbosity, whereas their equivalents in C++ are as clear as built-in types.Ok, in Java you can use MyString = "Hello " + 25 + " World" ; too... But, wait a second: This is operator overloading, isn\'t it? Isn\'t it cheating???:-DThe same generic code modifying operands should be usable both for built-ins/primitives (which have no interfaces in Java), standard objects (which could not have the right interface), and user-defined objects.For example, calculating the average value of two values of arbitrary types:Now that we have seen fair comparisons between C++ code using operator overloading, and the same code in Java, we can now discuss "operator overloading" as a concept.Even outside of computer science, there is operator overloading: For example, in mathematics, operators like +, -, *, etc. are overloaded.Indeed, the signification of +, -, *, etc. changes depending on the types of the operands (numerics, vectors, quantum wave functions, matrices, etc.).Most of us, as part of our science courses, learned multiple significations for operators, depending on the types of the operands. Did we find them confusing, them?This is the most important part of operator overloading: Like in mathematics, or in physics, the operation depends on its operands\' types.So, know the type of the operand, and you will know the effect of the operation.In C, the real behavior of an operator will change according to its operands. For example, adding two integers is different than adding two doubles, or even one integer and one double. There is even the whole pointer arithmetic domain (without casting, you can add to a pointer an integer, but you cannot add two pointers...).In Java, there is no pointer arithmetic, but someone still found string concatenation without the + operator would be ridiculous enough to justify an exception in the "operator overloading is evil" creed.It\'s just that you, as a C (for historical reasons) or Java (for personal reasons, see below) coder, you can\'t provide your own.In C++, operator overloading for built-in types is not possible (and this is a good thing), but user-defined types can have user-defined operator overloads.As already said earlier, in C++, and to the contrary to Java, user-types are not considered second-class citizens of the language, when compared to built-in types. So, if built-in types have operators, user types should be able to have them, too.The truth is that, like the toString(), clone(), equals() methods are for Java (i.e. quasi-standard-like), C++ operator overloading is so much part of C++ that it becomes as natural as the original C operators, or the before mentioned Java methods.Combined with template programming, operator overloading becomes a well known design pattern. In fact, you cannot go very far in STL without using overloaded operators, and overloading operators for your own class.Operator overloading should strive to respect the semantics of the operator. Do not subtract in a + operator (as in "do not subtract in a add function", or "return crap in a clone method").Cast overloading can be very dangerous because they can lead to ambiguities. So they should really be reserved for well defined cases. As for && and ||, do not ever overload them unless you really know what you\'re doing, as you\'ll lose the the short circuit evaluation that the native operators && and || enjoy.Because James Gosling said so:I left out operator overloading as a fairly personal choice because I had seen too many people abuse it in C++.James Gosling. Source: http://www.gotw.ca/publications/c_family_interview.htmPlease compare Gosling\'s text above with Stroustrup\'s below:Many C++ design decisions have their roots in my dislike for forcing people to do things in some particular way [...] Often, I was tempted to outlaw a feature I personally disliked, I refrained from doing so because I did not think I had the right to force my views on others.Bjarne Stroustrup. Source: The Desing and Evolution of C++ (1.3 General Background)Some objects would greatly benefit from operator overloading (concrete or numerical types, like BigDecimal, complex numbers, matrices, containers, iterators, comparators, parsers etc.).In C++, you can profit from this benefit because of Stroustrup\'s humility. In Java, you\'re simply screwed because of Gosling\'s personal choice.The reasons for not adding operator overloading now in Java could be a mix of internal politics, allergy to the feature, distrust of developers (you know, the saboteur ones that seem to haunt Java teams...), compatibility with the previous JVMs, time to write a correct specification, etc..So don\'t hold your breath waiting for this feature...Yeah...While this is far from being the only difference between the two languages, this one never fails to amuse me.Apparently, the C# folks, with their "every primitive is a struct, and a struct derives from Object", got it right at first try.Despite all the FUD against used defined operator overloading, the following languages support it: Scala, Dart, Python, F#, C#, D, Algol 68, Smalltalk, Groovy, Perl 6, C++, Ruby, Haskell, MATLAB, Eiffel, Lua, Clojure, Fortran 90, Swift, Ada, Delphi 2005...So many languages, with so many different (and sometimes opposing) philosophies, and yet they all agree on that point.Food for thought...James Gosling likened designing Java to the following:"There\'s this principle about moving, when you move from one apartment to another apartment. An interesting experiment is to pack up your apartment and put everything in boxes, then move into the next apartment and not unpack anything until you need it. So you\'re making your first meal, and you\'re pulling something out of a box. Then after a month or so you\'ve used that to pretty much figure out what things in your life you actually need, and then you take the rest of the stuff -- forget how much you like it or how cool it is -- and you just throw it away. It\'s amazing how that simplifies your life, and you can use that principle in all kinds of design issues: not do things just because they\'re cool or just because they\'re interesting."You can read the context of the quote hereBasically operator overloading is great for a class that models some kind of point, currency or complex number. But after that you start running out of examples fast.Another factor was the abuse of the feature in C++ by developers overloading operators like \'&&\', \'||\', the cast operators and of course \'new\'. The complexity resulting from combining this with pass by value and exceptions is well covered in the Exceptional C++ book.Check out Boost.Units: link textIt provides zero-overhead Dimensional analysis through operator overloading. How much clearer can this get?would actually output "Energy = 4 J" which is correct.The Java designers decided that operator overloading was more trouble than it was worth. Simple as that.In a language where every object variable is actually a reference, operator overloading gets the additional hazard of being quite illogical - to a C++ programmer at least. Compare the situation with C#\'s == operator overloading and Object.Equals and Object.ReferenceEquals (or whatever it\'s called).Groovy has operator overloading, and runs in the JVM. If you don\'t mind the performance hit (which gets smaller everyday). It\'s automatic based on method names. e.g., \'+\' calls the \'plus(argument)\' method.Well you can really shoot yourself in the foot with operator overloading. It\'s like with pointers people make stupid mistakes with them and so it was decided to take the scissors away.At least I think that\'s the reason.\nI\'m on your side anyway. :)I think this may have been a conscious design choice to force developers to create functions whose names clearly communicate their intentions. In C++ developers would overload operators with functionality that would often have no relation to the commonly accepted nature of the given operator, making it nearly impossible to determine what a piece of code does without looking at the definition of the operator.Saying  that operator overloading leads to logical errors of type that operator does not match the operation logic, it\'s like saying nothing. The same type of error will occur if function name is inappropriate for operation logic - so what\'s the solution: drop the ability of function usage!? \n This is a comical answer - "Inappropriate for operation logic", every parameter name, every class, function or whatever can be logicly inappropriate.\nI think that this option should be available in respectable programing language, and those that think that it\'s unsafe - hey no bothy says you have to use it. \nLets take the C#. They drooped the pointers but hey - there is \'unsafe code\' statement - program as you like on your own risk.Technically, there is operator overloading in every programming language that can deal with different types of numbers, e.g. integer and real numbers. Explanation: The term overloading means that there are simply several implementations for one function. In most programming languages different implementations are provided for the operator +, one for integers, one for reals, this is called operator overloading.Now, many people find it strange that Java has operator overloading for the operator + for adding strings together, and from a mathematical standpoint this would be strange indeed, but seen from a programming language\'s developer\'s standpoint, there is nothing wrong with adding builtin operator overloading for the operator + for other classes e.g. String. However, most people agree that once you add builtin overloading for + for String, then it is generally a good idea to provide this functionality for the developer as well.A completely disagree with the fallacy that operator overloading obfuscates code, as this is left for the developer to decide. This is na\xc3\xafve to think, and to be quite honest, it is getting old.+1 for adding operator overloading in Java 8.Some people say that operator overloading in Java would lead to obsfuscation. Have those people ever stopped to look at some Java code doing some basic maths like increasing a financial value by a percentage using BigDecimal ? .... the verbosity of such an exercise becomes its own demonstration of obsfuscation. Ironically, adding operator overloading to Java would allow us to create our own Currency class which would make such mathematical code elegant and simple (less obsfuscated).Assuming Java as the implementation language then a, b, and c would all be references to type Complex with initial values of null. Also assuming that Complex is immutable as the mentioned BigInteger and similar immutable BigDecimal, I\'d I think you mean the following, as you\'re assigning the reference to the Complex returned from adding b and c, and not comparing this reference to a.Isn\'t :much simpler than:Sometimes it would be nice to have operator overloading, friend classes and multiple inheritance.However I still think it was a good decision. If Java would have had operator overloading then we could never be sure of operator meanings without looking through source code. At present that\'s not necessary. And I think your example of using methods instead of operator overloading is also quite readable. If you want to make things more clear you could always add a comment above hairy statements.