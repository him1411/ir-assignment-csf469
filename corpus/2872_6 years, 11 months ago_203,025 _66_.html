In my Redis DB I have a number of prefix:<numeric_id> hashes.Sometimes I want to purge them all atomically. How do I do this without using some distributed locking mechanism?Starting with redis 2.6.0, you can run lua scripts, which execute atomically. I have never written one, but I think it would look something like thisUPDATE: link to EVAL documentation.Execute in bash:UPDATEOk, i understood. What about this way: store current additional incremental prefix and add it to all your keys. For example:You have values like this:When you need to purge data, you change prefix_actuall first (for example set prefix_prefix_actuall = 3), so your application will write new data to keys prefix:3:1 and prefix:3:2. Then you can safely take old values from prefix:2:1 and prefix:2:2 and purge old keys.Here\'s a completely working and atomic version of a wildcard delete implemented in Lua. It\'ll run much faster than the xargs version due to much less network back-and-forth, and it\'s completely atomic, blocking any other requests against redis until it finishes. If you want to atomically delete keys on Redis 2.6.0 or greater, this is definitely the way to go:This is a working version of @mcdizzle\'s idea in his answer to this question. Credit for the idea 100% goes to him.EDIT: Per Kikito\'s comment below, if you have more keys to delete than free memory in your Redis server, you\'ll run into the "too many elements to unpack" error. In that case, do:As Kikito suggested.Disclaimer: the following solution doesn\'t provide atomicity.Starting with v2.8 you really want to use the SCAN command instead of KEYS[1]. The following Bash script demonstrates deletion of keys by pattern:[1] KEYS is a dangerous command that can potentially result in a DoS. The following is a quote from its documentation page:Warning: consider KEYS as a command that should only be used in production environments with extreme care. It may ruin performance when it is executed against large databases. This command is intended for debugging and special operations, such as changing your keyspace layout. Don\'t use KEYS in your regular application code. If you\'re looking for a way to find keys in a subset of your keyspace, consider using sets.UPDATE: a one liner for the same basic effect -For those who were having trouble parsing other answers: Replace key:*:pattern with your own pattern and enter this into redis-cli and you are good to go.Credit lisco from: http://redis.io/commands/del@mcdizle\'s solution is not working it works only for one entry.This one works for all keys with same prefixNote: You should replace \'prefix\' with your key prefix...If you have space in the name of the keys, you can use this in bash:@itamar\'s answer is great, but the parsing of the reply wasn\'t working for me, esp. in the case where there are no keys found in a given scan. A possibly simpler solution, directly from the console:This also uses SCAN, which is preferable to KEYS in production, but is not atomic.I am using below command in redis 3.2.8You can get more help related to keys pattern search from here :- https://redis.io/commands/keys. Use your convenient glob-style pattern as per your requirement like *YOUR_KEY_PREFIX* or YOUR_KEY_PREFIX?? or any other.And if any of you have integrated Redis PHP library than below function will help you.Thank you :)I think what might help you is the MULTI/EXEC/DISCARD. While not 100% equivalent of transactions, you should be able to isolate the deletes from other updates.I just had the same problem. I stored session data for a user in the format:So, each entry was a seperate key-value pair. When the session is destroyed, I wanted to remove all session data by deleting keys with the pattern session:sessionid:* - but redis does not have such a function.What I did: store the session data within a hash. I just create a hash with the hash id of session:sessionid and then I push key-x, key-y, key-z in that hash (order did not matter to me) and if I dont need that hash anymore I just do a DEL session:sessionid and all data associated with that hash id is gone. DEL is atomic and accessing data/writing data to the hash is O(1).You can also use this command to delete the keys:-Suppose there are many types of keys in your redis like-Ex- \'xyz_category_fpc\' here xyz is a sitename, and these keys are        related to products and categories of a E-Commerce site and generated by FPC.If you use this command as below-ORIt deletes all the keys like \'xyz_category_fpc\' (delete 1, 2 and 3 keys). For delete other 4, 5 and 6 number keys use \'xyz_product_fpc\' in above command.If you want to Delete Everything in Redis, then follow these Commands-With redis-cli:For Example:- in your shell:FYI.Maybe you only need to modify capital characters.scan-match.sh clear-redis-key.shRun at bash promptThis is not direct answer to the question, but since I got here when searching for my own answers, I\'ll share this here.If you have tens or hundreds of millions of keys you have to match, the answers given here will cause Redis to be non responsive for significant amount of time (minutes?), and potentially crash because of memory consumption (be sure, background save will kick in in the middle of your operation).The following approach is undeniably ugly, but I didn\'t find a better one. Atomicity is out of question here, in this case main goal is to keep Redis up and responsive 100% of the time. It will work perfectly if you have all your keys in one of databases and you don\'t need to match any pattern, but cannot use http://redis.io/commands/FLUSHDB because of it\'s blocking nature.Idea is simple: write a script that runs in a loop and uses O(1) operation like http://redis.io/commands/SCAN or http://redis.io/commands/RANDOMKEY to get keys, checks if they match the pattern (if you need it) and http://redis.io/commands/DEL them one by one. If there is a better way to do it, please let me know, I\'ll update the answer.Example implementation with randomkey in Ruby, as a rake task, a non blocking substitute of something like redis-cli -n 3 flushdb:I support all answers related to having some tool or execute Lua expression.One more option from my side:In our production and pre-production databases there are thousands of keys. Time to time we need to delete some keys (by some mask), modify by some criteria etc. Of course, there is no way to do it manually from CLI, especially having sharding (512 logical dbs in each physical).For this purpose I write java client tool that does all this work. In case of keys deletion the utility can be very simple, only one class there:A version using SCAN rather than KEYS (as recommended for production servers) and --pipe rather than xargs. I prefer pipe over xargs because it\'s more efficient and works when your keys contain quotes or other special characters that your shell with try and interpret. The regex substitution in this example wraps the key in double quotes, and escapes any double quotes inside.poor man\'s atomic mass-delete?maybe you could set them all to EXPIREAT the same second - like a few minutes in the future - and then wait until that time and see them all "self-destruct" at the same time.but I am not really sure how atomic that would be.Spring RedisTemplate itself provides the functionality. RedissonClient in the latest version has deprecated the "deleteByPattern" functionality.redis-cli keys "*prefix*" work for me