Just curious, as it doesn\'t immediately seem possible, but is there a sneaky way to leverage the new iOS 6 UIRefreshControl class without using a UITableViewController subclass?I often use a UIViewController with a UITableView subview and conform to UITableViewDataSource and UITableViewDelegate rather than using a UITableViewController outright.On a hunch, and based on DrummerB\'s inspiration, I tried simply adding a UIRefreshControl instance as a subview to my UITableView. And it magically just works!This adds a UIRefreshControl above your table view and works as expected without having to use a UITableViewController :)EDIT: This above still works but as a few have pointed out, there is a slight "stutter" when adding the UIRefreshControl in this manner. A solution to that is to instantiate a UITableViewController, and then setting your UIRefreshControl and UITableView to that, i.e.:To eliminate the stutter that is caused by the accepted answer, you can assign your UITableView to a UITableViewController.EDIT:A way to add a UIRefreshControl with no UITableViewController with no stutter and retain the nice animation after refreshing data on the tableview.Later when handling the refreshed data...What you would try is use container view inside ViewController you are using. you can define clean UITableViewController subclass with dedicated tableview and place that in the ViewController.Well UIRefreshControl is a UIView subclass, so you can use it on it\'s own. I\'m not sure though how it renders itself. The rendering could simply depend on the frame, but it also could rely on a UIScrollView or the UITableViewController.Either way, it\'s going to be more of a hack than an elegant solution. I recommend you look into one of the available 3rd party clones or write your own.ODRefreshControlSlimeRefreshTry delaying the call to the refreshControl -endRefresh method by a fraction of a second after the tableView reloads its contents, either by using NSObject\'s -performSelector:withObject:afterDelay: or GCD\'s dispatch_after.I created a category on UIRefreshControl for this:I tested it and this also works on Collection Views. I\'ve noticed that a delay as small as\n0.01 seconds is enough:IOS 10 Swift 3.0it\'s simpleIf you want to learn about iOS 10 UIRefreshControl read here.Adding the refresh control as a subview creates an empty space above section headers.Instead, I embedded a UITableViewController into my UIViewController, then changed my tableView property to point towards the embedded one, and viola!  Minimal code changes. :-)Steps:For Swift 2.2 .First make UIRefreshControl() .In your viewDidLoad() method add:And make refresh functionHere\'s another solution which is a little different.I had to use it because of some view hierarchy issues I had: I was creating some functionality that required passing views around to different places in the view hierarchy, which broken when using a UITableViewController\'s tableview b/c the tableView is the UITableViewController\'s root view (self.view) and not just a regular view, it created inconsistent controller / view hierarchies and caused a crash.Basically create your own subclass of UITableViewController and override loadView to assign self.view a different view, and override  the tableView property to return a separate tableview.for example:When combined with Keller\'s solution this will more robust in the sense that the tableView is now a regular view, not a VC\'s root view, and be more robust against changing view hierarchies. Example of using it this way:There is another possible use for this:Since subclassing this way separates self.view from self.tableView, it\'s possible now to use this UITableViewController as more of a regular controller, and add other subviews to self.view without the oddities of adding subviews to UITableView, so one may considering making their view controllers directly a subclass of UITableViewController instead of having UITableViewController children.Some things to watch out for:Since we\'re overriding the tableView property without calling super, there may be some things to watch out for and should handle where necessary.  For example, setting the tableview in my above example will not add the tableview to self.view and not set the frame which you may want to do.  Also, in this implementation there is no default tableView given to you when the class is instantiated, which is also something you may consider adding.  I don\'t include it here because that is case by case, and this solution actually fits well with Keller\'s solution.Try this,The Above solutions are fine but tableView.refreshControl is available for UITableViewController only, till iOS 9.x and comes in UITableView from iOS 10.x onwards.Written in Swift 3 - Keller\'s first suggestion causes a strange bug in iOS 7 where the inset of the table is increased after the view controller reappears. Changing to the second answer, using the uitableviewcontroller, fixed things for me. It turns out you can use the following when you use a UIViewController with a UITableView subview and conform to UITableViewDataSource and UITableViewDelegate: