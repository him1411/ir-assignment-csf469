An interviewer recently asked me this question: given three boolean variables, a, b, and c, return true if at least two out of the three are true.My solution follows:He said that this can be improved further, but how?Rather than writing:Write:As for the expression itself, something like this:or this (whichever you find easier to grasp):It tests a and b exactly once, and c at most once.Just for the sake of using XOR to answer a relatively straight-forward problem...Why not implement it literally? :)In C you could just write a+b+c >= 2 (or !!a+!!b+!!c >= 2 to be very safe).In response to TofuBeer\'s comparison of java bytecode, here is a simple performance test:This prints the following on my machine (running Ubuntu on Intel Core 2 + sun java 1.6.0_15-b03 with HotSpot Server VM (14.1-b02, mixed mode)):First and second iterations:Later iterations:I wonder, what could java VM do that degrades performance over time for (a + b + c >= 2) case.And here is what happens if I run java with a -client VM switch:Mystery...And if I run it in GNU Java Interpreter, it gets almost 100 times slower, but the a&&b || b&&c || a&&c version wins then.Results from Tofubeer with the latest code running OS X:Results from  Paul Wagland with a Mac Java 1.6.0_26-b03-383-11A511This kind of questions can be solved with a Karnaugh Map:from which you infer that you need a group for first row and two groups for first column, obtaining the optimal solution of polygenelubricants:Readability should be the goal. Someone who reads the code must understand your intent immediately. So here is my solution.Explanation:If a==b, then both are true or both are false. If both are true, we have found our two true booleans, and can return true (by returning a). If both are false there cannot be two true booleans even if c is true, so we return false (by returning a). That\'s the (a==b) ? a part. What about : c ? Well if a==b is false, then exactly one of a or b must be true, so we have found the first true boolean, and the only thing left that matters is if c is also true, so we return c as the answer.You don\'t need to use the short circuiting forms of the operators.return (a & b) | (b & c) | (c & a);This performs the same number of logic operations as your version, however is completely branchless.Here\'s a test-driven, general approach.  Not as "efficient" as most of the solutions so far offered, but clear, tested, working, and generalized.Sum it up. It\'s called boolean algebra for a reason:If you look at the truth tables there, you can see that multiplication is boolean and, and simply addition is xor.To answer your question: Taking the answers (so far) here:and running them through the decompiler (javap -c X > results.txt):You can see that the ?: ones are slightly better then the fixed up version of your original.  The one that is the best is the one that avoids branching altogether.  That is good from the point of view of fewer instructions (in most cases) and better for branch prediction parts of the CPU, since a wrong guess in the branch prediction can cause CPU stalling. I\'d say the most efficient one is the one from moonshadow overall.  It uses the fewest instructions on average and reduces the chance for pipeline stalls in the CPU.  To be 100% sure you would need to find out the cost (in CPU cycles) for each instruction, which, unfortunately isn\'t readily available (you would have to look at the source for hotspot and then the CPU vendors specs for the time taken for each generated instruction).See the updated answer by Rotsor for a runtime analysis of the code.Here\'s another implementation using map/reduce. This scales well to billions of booleans\xc2\xa9 in a distributed environment. Using MongoDB:Creating a database values of booleans:Creating the map, reduce functions:Edit: I like CurtainDog\'s answer about having map/reduce apply to generic lists, so here goes a map function which takes a callback that determines whether a value should be counted or not.Running map/reduce:Another example of direct code:It\'s not the most succinct code, obviously.AddendumAnother (slightly optimized) version of this:This might run slightly faster, assuming that the comparison against 0 will use faster (or perhaps less) code than the comparison against 2.It really depends what you mean by "improved":Clearer?Terser?More general?More scalable?Faster?Which one is "improved" depends heavily on the situation.The most obvious set of improvements are:and thenBut those improvements are minor.Yet another way to do this but not a very good one:The Boolean hashcode values are fixed at 1231 for true and 1237 for false so could equally have used <= 3699I don\'t like ternary (return a ? (b || c) : (b && c); from the top answer), and I don\'t think I\'ve seen anyone mention it. It is written like this:In Clojure:Usage:I don\'t think I\'ve seen this solution yet:Its advantage is that once it reaches the number that you\'re looking for, it breaks.  So if this was "at least 2 out of this 1,000,000 values are true" where the first two are actually true, then it should go faster than some of the more "normal" solutions.Too many ways to do this...We can convert the bools to integers and perform this easy check:Since it wasn\'t specified how the code should be improved, I shall endeavour to improve the code by making it more amusing. Here\'s my solution:In case anyone\'s wondering if this code works, here\'s a simplification using the same logic:}This can be boiled down further to the following:But now it\'s not funny any more.The simplest way (IMO) that is not confusing and easy to read:A literal interpretation will work in all major languages:But I would probably make it easier for people to read, and expandable to more than three - something that seems to be forgotten by many programmers:As an addition to @TofuBeer TofuBeer\'s excellent post, consider @pdox pdox\'s answer:Consider also its disassembled version as given by "javap -c":pdox\'s answer compiles to less byte code than any of the previous answers. How does its execution time compare to the others?At least on my computer, pdox\'s answer is just slightly faster than @moonshadow moonshadow\'s answer, making pdox\'s the fastest overall (on my HP/Intel laptop).A C solution.or you may prefer:In Ruby:[a, b, c].count { |x| x } >= 2Which could be run in JRuby on the JavaVM. ;-)He\'s probably not looking for anything convoluted like bitwise comparison operators (not normally convoluted but with booleans, it\'s extremely odd to use bitwise operators) or something that is very roundabout like converting to int and summing them up.The most direct and natural way to solve this is with an expression like this:Put it in a function if you prefer, but it\'s not very complicated. The solution is logically concise and efficient.In C: