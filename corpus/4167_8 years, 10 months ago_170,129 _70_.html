In a Django form, how do I make a field read-only (or disabled)?When the form is being used to create a new entry, all fields should be enabled - but when the record is in update mode some fields need to be read-only.For example, when creating a new Item model, all fields must be editable, but while updating the record, is there a way to disable the sku field so that it is visible, but cannot be edited?Can class ItemForm be reused? What changes would be required in the ItemForm or Item model class? Would I need to write another class, "ItemUpdateForm", for updating the item?As pointed out in this answer, Django 1.9 added the Field.disabled attribute:The disabled boolean argument, when set to True, disables a form field using the disabled HTML attribute so that it won\xe2\x80\x99t be editable by users. Even if a user tampers with the field\xe2\x80\x99s value submitted to the server, it will be ignored in favor of the value from the form\xe2\x80\x99s initial data.With Django 1.8 and earlier, to disable entry on the widget and prevent malicious POST hacks you must scrub the input in addition to setting the readonly attribute on the form field:Or, replace if instance and instance.pk with another condition indicating you\'re editing.  You could also set the attribute disabled on the input field, instead of readonly.The clean_sku function will ensure that the readonly value won\'t be overridden by a POST.Otherwise, there is no built-in Django form field which will render a value while rejecting bound input data.  If this is what you desire, you should instead create a separate ModelForm that excludes the uneditable field(s), and just print them inside your template.Django 1.9 added the Field.disabled attribute: https://docs.djangoproject.com/en/1.9/ref/forms/fields/#disabledThe disabled boolean argument, when set to True, disables a form field using the disabled HTML attribute so that it won\xe2\x80\x99t be editable by users. Even if a user tampers with the field\xe2\x80\x99s value submitted to the server, it will be ignored in favor of the value from the form\xe2\x80\x99s initial data.Setting READONLY on widget only makes the input in the browser read-only. Adding a clean_sku which returns instance.sku ensures the field value will not change on form level.This way you can use model\'s (unmodified save) and aviod getting the field required error.awalker\'s answer helped me a lot!I\'ve changed his example to work with Django 1.3, using get_readonly_fields.Usually you should declare something like this in app/admin.py:I\'ve adapted in this way:And it works fine. Now if you add an Item, the url field is read-write, but on change it becomes read-only.To make this work for a ForeignKey field, a few changes need to be made.  Firstly, the SELECT HTML tag does not have the readonly attribute.  We need to use disabled="disabled" instead.  However, then the browser doesn\'t send any form data back for that field.  So we need to set that field to not be required so that the field validates correctly.  We then need to reset the value back to what it used to be so it\'s not set to blank.  So for foreign keys you will need to do something like:This way the browser won\'t let the user change the field, and will always POST as it it was left blank.  We then override the clean method to set the field\'s value to be what was originally in the instance.For Django 1.2+, you can override the field like so:I made a MixIn class which you may inherit to be able to add a read_only iterable field which will disable and secure fields on the non-first edit:(Based on Daniel\'s and Muhuk\'s answers)I\'ve just created the simplest possible widget for a readonly field - I don\'t really see why forms don\'t have this already:In the form:Very simple - and gets me just output. Handy in a formset with a bunch of read only values.\nOf course - you could also be a bit more clever and give it a div with the attrs so you can append classes to it.I ran across a similar problem. \nIt looks like I was able to solve it by defining a "get_readonly_fields" method in my ModelAdmin class.Something like this:The nice thing is that obj will be None when you are adding a new Item, or it will be the object being edited when you are changing an existing Item.get_readonly_display is documented here:\nhttp://docs.djangoproject.com/en/1.2/ref/contrib/admin/#modeladmin-methodsAs a useful addition to Humphrey\'s post, I had some issues with django-reversion, because it still registered disabled fields as \'changed\'. The following code fixes the problem.As I can\'t yet comment (muhuk\'s solution), I\'ll response as a separate answer. This is a complete code example, that worked for me:I was going into the same problem so I created a Mixin that seems to work for my use cases.Usage, just define which ones must be read only:Yet again, I am going to offer one more solution :) I was using Humphrey\'s code, so this is based off of that.However, I ran into issues with the field being a ModelChoiceField. Everything would work on the first request. However, if the formset tried to add a new item and failed validation, something was going wrong with the "existing" forms where the SELECTED option was being reset to the default "---------".Anyway, I couldn\'t figure out how to fix that. So instead, (and I think this is actually cleaner in the form), I made the fields HiddenInputField(). This just means you have to do a little more work in the template.So the fix for me was to simplify the Form:And then in the template, you\'ll need to do some manual looping of the formset.So, in this case you would do something like this in the template:This worked a little better for me and with less form manipulation.Two more (similar) approaches with one generalized example:1) first approach - removing field in save() method, e.g. (not tested ;) ):2) second approach - reset field to initial value in clean method:Based on second approach I generalized it like this:One simple option is to just type form.instance.fieldName in the template instead of form.fieldName.if your need multiple read-only fields.you can use any of methods given below method 1method 2 inheritance methodFor the Admin version, I think this is a more compact way if you have more than one field:Here is a slightly more involved version, based on christophe31\'s answer. It does not rely on the "readonly" attribute. This makes its problems, like select boxes still being changeable and datapickers still popping up, go away.Instead, it wraps the form fields widget in a readonly widget, thus making the form still validate. The content of the original widget is displayed inside <span class="hidden"></span> tags. If the widget has a render_readonly() method it uses that as the visible text, otherwise it parses the HTML of the original widget and tries to guess the best representation.Is this the simplest way?Right in a view code something like this: It works fine!Based on Yamikep\'s answer, I found a better and very simple solution which also handles ModelMultipleChoiceField fields.Removing field from form.cleaned_data prevents fields from being saved:Usage:How I do it with Django 1.11 : If you are using Django admin, here is the simplest solution.I think your best option would just be to include the readonly attribute in your template rendered in a <span> or <p> rather than include it in the form if it\'s readonly.Forms are for collecting data, not displaying it. That being said, the options to display in a readonly widget and scrub POST data are fine solutions.Set blank=True for \'sku\' CharField in models.py. Docmodels.pyforms.pyviews.pyin template