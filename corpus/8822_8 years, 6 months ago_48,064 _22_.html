This is just a curiosity question I was wondering if anyone had a good answer to:In the .NET Framework Class Library we have for example these two methods:Why do they use Func<TSource, bool> instead of Predicate<TSource>? Seems like the Predicate<TSource> is only used by List<T> and Array<T>, while Func<TSource, bool> is used by pretty much all Queryable and Enumerable methods and extension methods... what\'s up with that?While Predicate has been introduced at the same time that List<T> and Array<T>, in .net 2.0, the different Func and Action variants come from .net 3.5.So those Func predicates are used mainly for consistency in the LINQ operators. As of .net 3.5, about using Func<T> and Action<T> the guideline states:Do use the new LINQ types Func<> and\n  Expression<> instead of custom\n  delegates and predicatesI\'ve wondered this before. I like the Predicate<T> delegate - it\'s nice and descriptive. However, you need to consider the overloads of Where:That allows you to filter based on the index of the entry as well. That\'s nice and consistent, whereas:wouldn\'t be.Surely the actual reason for using Func instead of a specific delegate is that C# treats separately declared delegates as totally different types.Even though Func<int, bool> and Predicate<int> both have identical argument and return types, they are not assignment-compatible. So if every library declared its own delegate type for each delegate pattern, those libraries would not be able to interoperate unless the user inserts "bridging" delegates to perform conversions.By encouraging everyone to use Func, Microsoft is hoping that this will alleviate the problem of incompatible delegate types. Everyone\'s delegates will play nicely together, because they will just be matched up based on their parameter/return types.It doesn\'t solve all problems, because Func (and Action) can\'t have out or ref parameters, but those are less commonly used.Update: in the comments Svish says:Still, switching a parameter type from\n  Func to Predicate and\n  back, doesn\'t seem to make any\n  difference? At least it still compiles\n  without any problems.Yes, as long as your program only assigns methods to delegates, as in the first line of my Main function. The compiler silently generates code to new a delegate object that forwards on to the method. So in my Main function, I could change x1 to be of type ExceptionHandler2 without causing a problem.However, on the second line I try to assign the first delegate to another delegate. Even thought that 2nd delegate type has exactly the same parameter and return types, the compiler gives error CS0029: Cannot implicitly convert type \'ExceptionHandler1\' to \'ExceptionHandler2\'.Maybe this will make it clearer:My method IsNegative is a perfectly good thing to assign to the p and f variables, as long as I do so directly. But then I can\'t assign one of those variables to the other.The advice (in 3.5 and above) is to use the Action<...> and Func<...> - for the "why?" - one advantage is that "Predicate<T>" is only meaningful if you know what "predicate" means - otherwise you need to look at object-browser (etc) to find the signatute.Conversely Func<T,bool> follows a standard pattern; I can immediately tell that this is a function that takes a T and returns a bool -  don\'t need to understand any terminology - just apply my truth test.For "predicate" this might have been OK, but I appreciate the attempt to standardise. It also allows a lot of parity with the related methods in that area.