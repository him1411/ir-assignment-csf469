What is the reason browsers do not correctly recognize:Only this is recognized:Does this break the concept of XHTML support?Note: This statement is correct at least for all IE (6-8 beta 2).XHTML 1 specification says:\xd0\xa1.3. Element Minimization and Empty Element ContentGiven an empty instance of an element whose content model is not EMPTY (for example, an empty title or paragraph) do not use the minimized form (e.g. use <p> </p> and not <p />).XHTML DTD specifies script tags as:To add to what Brad and squadette have said, the self-closing XML syntax <script /> actually is correct XML, but for it to work in practice, your web server also needs to send your documents as properly formed XML with an XML mimetype like application/xhtml+xml in the HTTP Content-Type header (and not as text/html).However, sending an XML mimetype will cause your pages not to be parsed by IE7, which only likes text/html.From w3:In summary, \'application/xhtml+xml\'\n  SHOULD be used for XHTML Family\n  documents, and the use of \'text/html\'\n  SHOULD be limited to HTML-compatible\n  XHTML 1.0 documents. \'application/xml\'\n  and \'text/xml\' MAY also be used, but\n  whenever appropriate,\n  \'application/xhtml+xml\' SHOULD be used\n  rather than those generic XML media\n  types.I puzzled over this a few months ago, and the only workable (compatible with FF3+ and IE7) solution was to use the old <script></script> syntax with text/html (HTML syntax + HTML mimetype).If your server sends the text/html type in its HTTP headers, even with otherwise properly formed XHTML documents, FF3+ will use its HTML rendering mode which means that <script /> will not work (this is a change, Firefox was previously less strict).This will happen regardless of any fiddling with http-equiv meta tags, the XML prolog or doctype inside your document -- Firefox branches once it gets the text/html header, that determines whether the HTML or XML parser looks inside the document, and the HTML parser does not understand <script />.In case anyone\'s curious, the ultimate reason is that HTML was originally a dialect of SGML, which is XML\'s weird older brother. In SGML-land, tags can be specified in the DTD as either self-closing (e.g. BR, HR, INPUT), implicitly closeable (e.g. P, LI, TD), or explicitly closeable (e.g. TABLE, DIV, SCRIPT). XML of course has no concept of this.The tag-soup parsers used by modern browsers evolved out of this legacy, although their parsing model isn\'t pure SGML anymore. And of course your carefully-crafted XHTML is being treated as badly-written tag-soup/SGML unless you send it with an XML mime type. This is also why......gets interpreted by the browser as:...which is the recipe for a lovely obscure bug that can throw you into fits as you try to code against the DOM.Others have answered "how" and quoted spec. Here is the real story of "why no <script/>", after many hours digging into bug reports and mailing lists.HTML 4HTML 4 is based on SGML.SGML has some shorttags, such as <BR//, <B>text</>, <B/text/, or <OL<LI>item</LI</OL>.\nXML takes the first form, redefines the ending as ">" (SGML is flexible), so that it becomes <BR/>.However, HTML did not redfine, so <SCRIPT/> should mean <SCRIPT>>. \n(Yes, the \'>\' should be part of content, and the tag is still not closed.)Obviously, this is incompatible with XHTML and will break many sites (by the time browsers were mature enough to care about this), so nobody implemented shorttags and the specification advises against them.Effectively, all \'working\' self-ended tags are tags with optional end tag on technically non-conformant parsers and are in fact invalid.\nIt was W3C which came up with this hack to help transitioning to XHTML by making it HTML-compatible.And <script>\'s end tag is not optional."Self-ending" tag is a hack in HTML 4 and is meaningless.HTML 5HTML5 has five types of tags and only \'void\' and \'foreign\' tags are allowed to be self-closing.Because <script> is not void (it may have content) and is not foreign (like MathML or SVG), <script> cannot be self-closed, regardless of how you use it.But why? Can\'t they regard it as foreign, make special case, or something?HTML 5 aims to be backward-compatible with implementations of HTML 4 and XHTML 1.\nIt is not based on SGML or XML; its syntax is mainly concerned with documenting and uniting the implementations.\n(This is why <br/> <hr/> etc. are valid HTML 5 despite being invalid HTML4.)Self-closing <script> is one of the tags where implementations used to differ.\nIt used to work in Chrome, Safari, and Opera; to my knowledge it never worked in Internet Explorer or Firefox.This was discussed when HTML 5 was being drafted and got rejected because it breaks browser compatibility.\nWebpages that self-close script tag may not render correctly (if at all) in old browsers.\nThere were other proposals, but they can\'t solve the compatibility problem either.After the draft was released, WebKit updated the parser to be in conformance.Self-closing <script> does not happen in HTML 5 because of backward compatibility to HTML 4 and XHTML 1.XHTML 1 / XHTML 5When really served as XHTML, <script/> is really closed, as other answers have stated.Except that the spec says it should have worked when served as HTML:XHTML Documents ... may be labeled with the Internet Media Type "text/html" [RFC2854], as they are compatible with most HTML browsers.So, what happened?People asked Mozilla to let Firefox parse conforming documents as XHTML regardless of the specified content header (known as content sniffing).\nThis would have allowed self-closing scripts, and content sniffing was necessary anyway because web hosters were not mature enough to serve the correct header; IE was good at it.If the first browser war didn\'t end with IE 6, XHTML may have been on the list, too. But it did end. And IE 6 has a problem with XHTML.\nIn fact IE did not support the correct MIME type at all, forcing everyone to use text/html for XHTML because IE had major market share for a whole decade.And also content sniffing can be really bad and people are saying it should be stopped.Finally, it turns out that the W3C didn\'t mean XHTML to be sniffable: the document is both, HTML and XHTML, and Content-Type rules.\nOne can say they were standing firm on "just follow our spec" and ignoring what was practical. A mistake that continued into later XHTML versions.Anyway, this decision settled the matter for Firefox.\nIt was 7 years before Chrome was born; there was no other significant browser. Thus it was decided.Specifying the doctype alone does not trigger XML parsing because of following specifications.Internet Explorer 8 and earlier do not support XHTML parsing. Even if you use an XML declaration and/or an XHTML doctype, old IE still parse the document as plain HTML. And in plain HTML, the self-closing syntax is not supported. The trailing slash is just ignored, you have to use an explicit closing tag.Even browsers with support for XHTML parsing, such as IE 9 and later, will still parse the document as HTML unless you serve the document with a XML content type. But in that case old IE will not display the document at all!The people above have already pretty much explained the issue, but one thing that might make things clear is that, though people use \'<br/>\' and such all the time in HTML documents, any \'/\' in such a position is basically ignored, and only used when trying to make something both parseable as XML and HTML. Try \'<p/>foo</p>\', for example, and you get a regular paragraph.The self closing script tag won\'t work, because the script tag can contain inline code, and HTML is not smart enough to turn on or off that feature based on the presence of an attribute.On the other hand, HTML does have an excellent tag for including\n  references to outside resources: the <link> tag, and it can be\n  self-closing. It\'s already used to include stylesheets, RSS and Atom\n  feeds, canonical URIs, and all sorts of other goodies. Why not\n  JavaScript?If you want the script tag to be self enclosed you can\'t do that as I said, but there is an alternative, though not a smart one. You can use the self closing link tag and link to your JavaScript by giving it a type of text/javascript and rel as script, something like below:Unlike XML and XHTML, HTML has no knowledge of the self-closing syntax.  Browsers that interpret XHTML as HTML don\'t know that the / character indicates that the tag should be self-closing; instead they interpret it like an empty attribute and the parser still thinks the tag is \'open\'.Just as <script defer> is treated as <script defer="defer">, <script /> is treated as <script /="/">.Internet Explorer 8 and older don\'t support the proper MIME type for XHTML, application/xhtml+xml. If you\'re serving XHTML as text/html, which you have to for these older versions of Internet Explorer to do anything, it will be interpreted as HTML 4.01. You can only use the short syntax with any element that permits the closing tag to be omitted. See the HTML 4.01 Specification.The XML \'short form\' is interpreted as an attribute named /, which (because there is no equals sign) is interpreted as having an implicit value of "/". This is strictly wrong in HTML 4.01 - undeclared attributes are not permitted - but browsers will ignore it.IE9 and later support XHTML 5 served with application/xhtml+xml.In an HTML Document - VOID ELEMENTS do not need a "closing tag" at all!In xhtml, everything is Generic, therefore they all need termination e.g. a "closing tag"; Including br, a simple line-break, as <br></br> or its shorthand <br />.However, a Script Element is never a void or a parametric Element, because script tag before anything else, is a Browser Instruction, not a Data Description declaration.Principally, a Semantic Termination Instruction e.g., a "closing tag" is only needed for processing instructions who\'s semantics cannot be terminated by a succeeding tag. For instance: <H1> semantics cannot be terminated by a following <P> because it doesn\'t carry enough of its own semantics to override and therefore terminate the previous H1 instruction set. Although it will be able to break the stream into a new paragraph line, it is not "strong enough" to override the present font size & style line-height pouring down the stream, i.e leaking from H1 (because P doesn\'t have it). This is how and why the "/" (termination) signalling has been invented. A generic no-description termination Tag like < />, would have sufficed for any single fall off the encountered cascade, e.g.: <H1>Title< /> but that\'s not always the case, because we also want to be capable of "nesting", multiple intermediary tagging of the Stream: split into torrents before wrapping / falling onto another cascade. As a consequence a generic terminator such as < /> would not be able to determine the target of a property to terminate. For example: <b>bold <i>bold-italic < /> italic </>normal. Would undoubtedly fail to get our intention right and would most probably interpret it as bold bold-itallic bold normal.This is how the notion of a wrapper ie., container was born. (These notions are so similar that it is impossible to discern and sometimes the same element may have both. <H1> is both wrapper and container at the same time. Whereas <B> only a semantic wrapper). We\'ll need a plain, no semantics container. And of course the invention of a DIV Element came by. The DIV element is actually a 2BR-Container. Of course the coming of CSS made the whole situation weirder than it would otherwise have been and caused a great confusion with many great consequences - indirectly!Because with CSS you could easily override the native pre&after BR behavior of a newly invented DIV, it is often referred to, as a "do nothing container". Which is, naturally wrong! DIVs are block elements and will natively break the line of the stream both before and after the end signalling. Soon the WEB started suffering from page DIV-itis. Most of them still are.The coming of CSS with its capability to fully override and completely redefine the native behavior of any HTML Tag, somehow managed to confuse and blur the whole meaning of HTML existence...Suddenly all HTML tags appeared as if obsolete, they were defaced, stripped of all their original meaning, identity and purpose. Somehow you\'d gain the impression that they\'re no longer needed. Saying: A single container-wrapper tag would suffice for all the data presentation. Just add the required attributes. Why not have meaningful tags instead; Invent tag names as you go and let the CSS bother with the rest.This is how xhtml was born and of course the great blunt, paid so dearly by new comers and a distorted vision of what is what, and what\'s the damn purpose of it all. W3C went from World Wide Web to What Went Wrong, Comrades?!!The purpose of HTML is to stream meaningful data to the human recipient.To deliver Information.The formal part is there to only assist the clarity of information delivery.\nxhtml doesn\'t give the slightest consideration to the information. - To it, the information is absolutely irrelevant.The most important thing in the matter is to know and be able to understand that xhtml is not just a version of some extended HTML, xhtml is a completely different beast; grounds up; and therefore it is wise to keep them separate. 