I have a ScrollView that surrounds my entire layout so that the entire screen is scrollable.  The first element I have in this ScrollView is a HorizontalScrollView block that has features that can be scrolled through horizontally.  I\'ve added an ontouchlistener to the horizontalscrollview to handle touch events and force the view to "snap" to the closest image on the ACTION_UP event.So the effect I\'m going for is like the stock android homescreen where you can scroll from one to the other and it snaps to one screen when you lift your finger.This all works great except for one problem:  I need to swipe left to right almost perfectly horizontally for an ACTION_UP to ever register.  If I swipe vertically in the very least (which I think many people tend to do on their phones when swiping side to side), I will receive an ACTION_CANCEL instead of an ACTION_UP.  My theory is that this is because the horizontalscrollview is within a scrollview, and the scrollview is hijacking the vertical touch to allow for vertical scrolling.  How can I disable the touch events for the scrollview from just within my horizontal scrollview, but still allow for normal vertical scrolling elsewhere in the scrollview?Here\'s a sample of my code:}Update: I figured this out. On my ScrollView, I needed to override the onInterceptTouchEvent method to only intercept the touch event if the Y motion is > the X motion. It seems like the default behavior of a ScrollView is to intercept the touch event whenever there is ANY Y motion. So with the fix, the ScrollView will only intercept the event if the user is deliberately scrolling in the Y direction and in that case pass off the ACTION_CANCEL to the children.Here is the code for my Scroll View class that contains the HorizontalScrollView:Thank you Joel for giving me a clue on how to resolve this problem.I have simplified the code(without need for a GestureDetector) to achieve the same effect:I think I found a simpler solution, only this uses a subclass of ViewPager instead of (its parent) ScrollView.UPDATE 2013-07-16: I added an override for onTouchEvent as well. It could possibly help with the issues mentioned in the comments, although YMMV.This is similar to the technique used in android.widget.Gallery\'s onScroll().\nIt is further explained by the Google I/O 2013 presentation Writing Custom Views for Android.Update 2013-12-10: A similar approach is also described in a post from Kirill Grouchnikov about the (then) Android Market app.I\'ve found out that somethimes one ScrollView regains focus and the other loses focus. You can prevent that, by only granting one of the scrollView focus:Thanks to Neevek his answer worked for me but it doesn\'t lock the vertical scrolling when user has started scrolling the horizontal view(ViewPager) in horizontal direction and then without lifting the finger scroll vertically it starts to scroll the underlying container view(ScrollView). I fixed it by making a slight change in Neevak\'s code:It wasn\'t working well for me. I changed it and now it works smoothly. If anyone interested.}This finally became a part of support v4 library, NestedScrollView. So, no longer local hacks is needed for most of cases I\'d guess.Neevek\'s solution works better than Joel\'s on devices running 3.2 and above. There is a bug in Android that will cause java.lang.IllegalArgumentException: pointerIndex out of range if a gesture detector is used inside a scollview. To duplicate the issue, implement a custom scollview as Joel suggested and put a view pager inside. If you drag (don\'t lift you figure) to one direction (left/right) and then to the opposite, you will see the crash. Also in Joel\'s solution, if you drag the view pager by moving your finger diagonally, once your finger leave the view pager\'s content view area, the pager will spring back to its previous position. All these issues are more to do with Android\'s internal design or lack of it than Joel\'s implementation, which itself is a piece of smart and concise code. http://code.google.com/p/android/issues/detail?id=18990