I am new to C++ programming, but I have experience in Java. I need guidance on how to pass objects to functions in C++.Do I need to pass pointers, references, or non-pointer and non-reference values? I remember in Java there are no such issues since we pass just the variable that holds reference to the objects.It would be great if you could also explain where to use each of those options.Pass by value, except when Passing by pointer is virtually never advised. Optional parameters are best expressed as a boost::optional, and aliasing is done fine by reference.C++11\'s move semantics make passing and returning by value much more attractive even for complex objects.Pass arguments by const reference, except when (here, "pass by value" is called "pass by copy", because passing by value always creates a copy in C++03)There\'s more to this, but these few beginner\'s rules will get you quite far. There are some differences in calling conventions in C++ and Java. In C++ there are technically speaking only two conventions: pass-by-value and pass-by-reference, with some literature including a third pass-by-pointer convention (that is actually pass-by-value of a pointer type). On top of that, you can add const-ness to the type of the argument, enhancing the semantics.Pass by referencePassing by reference means that the function will conceptually receive your object instance and not a copy of it. The reference is conceptually an alias to the object that was used in the calling context, and cannot be null. All operations performed inside the function apply to the object outside the function. This convention is not available in Java or C.Pass by value (and pass-by-pointer)The compiler will generate a copy of the object in the calling context and use that copy inside the function. All operations performed inside the function are done to the copy, not the external element. This is the convention for primitive types in Java. An special version of it is passing a pointer (address-of the object) into a function. The function receives the pointer, and any and all operations applied to the pointer itself are applied to the copy (pointer), on the other hand, operations applied to the dereferenced pointer will apply to the object instance at that memory location, so the function can have side effects. The effect of using pass-by-value of a pointer to the object will allow the internal function to modify external values, as with pass-by-reference and will also allow for optional values (pass a null pointer).This is the convention used in C when a function needs to modify an external variable, and the convention used in Java with reference types: the reference  is copied, but the referred object is the same: changes to the reference/pointer are not visible outside the function, but changes to the pointed memory are.Adding const to the equationIn C++ you can assign constant-ness to objects when defining variables, pointers and references at different levels. You can declare a variable to be constant, you can declare a reference to a constant instance, and you can define all pointers to constant objects, constant pointers to mutable objects and constant pointers to constant elements. Conversely in Java you can only define one level of constant-ness (final keyword): that of the variable (instance for primitive types, reference for reference types), but you cannot define a reference to an immutable element (unless the class itself is immutable).This is extensively used in C++ calling conventions. When the objects are small you can pass the object by value. The compiler will generate a copy, but that copy is not an expensive operation. For any other type, if the function will not change the object, you can pass a reference to a constant instance (usually called constant reference) of the type. This will not copy the object, but pass it into the function. But at the same time the compiler will guarantee that the object is not changed inside the function.Rules of thumbThis are some basic rules to follow:There are other small deviations from these rules, the first of which is handling ownership of an object. When an object is dynamically allocated with new, it must be deallocated with delete (or the [] versions thereof). The object or function that is responsible for the destruction of the object is considered the owner of the resource. When a dynamically allocated object is created in a piece of code, but the ownership is transfered to a different element it is usually done with pass-by-pointer semantics, or if possible with smart pointers.Side noteIt is important to insist in the importance of the difference between C++ and Java references. In C++ references are conceptually the instance of the object, not an accessor to it. The simplest example is implementing a swap function:The swap function above changes both its arguments through the use of references. The closest code in Java:The Java version of the code will modify the copies of the references internally, but will not modify the actual objects externally. Java references are C pointers without pointer arithmetic that get passed by value into functions.There are several cases to consider.This case is mostly about style: do you want the code to look like call(obj) or call(&obj)? However, there are two points where the difference matters: the optional case, below, and you want to use a reference when overloading operators.This is the interesting case. The rule of thumb is "cheap to copy" types are passed by value \xe2\x80\x94 these are generally small types (but not always) \xe2\x80\x94 while others are passed by const ref. However, if you need to make a copy within your function regardless, you should pass by value. (Yes, this exposes a bit of implementation detail. C\'est le C++.)There\'s the least difference here between all situations, so choose whichever makes your life easiest.These declarations are actually the exact same function!  When passing by value, const is purely an implementation detail.  Try it out:Pass variables by value when the function needs complete isolation from the environment i.e. to prevent the function from modifying the original variable as well as to prevent other threads from modifying its value while the function is being executed.The downside is the CPU cycles and extra memory spent to copy the object.This form emulates pass-by-value behavior while removing the copying overhead. The function gets read access to the original object, but cannot modify its value.The downside is thread safety: any change made to the original object by another thread will show up inside the function while it\'s still executing.Use this when the function has to write back some value to the variable, which will ultimately get used by the caller.Just like the const reference case, this is not thread safe.Functionally same as pass by const-reference except for the different syntax, plus the fact that the calling function can pass NULL pointer to indicate it has no valid data to pass.Not thread safe.Similar to non-const reference. The caller typically sets the variable to NULL when the function is not supposed to write back a value. This convention is seen in many glibc APIs. Example:Just like all pass by reference/pointer, not thread safe.Since no one mentioned I am adding on it, When you pass a object to a function in c++ the default copy constructor of the object is called if you dont have one which creates a clone of the object and then pass it to the method, so when you change the object values that will reflect on the copy of the object instead of the original object, that is the problem in c++, So if you make all the class attributes to be pointers, then the copy constructors will copy the addresses of the pointer attributes , so when the method invocations on the object which manipulates the values stored in pointer attributes addresses, the changes also reflect in the original object which is passed as a parameter, so this can behave same a Java but dont forget that all your class attributes must be pointers, also you should change the values of pointers, will be much clear with code explanation. But this is not good idea as you will be ending up writing lot of code involving with pointers, which are prone for memory leaks and do not forget to call destructors. And to avoid this c++ have copy constructors where you will create new memory when the objects containing pointers are passed to function arguments which will stop manipulating other objects data, Java does pass by value and value is reference, so it do not require copy constructors.There are three methods of passing an object to a function as a parameter:Go through the following example:Output:Say i am in someFunc\n  The value of the pointer is -17891602\n  The value of the variable is 4  The following are the ways to pass a arguments/parameters to function in C++.1. by value.2. by reference.3. by object.