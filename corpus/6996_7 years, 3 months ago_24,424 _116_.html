I\'m beginning to understand how the forall keyword is used in so-called "existential types" like this:This is only a subset, however, of how forall is used and I simply cannot wrap my mind around its use in things like this:Or explaining why these are different:Or the whole RankNTypes stuff...I tend to prefer clear, jargon-free English rather than the kinds of language which are normal in academic environments.  Most of the explanations I attempt to read on this (the ones I can find through search engines) have these problems:So...On to the actual question.  Can anybody completely explain the forall keyword in clear, plain English (or, if it exists somewhere, point to such a clear explanation which I\'ve missed) that doesn\'t assume I\'m a mathematician steeped in the jargon?Edited to add:There were two stand-out answers from the higher-quality ones below, but unfortunately I can only choose one as best.  Norman\'s answer was detailed and useful, explaining things in a way that showed some of the theoretical underpinnings of forall and at the same time showing me some of the practical implications of it.  yairchu\'s answer covered an area nobody else mentioned (scoped type variables) and illustrated all of the concepts with code and a GHCi session.  Were it possible to select both as best, I would.  Unfortunately I can\'t and, after looking over both answers closely, I\'ve decided that yairchu\'s slightly edges out Norman\'s because of the illustrative code and attached explanation.  This is a bit unfair, however, because really I needed both answers to understand this to the point that forall doesn\'t leave me with a faint sense of dread when I see it in a type signature.Let\'s start with a code example:This code doesn\'t compile (syntax error) in plain Haskell 98. It requires an extension to support the forall keyword.Basically, there are 3 different common uses for the forall keyword (or at least so it seems), and each has its own Haskell extension: ScopedTypeVariables, RankNTypes/Rank2Types, ExistentialQuantification.The code above doesn\'t get a syntax error with either of those enabled, but only type-checks with ScopedTypeVariables enabled.Scoped Type Variables:Scoped type variables helps one specify types for code inside where clauses. It makes the b in val :: b the same one as the b in foob :: forall a b. (b -> b) -> b -> (a -> b) -> Maybe a -> b.A confusing point: you may hear that when you omit the forall from a type it is actually still implicitly there. (from Norman\'s answer: "normally these languages omit the forall from polymorphic types"). This claim is correct, but it refers to the other uses of forall, and not to the ScopedTypeVariables use.Rank-N-Types:Let\'s start with that mayb :: b -> (a -> b) -> Maybe a -> b is equivalent to mayb :: forall a b. b -> (a -> b) -> Maybe a -> b, except for when ScopedTypeVariables is enabled.This means that it works for every a and b.Let\'s say you want to do something like this.What\'s must be the type of this liftTup? It\'s liftTup :: (forall x. x -> f x) -> (a, b) -> (f a, f b). To see why, let\'s try to code it:"Hmm.. why does GHC infer that the tuple must contain two of the same type? Let\'s tell it they don\'t have to be"Hmm. so here ghc doesn\'t let us apply liftFunc on v because v :: b and liftFunc wants an x. We really want our function to get a function that accepts any possible x!So it\'s not liftTup that works for all x, it\'s the function that it gets that does.Existential Quantification:Let\'s use an example:How is that different from Rank-N-Types?With Rank-N-Types, forall a meant that your expression must fit all possible as. For example:An empty list does work as a list of any type.So with Existential-Quantification, foralls in data definitions mean that, the value contained can be of any suitable type, not that it must be of all suitable types.Can anybody completely explain the forall keyword in clear, plain English?No. (Well, maybe Don Stewart can.)Here are the barriers to a simple, clear explanation or forall:It\'s a quantifier.  You have a to have at least a little logic (predicate calculus) to have seen a universal or existential quantifier.  If you\'ve never seen predicate calculus or are not comfortable with quantifiers (and I have seen students during PhD qualifying exams who are not comfortable), then for you, there\'s no easy explanation of forall.It\'s a type quantifier.  If you haven\'t seen System F and gotten some practice writing polymorphic types, you\'re going to find forall confusing.  Experience with Haskell or ML is not enough, because normally these languages omit the forall from polymorphic types.  (In my mind, this is a language-design mistake.)In Haskell in particular, forall is used in ways that I find confusing.  (I\'m not a type theorist, but my work brings me in contact with a lot of type theory, and I\'m quite comfortable with it.)  For me, the main source of confusion is that forall is used to encode a type that I myself would prefer to write with exists.  It\'s justified by a tricky bit of type isomorphism involving quantifiers and arrows, and every time I want to understand it, I have to look things up and work out the isomorphism myself.If you are not comfortable with the idea of type isomorphism, or if you don\'t have any practice thinking about type isomorphisms, this use of forall is going to stymie you.While the general concept of forall is always the same (binding to introduce a type variable), the details of different uses can vary significantly.  Informal English is not a very good tool for explaining the variations.  To really understand what\'s going on, you need some mathematics.  In this case the relevant mathematics can be found in Benjamin Pierce\'s introductory text Types and Programming Languages, which is a very good book.As for your particular examples,runST should make your head hurt.  Higher-rank types (forall to the left of an arrow) are rarely found in the wild.   I encourage you to read the paper that introduced runST: "Lazy Functional State Threads".  This is a really good paper, and it will give you a much better intuition for the type of runST in particular and for higher-rank types in general.  The explanation take several pages, it\'s very well done, and I\'m not going to try to condense it here.ConsiderIf I call bar, I can simply pick any type a that I like, and I can pass it a function from type a to type a.  For example, I can pass the function (+1) or the function reverse.  You can think of the forall as saying "I get to pick the type now".  (The technical word for picking the type is instantiating.)The restrictions on calling foo are much more stringent: the argument to foo must be a polymorphic function.  With that type, the only functions I can pass to foo are id or a function that always diverges or errors, like undefined.   The reason is that with foo, the forall is to the left of the arrow, so as the caller of foo I don\'t get to pick what a isâ€”rather it\'s the implementation of foo that gets to pick what a is.  Because forall is to the left of the arrow, rather than above the arrow as in bar, the instantiation takes place in the body of the function rather than at the call site.Summary: A complete explanation of the forall keyword requires math and can be understood only by someone who has studied the math.  Even partial explanations are hard to understand without math.  But maybe my partial, non-math explanations help a little.  Go read Launchbury and Peyton Jones on runST!Addendum: Jargon "above", "below", "to the left of".  These have nothing to do with the textual ways types are written and everything to do with abstract-syntax trees.  In the abstract syntax, a forall takes the name of a type variable, and then there is a full type "below" the forall.  An arrow takes two types (argument and result type) and forms a new type (the function type).  The argument type is "to the left of" the arrow; it is the arrow\'s left child in the abstract-syntax tree.Examples:In forall a . [a] -> [a], the forall is above the arrow; what\'s to the left of the arrow is [a].Inthe type in parentheses would be called "a forall to the left of an arrow".  (I\'m using types like this in an optimizer I\'m working on.)My original answer:Can anybody completely explain the forall keyword in clear, plain EnglishAs Norman indicates, it is very hard to give a clear, plain English explanation\nof a technical term from type theory. We\'re all trying though.There is only really one thing to remember about \'forall\': it binds types to\nsome scope. Once you understand that, everything is fairly easy. It is the\nequivalent of \'lambda\' (or a form of \'let\') on the type level -- Norman Ramsey\nuses the notion of "left"/"above" to convey this same concept of scope in his\nexcellent answer.Most uses of \'forall\' are very simple, and you can find them introduced in the\nGHC Users Manual, S7.8., particularly the excellent S7.8.5 on nested\nforms of \'forall\'.In Haskell, we usually leave off the binder for types, when the type is\nuniversally quanitified, like so:is equivalent to:That\'s it. Since you can bind type variables now to some scope, you can have scopes other\nthan the top level ("universally quantified"), like your first example,\nwhere the type variable is only visible within the data structure. This allows\nfor hidden types ("existential types"). Or we can have arbitrary\nnesting of bindings ("rank N types").To deeply understand type systems, you will need to learn some jargon. That\'s\nthe nature of computer science. However, simple uses, like above, should be\nable to be grasped intuitively, via analogy with \'let\' on the value level. A\ngreat introduction is Launchbury and Peyton Jones.They\'re densely packed with assumptions that I\'ve read the latest in whatever branch of discrete math, category theory or abstract algebra is popular this week. (If I never read the words "consult the paper whatever for details of implementation" again, it will be too soon.)Er, and what about simple first-order logic? forall is pretty clearly in reference to universal quantification, and in that context the term existential makes more sense as well, though it would be less awkward if there were an exists keyword. Whether quantification is effectively universal or existential depends on the placement of the quantifier relative to where the variables are used on which side of a function arrow and it\'s all a bit confusing.So, if that doesn\'t help, or if you just don\'t like symbolic logic, from a more functional programming-ish perspective you can think of type variables as just being (implicit) type parameters to the function. Functions taking type parameters in this sense are traditionally written using a capital lambda for whatever reason, which I\'ll write here as /\\. So, consider the id function:We can rewrite it as lambdas, moving the "type parameter" out of the type signature and adding inline type annotations:Here\'s the same thing done to const:So your bar function might be something like this:Note that the type of the function given to bar as an argument depends on bar\'s type parameter. Consider if you had something like this instead:Here bar2 is applying the function to something of type Char, so giving bar2 any type parameter other than Char will cause a type error.On the other hand, here\'s what foo might look like:Unlike bar, foo doesn\'t actually take any type parameters at all! It takes a function that itself takes a type parameter, then applies that function to two different types.So when you see a forall in a type signature, just think of it as a lambda expression for type signatures. Just like regular lambdas, the scope of forall extends as far to the right as possible, up to enclosing parenthesis, and just like variables bound in a regular lambda, the type variables bound by a forall are only in scope within the quantified expression.Post scriptum: Perhaps you might wonder--now that we\'re thinking about functions taking type parameters, why can\'t we do something more interesting with those parameters than put them into a type signature? The answer is that we can!A function that puts type variables together with a label and returns a new type is a type constructor, which you could write something like this:But we\'d need completely new notation, because the way such a type is written, like Either a b, is already suggestive of "apply the function Either to these parameters".On the other hand, a function that sort of "pattern matches" on its type parameters, returning different values for different types, is a method of a type class. A slight expansion to my /\\ syntax above suggests something like this:Personally, I think I prefer Haskell\'s actual syntax...A function that "pattern matches" its type parameters and returns an arbitrary, existing type is a type family or functional dependency--in the former case, it even already looks a great deal like a function definition.Here is a quick and dirty explanation in plain terms that you\'re likely to be already familiar with.The forall keyword is really only used in one way in Haskell. It always means the same thing when you see it.Universal quantificationA universally quantified type is a type of the form forall a. f a. A value of that type can be thought of as a function that takes a type a as its argument and returns a value of type f a. Except that in Haskell these type arguments are passed implicitly by the type system. This "function" has to give you the same value no matter which type it receives, so the value is polymorphic.For example, consider the type forall a. [a]. A value of that type takes another type a and gives you back a list of elements of that same type a. There is only one possible implementation, of course. It would have to give you the empty list because a could be absolutely any type. The empty list is the only list value that is polymorphic in its element type (since it has no elements).Or the type forall a. a -> a. The caller of such a function provides both a type a and a value of type a. The implementation then has to return a value of that same type a. There\'s only one possible implementation again. It would have to return the same value that it was given.Existential quantificationAn existentially quantified type would have the form exists a. f a, if Haskell supported that notation. A value of that type can be thought of as a pair (or a "product") consisting of a type a and a value of type f a.For example, if you have a value of type exists a. [a], you have a list of elements of some type. It could be any type, but even if you don\'t know what it is there\'s a lot you could do to such a list. You could reverse it, or you could count the number of elements, or perform any other list operation that doesn\'t depend on the type of the elements.OK, so wait a minute. Why does Haskell use forall to denote an "existential" type like the following? It can be confusing, but it\'s really describing the type of the data constructor SB:Once constructed, you can think of a value of type ShowBox as consisting of two things. It\'s a type s together with a value of type s. In other words, it\'s a value of an existentially quantified type. ShowBox could really be written as exists s. Show s => s, if Haskell supported that notation.runST and friendsGiven that, how are these different?Let\'s first take bar. It takes a type a and a function of type a -> a, and produces a value of type (Char, Bool). We could choose Int as the a and give it a function of type Int -> Int for example. But foo is different. It requires that the implementation of foo be able to pass any type it wants to the function we give it. So the only function we could reasonably give it is id.We should now be able to tackle the meaning of the type of runST:So runST has to be able to produce a value of type a, no matter what type we give as a. To do so, it needs an argument of type forall s. ST s a which under the hood is just a function of type forall s. s -> (a, s). That function then has to be able to produce a value of type (a, s) no matter what type the implementation of runST decides to give as s.OK, so what? The benefit is that this puts a constraint on the caller of runST in that the type a cannot involve the type s at all. You can\'t pass it a value of type ST s [s], for example. What that means in practice is that the implementation of runST is free to perform mutation with the value of type s. The type system guarantees that this mutation is local to the implementation of runST.The type of runST is an example of a rank-2 polymorphic type because the type of its argument contains a forall quantifier. The type of foo above is also of rank 2. An ordinary polymorphic type, like that of bar, is rank-1, but it becomes rank-2 if the types of arguments are required to be polymorphic, with their own forall quantifier. And if a function takes rank-2 arguments then its type is rank-3, and so on. In general, a type that takes polymorphic arguments of rank n has rank n + 1.The reason why there are different uses of this keyword is that it\'s actually used in at least two different type system extensions: higher-rank types, and existentials.It\'s probably best just to read about and understand those two things separately, rather than trying to get an explanation of why \'forall\' is an appropriate bit of syntax in both at the same time.With Existential-Quantification, foralls in data definitions mean\n  that, the value contained can be of any suitable type, not\n  that it must be of all suitable types.\n  -- yachiru\'s answerAn explanation of why forall in data definitions are isomorphic to (exists a. a) (pseudo-Haskell) can be found in wikibooks\'s "Haskell/Existentially quantified types".The following is a brief verbatim summary:When pattern-matching/deconstructing MkT x, what is the type of x?x can be any type (as stated in the forall), and so it\'s type is:Therefore, the following are isomorphic:My simple interpretation of all this, is that "forall really means \'for all\'".\nAn important distinction to make is the impact of forall on the definition versus function application.A forall means the definition of the value or function must be polymorphic.If the thing being defined is a polymorphic value, then it means that the value must be valid for all suitable a, which is quite restrictive.If the thing being defined is a polymorphic function, then it means that the function must be valid for all suitable a, which isn\'t that restrictive because just because the function is polymorphic doesn\'t mean the parameter being applied have to be polymorphic. That is, if the function is valid for all a, then conversely any suitable a can be applied to the function. However, the type of the parameter can only be chosen once in the function definition.If a forall is inside the function parameter\'s type (i.e., a Rank2Type) then it means the applied parameter must be truly polymorphic, to be  consistent with the idea of forall means definition is polymorphic. In this case, the type of the parameter can be chosen more than once in the function definition ("and is chosen by the implementation of the function", as pointed out by Norman)Therefore, the reason why existential data definitions allows any a is because the data constructor is a polymorphic function:kind of MkT :: a -> *Which means any a may be applied to the function. As opposed to, say, a polymorphic value:kind of valueT :: aWhich means that the definition of valueT must be polymorphic. In this case, valueT can be defined as empty list [] of all types.Even though the meaning for forall is consistent in ExistentialQuantification and RankNType, existentials has a difference since the data constructor can be used in pattern matching. As documented in the ghc user guide:When pattern matching, each pattern match introduces a new, distinct, type for each existential type variable. These types cannot be unified with any other type, nor can they escape from the scope of the pattern match.