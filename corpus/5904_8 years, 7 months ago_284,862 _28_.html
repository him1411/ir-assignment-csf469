So I\'ve gotten the answer to my last question (I don\'t know why I didn\'t think of that).  I was printing a double using cout that got rounded when I wasn\'t expecting it.  How can I make cout print a double using full precision?You can set the precision directly on std::cout and use the std::fixed format specifier.You can #include <limits> to get the maximum precision of a float or double.Use std::setprecision:Here is what I would use:Basically the limits package has traits for all the build in types.\nOne of the traits for floating point numbers (float/double/long double) is the digits10 attribute. This defines the accuracy (I forget the exact terminology) of a floating point number in base 10.See: http://www.cplusplus.com/reference/std/limits/numeric_limits.html\nFor details about other attributes.The iostreams way is kind of clunky.  I prefer using boost::lexical_cast because it calculates the right precision for me.  And it\'s fast, too.Output:Pi: 3.14159265358979Here is how to display a double with full precision:This displays:100.0000000000005\nmax_digits10 is the number of digits that are necessary to uniquely represent all distinct double values. max_digits10 represents the number of digits before and after the decimal point.\nDon\'t use set_precision(max_digits10) with std::fixed.\nOn fixed notation, set_precision() sets the number of digits only after the decimal point. This is incorrect as max_digits10 represents the number of digits before and after the decimal point.This displays incorrect result:100.00000000000049738By full precision, I assume mean enough precision to show the best approximation to the intended value, but it should be pointed out that double is stored using base 2 representation and base 2 can\'t represent something as trivial as 1.1 exactly.  The only way to get the full-full precision of the actual double (with NO ROUND OFF ERROR) is to print out the binary bits (or hex nybbles).  One way of doing that is writing the double to a union and then printing out the integer value of the bits.This will give you the 100% accurate precision of the double... and be utterly unreadable because humans can\'t read IEEE double format !  Wikipedia has a good write up on how to interpret the binary bits.In newer C++, you can do%.12f means floating point, with precision of 12 digits.cout is an object that has a bunch of methods you can call to change the precision and formatting of printed stuff.There\'s a setprecision(...) operation, but you can also set other things like print width, etc.Look up cout in your IDE\'s reference. Most portably...With ostream::precision(int)will yieldWhy you have to say "+1" I have no clue, but the extra digit you get out of it is correct.