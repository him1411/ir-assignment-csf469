I am looking for a pattern that matches everything until the first occurrence of a specific character, say a ";" - a semicolon.I wrote this:But it actually matches everything (including the semicolon) until the last occurrence of a semicolon.You needThe [^;] is a character class, it matches everything but a semicolon.To cite the perlre manpage:You can specify a character class, by enclosing a list of characters in [] , which will match any character from the list. If the first character after the "[" is "^", the class matches any character not in the list.This should work in most regex dialects.Would;work?The "?" is a lazy operator, so the regex grabs as little as possible before matching the ;./^[^;]*/The [^;] says match anything except a semicolon.  The square brackets are a set matching operator, it\'s essentially, match any character in this set of characters, the ^ at the start makes it an inverse match, so match anything not in this set.Try /[^;]*/Google regex character classes for details.Try /[^;]*/That\'s a negating character class.this is not a regex solution, but something simple enough for your problem description. Just split your string and get the first item from your array.outputsample text: If for example we have the sample text above, the regex /(.*?\\;)/ will give you everything until the first occurence of semicolon (;), including the semicolon: "this is a test sentence;"This was very helpful for me as I was trying to figure out how to match all the characters in an xml tag including attributes. I was running into the "matches everything to the end" problem with:but was able to resolve the issue with:after reading this post. Thanks all."/^([^\\/]*)\\/$/" worked for me, to get only top "folders" from an array like:Really kinda sad that no one has given you the correct answer....In regex,  ?  makes it non greedy. By default regex will match as much as it can (greedy)Simply add a ?  and it will be non-greedy and match as little as possible!Good luck, hope that helps.This will match up to the first occurrence only in each string and will ignore subsequent occurrences.