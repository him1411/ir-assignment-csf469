From time to time I read that Fortran is or can be faster then C for heavy calculations. Is that really true? I must admit that I hardly know Fortran, but the Fortran code I have seen so far did not show that the language has features that C doesn\'t have.If it is true, please tell me why. Please don\'t tell me what languages or libs are good for number crunching, I don\'t intend to write an app or lib to do that, I\'m just curious.The languages have similar feature-set. The performance difference comes from the fact that Fortran says aliasing is not allowed. Any code that has aliasing is not valid Fortran but it is up to the programmer and not the compiler to detect these errors. Thus Fortran compilers ignore possible aliasing of memory pointers and allows them to generate more efficient code. Take a look at this little example in C:This function would run slower than the Fortran counterpart after optimization. Why so? If you write values into the output array you may change the values of matrix. After all the pointers could overlap and point to the same chunk of memory (including the int pointer!). The C compiler is forced to reload the four matrix values from memory for all computations.In Fortran the compiler can load the matrix values once and store them in registers. It can do so because the Fortran compiler assumes pointers/arrays do not overlap in memory.Fortunately the restrict keyword and strict-aliasing have been introduced to the C99 standard to address this problem. It\'s well supported in most C++ compilers these days as well. The keyword allows you to give the compiler a hint that the programmer promises that a pointer does not alias with any other pointer. The strict-aliasing means that the programmer promises that pointers of different type will never overlap, for example a double* will not overlap with an int* (with the specific exception that char* and void* can overlap with anything).If you use them you will get the same speed from C and Fortran. However, the ability to use the restrict keyword only with performance critical functions means that C (and C++) programs are much safer and easier to write. For example, consider the invalid Fortran code: CALL TRANSFORM(A(1, 30), A(2, 31), A(3, 32), 30), which most Fortran compilers will happily compile without any warning but introduces a bug that only shows up on some compilers, on some hardware and with some optimization options.When I started programming professionally the speed dominance of Fortran was just being challenged. I remember reading about it in Dr. Dobbs and telling the older programmers about the article--they laughed.So I have two views about this, theoretical and practical. In theory Fortran today has no intrinsic advantage to C/C++ or even any language that allows assembly code. In practice Fortran today still enjoys the benefits of legacy of a history and culture built around optimization of numerical code.Up until and including Fortran 77, language design considerations had optimization as a main focus. Due to the state of compiler theory and technology, this often meant restricting features and capability in order to give the compiler the best shot at optimizing the code. A good analogy is to think of Fortran 77 as a professional race car that sacrifices features for speed. These days compilers have gotten better across all languages and features for programmer productivity are more valued. However, there are still places where the people are mainly concerned with speed in scientific computing; these people most likely have inherited code, training and culture from people who themselves were Fortran programmers.When one starts talking about optimization of code there are many issues and the best way to get a feel for this is to lurk where people are whose job it is to have fast numerical code. But keep in mind that such critically sensitive code is usually a small fraction of the overall lines of code and very specialized: A lot of Fortran code is just as "inefficient" as a lot of other code in other languages and optimization should not even be a primary concern of such code.A wonderful place to start in learning about the history and culture of Fortran is wikipedia. The Fortran Wikipedia entry is superb and I very much appreciate those who have taken the time and effort to make it of value for the Fortran community.(A shortened version of this answer would have been a comment in the excellent thread started by Nils but I don\'t have the karma to do that. Actually, I probably wouldn\'t have written anything at all but for that this thread has actual information content and sharing as opposed to flame wars and language bigotry, which is my main experience with this subject. I was overwhelmed and had to share the love.)To some extent Fortran has been designed keeping compiler optimization in mind. The language supports whole array operations where compilers can exploit parallelism (specially on multi-core processors). For example,Dense matrix multiplication is simply:L2 norm of a vector x is:Moreover statements such as FORALL, PURE & ELEMENTAL procedures etc. further help to optimize code. Even pointers in Fortran arent as flexible as C because of this simple reason.The upcoming Fortran standard (2008) has co-arrays which allows you to easily write parallel code. G95 (open source) and compilers from CRAY already support it. So yes Fortran can be fast simply because compilers can optimize/parallelize it better than C/C++. But again like everything else in life there are good compilers and bad compilers.It is funny that a lot of answers here from not knowing the languages. This is especially true for C/C++ programmers who have opened and old FORTRAN 77 code and discuss the weaknesses. I suppose that the speed issue is mostly a question between C/C++ and Fortran. In a Huge code, it always depends on the programmer. There are some features of the language that Fortran outperforms and some features which C does. So, in 2011, no one can really say which one is faster.About the language itself, Fortran nowadays supports Full OOP features and it is fully backward compatible. I have used the Fortran 2003 thoroughly and I would say it was just delightful to use it. In some aspects, Fortran 2003 is still behind C++ but let\'s look at the usage. Fortran is mostly used for Numerical Computation, and nobody uses fancy C++ OOP features because of speed reasons. In high performance computing, C++ has almost no place to go(have a look at the MPI standard and you\'ll see that C++ has been deprecated!).Nowadays, you can simply do mixed language programming with Fortran and C/C++. There are even interfaces for GTK+ in Fortran. There are free compilers (gfortran, g95) and many excellent commercial ones. There are several reasons why Fortran could be faster. However the amount they matter is so inconsequential or can be worked around anyways, that it shouldn\'t matter. The main reason to use Fortran nowadays is maintaining or extending legacy applications.PURE and ELEMENTAL keywords on functions. These are functions that have no side effects. This allows optimizations in certain cases where the compiler knows the same function will be called with the same values. Note: GCC implements "pure" as an extension to the language. Other compilers may as well. Inter-module analysis can also perform this optimization but it is difficult.standard set of functions that deal with arrays, not individual elements. Stuff like sin(), log(), sqrt() take arrays instead of scalars. This makes it easier to optimize the routine. Auto-vectorization gives the same benefits in most cases if these functions are inline or builtinsBuiltin complex type. In theory this could allow the compiler to reorder or eliminate certain instructions in certain cases, but likely you\'d see the same benefit with the struct { double re, im; }; idiom used in C. It makes for faster development though as operators work on complex types in fortran.I think the key point in favor of Fortran is that it is a language slightly more suited for expressing vector- and array-based math.  The pointer analysis issue pointed out above is real in practice, since portable code cannot really assume that you can tell a compiler something.  There is ALWAYS an advantage to expression computaitons in a manner closer to how the domain looks.  C does not really have arrays at all, if  you look closely, just something that kind of behaves like it. Fortran has real arrawys. Which makes it easier to compile for certain types of algorithms especially for parallel machines. Deep down in things like run-time system and calling conventions, C and modern Fortran are sufficiently similar that it is hard to see what would make a difference.  Note that C here is really base C: C++ is a totally different issue with very different performance characteristics. There is no such thing as one language being faster than another, so the proper answer is no.What you really have to ask is "is code compiled with Fortran compiler X faster than equivalent code compiled with C compiler Y?" The answer to that question of course depends on which two compilers you pick.Another question one could ask would be along the lines of "Given the same amount of effort put into optimizing in their compilers, which compiler would produce faster code?"\nThe answer to this would in fact be Fortran. Fortran compilers have certian advantages:However, there is nothing stopping someone from putting a ton of effort into their C compiler\'s optimization, and making it generate better code than their platform\'s Fortran compiler. In fact, the larger sales generated by C compilers makes this scenario quite feasibleThere is another item where Fortran is different than C - and potentially faster. Fortran has better optimization rules than C.  In Fortran, the evaluation order of an expressions is not defined, which allows the compiler to optimize it - if one wants to force a certain order, one has to use parentheses. In C the order is much stricter, but with "-fast" options, they are more relaxed and "(...)" are also ignored. I think Fortran has a way which lies nicely in the middle. (Well, IEEE makes the live more difficult as certain evaluation-order changes require that no overflows occur, which either has to be ignored or hampers the evaluation).Another area of smarter rules are complex numbers. Not only that it took until C 99 that C had them, also the rules govern them is better in Fortran; since the Fortran library of gfortran is partially written in C but implements the Fortran semantics, GCC gained the option (which can also be used with "normal" C programs):-fcx-fortran-rules\n  Complex multiplication and division follow Fortran rules.  Range reduction is done as part of complex division, but there is no checking whether the result of a complex multiplication or division is "NaN + I*NaN", with an attempt to rescue the situation in that case.The alias rules mentioned above is another bonus and also - at least in principle - the whole-array operations, which if taken properly into account by the optimizer of the compiler, can lead faster code. On the contra side are that certain operation take more time, e.g. if one does an assignment to an allocatable array, there are lots of checks necessary (reallocate? [Fortran 2003 feature], has the array strides, etc.), which make the simple operation more complex behind the scenes - and thus slower, but makes the language more powerful. On the other hand, the array operations with flexible bounds and strides makes it easier to write code - and the compiler is usually better optimizing code than a user.In total, I think both C and Fortran are about equally fast; the choice should be more which language does one like more or whether using the whole-array operations of Fortran  and its better portability are more useful -- or the better interfacing to system and graphical-user-interface libraries in C.I compare speed of Fortran, C, and C++ with the classic Levine-Callahan-Dongarra benchmark from netlib.  The multiple language version, with OpenMP, is\nhttp://sites.google.com/site/tprincesite/levine-callahan-dongarra-vectors\nThe C is uglier, as it began with automatic translation, plus insertion of restrict and pragmas for certain compilers.\nC++ is just C with STL templates where applicable.  To my view, the STL is a mixed bag as to whether it improves maintainability.There is only minimal exercise of automatic function in-lining to see to what extent it improves optimization, since the examples are based on traditional Fortran practice where little reliance is place on in-lining.The C/C++ compiler which has by far the most widespread usage lacks auto-vectorization, on which these benchmarks rely heavily.Re the post which came just before this:  there are a couple of examples where parentheses are used in Fortran to dictate the faster or more accurate order of evaluation.  Known C compilers don\'t have options to observe the parentheses without disabling more important optimizations.There is nothing about the languages Fortran and C which makes one faster than the other for specific purposes.  There are things about specific compilers for each of these languages which make some favorable for certain tasks more than others.  For many years, Fortran compilers existed which could do black magic to your numeric routines, making many important computations insanely fast.  The contemporary C compilers couldn\'t do it as well.  As a result, a number of great libraries of code grew in Fortran.  If you want to use these well tested, mature, wonderful libraries, you break out the Fortran compiler.My informal observations show that these days people code their heavy computational stuff in any old language, and if it takes a while they find time on some cheap compute cluster.  Moore\'s Law makes fools of us all.I was doing some extensive mathematics with FORTRAN and C for a couple of years. From my own experience I can tell that FORTRAN is sometimes really better than C but not for its speed (one can make C perform as fast as FORTRAN by using appropriate coding style) but rather because of very well optimized libraries like LAPACK, and because of great parallelization. On my opinion, FORTRAN is really awkward to work with, and its advantages are not good enough to cancel that drawback, so now I am using C+GSL to do calculations.Any speed differences between Fortran and C will be more a function of compiler optimizations and the underlying math library used by the particular compiler.  There is nothing intrinsic to Fortran that would make it faster than C.Anyway, a good programmer can write Fortran in any language.I\'m a hobbyist programmer and i\'m "average" at both language.\nI find it easier to write fast Fortran code than C (or C++) code. Both Fortran and C are "historic" languages (by today standard), are heavily used, and have well supported free and commercial compiler. I don\'t know if it\'s an historic fact but Fortran feel like it\'s built to be paralleled/distributed/vectorized/whatever-many-cores-ized. And today it\'s pretty much the "standard metric" when we\'re talking about speed : "does it scale ?"For pure cpu crunching i love Fortran. For anything IO related i find it easier to work with C. (it\'s difficult in both case anyway).Now of course, for parallel math intensive code you probably want to use your GPU. Both C and Fortran have a lot of more or less well integrated CUDA/OpenCL interface (and now OpenACC).My moderately objective answer is : If you know both language equally well/poorly then i think Fortran is faster because i find it easier to write parallel/distributed code in Fortran than C. (once you understood that you can write "freeform" fortran and not just strict F77 code)Here is a 2nd answer for those willing to downvote me because they don\'t like the 1st answer : Both language have the features required to write high-performance code. So it\'s dependent of the algorithm you\'re implementing (cpu intensive ? io intensive ? memory intensive?), the hardware (single cpu ? multi-core ? distribute supercomputer ? GPGPU ? FPGA ?), your skill and ultimately the compiler itself. Both C and Fortran have awesome compiler. (i\'m seriously amazed by how advanced Fortran compilers are but so are C compilers).PS : i\'m glad you specifically excluded libs because i have a great deal of bad stuff to say about Fortran GUI libs. :)I haven\'t heard that Fortan is significantly faster than C, but it might be conceivable tht in certain cases it would be faster. And the key is not in the language features that are present, but in those that (usually) absent. An example are C pointers. C pointers are used pretty much everywhere, but the problem with pointers is that the compiler usually can\'t tell if they\'re pointing to the different parts of the same array.For example if you wrote a strcpy routine that looked like this:The compiler has to work under the assumption that the d and s might be overlapping arrays. So it can\'t perform an optimization that would produce different results when the arrays overlap. As you\'d expect, this considerably restricts the kind of optimizations that can be performed. [I should note that C99 has a "restrict" keyword that explictly tells the compilers that the pointers don\'t overlap. Also note that the Fortran too has pointers, with semantics different from those of C, but the pointers aren\'t ubiquitous as in C.]But coming back to the C vs. Fortran issue, it is conceivable that a Fortran compiler is able to perform some optimizations that might not be possible for a (straightforwardly written) C program. So I wouldn\'t be too surprised by the claim. However, I do expect that the performance difference wouldn\'t be all that much. [~5-10%]Generally FORTRAN is slower than C.  C can use hardware level pointers allowing the programmer to hand-optimize.  FORTRAN (in most cases) doesn\'t have access to hardware memory addressing hacks.  (VAX FORTRAN is another story.)   I\'ve used FORTRAN on and off since the \'70\'s.  (Really.)However, starting in the 90\'s FORTRAN has evolved to include specific language constructs that can be optimized into inherently parallel algorithms that can really scream on a multi-core processor.   For example, automatic Vectorizing allows multiple processors to handle each element in a vector of data concurrently.  16 processors -- 16 element vector -- processing takes 1/16th the time.In C, you have to manage your own threads and design your algorithm carefully for multi-processing, and then use a bunch of API calls to make sure that the parallelism happens properly.In FORTRAN, you only have to design your algorithm carefully for multi-processing.  The compiler and run-time can handle the rest for you.You can read a little about High Performance Fortran, but you find a lot of dead links.  You\'re better off reading about Parallel Programming (like OpenMP.org) and how FORTRAN supports that.Quick and simple:\nBoth are equally fast, but Fortran is simpler.\nWhats really faster in the end depends on the algorithm, but there is considerable no speed difference anyway. This is what I learned in a Fortran workshop at high performance computing center Stuttgard, Germany in 2015. I work both with Fortran and C and share this opinion.Explanation:C was designed to write operating systems. Hence it has more freedom than needed to write high performance code. In general this is no problem, but if one does not programm carefully, one can easily slow the code down.Fortran was designed for scientific programming. For this reason, it supports writing fast code syntax-wise, as this is the main purpose of Fortran. In contrast to the public opinion, Fortran is not an outdated programming language. Its latest standard is 2010 and new compilers are published on a regular basis, as most high performance code is writen in Fortran. Fortran further supports modern features as compiler directives (in C pragmas).Example:\nWe want to give a large struct as an input argument to a function (fortran: subroutine). Within the function the argument is not altered.C supports both, call by reference and call by value, which is a handy feature. In our case, the programmer might by accident use call by value. This slows down things considerably, as the struct needs to be copied in within memory first.Fortran works with call by reference only, which forces the programmer to copy the struct by hand, if he really wants a call by value operation. In our case fortran will be automatically as fast as the C version with call by reference.The faster code is not really up to the language, is the compiler so you can see the ms-vb "compiler" that generates bloated, slower and redundant object code that is tied together inside an ".exe", but powerBasic generates too way better code.\nObject code made by a C and C++ compilers is generated in some phases (at least 2) but by design most Fortran compilers have at least 5 phases including high-level optimizations so by design Fortran will always have the capability to generate highly optimized code.\nSo at the end is the compiler not the language you should ask for, the best compiler i know is the Intel Fortran Compiler because you can get it on LINUX and Windows and you can use VS as the IDE, if you\'re looking for a cheap tigh compiler you can always relay on OpenWatcom.More info about this:\nhttp://ed-thelen.org/1401Project/1401-IBM-Systems-Journal-FORTRAN.htmlMost of the posts already present compelling arguments, so I will just add the proverbial 2 cents to a different aspect.Being fortran faster or slower in terms of processing power in the end can have its importance, but if it takes 5 times more time to develop something in Fortran because:Then the issue is irrelevant. If something is slow, most of the time you cannot improve it beyond a given limit. If you want something faster, change the algorithm. In the end, computer time is cheap. Human time is not. Value the choice that reduces human time. If it increases computer time, it\'s cost effective anyway.Fortran has better I/O routines, e.g. the implied do facility gives flexibility that C\'s standard library can\'t match. The Fortran compiler directly handles the more complex \nsyntax involved, and as such syntax can\'t be easily reduced \nto argument passing form, C can\'t implement it efficiently.Using modern standards and compiler, no!Some of the folks here have suggested that FORTRAN is faster because the compiler doesn\'t need to worry about aliasing (and hence can make more assumptions during optimisation). However, this has been dealt with in C since the C99 (I think) standard with the inclusion of the restrict keyword. Which basically tells the compiler, that within a give scope, the pointer is not aliased. Furthermore C enables proper pointer arithmetic, where things like aliasing can be very useful in terms of performance and resource allocation. Although I think more recent version of FORTRAN enable the use of "proper" pointers.For modern implementations C general outperforms FORTRAN (although it is very fast too).http://benchmarksgame.alioth.debian.org/u64q/fortran.htmlEDIT:A fair criticism of this seems to be that the benchmarking may be biased. Here is another source (relative to C) that puts result in more context:http://julialang.org/benchmarks/You can see that C typically outperforms Fortran in most instances (again see criticisms below that apply here too); as others have stated, benchmarking is an inexact science that can be easily loaded to favour one language over others. But it does put in context how Fortran and C have similar performance.This is more than somewhat subjective, because it gets into the quality of compilers and such more than anything else. However, to more directly answer your question, speaking from a language/compiler standpoint there is nothing about Fortran over C that is going to make it inherently faster or better than C. If you are doing heavy math operations, it will come down to the quality of the compiler, the skill of the programmer in each language and the intrinsic math support libraries that support those operations to ultimately determine which is going to be faster for a given implementation.EDIT: Other people such as @Nils have raised the good point about the difference in the use of pointers in C and the possibility for aliasing that perhaps makes the most naive implementations slower in C. However, there are ways to deal with that in C99, via compiler optimization flags and/or in how the C is actually written. This is well covered in @Nils answer and the subsequent comments that follow on his answer.Fortran traditionally doesn\'t set options such as -fp:strict (which ifort requires to enable some of the features in USE IEEE_arithmetic, a part of f2003 standard).  Intel C++ also doesn\'t set -fp:strict as a default, but that is required for ERRNO handling, for example, and other C++ compilers don\'t make it convenient to turn off ERRNO or gain optimizations such as simd reduction. gcc and g++ have required me to set up Makefile to avoid using the dangerous combination -O3 -ffast-math -fopenmp -march=native.\nOther than these issues, this question about relative performance gets more nit-picky and dependent on local rules about choice of compilers and options.