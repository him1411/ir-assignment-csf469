For a while now I\'ve been using subversion for my personal projects.More and more I keep hearing great things about Git and Mercurial, and DVCS in general.I\'d like to give the whole DVCS thing a whirl, but I\'m not too familiar with either option.What are some of the differences between Mercurial and Git?Note that I\'m not trying to find out which one is "best" or even which one I should start with.  I\'m mainly looking for key areas where they are similar and where they are different, because I am interested to know how they differ in terms of implementation and philosophy.Disclaimer: I use Git, follow Git development on git mailing list, and even contribute a bit to Git (gitweb mainly). I know Mercurial from documentation and some from discussion on #revctrl IRC channel on FreeNode.Thanks to all people on on #mercurial IRC channel who provided help about Mercurial for this writeupHere it would be nice to have some syntax for table, something like in PHPMarkdown / MultiMarkdown / Maruku extension of MarkdownThere are a few things that differ Mercurial from Git, but there are other things that make them similar.  Both projects borrow ideas from each other.  For example hg bisect command in Mercurial (formerly bisect extension) was inspired by git bisect command in Git, while idea of git bundle was inspired by hg bundle.In Git there are four types of objects in its object database: blob objects which contain contents of a file, hierarchical tree objects which store directory structure, including file names and relevant parts of file permissions (executable permission for files, being a symbolic link), commit object which contain authorship info, pointer to snapshot of state of repository at revision represented by a commit (via a tree object of top directory of project) and references to zero or more parent commits, and tag objects which reference other objects and can be signed using PGP / GPG.Git uses two ways of storing objects: loose format, where each object is stored in a separate file (those files are written once, and never modified), and packed format where many objects are stored delta-compressed in a single file.  Atomicity of operations is provided by the fact, that reference to a new object is written (atomically, using create + rename trick) after writing an object.Git repositories require periodic maintenance using git gc (to reduce disk space and improve performance), although nowadays Git does that automatically.  (This method provides better compression of repositories.)Mercurial (as far as I understand it) stores history of a file in a filelog (together, I think, with extra metadata like rename tracking, and some helper information); it uses flat structure called manifest to store directory structure, and structure called changelog which store information about changesets (revisions), including commit message and zero, one or two parents.Mercurial uses transaction journal to provide atomicity of operations, and relies on truncating files to clean-up after failed or interrupted operation.  Revlogs are append-only.Looking at repository structure in Git versus in Mercurial, one can see that Git is more like object database (or a content-addressed filesystem), and Mercurial more like traditional fixed-field relational database.Differences:\nIn Git the tree objects form a hierarchical structure; in Mercurial manifest file is flat structure.  In Git blob object store one version of a contents of a file; in Mercurial filelog stores whole history of a single file (if we do not take into account here any complications with renames). This means that there are different areas of operations where Git would be faster than Mercurial, all other things considered equal (like merges, or showing history of a project), and areas where Mercurial would be faster than Git (like applying patches, or showing history of a single file). This issue might be not important for end user. Because of the fixed-record structure of Mercurial\'s changelog structure, commits in Mercurial can have only up to two parents; commits in Git can have more than two parents (so called "octopus merge").  While you can (in theory) replace octopus merge by a series of two-parent merges, this might cause complications when converting between Mercurial and Git repositories.As far as I know Mercurial doesn\'t have equivalent of annotated tags (tag objects) from Git. A special case of annotated tags are signed tags (with PGP / GPG signature); equivalent in Mercurial can be done using GpgExtension, which extension is being distributed along with Mercurial.  You can\'t tag non-commit object in Mercurial like you can in Git, but that is not very important, I think (some git repositories use tagged blob to distribute public PGP key to use to verify signed tags).In Git references (branches, remote-tracking branches and tags) reside outside DAG of commits (as they should).  References in refs/heads/ namespace (local branches) point to commits, and are usually updated by "git commit"; they point to the tip (head) of branch, that\'s why such name.  References in refs/remotes/<remotename>/ namespace (remote-tracking branches) point to commit, follow branches in remote repository <remotename>, and are updated by "git fetch" or equivalent.  References in refs/tags/ namespace (tags) point usually to commits (lightweight tags) or tag objects (annotated and signed tags), and are not meant to change.In Mercurial you can give persistent name to revision using tag; tags are stored similarly to the ignore patterns.  It means that globally visible tags are stored in revision-controlled .hgtags file in your repository. That has two consequences: first, Mercurial has to use special rules for this file to get current list of all tags and to update such file (e.g. it reads the most recently committed  revision of the file, not currently checked out version); second, you have to commit changes to this file to have new tag visible to other users / other repositories (as far as I understand it).Mercurial also supports local tags, stored in hg/localtags, which are not visible to others (and of course are not transferable) In Git tags are fixed (constant) named references to other objects (usually tag objects, which in turn point to commits) stored in refs/tags/ namespace.  By default when fetching or pushing a set of revision, git automatically fetches or pushes tags which point to revisions being fetched or pushed.  Nevertheless you can control to some extent which tags are fetched or pushed.Git treats lightweight tags (pointing directly to commits) and annotated tags (pointing to tag objects, which contain tag message which optionally includes PGP signature, which in turn point to commit) slightly differently, for example by default it considers only annotated tags when describing commits using "git describe".Git doesn\'t have a strict equivalent of local tags in Mercurial. Nevertheless git best practices recommend to setup separate public bare repository, into which you push ready changes, and from which others clone and fetch. This means that tags (and branches) that you don\'t push, are private to your repository. On the other hand you can also use namespace other than heads, remotes or tags, for example local-tags for local tags.Personal opinion: In my opinion tags should reside outside revision graph, as they are external to it (they are pointers into graph of revisions).  Tags should be non-versioned, but transferable.  Mercurial\'s choice of using a mechanism similar to the one for ignoring files, means that it either has to treat .hgtags specially (file in-tree is transferable, but ordinary it is versioned), or have tags which are local only (.hg/localtags is non-versioned, but untransferable).In Git local branch (branch tip, or branch head) is a named reference to a commit, where one can grow new commits.  Branch can also mean active line of development, i.e. all commits reachable from branch tip.  Local branches reside in refs/heads/ namespace, so e.g. fully qualified name of \'master\' branch is \'refs/heads/master\'.Current branch in Git (meaning checked out branch, and branch where new commit will go) is the branch which is referenced by the HEAD ref. One can have HEAD pointing directly to a commit, rather than being symbolic reference; this situation of being on an anonymous unnamed branch is called detached HEAD ("git branch" shows that you are on \'(no branch)\').In Mercurial there are anonymous branches (branch heads), and one can use bookmarks (via bookmark extension).  Such bookmark branches are purely local, and those names were (up to version 1.6) not transferable using Mercurial. You can use rsync or scp to copy the .hg/bookmarks file to a remote repository. You can also use hg id -r <bookmark> <url> to get the revision id of a current tip of a bookmark. Since 1.6 bookmarks can be pushed/pulled. The BookmarksExtension page has a section on Working With Remote Repositories.  There is a difference in that in Mercurial bookmark names are global, while definition of \'remote\' in Git describes also mapping of branch names from the names in remote repository to the names of local remote-tracking branches; for example refs/heads/*:refs/remotes/origin/* mapping means that one can find state of \'master\' branch (\'refs/heads/master\') in the remote repository in the \'origin/master\' remote-tracking branch (\'refs/remotes/origin/master\').Mercurial has also so called named branches, where the branch name is embedded in a commit (in a changeset).  Such name is global (transferred on fetch).  Those branch names are permanently recorded as part of the changeset\\u2019s metadata.  With modern Mercurial you can close "named branch" and stop recording branch name.  In this mechanism tips of branches are calculated on the fly.Mercurial\'s "named branches" should in my opinion be called commit labels instead, because it is what they are.  There are situations where "named branch" can have multiple tips (multiple childless commits), and can also consist of several disjoint parts of graph of revisions.There is no equivalent of those Mercurial "embedded branches" in Git; moreover Git\'s philosophy is that while one can say that branch includes some commit, it doesn\'t mean that a commit belongs to some branch.Note that Mercurial documentation still proposes to use separate clones (separate repositories) at least for long-lived branches (single branch per repository workflow), aka branching by cloning.Mercurial by default pushes all heads.  If you want to push a single branch (single head), you have to specify tip revision of the branch you want to push.  You can specify branch tip by its revision number (local to repository), by revision identifier, by bookmark name (local to repository, doesn\'t get transferred), or by embedded branch name (named branch).As far as I understand it, if you push a range of revisions that contain commits marked as being on some "named branch" in Mercurial parlance, you will have this "named branch" in the repository you push to.  This means that names of such embedded branches ("named branches") are global (with respect to clones of given repository / project).By default (subject to push.default configuration variable) "git push" or "git push <remote>" Git would push matching branches, i.e. only those local branches that have their equivalent already present in remote repository you push into.  You can use --all option to git-push ("git push --all") to push all branches, you can use "git push <remote> <branch>" to push a given single branch, and you can use "git push <remote> HEAD" to push current branch.All of the above assumes that Git isn\'t configured which branches to push via remote.<remotename>.push  configuration variables.Note: here I use Git terminology where "fetch" means downloading changes from remote repository without integrating those changes with local work.  This is what "git fetch" and "hg pull" does.If I understand it correctly, by default Mercurial fetches all heads from remote repository, but you can specify branch to fetch via "hg pull --rev <rev> <url>" or "hg pull <url>#<rev>" to get single branch.  You can specify <rev> using revision identifier, "named branch" name (branch embedded in changelog), or bookmark name.  Bookmark name however (at least currently) doesn\'t get transferred.  All "named branches" revisions you get belong to get transferred.  "hg pull" stores tips of branches it fetched as anonymous, unnamed heads.In Git by default (for \'origin\' remote created by "git clone", and for remotes created using "git remote add")  "git fetch" (or "git fetch <remote>") gets all branches from remote repository (from refs/heads/ namespace), and stores them in refs/remotes/ namespace.  This means for example that branch named \'master\' (full name: \'refs/heads/master\') in remote \'origin\' would get stored (saved) as \'origin/master\' remote-tracking branch (full name: \'refs/remotes/origin/master\').You can fetch single branch in Git by using git fetch <remote> <branch> - Git would store requested branch(es) in FETCH_HEAD, which is something similar to Mercurial unnamed heads.Those are but examples of default cases of powerful refspec Git syntax: with refspecs you can specify and/or configure which branches one want to fetch, and where to store them.  For example default "fetch all branches" case is represented by \'+refs/heads/*:refs/remotes/origin/*\' wildcard refspec, and "fetch single branch" is shorthand for \'refs/heads/<branch>:\'.  Refspecs are used to map names of branches (refs) in remote repository to local refs names.  But you don\'t need to know (much) about refspecs to be able to work effectively with Git (thanks mainly to "git remote" command).Personal opinion: I personally think that "named branches" (with branch names embedded in changeset metadata) in Mercurial are misguided design with its global namespace, especially for a distributed version control system.  For example let\'s take case where both Alice and Bob have "named branch" named \'for-joe\' in their repositories, branches which have nothing in common. In Joe\'s repository however those two branches would be mistreated as a single branch. So you have somehow come up with convention protecting against branch name clashes. This is not problem with Git, where in Joe\'s repository \'for-joe\' branch from Alice would be \'alice/for-joe\', and from Bob it would be \'bob/for-joe\'. See also Separating branch name from branch identity issue raised on Mercurial wiki.Mercurial\'s "bookmark branches" currently lack in-core distribution mechanism.Differences:\nThis area is one of the main differences between Mercurial and Git, as james woodyatt and Steve Losh said in their answers. Mercurial, by default, uses anonymous lightweight codelines, which in its terminology are called "heads".  Git uses lightweight named branches, with injective mapping to map names of branches in remote repository to names of remote-tracking branches.  Git "forces" you to name branches (well, with exception of single unnamed branch, situation called detached HEAD), but I think this works better with branch-heavy workflows such as topic branch workflow, meaning multiple branches in single repository paradigm.In Git there are many ways of naming revisions (described e.g. in git rev-parse manpage):There are also revision specifiers involving reflog, not mentioned here.  In Git each object, be it commit, tag, tree or blob has its SHA-1 identifier; there is special syntax like e.g. \'next:Documentation\' or \'next:README\' to refer to tree (directory) or blob (file contents) at specified revision.Mercurial also has many ways of naming changesets (described e.g. in hg manpage):Differences\nAs you can see comparing above lists Mercurial offers revision numbers, local to repository, while Git doesn\'t.  On the other hand Mercurial offers relative offsets only from \'tip\' (current branch), which are local to repository (at least without ParentrevspecExtension), while Git allows to specify any commit following from any tip.The most recent revision is named HEAD in Git, and "tip" in Mercurial; there is no null revision in Git. Both Mercurial and Git can have many root (can have more than one parentless commits; this is usually result of formerly separate projects joining).See also: Many different kinds of revision specifiers article on Elijah\'s Blog (newren\'s).Personal opinion: I think that revision numbers are overrated (at least for distributed development and/or nonlinear / branchy history).  First, for a distributed version control system they have to be either local to repository, or require treating some repository in a special way as a central numbering authority.  Second, larger projects, with longer history, can have number of revisions in 5 digits range so they are offer only slight advantage over shortened to 6-7 character revision identifiers, and imply strict ordering while revisions are only partially ordered (I mean here that revisions n and n+1 doesn\'t need to be parent and child).In Git revision ranges are topological.  Commonly seen A..B syntax, which for linear history means revision range starting at A (but excluding A), and ending at B (i.e. range is open from below), is shorthand ("syntactic sugar") for ^A B, which for history traversing commands mean all commits reachable from B, excluding those reachable from A.  This means that the behavior of A..B range is entirely predictable (and quite useful) even if A is not ancestor of B: A..B means then range of revisions from common ancestor of A and B (merge base) to revision B.In Mercurial revision ranges are based on range of revision numbers. Range is specified using A:B syntax, and contrary to Git range acts as a closed interval.  Also range B:A is the range A:B in reverse order, which is not the case in Git (but see below note on A...B syntax).  But such simplicity comes with a price: revision range A:B makes sense only if A is ancestor of B or vice versa, i.e. with linear history; otherwise (I guess that) the range is unpredictable, and the result is local to repository (because revision numbers are local to repository).This is fixed with Mercurial 1.6, which has new topological revision range, where \'A..B\' (or \'A::B\') is understood as the set of changesets that are both descendants of X and ancestors of Y.  This is, I guess, equivalent to \'--ancestry-path A..B\' in Git.Git also has notation A...B for symmetric difference of revisions; it means A B --not $(git merge-base A B), which means all commits reachable from either A or B, but excluding all commits reachable from both of them (reachable from common ancestors).Mercurial uses rename tracking to deal with file renames.  This means that the information about the fact that a file was renamed is saved at the commit time; in Mercurial this information is saved in the "enhanced diff" form in filelog (file revlog) metadata.  The consequence of this is that you have to use hg rename / hg mv... or you need to remember to run hg addremove to do similarity based rename detection.Git is unique among version control systems in that it uses rename detection to deal with file renames.  This means that the fact that file was renamed is detected at time it is needed: when doing a merge, or when showing a diff (if requested / configured).  This has the advantage that rename detection algorithm can be improved, and is not frozen at time of commit.Both Git and Mercurial require using --follow option to follow renames when showing history of a single file.  Both can follow renames when showing line-wise history of a file in git blame / hg annotate.In Git the git blame command is able to follow code movement, also moving (or copying) code from one file to the other, even if the code movement is not part of wholesome file rename.  As far as I know this feature is unique to Git (at the time of writing, October 2009).Both Mercurial and Git have support for fetching from and pushing to repositories on the same filesystem, where repository URL is just a filesystem path to repository.  Both also have support for fetching from bundle files.Mercurial support fetching and pushing via SSH and via HTTP protocols.  For SSH one needs an accessible shell account on the destination machine and a copy of hg installed / available.  For HTTP access the hg-serve or Mercurial CGI script running is required, and Mercurial needs to be installed on server machine.Git supports two kinds of protocols used to access remote repository:Mercurial is implemented in Python, with some core code written in C for performance.  It provides API for writing extensions (plugins) as a way of adding extra features.  Some of functionality, like "bookmark branches" or signing revisions, is provided in extensions distributed with Mercurial and  requires turning it on.Git is implemented in C, Perl and shell scripts.  Git provides many low level commands (plumbing) suitable to use in scripts.  The usual way of introducing new feature is to write it as Perl or shell script, and when user interface stabilizes rewrite it in C for performance, portability, and in the case of shell script avoiding corner cases (this procedure is called builtinification).Git relies and is built around [repository] formats and [network] protocols.  Instead of language bindings there are (partial or complete) reimplementations of Git in other languages (some of those are partially reimplementations, and partially wrappers around git commands): JGit (Java, used by EGit, Eclipse Git Plugin), Grit (Ruby), Dulwich (Python), git# (C#).TL;DRI think you can get a feeling of what those systems are similar or different in by whatching those two videos:Linus Torvalds on Git (http://www.youtube.com/watch?v=4XpnKHJAok8)\nBryan O\'Sullivan on Mercurial (http://www.youtube.com/watch?v=JExtkqzEoHY)Both of them are very similar in design but very different in implementations.I use Mercurial. As far as I understand Git, one major thing git is different is that it tracks contents of files instead of files themselves. Linus says that if you move a function from one file to another, Git will tell you the history of that single function across the move.They also say that git is slower over HTTP but it has it\'s own network protocol and server.Git works better as an SVN thick client than Mercurial. You can pull and push against an SVN server. This functionality is still under development in MercurialBoth Mercurial and Git have very nice web hosting solutions available (BitBucket and GitHub), but Google Code supports Mercurial only. By the way, they have a very detailed comparison of Mercurial and Git they did for deciding which one to support (http://code.google.com/p/support/wiki/DVCSAnalysis). It has a lot of good info.I wrote a blog entry about Mercurial\'s branching models a while ago, and included comparisons to git\'s branching model.  Maybe you\'ll find it interesting: http://stevelosh.com/blog/entry/2009/8/30/a-guide-to-branching-in-mercurial/I use both quite regularly.  The major functional difference is in the way Git and Mercurial name branches within repositories.  With Mercurial, branch names are cloned and pulled along with their changesets.  When you add changes to a new branch in Mercurial and push to another repository, the branch name is pushed at the same time.  So, branch names are more-or-less global in Mercurial, and you have to use the Bookmark extension to have local-only lightweight names (if you want them; Mercurial, by default, uses anonymous lightweight codelines, which in its terminology are called "heads").  In Git, branch names and their injective mapping to remote branches are stored locally and you must manage them explicitly, which means knowing how to do that.  This is pretty much where Git gets its reputation for being harder to learn and use than Mercurial.As others will note here, there are lots and lots of minor differences.  The thing with the branches is the big differentiator.Take a look at Git vs. Mercurial: Please Relax blog post by Patrick Thomson, where he writes:\nGit is MacGyver, Mercurial is James BondNote that this blog post is from August 7, 2008, and both SCM improved much since.Mercurial is almost fully written in python. Git\'s core is written in C (and should be faster, than Mercurial\'s) and tools written in sh, perl, tcl and uses standard GNU utils. Thus it needs to bring all these utils and interpreters with it to system that doesn\'t contain them (e.g. Windows).Both support work with SVN, although AFAIK svn support is broken for git on Windows (may be I am just unlucky/lame, who knows). There\'re also extensions which allow to interoperate between git and Mercurial.Mercurial has nice Visual Studio integration. Last time I checked, plugin for Git was working but extremely slow.They basic command sets are very similar(init, clone, add, status, commit, push, pull etc.). So, basic workflow will be the same. Also, there\'s TortoiseSVN-like client for both.Extensions for Mercurial can be written in python (no surprise!) and for git they can be written in any executable form (executable binary, shell script etc). Some extensions are crazy powerful, like git bisect.If you need good Windows support, you might prefer Mercurial. TortoiseHg (Windows explorer plugin) manages to offer a simple to use graphical interface to a rather complex tool. As state here, you will also have a Visual Studio plugin. However, last time I tried, the SVN interface didn\'t work that well on Windows.If you don\'t mind the command line interface, I would recommend Git. Not for technical reason but for a strategical one. The adoption rate of git is much higher. Just see how many famous open source projects are switching from cvs/svn to Mercurial and how many are switching to Git. See how many code/project hosting providers you can find with git support compared to Mercurial hosting.After reading all over that Mercurial is easier (which I still believe it is, after all the internet community is of the opinion), when I started working with Git and Mercurial I felt Git is relatively simpler for me to adapt to (I started off with Mercurial with TortoiseHg) when working from the command line, mainly because the git commands were named appropriately according to me and are fewer in number. Mercurial has different naming for each command that does a distinct job, while Git commands can be multipurpose according to situation (for eg, checkout). While Git was harder back then, now the difference is hardly substantial. YMMV.. With a good GUI client like TortoiseHg, true it was much easier to work with Mercurial and I did not have to remember the slightly confusing commands. I\'m not going into detail how every command for the same action varied, but here are two comprehensive lists: 1 from Mercurial\'s own site and 2nd from wikivs. Git saves a record of every version of committed files internally, while Hg saves just the changesets which can have a smaller footprint. Git makes it easier to change the history compared to Hg, but then again its a hate-it-or-love-it feature. I like Hg for former and Git for latter.What I miss in Hg is the submodule feature of Git. Hg has subrepos but that\'s not exactly Git submodule.Ecosystem around the two can also influence one\'s choice: Git has to be more popular (but that\'s trivial), Git has GitHub while Mercurial has BitBucket, Mercurial has TortoiseHg for which I haven\'t seen an equivalent as good for Git.Each has its advantages and disadvantages, with either of them you\'re not going to lose.Check out Scott Chacon\'s post from a while back.I think git has a reputation for being "more complicated", though in my experience it\'s not more complicated than it needs to be.  IMO, the git model is way easier to understand (tags contain commits (and pointers to zero or more parent commits) contain trees contain blobs and other trees... done).It\'s not just my experience that git is not more confusing than mercurial.  I\'d recommend again reading this blog post from Scott Chacon on the matter.One difference totally unrelated to the DVCSs themselves:Git seems to be very popular with C developers. Git is the de-facto repository for the Linux Kernel and this may be the reason why it is so popular with C developers. This is especially true for those that have the luxury of only working in the Linux/Unix world.Java developers seem to favor Mercurial over Git. There are possibly two reasons for that: One is that a number of very large Java projects are hosted on Mercurial, including the JDK itself. Another is that the structure and clean documentation of Mercurial appeals to people coming from the Java camp whereas such people find Git inconsistent wrt command naming and lacking in documentation. I\'m not saying that is actually true, I\'m saying people have got used to something from their usual habitat and then they tend to choose DVCS from that.Python developers almost exclusively favor Mercurial, I would assume. There\'s actually no rational reason for that other than the fact that Mercurial is based on Python. (I use Mercurial too and I really don\'t understand why people make a fuss about the implementation language of the DVCS. I don\'t understand a word of Python and if it wasn\'t for the fact that it is listed somewhere that it is based on Python then I wouldn\'t have known).I don\'t think you can say that one DVCS fits a language better than another, so you shouldn\'t choose from that. But in reality people choose (partly) based on which DVCS they get most exposed to as part of their community.(nope, I don\'t have usage statistics to back up my claims above .. it is all based on my own subjectivity)I\'ve used Git for a little over a year at my present job, and prior to that, used Mercurial for a little over a year at my previous job.  I\'m going to provide an evaluation from a user\'s perspective.First, both are distributed version control systems.  Distributed version control systems require a change in mindset from traditional version control systems, but actually work much better in many ways once one understands them.  For this reason, I consider both Git and Mercurial much superior to Subversion, Perforce, etc.  The difference between distributed version control systems and traditional version control systems is much larger than the difference between Git and Mercurial.However, there are also significant differences between Git and Mercurial that make each better suited to its own subset of use cases.Mercurial is simpler to learn.  I got to the point where I rarely had to refer to documentation or notes after a few weeks of using Mercurial; I still have to refer to my notes regularly with Git, even after using it for a year.  Git is considerably more complicated.This is partly because Mercurial is just plain cleaner.  You rarely have to branch manually in Mercurial; Mercurial will create an anonymous branch automatically for you if and when you need it.  Mercurial nomenclature is more intuitive; you don\'t have to worry about the difference between "fetch" and "pull" as you do with Git.  Mercurial is a bit less buggy.  There are file name case sensitivity issues that used to cause problems when pushing projects across platforms with both Git and Mercurial; this were fixed in Mercurial some time ago while they hadn\'t been fixed in Git last I checked.  You can tell Mercurial about file renames; with Git, if it doesn\'t detect the rename automatically - a very hit or miss proposition in my experience - the rename can\'t be tracked at all.The other reason for Git\'s additional complication, however, is that much of it is needed to support additional features and power.  Yes, it\'s more complicated to handle branching in Git - but on the other hand, once you have the branches, it\'s not too difficult to do things with those branches that are virtually impossible in Mercurial.  Rebasing branches is one of these things:  you can move your branch so that its base, instead of being the state of the trunk when you branched, is the state of the trunk now; this greatly simplifies version history when there are many people working on the same code base, since each of the pushes to trunk can be made to appear sequential, rather than intertwined.  Similarly, it\'s much easier to collapse multiple commits on your branch into a single commit, which can again help in keeping the version control history clean:  ideally, all the work on a feature can appear as a single commit in trunk, replacing all the minor commits and subbranches that the developer may have made while developing the feature.Ultimately I think the choice between Mercurial and Git should depend on how large your version control projects are, measured in terms of the number of people working on them simultaneously.  If you have a group of a dozen or more working on a single monolithic web application, for example, Git\'s more powerful branch management tools will make it a much better fit for your project.  On the other hand, if your team is developing a heterogeneous distributed system, with only one or two developers working on any one component at any one time, using a Mercurial repository for each of the component projects will allow development to proceed more smoothly with less repository management overhead.Bottom line:  if you have a big team developing a single huge application, use Git; if your individual applications are small, with any scale coming from the number rather than the size of such applications, use Mercurial.