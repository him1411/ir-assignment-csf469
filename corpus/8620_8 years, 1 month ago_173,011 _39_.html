How are \\r and \\n different? I think it has something to do with Unix vs. Windows vs. Mac, but I\'m not sure exactly how they\'re different, and which to search for/match in regexes.They\'re different characters. \\r is carriage return, and \\n is line feed.On "old" printers, \\r sent the print head back to the start of the line, and \\n advanced the paper by one line. Both were therefore necessary to start printing on the next line.Obviously that\'s somewhat irrelevant now, although depending on the console you may still be able to use \\r to move to the start of the line and overwrite the existing text.More importantly, Unix tends to use \\n as a line separator; Windows tends to use \\r\\n as a line separator and Macs (up to OS 9) used to use \\r as the line separator. (Mac OS X is Unix-y, so uses \\n instead; there may be some compatibility situations where \\r is used instead though.)For more information, see the Wikipedia newline article.EDIT: This is language-sensitive. In C# and Java, for example, \\n always means Unicode U+000A, which is defined as line feed. In C and C++ the water is somewhat muddier, as the meaning is platform-specific. See comments for details.In C and C++, \\n is a concept, \\r is a character, and \\r\\n is (almost always) a portability bug.Think of an old teletype.  The print head is positioned on some line and in some column.  When you send a printable character to the teletype, it prints the character at the current position and moves the head to the next column.  (This is conceptually the same as a typewriter, except that typewriters typically moved the paper with respect to the print head.)When you wanted to finish the current line and start on the next line, you had to do two separate steps:ASCII encodes these actions as two distinct control characters:In the days of teletypes and early technology printers, people actually took advantage of the fact that these were two separate operations.  By sending a CR without following it by a LF, you could print over the line you already printed.  This allowed effects like accents, bold type, and underlining.  Some systems overprinted several times to prevent passwords from being visible in hardcopy.  On early serial CRT terminals, CR was one of the ways to control the cursor position in order to update text already on the screen.But most of the time, you actually just wanted to go to the next line.  Rather than requiring the pair of control characters, some systems allowed just one or the other.  For example:Why did different systems choose different methods?  Simply because there was no universal standard.  Where your keyboard probably says "Enter", older keyboards used to say "Return", which was short for Carriage Return.  In fact, on a serial terminal, pressing Return actually sends the CR character.  If you were writing a text editor, it would be tempting to just use that character as it came in from the terminal.  Perhaps that\'s why the older Macs used just CR.Now that we have standards, there are more ways to represent line breaks.  Although extremely rare in the wild, Unicode has new characters like:Even before Unicode came along, programmers wanted simple ways to represent some of the most useful control codes without worrying about the underlying character set.  C has several escape sequences for representing control codes:(This list is intentionally incomplete.)This mapping happens at compile-time--the compiler sees \\a and puts whatever magic value is used to ring the bell.Notice that most of these mnemonics have direct correlations to ASCII control codes.  For example, \\a would map to 0x07 BEL.  A compiler could be written for a system that used something other than ASCII for the host character set (e.g., EBCDIC).  Most of the control codes that had specific mnemonics could be mapped to control codes in other character sets.Huzzah!  Portability!Well, almost.  In C, I could write printf("\\aHello, World!"); which rings the bell (or beeps) and outputs a message.  But if I wanted to then print something on the next line, I\'d still need to know what the host platform requires to move to the next line of output.  CR LF?  CR?  LF?  NL?  Something else?  So much for portability.C has two modes for I/O:  binary and text.  In binary mode, whatever data is sent gets transmitted as-is.  But in text mode, there\'s a run-time translation that converts a special character to whatever the host platform needs for a new line (and vice versa).Great, so what\'s the special character?Well, that\'s implementation dependent, too, but there\'s an implementation-independent way to specify it: \\n.  It\'s typically called the "newline character".This is a subtle but important point: \\n is mapped at compile time to an implementation-defined character value which (in text mode) is then mapped again at run time to the actual character (or sequence of characters) required by the underlying platform to move to the next line.\\n is different than all the other backslash literals because there are two mappings involved.  This two-step mapping makes \\n significantly different than even \\r, which is simply a compile-time mapping to CR (or the most similar control code in whatever the underlying character set is).This trips up many C and C++ programmers.  If you were to poll 100 of them, at least 99 will tell you that \\n means line feed.  This is not entirely true.  Most (perhaps all) C and C++ implementations use LF as the magic intermediate value for \\n, but that\'s an implementation detail.  It\'s feasible for a compiler to use a different value.  In fact, if the host character set is not a superset of ASCII (e.g., if it\'s EBCDIC), then \\n will almost certainly not be LF.So, in C and C++:"\\n" => Newline or Linefeed\n(semantics)Unix based systems use just a "\\n" to end a line of text. In short \\r has ASCII value 13 (CR) and \\n has ASCII value 10 (LF).\nMac uses CR as line delimiter (at least, it did before, I am not sure for modern macs), *nix uses LF and Windows uses both (CRLF).\\r is used to point to the start of a line and can replace the text from there, e.g.Produces this output:\\n is for new line.In addition to @Jon Skeet\'s answer:Traditionally Windows has used \\r\\n, Unix \\n and Mac \\r, however newer Macs use \\n as they\'re unix based.in C# I found they use \\r\\n in a string.\\r is Carriage Return; \\n is New Line (Line Feed) ... depends on the OS as to what each means. Read this article for more on the difference between \'\\n\' and \'\\r\\n\' ... in C.\\r used for carriage return.  (ASCII value is 13)\n\\n used for new line. (ASCII value is 10)