I made a collection for which I want to provide an STL-style, random-access iterator. I was searching around for an example implementation of an iterator but I didn\'t find any. I know about the need for const overloads of [] and * operators. What are the requirements for an iterator to be "STL-style" and what are some other pitfalls to avoid (if any)?Additional context: This is for a library and I don\'t want to introduce any dependency on it unless I really need to. I write my own collection to be able to provide binary compatibility between C++03 and C++11 with the same compiler (so no STL which would probably break).http://www.cplusplus.com/reference/std/iterator/ has a handy chart that details the specs of \xc2\xa7 24.2.2 of the C++11 standard.  Basically, the iterators have tags that describe the valid operations, and the tags have a hierarchy.  Below is purely symbolic, these classes don\'t actually exist as such.You can either specialize std::iterator_traits<youriterator>, or put the same typedefs in the iterator itself, or inherit from std::iterator (which has these typedefs).  I prefer the second option, to avoid changing things in the std namespace, and for readability, but most people inherit from std::iterator.Note the iterator_category should be one of std::input_iterator_tag, std::output_iterator_tag, std::forward_iterator_tag, std::bidirectional_iterator_tag, or std::random_access_iterator_tag, depending on which requirements your iterator satisfies.  Depending on your iterator, you may choose to specialize std::next, std::prev, std::advance, and std::distance as well, but this is rarely needed.  In extremely rare cases you may wish to specialize std::begin and std::end.Your container should probably also have a const_iterator, which is a (possibly mutable) iterator to constant data that is similar to your iterator except it should be implicitly constructable from a iterator and users should be unable to modify the data.  It is common for its internal pointer to be a pointer to non-constant data, and have iterator inherit from const_iterator so as to minimize code duplication.My post at Writing your own STL Container has a more complete container/iterator prototype.The iterator_facade documentation from Boost.Iterator provides what looks like a nice tutorial on implementing iterators for a linked list.  Could you use that as a starting point for building a random-access iterator over your container?If nothing else, you can take a look at the member functions and typedefs provided by iterator_facade and use it as a starting point for building your own.Thomas Becker wrote a useful article on the subject here.There was also this (perhaps simpler) approach that appeared previously on SO: How to correctly implement custom iterators and const_iterators?First of all you can look here for a list of the various operations the individual iterator types need to support.Next, when you have made your iterator class you need to either specialize std::iterator_traits for it and provide some neccessary typedefs (like iterator category or value type) or alternatively derive it from std::iterator, which defines the needed typedefs for you and can therefore be used with the default std::iterator_traits.disclaimer: I know some people don\'t like cplusplus.com that much, but they provide some really useful information on this.Here is sample of raw pointer iterator.You shouldn\'t use iterator class to work with raw pointers!Raw pointer range based loop workaround. Please, correct me, if there is better way to make range based loop from raw pointer.And simple testI was/am in the same boat as you for different reasons (partly educational, partly constraints). I had to re-write all the containers of the standard library and the containers had to conform to the standard. That means, if I swap out my container with the stl version, the code would work the same. Which also meant that I had to re-write the iterators. Anyway, I looked at EASTL. Apart from learning a ton about containers that I never learned all this time using the stl containers or through my undergraduate courses. The main reason is that EASTL is more readable than the stl counterpart (I found this is simply because of the lack of all the macros and straight forward coding style). There are some icky things in there (like #ifdefs for exceptions) but nothing to overwhelm you.As others mentioned, look at cplusplus.com\'s reference on iterators and containers.  