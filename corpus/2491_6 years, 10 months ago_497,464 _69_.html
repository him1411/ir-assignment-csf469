How do you extract form data (form[method="post"]) and file uploads sent from the HTTP POST method in Node.js?I\'ve read the documentation, googled and found nothing.Is there a library or a hack?If you use Express (high-performance, high-class web development for Node.js), you can do this:HTML:JavaScript:UPDATED on 1/June/2016:Method above is deprecated use now:You can use the querystring module:Now, for example, if you have an input field with name age, you could access it using the variable post:Make sure to kill the connection if someone tries to flood your RAM!Here\'s a very simple no-framework wrapper based on the other answers and articles posted in here:Usage example:It will be cleaner if you encode your data to JSON, then send it to Node.js.A lot of answers here are not good practices anymore or don\'t explain anything, so that\'s why I\'m writing this.When the callback of http.createServer is called, is when the server have actually received all the headers for the request, but it\'s possible that the data have not been received yet, so we have to wait for it. The http request object(a http.IncomingMessage instance) is actually a readable stream. In readable streams whenever a chunk of data arrives, a data event is emitted(assuming you have registered a callback to it) and when all chunks have arrived an end event is emitted. Here\'s an example on how you listen to the events: If you try this you will notice the chunks are buffers. If you are not dealing with binary data and need to work with strings instead I suggest use request.setEncoding method which causes the stream emit strings interpreted with the given encoding and handles multi-byte characters properly.Now you are probably not interested in each chunk by it\'s own, so in this case probably you want to buffer it like this:Here Buffer.concat is used, which simply concatenates all buffers and return one big buffer. You can also use the concat-stream module which does the same:If you are trying to accept HTML forms POST submission with no files or handing jQuery ajax calls with the default content type, then the content type is application/x-www-form-urlencoded with uft-8 encoding. You can use the querystring module to de-serialize it and access the properties:If your content type is JSON instead, you can simply use JSON.parse instead of qs.parse.If you are dealing with files or handling multipart content type, then in that case, you should use something like formidable which removes all the pain from dealing with it. Have a look at this other answer of mine where I have posted helpful links and modules for multipart content.If you don\'t want to parse the content but rather pass it to somewhere else, for example send it to another http request as the data or save it to a file I suggest piping it rather than buffering it, as it\'ll be less code, handles back pressure better, it\'ll take less memory and in some cases faster.So if you want to save the content to a file:As other answers have noted keep in my mind that malicious clients might send you a huge amount of data to crash your application or fill your memory so to protect that make sure you drop requests which emit data pass a certain limit. If you don\'t use a library to handle the incoming data. I would suggest using something like stream-meter which can abort the request if reaches the specified limit:or or Also try to use npm modules rather implementing on your own as they will probably handle edge cases better. For express I suggest using body-parser. For koa, there\'s a similar module.If you don\'t use a framework, body is quite good.For anyone wondering how to do this trivial task without installing a web framework I managed to plop this together. Hardly production ready but it seems to work.You can use body-parser, the Node.js body parsing middleware.First load body-parser Some example codeMore documentation can be found hereIf you don\'t want to chunk your data together with the data callback you can always use the readable callback like this:This approach modifies the incoming request, but as soon as you finish your response the request will be garbage collected, so that should not be a problem.An advanced approach would be to check the body size first, if you\'re afraid of huge bodies.Here is how you can do it if you use node-formidable:You need to receive the POST data in chunks using request.on(\'data\', function(chunk) {...})You should consider adding a size limit at the indicated position as thejh suggested.There are multiple ways to do it. However, the quickest way I know is to use the Express.js library with body-parser.That can work for strings, but I would change bodyParser.urlencoded to bodyParser.json instead if the POST data contains a JSON array.More info: http://www.kompulsa.com/how-to-accept-and-parse-post-requests-in-node-js/And if you don\'t want to use the entire framework like Express, but you also need different kinds of forms, including uploads, then formaline may be a good choice.It is listed in Node.js modulesIf you are using Express.js, before you can access to the req.body, you must add middleware bodyParser:Then you can ask forThanksLimit POST size avoid flood your node app.\nThere is a great raw-body module, suitable both for express and connect, that can help you limit request by size and length.I found a video which explains on how to achieve this:\nhttps://www.youtube.com/watch?v=nuw48-u3YrgIt uses default "http" module together with "querystring" and "stringbuilder" modules.  The application takes two numbers (using two textboxes) from a web page and upon submit, returns sum of those two (along with persisting the values in the textboxes).  This is the best example I could find anywhere else.Related source code:If it involves a file upload, the browser usually send it as a "multipart/form-data" content-type.\nYou can use this in such casesReference 1Reference 2On form fields like these some of the above answers will fail because they only support flat data.For now I am using the Casey Chu answer but with the "qs" instead of the "querystring" module. This is the module "body-parser" uses as well. So if you want nested data you have to install qs. Then replace the first line like:For those using raw binary POST upload without encoding overhead you can use:client:server:This should work :you can extract post parameter without using express. 1: nmp  install multiparty2:  import multiparty . as var multiparty = require(\'multiparty\');3: `4: and HTML FORM IS . I hope this will work for you. Thanks.