How do I convert a char to an int in C and C++?Depends on what you want to do:to read the value as an ascii code, you can writeto convert the character \'0\' -> 0, \'1\' -> 1, etc, you can writeC and C++ always promote types to at least int. Furthermore character literals are of type int in C and char in C++.You can convert a char type simply by assigning to an int. Well, in ascii code numbers start from 48. All you need to do is:char is just a 1 byte integer. There is nothing magic with the char type! Just as you can assign a short to an int, or an int to a long, you can assign a char to an int.Yes, the name of the primitive data type happens to be "char", which insinuates that it should only contain characters. But in reality, "char" is just a poor name choise to confuse everyone who tries to learn the language. A better name for it is int8_t, and you can use that name instead, if your compiler follows the latest C standard.Though of course you should use the char type when doing string handling, because the index of the classic ASCII table fits in 1 byte. You could however do string handling with regular ints as well, although there is no practical reason in the real world why you would ever want to do that. For example, the following code will work perfectly:You have to realize that characters and strings are just numbers, like everything else in the computer. When you write \'a\' in the source code, it is pre-processed into the number 97, which is an integer constant.So if you write an expression likethis is actually equivalent towhich is then going through the C language integer promotionsand then truncated to a char to fit the result typeThere\'s a lot of subtle things like this going on between the lines, where char is implicitly treated as an int.(This answer addresses the C++ side of things, but the sign extension problem exists in C too.)Handling all three char types (signed, unsigned, and "char") is more delicate than it first appears.  Values in the range 0 to SCHAR_MAX (which is 127 for an 8-bit char) are easy:But when somevalue is outside of that range, only going through unsigned char gives you consistent results for the "same" char values in all three types:This is important when using functions from <ctype>, such as isupper or toupper, because of sign extension:Note the conversion through int is implicit; this has the same UB:To fix this, go through unsigned char, which is easily done by wrapping <ctype> functions through safe_ctype:This works because any function taking any of the three char types can also take the other two char types.  It leads to two functions which can handle any of the types:Ord(c) always gives you a non-negative value \xe2\x80\x93 even when passed a negative char or negative signed char \xe2\x80\x93 and chr takes any value ord produces and gives back the exact same char.In practice, I would probably just cast through unsigned char instead of using these, but they do succinctly wrap the cast, provide a convenient place to add error checking for int-to-char, and would be shorter and more clear when you need to use them several times in close proximity.It sort of depends on what you mean by "convert". If you have a series of characters that represents an integer, like "123456", then there are two typical ways to do that in C: Use a special-purpose conversion like atoi() or strtol(), or the general-purpose sscanf(). C++ (which is really a different language masquerading as an upgrade) adds a third, stringstreams.If you mean you want the exact bit pattern in one of your int variables to be treated as a char, that\'s easier. In C the different integer types are really more of a state of mind than actual separate "types". Just start using it where chars are asked for, and you should be OK. You might need an explicit conversion to make the compiler quit whining on occasion, but all that should do is drop any extra bits past 256.Use static_cast<int>:Edit: You probably should try to avoid to use (int)int num = (int) letter;check out Why use static_cast<int>(x) instead of (int)x? for more info.Presumably you want this conversion for using functions from the C standard library.In that case, do (C++ syntax)The expression UChar( c ) converts to unsigned char in order to get rid of negative values, which, except for EOF, are not supported by the C functions.Then the result of that expression is used as actual argument for an int formal argument. Where you get automatic promotion to int. You can alternatively write that last step explicitly, like int( UChar( c ) ), but personally I find that too verbose.Cheers & hth.,I was having problems converting a char array like "7c7c7d7d7d7d7c7c7c7d7d7d7d7c7c7c7c7c7c7d7d7c7c7c7c7d7c7d7d7d7c7c2e2e2e" into its actual integer value that would be able to be represented by `7C\' as one hexadecimal value. So, after cruising for help I created this, and thought it would be cool to share.This separates the char string into its right integers, and may be helpful to more people than just me ;)Hope it helps!For char or short to int, you just need to assign the value.Same to int64.All values will be 16.I have absolutely null skills in C, but for a simple parsing:     ...this worked for me: