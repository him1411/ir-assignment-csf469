I am trying to work on sending an object of my customer class from one Activity and display it in another Activity.The code for the customer class:I want to send its object from one Activity to another and then display the data on the other Activity.How can I achieve that?One option could be letting your custom class implement the Serializable interface and then you can pass object instances in the intent extra using the putExtra(Serializable..) variant of the Intent#putExtra() method.Pseudocode:Implement your class with Serializable. Let\'s suppose that this is your entity class:We are sending the object called dene from X activity to Y activity. Somewhere in X activity;In Y activity we are getting the object.That\'s it.Using global static variables is not good software engineering practice. Converting an object\'s fields into primitive data types can be a hectic job. Using serializable is OK, but it\'s not performance-efficient on the Android platform. Parcelable is specifically designed for Android and you should use it. Here is a simple example: Passing custom objects between Android activitiesYou can generate Parcelable code for you class using this site.While calling an activity In toClass.java receive the activity by Please make sure that customer class implements parcelableIn my experience there are three main solutions, each with their disadvantages and advantages:Implementing ParcelableImplementing SerializableUsing a light-weight event bus library of some sort (for example, Greenrobot\'s EventBus or Square\'s Otto)Parcelable - fast and Android standard, but it has lots of boilerplate code and requires hard-coded strings for reference when pulling values out the intent (non-strongly typed).Serializable - close to zero boilerplate, but it is the slowest approach and also requires hard-coded strings when pulling values out the intent (non-strongly typed).Event Bus - zero boilerplate, fastest approach, and does not require hard-coded strings, but it does require an additional dependency (although usually lightweight, ~40Â KB)I posted a very detailed comparison around these three approaches, including efficiency benchmarks. If you are interested you can find it at\nPassing Objects Between Android Activities.Use gson to convert your object to JSON and pass it through intent. In the new Activity convert the JSON to an object.Example:And in your next activity, where you want to pass object:You could also write the object\'s data into temporary Strings and ints, and pass them to the activity. Of course that way, you get the data transported, but not the object itself.But if you just want to display them, and not use the object in another method or something like that, it should be enough. I did it the same way to just display data from one object in another activity.You could also pass them in directly instead of the temp ivars, but this way it\'s clearer, in my opinion. Additionally, you can set the temp ivars to null so that they get cleaned by the GarbageCollector sooner.Good luck!On a side note: override toString() instead of writing your own print method.As mentioned in the comments below, this is how you get your data back in another activity:There are a couple of ways by which you can access variables or objects in other classes or Activity.A. DatabaseB. Shared preferences.C. Object serialization.D. A class which can hold common data can be named as Common Utilities. It depends on you.E. Passing data through Intents and Parcelable Interface.It depends upon your project needs.A. DatabaseSQLite is an open source database which is embedded into Android. SQLite supports standard relational database features like SQL syntax, transactions and prepared statements.TutorialsB. Shared preferencesSuppose you want to store username. So there will now be two things, a key username, value value.How to storeUsing putString(), putBoolean(), putInt(), putFloat(), and putLong() you can save your desired dtatype.How to fetchhttp://developer.android.com/reference/android/content/SharedPreferences.htmlC. Object serializationObject serlization is used if we want to save an object state to send it over a network or you can use it for your purpose also.Use Java beans and store in it as one of his fields and use getters and setter for that.JavaBeans are Java classes that have properties. Think of\nproperties as private instance variables. Since they\'re private, the only way\nthey can be accessed from outside of their class is through methods in the class. The methods that change a property\'s value are called setter methods, and the methods that retrieve a property\'s value are called getter methods.Set the variable in your mail method by usingThen use object serialzation to serialize this object and in your other class deserialize this object.In serialization an object can be represented as a sequence of bytes that includes the object\'s data as well as information about the object\'s type and the types of data stored in the object.After a serialized object has been written into a file, it can be read from the file and deserialized. That is, the type information and bytes that represent the object and its data can be used to recreate the object in memory.If you want tutorial for this refer to:Serialization in Java (blog post)Get variable in other classes (Stack Overflow)D. CommonUtilitiesYou can make a class by yourself which can contain common data which you frequently need in your project.SampleE. Passing data through intentsPlease refer the tutorial Android \xe2\x80\x93 Parcel data to pass between Activities using Parcelable classes for this option of passing data.I made a singleton helper class that holds temporary objects.Instead of putting your objects within Intent, use IntentHelper:Inside your new Activity, you can get the object:Bear in mind that once loaded, the object is removed to avoid unnecessary references. I found a simple & elegant method:Code for the first activity:Code for the second activity:you will find objSent & objReceived have the same hashCode, so they are identical.But why can we pass a java object in this way?Actually, android binder will create global JNI reference for java object and release this global JNI reference when there are no reference for this java object. binder will save this global JNI reference in the Binder object.*CAUTION: this method ONLY work unless the two activities run in the same process, otherwise throw ClassCastException at (ObjectWrapperForBinder)getIntent().getExtras().getBinder("object_value") *class ObjectWrapperForBinder  definationBut Method 2 has a little but serious issue, if the receiver fail to restore the java object (for example, some exception happen before restore the java object, or the receiver Activity does not exist at all), then the java object will become an orphan or memory leak, \nMethod 1  don\'t have this issue, because android binder will handle this exceptionTo invoke the java object remotely, we will create a data contract/interface to describe the java object, we will use the aidl fileIDataContract.aidlCode for the first activityCode for the second activity:change the android:process attribute in AndroidManifest.xml to a non-empty process name to  make sure the second activity run in another processIn this way, we can pass an interface between two activities even though they run in different process, and call the interface method remotelymethod 3 seem not simple enough because we must implement an aidl interface.\nIf you just want to do simple task and the method return value is unnecessary, we can use android.os.MessengerCode for the first activity( sender):Code for the second activity ( receiver ):All the Messenger.send will execute in a Handler asynchronously and sequentially.Actually, android.os.Messenger is also an aidl interface, if you have the android source code, you can find a file named IMessenger.aidl The best way is to have a class (call it Control) in your application that will hold a static variable of type \'Customer\' (in your case). Initialize the variable in your Activity A.For example:Then go to Activity B and fetch it from Control class. Don\'t forget to assign a null after using the variable, otherwise memory will be wasted.Now you want to pass the object of this class in startActivity. Simply use this:This works here because MyClass implements Serializable.Create your own class Customer as following:In your onCrate() methodIn xyz activity class you neet to use following code:If you choose use the way Samuh describes, remember that only primitive values can be sent. That is, values that are parcable. So, if your object contains complex objects these will not follow. For example, variables like Bitmap, HashMap etc... These are tricky to pass by the intent.In general I would advice you to send only primitive datatypes as extras, like String, int, boolean etc. In your case it would be: String fname, String lname, int age, and String address.My opinion: More complex objects are better shared by implementing a ContentProvider, SDCard, etc. It\'s also possible to use a static variable, but this may fastly lead to error-prone code...But again, it\'s just my subjective opinion.I am using parcelable to send data from one activity to another acivity. Here is my code that works fine in my project.In activityA use it like this:In ActivityB use it like this to get data:You can try to use that class. The limitation is that it can\'t be used outside of one process.One activity:Other activity:Crete a class like bean class and implement the Serializable interface. Then we can pass it through the intent method, for example:Then get it from the other activity, for example: Create two methods in your custom Class like thisNow in your sender Activity do like thisAnd in your receiver ActivityThis question is also discussed in another Stack Overflow question. Please have a look at a solution to Passing data through intent using Serializable. The main point is about using Bundle object which stores the necessary data inside Intent.To extract values:Advantage of Serializable is its simplicity. However, you should consider using Parcelable method if you need many data to be transferred, because Parcelable is specifically designed for Android and it is more efficient than Serializable. You can create Parcelable class using:Yeah, using a static object is by far the easiest way of doing this with custom non-serialisable objects.Android Activity objects can be destroyed and reconstituted. So, you will need to use another approach to look them - or any object they create!!! -  up. That is, you could pass as static class reference but then the object handle (Java calls these "references", as does SmallTalk; but they are not references in the sense of C or assembly) will be possibly invalid later because a "feature" of Android OE is any Activity can be annihilated and reconstituted later.The original question asked "How to pass object from one activity to another in Android" and nobody has answered that. For sure, you can serialized (Serializable, Parcelable, to/from JSON) and pass a copy of the object\'s data and a new object having the same data could be created; but it will NOT have the same references/handles.  Also, many others mentioned you can store the reference in a static store. And that will work unless Android decides to onDestroy your Activity. So, to really solve the original question you would need a static lookup plus each object will update its reference when/if it is recreated. E.g. each Android Activity would relist itself if its onCreate is called. You can also see how some people use the task list to search out an Activity by name. (system is temporarily destroying this instance of the activity to save space..getRunningTasks, the task list is effectively a specialized listing of the most recent object instance of each Activity).For reference:Stopped:\n  "The activity is completely obscured by another activity (the activity is now in the "background"). A stopped activity is also still alive (the Activity object is retained in memory, it maintains all state and member information, but is not attached to the window manager). However, it is no longer visible to the user and it can be killed by the system when memory is needed elsewhere."onDestroy\n  "system is temporarily destroying this instance of the activity to save space."So, the Message Bus is a workable solution. It basically "punts". Rather than try to have references to objects; then you re-architect your design to use MessagePassing instead of SequentialCode. Exponentially harder to debug; but it lets you ignore these sort of OperatingEnvironment understandings. Effectively, each object method access is inverted so the caller posts a Message and the object itself defines a handler for that message. Lots more code but can make it robust with the Android OE restrictions.If all you want is the top Activity (typical thing in Android apps due to "Context" being needed everywhere), then you can just have each Activity lists itself as "top" in the static global space whenever its onResume is called. Then your AlertDialog or whatever which needs a context can just grab it from there. Also, its a bit yucky to use a global but can simplifying passing a Context up and down everywhere and, for sure, when you use a MessageBus then IT IS global anyways. I know that static is bad, but it seems that we\'re forced to use it here. The problem with parceables/seriazables is that the two activities have duplicate instances of the same object = waste of memory and CPU.Calling activityCalled activity (note that onCreate() and onResume() may be called multiple times when the system destroys and recreates activities)Another way is to declare a static field of the class that you want to pass in that very class. It will serve only for this purpose. Don\'t forget that it can be null in onCreate, because your app package has been unloaded from memory by system and reloaded later.Bearing in mind that you still need to handle activity lifecycle, you may want to write all the data straight to shared preferences, painful with complex data structures as it is.Start another activity from this activity and pass parameters via Bundle ObjectRetrive data on another activity (YourActivity)This is ok for simple kind of data type.\nBut if u want to pass complex data in between activity. U need to serialize it first.Here we have Employee ModelYou can use Gson lib provided by google to serialize the complex data \nlike thisI had always wondered why this can\'t be as simple as calling into a method of the other activity. I recently wrote a utility library that makes it almost as simple as that. You can check it out here(https://github.com/noxiouswinter/gnlib_android/wiki/gnlauncher). GNLauncher makes sending objects/data to an Activity from another Activity etc as easy as calling a function in tha Activity with the required data as parameters. It introduces type safety and removes all the hastles of having to serialize, attaching to the intent using string keys and undoing the same at the other end.Define an interface with the methods you want to call on the Activity to launch.Implement the above interface on the Activity to launch into.\nAlso notify GNLauncher when the activity is ready.In the other Activity, get a proxy to the above Activity and call any method with the desired parameters.The first activity will be launched and the method called into with the required parameters.Please refer to https://github.com/noxiouswinter/gnlib_android/wiki#prerequisites for information on how to add the dependencies. Pass object from one activity to another activity.    (1) source activity(2) destination acitivityI used to set object with Pacelable or Serializable to transfer, but whenever I add other variables to object(model), I have to register it all. It\'s so nconvenient. It\'s super easy to transfer object between activities or fragments. Android DataCacheWe can pass the object from one activity to another activity:Inside poSuppliersDetails we have some values. Now I am sending this object to target activity:How to get this in ACtivityTwo:Above answers almost all correct but for those who doesn\'t undestand those answers\nAndroid has powerfull class Intent with help of it you share data between not only activity but another components of Android (broadcasr receiver, servises for content provide we use ContetnResolver class no Intent).\nIn your activity you build intentIn your receving activity you haveYou have to implement Parceable or Serializable interface on your object in order to share between activities. It is hard to implement Parcealbe  rather than Serializable interface on object that\'s why android has plugin especially for this.Download it and use itPass one activity to another:Get values:Hello all I see a lot of good options but I was wondering why Binding hasn\'t been used?Passing a reference to an object just seems more efficient to me than serializing and desterilizing objects, but I have not done a deep dive to see if that is what is going on behind the scenes.Creating a Binder is simple enough...And creating the parcelable to use it isn\'t that bad ether.This logic is really cool because you are actually passing a reference from activity to activity.I would advise checking for nulls and if the instanceof Binder is MyBinder!and to implement this you just...Send it offGet it backHeck someone could get all crazy and make this sucker a true generic.