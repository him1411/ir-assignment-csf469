It seems to me that having a "function that always returns 5" is breaking or diluting the meaning of "calling a function".  There must be a reason, or a need for this capability or it wouldn\'t be in C++11.  Why is it there? It seems to me that if I wrote a function that return a literal value, and I came up to a code-review, someone would tell me, I should then, declare a constant value instead of writing return 5.Suppose it does something a little more complicated.Now you have something that can be evaluated down to a constant while maintaining good readability and allowing slightly more complex processing than just setting a constant to a number.It basically provides a good aid to maintainability as it becomes more obvious what you are doing.  Take max( a, b ) for example:Its a pretty simple choice there but it does mean that if you call max with constant values it is explicitly calculated at compile time and not at runtime.Another good example would be a DegreesToRadians function.  Everyone finds degrees easier to read than radians.  While you may know that 180 degrees is in radians it is much clearer written as follows:Lots of good info here:http://en.cppreference.com/w/cpp/language/constexprTake std::numeric_limits<T>::max(): for whatever reason, this is a method. constexpr would be beneficial here.Another example: you want to declare a C-array (or a std::array) that is as big as another array. The way to do this at the moment is like so:But wouldn\xe2\x80\x99t it be better to be able to write:Thanks to constexpr, you can:constexpr was not introduced as a way to tell the implementation that something can be evaluated in a context which requires a constant-expression; conforming implementations has been able to prove this prior to C++11.Something an implementation cannot prove is the intent of a certain piece of code:Let\'s say you are developing a library and realize that you want to be able to calculate the sum of every integer in the interval (0,N].A compiler can easily prove that the above function is callable in a constant-expression if the argument passed is known during translation; but you have not declared this as an intent - it just happened to be the case.Now someone else comes along, reads your function, does the same analysis as the compiler; "Oh, this function is usable in a constant-expression!", and writes the following piece of code.You, as an "awesome" library developer, decide that f should cache the result when being invoked; who would want to calculate the same set of values over and over?By introducing your silly optimization, you just broke every usage of your function that happened to be in a context where a constant-expression was required.You never promised that the function was usable in a constant-expression, and without constexpr there would be no way of providing such promise. The primary usage of constexpr is to declare intent.If an entity isn\'t marked as constexpr - it was never intended to be used in a constant-expression; and even if it is, we rely on the compiler to diagnose such context (because it disregards our intent).constexpr functions are really nice and a great addition to c++.  However, you are right in that most of the problems it solves can be inelegantly worked around with macros.However, one of the uses of constexpr has no C++03 equivalent, typed constants.From what I\'ve read, the need for constexpr comes from an issue in metaprogramming.  Trait classes may have constants represented as functions, think: numeric_limits::max().  With constexpr, those types of functions can be used in metaprogramming, or as array bounds, etc etc.Another example off of the top of my head would be that for class interfaces, you may want derived types define their own constants for some operation.Edit:After poking around on SO, it looks like others have come up with some examples of what might be possible with constexprs.From Stroustrup\'s speech at "Going Native 2012":Another use (not yet mentioned) is constexpr constructors. This allows creating compile time constants which don\'t have to be initialized during runtime.Pair that with user defined literals and you have full support for literal user defined classes.There used to be a pattern with metaprogramming:I believe constexpr was introduced to let you write such constructs without the need for templates and weird constructs with specialization, SFINAE and stuff - but exactly like you\'d write a run-time function, but with the guarantee that the result will be determined in compile-time.However, note that:Compile this with g++ -O3 and you\'ll see that fact(10) is indeed evaulated at compile-time!An VLA-aware compiler (so a C compiler in C99 mode or C++ compiler with C99 extensions) may even allow you to do:But that it\'s non-standard C++ at the moment - constexpr looks like a way to combat this (even without VLA, in the above case). And there\'s still the problem of the need to have "formal" constant expressions as template arguments.Have just started switching over a project to c++11 and came across a perfectly good situation for constexpr which cleans up alternative methods of performing the same operation.  The key point here is that you can only place the function into the array size declaration when it is declared constexpr.  There are a number of situations where I can see this being very useful moving forward with the area of code that I am involved in.Your basic example serves he same argument as that of constants themselves. Why useoverBecause it\'s way more maintainable. Using constexpr is much, much faster to write and read than existing metaprogramming techniques.It can enable some new optimisations.  const traditionally is a hint for the type system, and cannot be used for optimisation (e.g. a const member function can const_cast and modify the object anyway, legally, so const cannot be trusted for optimisation).constexpr means the expression really is constant, provided the inputs to the function are const.  Consider:If this is exposed in some other module, the compiler can\'t trust that GetNumber() won\'t return different values each time it\'s called - even consecutively with no non-const calls in between - because const could have been cast away in the implementation.  (Obviously any programmer who did this ought to be shot, but the language permits it, therefore the compiler must abide by the rules.)Adding constexpr:The compiler can now apply an optimisation where the return value of GetNumber() is cached and eliminate additional calls to GetNumber(), because constexpr is a stronger guarantee that the return value won\'t change.It\'s useful for something likeTie this in with a traits class or the like and it becomes quite useful.