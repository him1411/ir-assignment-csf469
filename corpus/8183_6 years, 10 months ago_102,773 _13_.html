I have a list of lists:If I wanted to sort by one element, say the tall/short element, I could do it via s = sorted(s, key = itemgetter(1)).If I wanted to sort by both tall/short and colour, I could do the sort twice, once for each element, but is there a quicker way?A key can be a function that returns a tuple:Or you can achieve the same using itemgetter:And notice that here you can use sort instead of using sorted and then reassigning:I\'m not sure if this is the most pythonic method ...\nI had a list of tuples that needed sorting 1st by descending integer values and 2nd alphabetically. This required reversing the integer sort but not the alphabetical sort. Here was my solution: (on the fly in an exam btw, I was not even aware you could \'nest\' sorted functions)It appears you could use a list instead of a tuple. \nThis becomes more important I think when you are grabbing attributes instead of \'magic indexes\' of a list/tuple.  In my case I wanted to sort by multiple attributes of a class, where the incoming keys were strings. I needed different sorting in different places, and I wanted a common default sort for the parent class that clients were interacting with; only having to override the \'sorting keys\' when I really \'needed to\', but also in a way that I could store them as lists that the class could shareSo first I defined a helper methodthen to use itThis will use the generated lambda function sort the list by object.attrA and then object.attrB assuming object has a getter corresponding to the string names provided.  And the second case would sort by object.attrC then object.attrA.   This also allows you to potentially expose outward sorting choices to be shard alike by a consumer, a unit test, or for them to perhaps tell you how they want sorting done for some operation in your api by only have to give you a list and not coupling them to your back end implementation.