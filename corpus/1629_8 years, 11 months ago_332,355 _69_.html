I\'d like to do the equivalent of the following in LINQ, but I can\'t figure out how:What is the real syntax?There is no ForEach extension for IEnumerable; only for List<T>. So you could doAlternatively, write your own ForEach extension method:Fredrik has provided the fix, but it may be worth considering why this isn\'t in the framework to start with. I believe the idea is that the LINQ query operators should be side-effect-free, fitting in with a reasonably functional way of looking at the world. Clearly ForEach is exactly the opposite - a purely side-effect-based construct.That\'s not to say this is a bad thing to do - just thinking about the philosophical reasons behind the decision.Update 7/17/2012: Apparently as of C# 5.0, the behavior of foreach described below has been changed and "the use of a foreach iteration variable in a nested lambda expression no longer produces unexpected results." This answer does not apply to C# \xe2\x89\xa5 5.0. @John Skeet and everyone who prefers the foreach keyword.The problem with "foreach" in C# prior to 5.0, is that it is inconsistent with how the equivalent "for comprehension" works in other languages, and with how I would expect it to work (personal opinion stated here only because others have mentioned their opinion regarding readability).  See all of the questions concerning "Access to modified closure"\nas well as "Closing over the loop variable considered harmful".  This is only "harmful" because of the way "foreach" is implemented in C#.Take the following examples using the functionally equivalent extension method to that in @Fredrik Kalseth\'s answer.Apologies for the overly contrived example.  I\'m only using Observable because it\'s not entirely far fetched to do something like this. Obviously there are better ways to create this observable, I am only attempting to demonstrate a point.  Typically the code subscribed to the observable is executed asynchronously and potentially in another thread.  If using "foreach", this could produce very strange and potentially non-deterministic results.The following test using "ForEach" extension method passes:The following fails with the error:Expected: equivalent to < 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 > \n   But was:  < 9, 9, 9, 9, 9, 9, 9, 9, 9, 9 >You could use the FirstOrDefault() extension, which is available for IEnumerable<T>. By returning false from the predicate, it will be run for each element but will not care that it doesn\'t actually find a match. This will avoid the ToList() overhead.I took Fredrik\'s method and modified the return type.This way, the method supports deferred execution like other LINQ methods.EDIT: If this wasn\'t clear, any usage of this method must end with ToList() or any other way to force the method to work on the complete enumerable. Otherwise, the action would not be performed!And here\'s the test to help see it:If you remove the ToList() in the end, you will see the test failing since the StringBuilder contains an empty string. This is because no method forced the ForEach to enumerate.I\'d like to do the equivalent of the following in LINQ, but I can\'t figure out how:As others have pointed out here and abroad LINQ and IEnumerable methods are expected to be side-effect free. Do you really want to "do something" to each item in the IEnumerable? Then foreach is the best choice. People aren\'t surprised when side-effects happen here. However in my experience side-effects are usually not required. More often than not there is a simple LINQ query waiting to be discovered accompanied by a StackOverflow.com answer by either Jon Skeet, Eric Lippert, or Marc Gravell explaining how to do what you want!If you are actually just aggregating (accumulating) some value then you should consider the Aggregate extension method.Perhaps you want to create a new IEnumerable from the existing values. Or maybe you want to create a look-up table:The list (pun not entirely intended) of possibilities goes on and on. If you can use IQueryable<T> instead of IEnumerable<T>, then the Select method should do what you want. Although as Martin Harris points out, the Select() won\'t actually be evaluated until you enumerate the collection, so if you\'re relying on DoStuff() to perform some side-effect, you\'re better off with something likeLINQ\'s select method doesn\'t really have anything in common with the SQL SELECT keyword; what it does is apply a function to each element in a set, and return a (lazy-evaluated!) set containing the results of those functions.There is an experimental release by Microsoft of Interactive Extensions to LINQ (also on NuGet, see RxTeams\'s profile for more links). The Channel 9 video explains it well.Its docs are only provided in XML format. I have run this documentation in Sandcastle to allow it to be in a more readable format.  Unzip the docs archive and look for index.html.Among many other goodies, it provides the expected ForEach implementation. It allows you to write code like this:The purpose of ForEach is to cause side effects.\nIEnumerable is for lazy enumeration of a set.This conceptual difference is quite visible when you consider it.SomeEnumerable.ForEach(item=>DataStore.Synchronize(item));This wont execute until you do a "count" or a "ToList()" or something on it.\nIt clearly is not what is expressed.You should use the IEnumerable extensions for setting up chains of iteration, definining content by their respective sources and conditions. Expression Trees are powerful and efficient, but you should learn to appreciate their nature. And not just for programming around them to save a few characters overriding lazy evaluation.According to PLINQ (available since .Net 4.0), you can do anto do a parallel foreach loop on an IEnumerable.As numerous answers already point out, you can easily add such an extension method yourself. However, if you don\'t want to do that, although I\'m not aware of anything like this in the BCL, there\'s still an option in the System namespace, if you already have a reference to Reactive Extension (and if you don\'t, you should have):Although the method names are a bit different, the end result is exactly what you\'re looking for.If you want to act as the enumeration rolls you should yield each item.Many people mentioned it, but I had to write it down. Isn\'t this most clear/most readable?Short and simple(st).Now we have the option of...Of course, this opens up a whole new can of threadworms.ps (Sorry about the fonts, it\'s what the system decided)Inspired by Jon Skeet, I have extended his solution with the following:Extension Method:Client:.\n.\n.I respectually disagree with the notion that link extension methods should be side-effect free (not only because they aren\'t, any delegate can perform side effects).Consider the following:What the example shows is really just a kind of late-binding that allows one invoke one of many possible actions having side-effects on a sequence of elements, without having to write a big switch construct to decode the value that defines the action and translate it into its corresponding method.If you\'re doing this e.g. because you need the index in your iteration, you could always use a Where construct:This has the added benefit that the original array is returned "unchanged" (the objects referenced by the list are the same, though they may not have the same data), which is often desireable in functional / chain programming methodologies like LINQ.This "functional approach" abstraction leaks big time. Nothing on the language level prevents side effects. As long as you can make it call your lambda/delegate for every element in the container - you will get the "ForEach" behavior.Here for example one way of merging srcDictionary into destDictionary (if key already exists - overwrites)this is a hack, and should not be used in any production code.For VB.NET you should use:ForEach can also be Chained, just put back to the pileline after the action. remain fluentEdit2 above code is working, but a better version is using this. Edit below was a wrong example, pointed out by Taemyr. Thanks lots.\nI\'m wondering why noone has responded by use of delegate function yet?\nIn my coding I find it a far more clear and concise way of representing a subroutine you\'d like to execute on iteration of a list.NOTE: from experience, I always suggest using ToList() to avoid any issues with indexing if your original list changes, see example below:Yet another ForEach Example 