I just started trying out node.js a few days ago. I\'ve realized that the Node is terminated whenever I have an unhandled exception in my program. This is different than the normal server container that I have been exposed to where only the Worker Thread dies when unhandled exceptions occur and the container would still be able to receive the request. This raises a few questions:I would appreciate any pointer/article that would show me the common best practices for handling uncaught exceptions in node.jsUpdate: Joyent now has their own guide mentioned in this answer. The following information is more of a summary:Ideally we\'d like to avoid uncaught errors as much as possible, as such, instead of literally throwing the error, we can instead safely "throw" the error using one of the following methods depending on our code architecture:For synchronous code, if an error happens, return the error:For callback-based (ie. asynchronous) code, the first argument of the callback is err, if an error happens err is the error, if an error doesn\'t happen then err is null. Any other arguments follow the err argument:For eventful code, where the error may happen anywhere, instead of throwing the error, fire the error event instead:Sometimes though, there may still be code that throws an error somewhere which can lead to an uncaught exception and a potential crash of our application if we don\'t catch it safely. Depending on our code architecture we can use one of the following methods to catch it:When we know where the error is occurring, we can wrap that section in a node.js domainIf we know where the error is occurring is synchronous code, and for whatever reason can\'t use domains (perhaps old version of node), we can use the try catch statement:However, be careful not to use try...catch in asynchronous code, as an asynchronously thrown error will not be caught:Another thing to be careful about with try...catch is the risk of wrapping your completion callback inside the try statement like so:This gotcha is very easy to do as your code becomes more complex. As such, it is best to either use domains or to return errors to avoid (1) uncaught exceptions in asynchronous code (2) the try catch catching execution that you don\'t want it to. In languages that allow for proper threading instead of JavaScript\'s asynchronous event-machine style, this is less of an issue.Finally, in the case where an uncaught error happens in a place that wasn\'t wrapped in a domain or a try catch statement, we can make our application not crash by using the uncaughtException listener (however doing so can put the application in an unknown state):Following is a summarization and curation from many different sources on this topic including code example and quotes from selected blog posts. The complete list of best practices can be found hereTL;DR: Handling async errors in callback style is probably the fastest way to hell (a.k.a the pyramid of doom). The best gift you can give to your code is using instead a reputable promise library which provides much compact and familiar code syntax like try-catchOtherwise: Node.JS callback style, function(err, response), is a promising way to un-maintainable code due to the mix of error handling with casual code, excessive nesting and awkward coding patternsCode example - goodcode example anti pattern \xe2\x80\x93 callback style error handlingBlog quote: "We have a problem with promises"\n(From the blog pouchdb, ranked 11 for the keywords "Node Promises")"\xe2\x80\xa6And in fact, callbacks do something even more sinister: they deprive us of the stack, which is something we usually take for granted in programming languages. Writing code without a stack is a lot like driving a car without a brake pedal: you don\xe2\x80\x99t realize how badly you need it, until you reach for it and it\xe2\x80\x99s not there. The whole point of promises is to give us back the language fundamentals we lost when we went async: return, throw, and the stack. But you have to know how to use promises correctly in order to take advantage of them."TL;DR: It pretty common to see code that throws errors as string or as a custom type \xe2\x80\x93 this complicates the error handling logic and the interoperability between modules. Whether you reject a promise, throw exception or emit error \xe2\x80\x93 using Node.JS built-in Error object increases uniformity and prevents loss of error informationOtherwise: When executing some module, being uncertain which type of errors come in return \xe2\x80\x93 makes it much harder to reason about the coming exception and handle it. Even worth, using custom types to describe errors might lead to loss of critical error information like the stack trace!Code example - doing it rightcode example anti patternBlog quote: "A string is not an error"\n(From the blog devthought, ranked 6 for the keywords \xe2\x80\x9cNode.JS error object\xe2\x80\x9d)"\xe2\x80\xa6passing a string instead of an error results in reduced interoperability between modules. It breaks contracts with APIs that might be performing instanceof Error checks, or that want to know more about the error. Error objects, as we\xe2\x80\x99ll see, have very interesting properties in modern JavaScript engines besides holding the message passed to the constructor.."TL;DR: Operations errors (e.g. API received an invalid input) refer to known cases where the error impact is fully understood and can be handled thoughtfully. On the other hand, programmer error (e.g. trying to read undefined variable) refers to unknown code failures that dictate to gracefully restart the applicationOtherwise: You may always restart the application when an error appear, but why letting ~5000 online users down because of a minor and predicted error (operational error)? the opposite is also not ideal \xe2\x80\x93 keeping the application up when unknown issue (programmer error) occurred might lead unpredicted behavior. Differentiating the two allows acting tactfully and applying a balanced approach based on the given contextCode example - doing it rightcode example - marking an error as operational (trusted)Blog Quote: "Otherwise you risk the state"\n(From the blog debugable, ranked 3 for the keywords "Node.JS uncaught exception")"\xe2\x80\xa6By the very nature of how throw works in JavaScript, there is almost never any way to safely \xe2\x80\x9cpick up where you left off\xe2\x80\x9d, without leaking references, or creating some other sort of undefined brittle state. The safest way to respond to a thrown error is to shut down the process. Of course, in a normal web server, you might have many connections open, and it is not reasonable to abruptly shut those down because an error was triggered by someone else. The better approach is to send an error response to the request that triggered the error, while letting the others finish in their normal time, and stop listening for new requests in that worker"TL;DR: Error handling logic such as mail to admin and logging should be encapsulated in a dedicated and centralized object that all end-points (e.g. Express middleware, cron jobs, unit-testing) call when an error comes in.Otherwise: Not handling errors within a single place will lead to code duplication and probably to errors that are handled improperlyCode example - a typical error flowBlog quote: "Sometimes lower levels can\xe2\x80\x99t do anything useful except propagate the error to their caller"\n(From the blog Joyent, ranked 1 for the keywords \xe2\x80\x9cNode.JS error handling\xe2\x80\x9d)"\xe2\x80\xa6You may end up handling the same error at several levels of the stack. This happens when lower levels can\xe2\x80\x99t do anything useful except propagate the error to their caller, which propagates the error to its caller, and so on. Often, only the top-level caller knows what the appropriate response is, whether that\xe2\x80\x99s to retry the operation, report an error to the user, or something else. But that doesn\xe2\x80\x99t mean you should try to report all errors to a single top-level callback, because that callback itself can\xe2\x80\x99t know in what context the error occurred"TL;DR: Let your API callers know which errors might come in return so they can handle these thoughtfully without crashing. This is usually done with REST API documentation frameworks like SwaggerOtherwise: An API client might decide to crash and restart only because he received back an error he couldn\xe2\x80\x99t understand. Note: the caller of your API might be you (very typical in a microservices environment)Blog quote: "You have to tell your callers what errors can happen"\n(From the blog Joyent, ranked 1 for the keywords \xe2\x80\x9cNode.JS logging\xe2\x80\x9d)\xe2\x80\xa6We\xe2\x80\x99ve talked about how to handle errors, but when you\xe2\x80\x99re writing a new function, how do you deliver errors to the code that called your function? \xe2\x80\xa6If you don\xe2\x80\x99t know what errors can happen or don\xe2\x80\x99t know what they mean, then your program cannot be correct except by accident. So if you\xe2\x80\x99re writing a new function, you have to tell your callers what errors can happen and what they meaTL;DR: When an unknown error occurs (a developer error, see best practice number #3)- there is uncertainty about the application healthiness. A common practice suggests restarting the process carefully using a \xe2\x80\x98restarter\xe2\x80\x99 tool like Forever and PM2Otherwise: When an unfamiliar exception is caught, some object might be in a faulty state (e.g an event emitter which is used globally and not firing events anymore due to some internal failure) and all future requests might fail or behave crazilyCode example - deciding whether to crashBlog quote: "There are three schools of thoughts on error handling"\n(From the blog jsrecipes)\xe2\x80\xa6There are primarily three schools of thoughts on error handling: 1. Let the application crash and restart it. 2. Handle all possible errors and never crash. 3. Balanced approach between the twoTL;DR: A set of mature logging tools like Winston, Bunyan or Log4J, will speed-up error discovery and understanding. So forget about console.log.Otherwise: Skimming through console.logs or manually through messy text file without querying tools or a decent log viewer might keep you busy at work until lateCode example - Winston logger in actionBlog quote: "Lets identify a few requirements (for a logger):"\n(From the blog strongblog)\xe2\x80\xa6Lets identify a few requirements (for a logger):\n  1. Time stamp each log line. This one is pretty self explanatory \xe2\x80\x93 you should be able to tell when each log entry occured.\n  2. Logging format should be easily digestible by humans as well as machines.\n  3. Allows for multiple configurable destination streams. For example, you might be writing trace logs to one file but when an error is encountered, write to the same file, then into error file and send an email at the same time\xe2\x80\xa6TL;DR: Monitoring and performance products (a.k.a APM) proactively gauge your codebase or API so they can auto-magically highlight errors, crashes and slow parts that you were missingOtherwise: You might spend great effort on measuring API performance and downtimes, probably you\xe2\x80\x99ll never be aware which are your slowest code parts under real world scenario and how these affects the UXBlog quote: "APM products segments"\n(From the blog Yoni Goldberg)"\xe2\x80\xa6APM products constitutes 3 major segments:1. Website or API monitoring \xe2\x80\x93 external services that constantly monitor uptime and performance via HTTP requests. Can be setup in few minutes. Following are few selected contenders: Pingdom, Uptime Robot, and New Relic\n  2. Code instrumentation \xe2\x80\x93 products family which require to embed an agent within the application to benefit feature slow code detection, exceptions statistics, performance monitoring and many more. Following are few selected contenders: New Relic, App Dynamics\n  3. Operational intelligence dashboard \xe2\x80\x93 these line of products are focused on facilitating the ops team with metrics and curated content that helps to easily stay on top of application performance. This is usually involves aggregating multiple sources of information (application logs, DB logs, servers log, etc) and upfront dashboard design work. Following are few selected contenders: Datadog, Splunk"The above is a shortened version - see here more best practices and examplesYou can catch uncaught exceptions, but it\'s of limited use. See http://debuggable.com/posts/node-js-dealing-with-uncaught-exceptions:4c933d54-1428-443c-928d-4e1ecbdd56cbmonit, forever or upstart can be used to restart node process when it crashes. A graceful shutdown is best you can hope for (e.g. save all in-memory data in uncaught exception handler).nodejs domains is the most up to date way of handling errors in nodejs. Domains can capture both error/other events as well as traditionally thrown objects. Domains also provide functionality for handling callbacks with an error passed as the first argument via the intercept method.As with normal try/catch-style error handling, is is usually best to throw errors when they occur, and block out areas where you want to isolate errors from affecting the rest of the code. The way to "block out" these areas are to call domain.run with a function as a block of isolated code. In synchronous code, the above is enough - when an error happens you either let it be thrown through, or you catch it and handle there, reverting any data you need to revert.When the error happens in an asynchronous callback, you either need to be able to fully handle the rollback of data (shared state, external data like databases, etc). OR you have to set something to indicate that an exception has happened - where ever you care about that flag, you have to wait for the callback to complete.Some of that above code is ugly, but you can create patterns for yourself to make it prettier, eg:UPDATE (2013-09):Above, I use a future that implies fibers semantics, which allow you to wait on futures in-line. This actually allows you to use traditional try-catch blocks for everything - which I find to be the best way to go. However, you can\'t always do this (ie in the browser)...There are also futures that don\'t require fibers semantics (which then work with normal, browsery JavaScript). These can be called futures, promises, or deferreds (I\'ll just refer to futures from here on). Plain-old-JavaScript futures libraries allow errors to be propagated between futures. Only some of these libraries allow any thrown future to be correctly handled, so beware. An example:This mimics a normal try-catch, even though the pieces are asynchronous. It would print:Note that it doesn\'t print \'3\' because an exception was thrown that interrupts that flow.Take a look at bluebird promises:Note that I haven\'t found many other libraries other than these that properly handle thrown exceptions. jQuery\'s deferred, for example, don\'t - the "fail" handler would never get the exception thrown an a \'then\' handler, which in my opinion is a deal breaker.I wrote about this recently at http://snmaynard.com/2012/12/21/node-error-handling/. A new feature of node in version 0.8 is domains and allow you to combine all the forms of error handling into one easier manage form. You can read about them in my post.You can also use something like Bugsnag to track your uncaught exceptions and be notified via email, chatroom or have a ticket created for an uncaught exception (I am the co-founder of Bugsnag).One instance where using a try-catch might be appropriate is when using a forEach loop. It is synchronous but at the same time you cannot just use a return statement in the inner scope. Instead a try and catch approach can be used to return an Error object in the appropriate scope. Consider: It is a combination of the approaches described by @balupton above.I would just like to add that Step.js library helps you handle exceptions by always passing it to the next step function. Therefore you can have as a last step a function that check for any errors in any of the previous steps. This approach can greatly simplify your error handling.Below is a quote from the github page:any exceptions thrown are caught and passed as the first argument to\n  the next function. As long as you don\'t nest callback functions inline\n  your main functions this prevents there from ever being any uncaught\n  exceptions. This is very important for long running node.JS servers\n  since a single uncaught exception can bring the whole server down.Furthermore, you can use Step to control execution of scripts to have a clean up section as the last step. For example if you want to write a build script in Node and report how long it took to write, the last step can do that (rather than trying to dig out the last callback).After reading this post some time ago I was wondering if it was safe to use domains for exception handling on an api / function level. I wanted to use them to simplify exception handling code in each async function I wrote. My concern was that using a new domain for each function would introduce significant overhead. My homework seems to indicate that there is minimal overhead and that performance is actually better with domains than with try catch in some situations.http://www.lighthouselogic.com/#/using-a-new-domain-for-each-async-function-in-node/If you want use Services in Ubuntu(Upstart): Node as a service in Ubuntu 11.04 with upstart, monit and forever.jsCatching errors has been very well discussed here, but it\'s worth remembering to log the errors out somewhere so you can view them and fix stuff up.\xe2\x80\x8bBunyan is a popular logging framework for NodeJS - it supporst writing out to a bunch of different output places which makes it useful for local debugging, as long as you avoid console.log.\n\xe2\x80\x8b\nIn your domain\'s error handler you could spit the error out to a log file.This can get time consuming if you have lots of errors and/or servers to check, so it could be worth looking into a tool like Raygun (disclaimer, I work at Raygun) to group errors together - or use them both together.\n\xe2\x80\x8b\nIf you decided to use Raygun as a tool, it\'s pretty easy to setup too\xe2\x80\x8b\nCrossed with using a tool like PM2 or forever, your app should be able to crash, log out what happened and reboot without any major issues.