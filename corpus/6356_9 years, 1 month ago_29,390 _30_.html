I am starting a new web application in PHP and this time around I want to create something that people can extend by using a plugin interface. How does one go about writing \'hooks\' into their code so that plugins can attach to specific events?You could use an Observer pattern.  A simple functional way to accomplish this:Output:Notes:For this example source code, you must declare all your plugins before the actual source code that you want to be extendable.  I\'ve included an example of how to handle single or multiple values being passed to the plugin.  The hardest part of this is writing the actual documentation which lists what arguments get passed to each hook.This is just one method of accomplishing a plugin system in PHP.  There are better alternatives, I suggest you check out the WordPress Documentation for more information.Sorry, it appears underscore characters are replaced by HTML entities by Markdown?  I can re-post this code when this bug gets fixed.Edit: Nevermind, it only appears that way when you are editingSo let\'s say you don\'t want the Observer pattern because it requires that you change your class methods to handle the task of listening, and want something generic. And let\'s say you don\'t want to use extends inheritance because you may already be inheriting in your class from some other class. Wouldn\'t it be great to have a generic way to make any class pluggable without much effort? Here\'s how:In Part 1, that\'s what you might include with a require_once() call at the top of your PHP script. It loads the classes to make something pluggable.In Part 2, that\'s where we load a class. Note I didn\'t have to do anything special to the class, which is significantly different than the Observer pattern.In Part 3, that\'s where we switch our class around into being "pluggable" (that is, supports plugins that let us override class methods and properties). So, for instance, if you have a web app, you might have a plugin registry, and you could activate plugins here. Notice also the Dog_bark_beforeEvent() function. If I set $mixed = \'BLOCK_EVENT\' before the return statement, it will block the dog from barking and would also block the Dog_bark_afterEvent because there wouldn\'t be any event.In Part 4, that\'s the normal operation code, but notice that what you might think would run does not run like that at all. For instance, the dog does not announce it\'s name as \'Fido\', but \'Coco\'. The dog does not say \'meow\', but \'Woof\'. And when you want to look at the dog\'s name afterwards, you find it is \'Different\' instead of \'Coco\'. All those overrides were provided in Part 3.So how does this work? Well, let\'s rule out eval() (which everyone says is "evil") and rule out that it\'s not an Observer pattern. So, the way it works is the sneaky empty class called Pluggable, which does not contain the methods and properties used by the Dog class. Thus, since that occurs, the magic methods will engage for us. That\'s why in parts 3 and 4 we mess with the object derived from the Pluggable class, not the Dog class itself. Instead, we let the Plugin class do the "touching" on the Dog object for us. (If that\'s some kind of design pattern I don\'t know about -- please let me know.)The hook and listener method is the most commonly used, but there are other things you can do.  Depending on the size of your app, and who your going to allow see the code (is this going to be a FOSS script, or something in house) will influence greatly how you want to allow plugins.kdeloach has a nice example, but his implementation and hook function is a little unsafe.  I would ask for you to give more information of the nature of php app your writing, And how you see plugins fitting in.  +1 to kdeloach from me.Here is an approach I\'ve used, it\'s an attempt to copy from Qt signals/slots mechanism, a kind of Observer pattern.\nObjects can emit signals.\nEvery signal has an ID in the system - it\'s composed by sender\'s id + object name\nEvery signal can be binded to the receivers, which simply is a "callable"\nYou use a bus class to pass the signals to anybody interested in receiving them\nWhen something happens, you "send" a signal. \nBelow is and example implementationI believe the easiest way would be to follow Jeff\'s own advice and have a look around existing code. Try looking at Wordpress, Drupal, Joomla and other well known PHP-based CMS\'s to see how their API hooks look and feel. This way you can even get ideas you may have not thought of previously to make things a little more rubust.A more direct answer would be to write general files that they would "include_once" into their file that would provide the usability they would need. This would be broken up into categories and NOT provided in one MASSIVE "hooks.php" file. Be careful though, because what ends up happening is that files that they include end up having more and more dependencies and functionality improves. Try to keep API dependencies low. I.E fewer files for them to include.There\'s a neat project called Stickleback by Matt Zandstra at Yahoo that handles much of the work for handling plugins in PHP.It enforces the interface of a plugin class, supports a command line interface and isn\'t too hard to get up and running - especially if you read the cover story about it in the PHP architect magazine.Good advice is to look how other projects have done it. Many call for having plugins installed and their "name" registered for services (like wordpress does) so you have "points" in your code where you call a function that identifies registered listeners and executes them. A standard OO design patter is the Observer Pattern, which would be a good option to implement in a truly object oriented PHP system.The Zend Framework makes use of many hooking methods, and is very nicely architected. That would be a good system to look at.I am surprised that most of the answers here seem to be geared about plugins that are local to the web application, ie, plugins that run on the local web server.What about if you wanted the plugins to run on a different - remote - server? The best way to do this would be to provide a form that allows you to define different URLs that would be called when particular events occur in your application.Different events would send different information based on the event that just occurred.This way, you would just perform a cURL call to the URL that has been provided to your application (eg over https) where remote servers can perform tasks based on information that has been sent by your application.This provides two benefits: