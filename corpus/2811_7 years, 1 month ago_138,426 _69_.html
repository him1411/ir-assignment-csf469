Section 4.2 of the draft OAuth 2.0 protocol indicates that an authorization server can return both an access_token (which is used to authenticate oneself with a resource) as well as a refresh_token, which is used purely to create a new access_token:https://tools.ietf.org/html/rfc6749#section-4.2Why have both? Why not just make the access_token last as long as the refresh_token and not have a refresh_token?The idea of refresh tokens is that if an access token is compromised, because it is short-lived, the attacker has a limited window in which to abuse it.Refresh tokens, if compromised, are useless because the attacker requires the client id and secret in addition to the refresh token in order to gain an access token.Having said that, because every call to both the authorization server and the resource server is done over SSL - including the original client id and secret when they request the access/refresh tokens - I am unsure as to how the access token is any more "compromisable" than the long-lived refresh token and clientid/secret combination.This of course is different to implementations where you don\'t control both the authorization and resource servers.Here is a good thread talking about uses of refresh tokens: OAuth Archives.A quote from the above, talking about the security purposes of the refresh token:Refresh tokens... mitigates the risk of a long-lived access_token leaking (query param in a log file on an insecure resource server, beta or poorly coded resource server app, JS SDK client on a non https site that puts the access_token in a cookie, etc)The link to discussion, provided by Catchdave, has another valid point made by Dick Hardt, which I believe is worth to be mentioned here in addition to what\'s been written above:My recollection of refresh tokens was for security and revocation.\n  <...>revocation: if the access token is self contained, authorization can be revoked by not issuing new access tokens. A resource does not need to query the authorization server to see if the access token is valid.This simplifies access token validation and makes it easier to scale and support multiple authorization servers.  There is a window of time when an access token is valid, but authorization is revoked. Indeed, in the situation where Resource Server and Authorization Server is the same entity, and where the connection between user and either of them is (usually) equally secure, there is not much sense to keep refresh token separate from the access token.Although, as mentioned in the quote, another role of refresh tokens is to ensure the access token can be revoked at any time by the User (via the web-interface in their profiles, for example) while keeping the system scalable at the same time.Generally, tokens can either be random identifiers pointing to the specific record in the Server\'s database, or they can contain all information in themselves (certainly, this information have to be signed, with MAC, for example).How the system with long-lived access tokens should workThe server allows the Client to get access to User\'s data within a pre-defined set of scopes by issuing a token. As we want to keep the token revocable, we must store in the database the token along with the flag "revoked" being set or unset (otherwise, how would you do that with self-contained token?) Database can contain as much as len(users) x len(registered clients) x len(scopes combination) records. Every API request then must hit the database. Although it\'s quite trivial to make queries to such database performing O(1), the single point of failure itself can have negative impact on the scalability and performance of the system.How the system with long-lived refresh token and short-lived access token should workHere we issue two keys: random refresh token with the corresponding record in the database, and signed self-contained access token, containing among others the expiration timestamp field.As the access token is self-contained, we don\'t have to hit the database at all to check its validity. All we have to do is to decode the token and to validate the signature and the timestamp.Nonetheless, we still have to keep the database of refresh tokens, but the number of requests to this database is generally defined by the lifespan of the access token (the longer the lifespan, the lower the access rate).In order to revoke the access of Client from a particular User, we should mark the corresponding refresh token as "revoked" (or remove it completely) and stop issuing new access tokens. It\'s obvious though that there is a window during which the refresh token has been revoked, but its access token may still be valid.TradeoffsRefresh tokens partially eliminate the SPoF (Single Point of Failure) of Access Token database, yet they have some obvious drawbacks.The "window". A timeframe between events "user revokes the access" and "access is guaranteed to be revoked".The complication of the Client logic.without refresh tokenwith refresh tokenI hope this answer does make sense and helps somebody to make more thoughtful decision. I\'d like to note also that some well-known OAuth2 providers, including github and foursquare adopt protocol without refresh tokens, and seem happy with that.Despite all the great answers above, I as a security master student and programmer who previously worked at eBay when I took a look into buyer protection and fraud, can say to separate access token and refresh token has its best balance between harassing user of frequent username/password input and keeping the authority in hand to revoke access to potential abuse of your service.Think of a scenario like this. You issue user of an access token of 3600 seconds and refresh token much longer as one day.The user is a good user, he is at home and gets on/off your website shopping and searching on his iPhone. His IP address doesn\'t change and have a very low load on your server. Like 3-5 pages request every minute. When his 3600 seconds on the access token is over, he requires a new one with the refresh token. We, on the server side, check his activity history and IP address, think he is a human and behaves himself. We grant him a new access token to continue using our service. The user won\'t need to enter again the username/password until he has reached one day life-span of refresh token itself.The user is a careless user. He lives in New York, USA and got his virus program shutdown and was hacked by a hacker in Poland. When the hacker got the access token and refresh token, he tries to impersonate the user and use our service. But after the short-live access token expires, when the hacker tries to refresh the access token, we, on the server, has noticed a dramatic IP change in user behavior history (hey, this guy logins in USA and now refresh access in Poland after just 3600s ???). We terminate the refresh process, invalidate the refresh token itself and prompt to enter username/password again.The user is a malicious user. He is intended to abuse our service by calling 1000 times our API each minute using a robot. He can well doing so until 3600 seconds later, when he tries to refresh the access token, we noticed his behavior and think he might not be a human. We reject and terminate the refresh process and ask him to enter username/password again. This might potentially break his robot\'s automatic flow. At least makes him uncomfortable.You can see the refresh token has acted perfectly when we try to balance our work, user experience and potential risk of a stolen token. Your watch dog on the server side can check more than IP change, frequency of api calls to determine whether the user shall be a good user or not.Another word is you can also try to limit the damage control of stolen token/abuse of service by implementing on each api call the basic IP watch dog or any other measures. But this is expensive as you have to read and write record about the user and will slow down your server response.Neither of these answers get to the core reason refresh tokens exist. Obviously, you can always get a new access-token/refresh-token pair by sending your client credentials to the auth server - thats how you get them in the first place.So the sole purpose of the refresh token is to limit the use of the client credentials being sent over the wire to the auth service. The shorter the ttl of the access-token, the more often the client credentials will have to be used to obtain a new access-token, and therefore the more opportunities attackers have to compromise the client credentials (although this may be super difficult anyway if asymmetric encryption is being used to send them). So if you have a single-use refresh-token, you can make the ttl of access-tokens arbitrarily small without compromising the client credentials.This answer is from Justin Richer via the OAuth 2 standard body email list. This is posted with his permission.The lifetime of a refresh token is up to the (AS) authorization server \xe2\x80\x94 they can expire, be revoked, etc. The difference between a refresh token and an access token is the audience: the refresh token only goes back to the authorization server, the access token goes to the (RS) resource server. Also, just getting an access token doesn\xe2\x80\x99t mean the user\xe2\x80\x99s logged in. In fact, the user might not even be there anymore, which is actually the intended use case of the refresh token. Refreshing the access token will give you access to an API on the user\xe2\x80\x99s behalf, it will not tell you if the user\xe2\x80\x99s there.OpenID Connect doesn\xe2\x80\x99t just give you user information from an access token, it also gives you an ID token. This is a separate piece of data that\xe2\x80\x99s directed at the client itself, not the AS or the RS. In OIDC, you should only consider someone actually \xe2\x80\x9clogged in\xe2\x80\x9d by the protocol if you can get a fresh ID token. Refreshing it is not likely to be enough.For more information please read http://oauth.net/articles/authentication/To clear up some confusion you have to understand the roles of the client secret and the user password, which are very different.The client is an app/website/program/..., backed by a server, that wants to authenticate a user by using a third-party authentication service. The client secret is a (random) string that is known to both this client and the authentication server. Using this secret the client can identify itself with the authentication server, receiving authorization to request access tokens.To get the initial access token and refresh token, what is required is:To get a refreshed access token however the client uses the following information:This clearly shows the difference: when refreshing, the client receives authorization to refresh access tokens by using its client secret, and can thus re-authenticate the user using the refresh token instead of the user ID + password. This effectively prevents the user from having to re-enter his/her password.This also shows that losing a refresh token is no problem because the client ID and secret are not known. It also shows that keeping the client ID and client secret secret is vital.Clients can be compromised in many ways. For example a cell phone can be cloned.  Having an access token expire means that the client is forced to re-authenticate to the authorization server. During the re-authentication, the authorization server can check other characteristics (IOW perform adaptive access management).Refresh tokens allow for a client only re-authentication, where as re-authorize forces a dialog with the user which many have indicated they would rather not do.Refresh tokens fit in essentially in the same place where normal web sites might choose to periodically re-authenticate users after an hour or so (e.g. banking site). It isn\'t highly used at present since most social web sites don\'t re-authenticate web users, so why would they re-authenticate a client?To further simplify B T\'s answer: Use refresh tokens when you don\'t typically want the user to have to type in credentials again, but still want the power to be able to revoke the permissions (by revoking the refresh token) You cannot revoke an access token, only a refresh token.Why not just make the access_token last as long as the refresh_token\n  and not have a refresh_token?In addition to great answers other people have provided there is another reason why would use refresh tokens and its to do with claims. Each token contains claims which can include anything from the users name, their roles or the provider which created the claim. As a token is refreshed these claims are updated.If we refresh the tokens more often we are obviously putting more strain on our identity services however we are getting more accurate and up-to-date claims.Let\'s consider a system where each user is linked to one or more roles and each role is linked to one or more access privileges. This information can be cached for better API performance. But then, there may be changes in the user and role configurations (for e.g. new access may be granted or current access may be revoked) and these should be reflected in the cache.We can use access and refresh tokens for such purpose. When an API is invoked with access token, the resource server checks the cache for access rights. IF there is any new access grants, it is not reflected immediately. Once the access token expires (say in 30 minutes) and the client uses the refresh token to generate a new access token, the cache can be updated with the updated user access right information from the DB. In other words, we can move the expensive operations from every API call using access tokens to the event of access token generation using refresh token.First, the client authenticates with the authorization server by giving the authorization grant.Then, the client requests the resource server for the protected resource by giving the access token.The resource server validates the access token and provides the protected resource.The client makes the protected resource request to the resource server by granting the access token, where the resource server validates it and serves the request, if valid. This step keeps on repeating until the access token expires.If the access token expires, the client authenticates with the authorization server and requests for a new access token by providing refresh token. If the access token is invalid, the resource server sends back the invalid token error response to the client.The client authenticates with the authorization server by granting the refresh token.The authorization server then validates the refresh token by authenticating the client and issues a new access token, if it is valid.