Switch statement fallthrough is one of my personal major reasons for loving switch vs. if/else if constructs. An example is in order here:The smart people are cringing because the string[]s should be declared outside the function: well, they are, this is just an example.The compiler fails with the following error:Why? And is there any way to get this sort of behaviour without having three ifs?(Copy/paste of an answer I provided elsewhere)Falling through switch-cases can be achieved by having no code in a case (see case 0), or using the special goto case (see case 1) or goto default (see case 2) forms:The "why" is to avoid accidental fall-through, for which I\'m grateful. This is a not uncommon source of bugs in C and pre-1.5 Java.The workaround is to use goto, e.g.The general design of switch/case is a little bit unfortunate in my view. It stuck too close to C - there are some useful changes which could be made in terms of scoping etc. Arguably a smarter switch which could do pattern matching etc would be helpful, but that\'s really changing from switch to "check a sequence of conditions" - at which point a different name would perhaps be called for.Switch fallthrough is historically one of the major source of bugs in modern softwares. The language designer decided to make it mandatory to jump at the end of the case, unless you are defaulting to the next case directly without processing.To add to the answers here, I think it\'s worth considering the opposite question in conjunction with this, viz. why did C allow fall-through in the first place?Any programming language of course serves two goals:The creation of any programming language is therefore a balance between how to best serve these two goals. On the one hand, the easier it is to turn into computer instructions (whether those are machine code, bytecode like IL, or the instructions are interpreted on execution) then more able that process of compilation or interpretation will be to be efficient, reliable and compact in output. Taken to its extreme, this goal results in our just writing in assembly, IL, or even raw op-codes, because the easiest compilation is where there is no compilation at all.Conversely, the more the language expresses the intention of the programmer, rather than the means taken to that end, the more understandable the program both when writing and during maintenance.Now, switch could always have been compiled by converting it into the equivalent chain of if-else blocks or similar, but it was designed as allowing compilation into a particular common assembly pattern where one takes a value, computes an offset from it (whether by looking up a table indexed by a perfect hash of the value, or by actual arithmetic on the value*). It\'s worth noting at this point that today, C# compilation will sometimes turn switch into the equivalent if-else, and sometimes use a hash-based jump approach (and likewise with C, C++, and other languages with comparable syntax).In this case there are two good reasons for allowing fall-through:It just happens naturally anyway: if you build a jump table into a set of instructions, and one of the earlier batches of instructions doesn\'t contain some sort of jump or return, then execution will just naturally progress into the next batch. Allowing fall-through was what would "just happen" if you turned the switch-using C into jump-table\xe2\x80\x93using machine code.Coders who wrote in assembly were already used to the equivalent: when writing a jump table by hand in assembly, they would have to consider whether a given block of code would end with a return, a jump outside of the table, or just continue on to the next block. As such, having the coder add an explicit break when necessary was "natural" for the coder too.At the time therefore, it was a reasonable attempt to balance the two goals of a computer language as it relates to both the produced machine code, and the expressiveness of the source code.Four decades later though, things are not quite the same, for a few reasons:Related to those last two points, consider the following quote from the current edition of K&R:Falling through from one case to another is not robust, being prone to disintegration when the program is modified. With the exception of multiple labels for a single computation, fall-throughs should be used sparingly, and commented.As a matter of good form, put a break after the last case (the default here) even though it\'s logically unnecessary. Some day when another case gets added at the end, this bit of defensive programming will save you.So, from the horse\'s mouth, fall-through in C is problematic. It\'s considered good practice to always document fall-throughs with comments, which is an application of the general principle that one should document where one does something unusual, because that\'s what will trip later examination of the code and/or make your code look like it has a novice\'s bug in it when it is in fact correct.And when you think about it, code like this:Is adding something to make the fall-through explicit in the code, it\'s just not something that can be detected (or whose absence can be detected) by the compiler.As such, the fact that on has to be explicit with fall-through in C# doesn\'t add any penalty to people who wrote well in other C-style languages anyway, since they would already be explicit in their fall-throughs.\xe2\x80\xa0Finally, the use of goto here is already a norm from C and other such languages:In this sort of case where we want a block to be included in the code executed for a value other than just that which brings one to the preceding block, then we\'re already having to use goto. (Of course, there are means and ways of avoiding this with different conditionals but that\'s true of just about everything relating to this question). As such C# built on the already normal way to deal with one situation where we want to hit more than one block of code in a switch, and just generalised it to cover fall-through as well. It also made both cases more convenient and self-documenting, since we have to add a new label in C but can use the case as a label in C#. In C# we can get rid of the below_six label and use goto case 5 which is clearer as to what we are doing. (We\'d also have to add break for the default, which I left out just to make the above C code clearly not C# code).In summary therefore:All in all, a pretty reasonable design decision*Some forms of BASIC would allow one to do the likes of GOTO (x AND 7) * 50 + 240 which while brittle and hence a particularly persuasive case for banning goto, does serve to show a higher-language equivalent of the sort of way that lower-level code can make a jump based on arithmetic upon a value, which is much more reasonable when it\'s the result of compilation rather than something that has to be maintained manually. Implementations of Duff\'s Device in particular lend themselves well to the equivalent machine code or IL because each block of instructions will often be the same length without needing the addition of nop fillers.\xe2\x80\xa0Duff\'s Device comes up here again, as a reasonable exception. The fact that with that and similar patterns there\'s a repetition of operations serves to make the use of fall-through relatively clear even without an explicit comment to that effect.You can \'goto case label\'\nhttp://www.blackwasp.co.uk/CSharpGoto.aspxThe goto statement is a simple command that unconditionally transfers the control of the program to another statement. The command is often criticised with some developers advocating its removal from all high-level programming languages because it can lead to spaghetti code. This occurs when there are so many goto statements or similar jump statements that the code becomes difficult to read and maintain. However, there are programmers who point out that the goto statement, when used carefully, provides an elegant solution to some problems...They left out this behaviour by design to avoid when it was not used by will but caused problems.It can be used only if there is no statement in the case part, like:They changed the switch statement (from C/Java/C++) behavior for c#.  I guess the reasoning was that people forgot about the fall through and errors were caused.  One book I read said to use goto to simulate, but this doesn\'t sound like a good solution to me.After each case statement require break or goto statement even if it is a default case.A jump statement such as a break is\n  required after each case block,\n  including the last block whether it is\n  a case statement or a default\n  statement. With one exception, (unlike\n  the C++ switch statement), C# does not\n  support an implicit fall through from\n  one case label to another. The one\n  exception is if a case statement has\n  no code.-- C# switch() documentationC# doesn\'t support fall through with switch/case statements. Not sure why, but there\'s really no support for it. Linkageswitch (C# Reference) saysC# requires the end of switch sections, including the final one, So you also need to add a break; to your default section, otherwise there will still will be a compiler error.You can achieve fall through like c++ by the goto keyword.EX:Just a quick note to add that the compiler for Xamarin actually got this wrong and it allows fallthrough. It has supposedly been fixed, but has not been released. Discovered this in some code that actually was falling through and the compiler did not complain.You forgot to add the "break;" statement into case 3. In case 2 you wrote it into the if block.\nTherefore try this: