When I make a POST request with a JSON body to my REST service I include Content-type: application/json; charset=utf-8 in the message header. Without this header, I get an error from the service. I can also successfully use Content-type: application/json without the ;charset=utf-8 portion. What exactly does charset=utf-8 do ? I know it specifies the character encoding but the service works fine without it. Does this encoding limit the characters that can be in the message body?The header just denotes what the content is encoded in. It is not necessarily possible to deduce the type of the content from the content itself, i.e. you can\'t necessarily just look at the content and know what to do with it. That\'s what HTTP headers are for, they tell the recipient what kind of content they\'re (supposedly) dealing with.Content-type: application/json; charset=utf-8 designates the content to be in JSON format, encoded in the UTF-8 character encoding. Designating the encoding is somewhat redundant for JSON, since the default (only?) encoding for JSON is UTF-8. So in this case the receiving server apparently is happy knowing that it\'s dealing with JSON and assumes that the encoding is UTF-8 by default, that\'s why it works with or without the header.Does this encoding limit the characters that can be in the message body?No. You can send anything you want in the header and the body. But, if the two don\'t match, you may get wrong results. If you specify in the header that the content is UTF-8 encoded but you\'re actually sending Latin1 encoded content, the receiver may produce garbage data, trying to interpret Latin1 encoded data as UTF-8. If of course you specify that you\'re sending Latin1 encoded data and you\'re actually doing so, then yes, you\'re limited to the 256 characters you can encode in Latin1.To substantiate @deceze\'s claim that the default JSON encoding is UTF-8...From IETF RFC4627:JSON text SHALL be encoded in Unicode.  The default encoding is\n    UTF-8.Since the first two characters of a JSON text will always be ASCII\n    characters [RFC0020], it is possible to determine whether an octet\n    stream is UTF-8, UTF-16 (BE or LE), or UTF-32 (BE or LE) by looking\n    at the pattern of nulls in the first four octets.Note that IETF RFC4627 has been superseded by IETF RFC7158.  In section [8.1] it retracts the text sited by @Drew earlier by saying: 