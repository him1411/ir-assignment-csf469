Is there a way to statically/globally request a copy of the ApplicationContext in a Spring application?Assuming the main class starts up and initializes the application context, does it need to pass that down through the call stack to any classes that need it, or is there a way for a class to ask for the previously created context?  (Which I assume has to be a singleton?)If the object that needs access to the container is a bean in the container, just implement the BeanFactoryAware or ApplicationContextAware interfaces.If an object outside the container needs access to the container, I\'ve used a standard GoF singleton pattern for the spring container. That way, you only have one singleton in your application, the rest are all singleton beans in the container.You can implement ApplicationContextAware or just use @Autowired:SpringBean will have ApplicationContext injected, within which this bean is instantiated. For example if you have web application with a pretty standard contexts hierarchy:and SpringBean is declared within main context, it will have main context injected;\notherwise, if it\'s declared within MVC context, it will have MVC context injected.Here\'s a nice way (not mine, the original reference is here:\nhttp://sujitpal.blogspot.com/2007/03/accessing-spring-beans-from-legacy-code.htmlI\'ve used this approach and it works fine. Basically it\'s a simple bean that holds a (static) reference to the application context. By referencing it in the spring config it\'s initialized. Take a look at the original ref, it\'s very clear.I believe you could use SingletonBeanFactoryLocator. The beanRefFactory.xml file would hold the actual applicationContext, It would go something like this:And the code to get a bean from the applicationcontext from whereever would be something like this:The Spring team discourage the use of this class and yadayada, but it has suited me well where I have used it.Before you implement any of the other suggestions, ask yourself these questions...The answers to these questions are easier in certain types of applications (Web apps, for example) than they are in others, but are worth asking anyway.Accessing the ApplicationContext does kind of violate the whole dependency injection principle, but sometimes you\'ve not got much choice.If you use a web-app there is also another way to access the application context without using singletons by using a servletfilter and a ThreadLocal. In the filter you can access the application context using WebApplicationContextUtils and store either the application context or the needed beans in the TheadLocal. Caution: if you forget to unset the ThreadLocal you will get nasty problems when trying to undeploy the application! Thus, you should set it and immediately start a try that unsets the ThreadLocal in the finally-part.Of course, this still uses a singleton: the ThreadLocal. But the actual beans do not need to be anymore. The can even be request-scoped, and this solution also works if you have multiple WARs in an Application with the libaries in the EAR. Still, you might consider this use of ThreadLocal as bad as the use of plain singletons. ;-)Perhaps Spring already provides a similar solution? I did not find one, but I don\'t know for sure.Take a look at ContextSingletonBeanFactoryLocator.  It provides static accessors to get hold of Spring\'s contexts, assuming they have been registered in certain ways.  It\'s not pretty, and more complex than perhaps you\'d like, but it works.Note that by storing any state from the current ApplicationContext, or the ApplicationContext itself in a static variable - for example using the singleton pattern - you will make your tests unstable and unpredictable if you\'re using Spring-test. This is because Spring-test caches and reuses application contexts in the same JVM. For example:When Test A runs, an ApplicationContext is created, and any beans implemeting ApplicationContextAware or autowiring ApplicationContext might write to the static variable.When Test B runs the same thing happens, and the static variable now points to Test B\'s ApplicationContextWhen Test C runs, no beans are created as the TestContext (and herein the ApplicationContext) from Test A is resused. Now you got a static variable pointing to another ApplicationContext than the one currently holding the beans for your test.Please note that; the below code will create new application context instead of using the already loaded one.Also note that beans.xml should be part of src/main/resources means in war it is part of WEB_INF/classes, where as the real application will be loaded through applicationContext.xml mentioned at Web.xml.It is difficult to mention applicationContext.xml path in ClassPathXmlApplicationContext constructor. ClassPathXmlApplicationContext("META-INF/spring/applicationContext.xml") wont be able to locate the file.So it is better to use existing applicationContext by using annotations.Source: http://sujitpal.blogspot.de/2007/03/accessing-spring-beans-from-legacy-code.html