You know, I haven\'t seen a good answer for this anywhere. Is it possible to embed a pre-existing DLL into a compiled C# executable (so that you only have one file to distribute)? If it is possible, how would one go about doing it?Normally, I\'m cool with just leaving the DLLs outside and having the setup program handle everything, but there have been a couple of people at work who have asked me this and I honestly don\'t know.I highly recommend to use Costura.Fody - by far the best and easiest way to embed resources in your assembly. It\'s available as NuGet package.After adding it to the project, it will automatically embed all references that are copied to the output directory into your main assembly. You might want to clean the embedded files by adding a target to your project:You\'ll also be able to specify whether to include the pdb\'s, exclude certain assemblies, or extracting the assemblies on the fly. As far as I know, also unmanaged assemblies are supported.UpdateCurrently, some people are trying to add support for DNX.If they\'re actually managed assemblies, you can use ILMerge. For native DLLs, you\'ll have a bit more work to do. See also: How can a C++ windows dll be merged into a C# application exe? Just right-click your project in Visual Studio, choose Project Properties -> Resources -> Add Resource -> Add Existing File\xe2\x80\xa6\nAnd include the code below to your App.xaml.cs or equivalent.Here\'s my original blog post:\nhttp://codeblog.larsholm.net/2011/06/embed-dlls-easily-in-a-net-assembly/Yes, it is possible to merge .NET executables with libraries. There are multiple tools available to get the job done:In addition this can be combined with the Mono Linker, which does remove unused code and therefor makes the resulting assembly smaller.Another possibility is to use .NETZ, which does not only allow compressing of an assembly, but also can pack the dlls straight into the exe. The difference to the above mentioned solutions is that .NETZ does not merge them, they stay separate assemblies but are packed into one package..NETZ is a open source tool that compresses and packs the Microsoft .NET Framework executable (EXE, DLL) files in order to make them smaller. ILMerge can combine assemblies to one single assembly provided the assembly has only managed code. You can use the commandline app, or add reference to the exe and programmatically merge. For a GUI version there is Eazfuscator, and also .Netz both of which are free. Paid apps include BoxedApp and SmartAssembly. If you have to merge assemblies with unmanaged code, I would suggest SmartAssembly. I never had hiccups with SmartAssembly but with all others. Here, it can embed the required dependencies as resources to your main exe.You can do all this manually not needing to worry if assembly is managed or in mixed mode by embedding dll to your resources and then relying on AppDomain\'s Assembly ResolveHandler. This is a one stop solution by adopting the worst case, ie assemblies with unmanaged code.The key here is to write the bytes to a file and load from its location. To avoid chicken and egg problem, you have to ensure you declare the handler before accessing assembly and that you do not access the assembly members (or instantiate anything that has to deal with the assembly) inside the loading (assembly resolving) part. Also take care to ensure GetMyApplicationSpecificPath() is not any temp directory since temp files could be attempted to get erased by other programs or by yourself (not that it will get deleted while your program is accessing the dll, but at least its a nuisance. AppData is good location). Also note that you have to write the bytes each time, you cant load from location just \'cos the dll already resides there.For managed dlls, you need not write bytes, but directly load from the location of the dll, or just read the bytes and load the assembly from memory. Like this or so:If the assembly is fully unmanaged, you can see this link or this as to how to load such dlls.The excerpt by Jeffrey Richter is very good. In short, add the library\'s as embedded resources and add a callback before anything else. Here is a version of the code (found in the comments of his page) that I put at the start of Main method for a console app (just make sure that any calls that use the library\'s are in a different method to Main).To expand on @Bobby\'s asnwer above.  You can edit your .csproj to use IL-Repack to automatically package all files into a single assembly when you build.Here is a simple sample that merges ExampleAssemblyToMerge.dll into your project output.I would recommend you check out the .NETZ utility, which also compresses the assembly with a scheme of your choice:http://madebits.com/netz/help.php#singleYou could add the DLLs as embedded resources, and then have your program unpack them into the application directory on startup (after checking to see if they\'re there already).Setup files are so easy to make, though, that I don\'t think this would be worth it.EDIT:  This technique would be easy with .NET assemblies.  With non-.NET DLLs it would be a lot more work (you\'d have to figure out where to unpack the files and register them and so on).Check boxedappIt can embed a dll into any app. Written in C# too, of course :)Hope it helps.Neither the ILMerge approach nor Lars Holm Jensen\'s handling the AssemblyResolve event will work for a plugin host. Say executable H loads assembly P dynamically and accesses it via interface IP defined in an separate assembly. To embed IP into H one shall need a little modification to Lars\'s code:The trick to handle repeated attempts to resolve the same assembly and return the existing one instead of creating a new instance.EDIT:\nLest it spoil .NET\'s serialization, make sure to return null for all assemblies not embedded in yours, thereby defaulting to the standard behaviour.  You can get a list of these libraries by:and just return null if the passed assembly does not belong to IncludedAssemblies .Another product that can handle this elegantly is SmartAssembly, at SmartAssembly.com . This product will, in addition to merging all dependencies into a single DLL,  (optionally) obfuscate your code, remove extra meta-data to reduce the resulting file size, and can also actually optimize the IL to increase runtime performance. There is also some kind of global exception handling / reporting feature it adds to your software (if desired) that I didn\'t take the time to understand, but could be useful. I believe it also has a command line API so you can make it part of your build process.ILMerge does exactly what you want.Besides ILMerge, if you don\'t want to bother with command line switches, I really recommend ILMerge-Gui. It\'s an open source project, really good!It may sound simplistic, but WinRar gives the option to compress a bunch of files to a self-extracting executable.\nIt has lots of configurable options: final icon, extract files to given path, file to execute after extraction, custom logo/texts for popup shown during extraction, no popup window at all, license agreement text, etc.\nMay be useful in some cases.I use the csc.exe compiler called from a .vbs script.In your xyz.cs script, add the following lines after the directives (my example is for the Renci SSH):The ref, res and ico tags will be picked up by the .vbs script below to form the csc command.Then add the assembly resolver caller in the Main:...and add the resolver itself somewhere in the class:I name the vbs script to match the .cs filename (e.g. ssh.vbs looks for ssh.cs); this makes running the script numerous times a lot easier, but if you aren\'t an idiot like me then a generic script could pick up the target .cs file from a drag-and-drop:It\'s possible but not all that easy, to create a hybrid native/managed assembly in C#. Were you using C++ instead it\'d be a lot easier, as the Visual C++ compiler can create hybrid assemblies as easily as anything else.Unless you have a strict requirement to produce a hybrid assembly, I\'d agree with MusiGenesis that this isn\'t really worth the trouble to do with C#. If you need to do it, perhaps look at moving to C++/CLI instead.Generally you would need some form of post build tool to perform an assembly merge like you are describing.  There is a free tool called Eazfuscator (eazfuscator.blogspot.com/) which is designed for bytecode mangling that also handles assembly merging.  You can add this into a post build command line with Visual Studio to merge your assemblies, but your mileage will vary due to issues that will arise in any non trival assembly merging scenarios.You could also check to see if the build make untility NANT has the ability to merge assemblies after building, but I am not familiar enough with NANT myself to say whether the functionality is built in or not.There are also many many Visual Studio plugins that will perform assembly merging as part of building the application.Alternatively if you don\'t need this to be done automatically, there are a number of tools like ILMerge that will merge .net assemblies into a single file.The biggest issue I\'ve had with merging assemblies is if they use any similar namespaces.  Or worse, reference different versions of the same dll (my problems were generally with the NUnit dll files).I tried out this solution at code-project which embeds the DLL:\nhttp://www.codeproject.com/Articles/528178/Load-DLL-From-Embedded-ResourceAnd it worked just fine.