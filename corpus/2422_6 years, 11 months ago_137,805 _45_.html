I\'m building a server that allows clients to store objects.  Those objects are fully constructed at client side, complete with object IDs that are permanent for the whole lifetime of the object.I have defined the API so that clients can create or modify objects using PUT:The {id} is the object ID, so it is part of the Request-URI.Now, I\'m also considering allowing clients to create the object using POST:Since POST is meant as "append" operation, I\'m not sure what to do in case the object is already there.  Should I treat the request as modification request or should I return some error code (which)?My feeling is 409 Conflict is the most appropriate, however, seldom seen in the wild of course:The request could not be completed due to a conflict with the current state of the resource. This code is only allowed in situations where it is expected that the user might be able to resolve the conflict and resubmit the request. The response body SHOULD include enough information for the user to recognize the source of the conflict. Ideally, the response entity would include enough information for the user or user agent to fix the problem; however, that might not be possible and is not required. Conflicts are most likely to occur in response to a PUT request. For example, if versioning were being used and the entity being PUT included changes to a resource which conflict with those made by an earlier (third-party) request, the server might use the 409 response to indicate that it can\'t complete the request. In this case, the response entity would likely contain a list of the differences between the two versions in a format defined by the response Content-Type.Personally I go with the WebDAV extension 422 Unprocessable Entity.REST Patterns describes it asThe 422 Unprocessable Entity status code means the server understands the content type of the request entity (hence a 415 Unsupported Media Type status code is inappropriate), and the syntax of the request entity is correct (thus a 400 Bad Request status code is inappropriate) but was unable to process the contained instructions.According to RFC 7231, a 303 See Other MAY be used If the result of processing a POST would be equivalent to a\n   representation of an existing resource.Late to the game maybe but I stumbled upon this semantics issue while trying to make a REST API.To expand a little on Wrikken\'s answer, I think you could use either 409 Conflict or 403 Forbidden depending on the situation - in short, use a 403 error when the user can do absolutely nothing to resolve the conflict and complete the request (e.g. they can\'t send a DELETE request to explicitly remove the resource), or use 409 if something could possibly be done.The server understood the request, but is refusing to fulfill it.\n  Authorization will not help and the request SHOULD NOT be repeated. If\n  the request method was not HEAD and the server wishes to make public\n  why the request has not been fulfilled, it SHOULD describe the reason\n  for the refusal in the entity. If the server does not wish to make\n  this information available to the client, the status code 404 (Not\n  Found) can be used instead.Nowadays, someone says "403" and a permissions or authentication issue comes to mind, but the spec says that it\'s basically the server telling the client that it\'s not going to do it, don\'t ask it again, and here\'s why the client shouldn\'t.As for PUT vs. POST... POST should be used to create a new instance of a resource when the user has no means to or shouldn\'t create an identifier for the resource. PUT is used when the resource\'s identity is known....The fundamental difference between the POST and PUT requests is\n  reflected in the different meaning of the Request-URI. The URI in a\n  POST request identifies the resource that will handle the enclosed\n  entity. That resource might be a data-accepting process, a gateway to\n  some other protocol, or a separate entity that accepts annotations. In\n  contrast, the URI in a PUT request identifies the entity enclosed with\n  the request -- the user agent knows what URI is intended and the\n  server MUST NOT attempt to apply the request to some other resource.\n  If the server desires that the request be applied to a different URI,it MUST send a 301 (Moved Permanently) response; the user agent MAY\n  then make its own decision regarding whether or not to redirect the\n  request."302 Found" sounds logical for me. And the RFC 2616 says that it CAN be answered for other requests than GET and HEAD (and this surely includes POST)But it still keeps the visitor going to this URL to get this "Found" resource, by the RFC. To make it to go directly to the real "Found" URL one should be using "303 See Other", which makes sense, but forces another call to GET its following URL. On the good side, this GET is cacheable.I think that I would use "303 See Other". I dont know if I can respond with the "thing" found in the body, but I would like to do so to save one roundtrip to the server.UPDATE: After re-reading the RFC, I still think that an inexistent "4XX+303 Found" code should be the correct. However, the "409 Conflict" is the best existing answer code (as pointed by @ Wrikken), maybe including a Location header pointing to the existing resource.I don\'t think you should do this. The POST is, as you know, to modify the collection and it\'s used to CREATE a new item. So, if you send the id (I think it\'s not a good idea), you should modify the collection, i.e., modify the item, but it\'s confusing. Use it to add an item, without id. It\'s the best practice. If you want to capture an UNIQUE constraint (not the id) you can response 409, as you can do in PUT requests. But not the ID.I think for REST, you just have to make a decision on the behavior for that particular system in which case, I think the "right" answer would be one of a couple answers given here. If you want the request to stop and behave as if the client made a mistake that it needs to fix before continuing, then use 409. If the conflict really isn\'t that important and want to keep the request going, then respond by redirecting the client to the entity that was found. I think proper REST APIs should be redirecting (or at least providing the location header) to the GET endpoint for that resource following a POST anyway, so this behavior would give a consistent experience.What about returning a 418?Because the client ask to persist an entity that already exists on the server, the server finally gets mad and think he\'s a teapot and return: 418 I\'m a teapot. References:Another potential treatment is using PATCH after all. A PATCH is defined as something that changes the internal state and is not restricted to appending.PATCH would solve the problem by allowing you to update already existing items. See: RFC 5789: PATCHWhy not a 202 Accepted? It\'s an OK request (200s), there were no client errors (400s), per se.From 10 Status Code Definitions:"202 Accepted. The request has been accepted for processing, but the processing has not been completed."... because it didn\'t need to be completed, because it already existed. The client doesn\'t know it already existed, they didn\'t do anything wrong.I\'m leaning on throwing a 202, and returning similar content to what a GET /{resource}/{id} would have returned.What about 208 - http://httpstatusdogs.com/208-already-reported ? Is that a option?In my opinion, if the only thing is a repeat resource no error should be raised. After all, there is no error neither on the client or server sides.Stumbled upon this question while checking for correct code for duplicate record.Pardon my ignorance but I don\'t understand why everyone is ignoring the code "300" which clearly says "multiple choice" or "Ambiguous"In my opinion this would be the perfect code for building a non standard or a particular system for your own use. I could be wrong as well!https://tools.ietf.org/html/rfc7231#section-6.4.1