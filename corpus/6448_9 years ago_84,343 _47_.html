I just came across an interesting situation in JavaScript.  I have a class with a method that defines several objects using object-literal notation.  Inside those objects, the this pointer is being used.  From the behavior of the program, I have deduced that the this pointer is referring to the class on which the method was invoked, and not the object being created by the literal.  This seems arbitrary, though it is the way I would expect it to work.  Is this defined behavior?  Is it cross-browser safe?  Is there any reasoning underlying why it is the way it is beyond "the spec says so" (for instance, is it a consequence of some broader design decision/philosophy)?  Pared-down code example:Cannibalized from another post of mine, here\'s more than you ever wanted to know about this.Before I start, here\'s the most important thing to keep in mind about Javascript, and to repeat to yourself when it doesn\'t make sense.  Javascript does not have classes (ES6 class is syntactic sugar). If something looks like a class, it\'s a clever trick. Javascript has objects  and functions.  (that\'s not 100% accurate, functions are just objects, but it can sometimes be helpful to think of them as separate things)The this variable is attached to functions.  Whenever you invoke a function, this is given a certain value, depending on how you invoke the function.  This is often called the invocation pattern.There are four ways to invoke functions in javascript.  You can invoke the function as a method, as a function, as a constructor, and with apply.A method is a function that\'s attached to an objectWhen invoked as a method, this will be bound to the object the function/method is a part of.  In this example, this will be bound to foo.If you have a stand alone function, the this variable will be bound to the "global" object, almost always the window object in the context of a browser.This may be what\'s tripping you up, but don\'t feel bad.  Many people consider this a bad design decision.  Since a callback is invoked as a function and not as a method,  that\'s why you\'re seeing what appears to be inconsistent behavior.Many people get around the problem by doing something like, um, thisYou define a variable that which points to this. Closure (a topic all it\'s own) keeps that around, so if you call bar as a callback, it still has a reference.NOTE: In use strict mode if used as function, this is not bound to global. (It is undefined). You can also invoke a function as a constructor.  Based on the naming convention you\'re using (TestObject) this also may be what you\'re doing and is what\'s tripping you up.You invoke a function as a Constructor with the new keyword.When invoked as a constructor, a new Object will be created, and this will be bound to that object.  Again, if you have inner functions and they\'re used as callbacks, you\'ll be invoking them as functions, and this will be bound to the global object.  Use that var that = this trick/pattern.Some people think the constructor/new keyword was a bone thrown to Java/traditional OOP programmers as a way to create something similar to classes.Finally, every function has a method (yes, functions are objects in Javascript) named "apply".  Apply lets you determine what the value of this will be, and also lets you pass in an array of arguments.  Here\'s a useless example.Functions are just a type of Object.All Function objects have call and apply methods which execute the Function object they\'re called on.When called, the first argument to these methods specifies the object which will be referenced by the this keyword during execution of the Function - if it\'s null or undefined, the global object, window, is used for this.Thus, calling a Function......with parentheses - foo() - is equivalent to foo.call(undefined) or foo.apply(undefined), which is effectively the same as foo.call(window) or foo.apply(window).Additional arguments to call are passed as the arguments to the function call, whereas a single additional argument to apply can specify the arguments for the function call as an Array-like object.Thus, foo(1, 2, 3) is equivalent to foo.call(null, 1, 2, 3) or foo.apply(null, [1, 2, 3]).If a function is a property of an object......accessing a reference to the Function via the object and calling it with parentheses - obj.foo() - is equivalent to foo.call(obj) or foo.apply(obj).However, functions held as properties of objects are not "bound" to those objects. As you can see in the definition of obj above, since Functions are just a type of Object, they can be referenced (and thus can be passed by reference to a Function call or returned by reference from a Function call). When a reference to a Function is passed, no additional information about where it was passed from is carried with it, which is why the following happens:The call to our Function reference, baz, doesn\'t provide any context for the call, so it\'s effectively the same as baz.call(undefined), so this ends up referencing window. If we want baz to know that it belongs to obj, we need to somehow provide that information when baz is called, which is where the first argument to call or apply and closures come into play.When a Function is executed, it creates a new scope and has a reference to any enclosing scope. When the anonymous function is created in the above example, it has a reference to the scope it was created in, which is bind\'s scope. This is known as a "closure."When you attempt to access a variable this "scope chain" is walked to find a variable with the given name - if the current scope doesn\'t contain the variable, you look at the next scope in the chain, and so on until you reach the global scope. When the anonymous function is returned and bind finishes executing, the anonymous function still has a reference to bind\'s scope, so bind\'s scope doesn\'t "go away".Given all the above you should now be able to understand how scope works in the following example, and why the technique for passing a function around "pre-bound" with a particular value of this it will have when it is called works:Is this defined behavior? Is it\n  cross-browser safe?Yes. And yes.Is there any reasoning underlying why\n  it is the way it is...The meaning of this is pretty simple to deduce:The second case is obviously a design flaw, but it\'s pretty easy to work around it by using closures.In this case the inner this is bound to the global object instead of to the this variable of the outer function.\nIt\'s the way the language is designed.See "JavaScript: The Good Parts"  by Douglas Crockford for a good explanation.I found a nice tutorial about the ECMAScript thisA this value is a special object which is related with the execution\n  context. Therefore, it may be named as a context object (i.e. an\n  object in which context the execution context is activated).Any object may be used as this value of the context.a this value is a property of the execution context, but not a\n  property of the variable object.This feature is very important, because in contrary to variables, this value never participates in identifier resolution process. I.e. when accessing this in a code, its value is taken directly from the execution context and without any scope chain lookup. The value of this is determinate only once when entering the context.In the global context, a this value is the global object itself (that means, this value here equals to variable object)In case of a function context, this value in every single function call may be differentReference Javascript-the-core and Chapter-3-this