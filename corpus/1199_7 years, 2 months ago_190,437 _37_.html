I want to reduce load times on my websites by moving all cookies into local storage since they seem to have the same functionality. Are there any pros/cons (especially performance-wise) in using local storage to replace cookie functionality except for the obvious compatibility issues?Cookies and local storage serve different purposes. Cookies are primarily for reading server-side, local storage can only be read by the client-side. So the question is, in your app, who needs this data â€” the client or the server?If it\'s your client (your JavaScript), then by all means switch. You\'re wasting bandwidth by sending all the data in each HTTP header.If it\'s your server, local storage isn\'t so useful because you\'d have to forward the data along somehow (with Ajax or hidden form fields or something). This might be okay if the server only needs a small subset of the total data for each request.You\'ll want to leave your session cookie as a cookie either way though.As per the technical difference, and also my understanding:Apart from being an old way of saving data, Cookies give you a limit of 4096 bytes (4095, actually) - its per cookie. Local Storage is as big as 5MB per domain - SO Question also mentions it  localStorage is an implementation of the Storage Interface. It stores data with no expiration date, and gets cleared only through JavaScript, or clearing the Browser Cache / Locally Stored Data - unlike cookie expiry.In the context of JWTs, Stormpath have written a fairly helpful article outlining possible ways to store them, and the (dis-)advantages pertaining to each method.It also has a short overview of XSS and CSRF attacks, and how you can combat them.I\'ve attached some short snippets of the article below, in case their article is taken offline/their site goes down.Problems:Web Storage (localStorage/sessionStorage) is accessible through JavaScript on the same domain. This means that any JavaScript running on your site will have access to web storage, and because of this can be vulnerable to cross-site scripting (XSS) attacks. XSS in a nutshell is a type of vulnerability where an attacker can inject JavaScript that will run on your page. Basic XSS attacks attempt to inject JavaScript through form inputs, where the attacker puts alert(\'You are Hacked\'); into a form to see if it is run by the browser and can be viewed by other users.Prevention:To prevent XSS, the common response is to escape and encode all untrusted data. But this is far from the full story. In 2015, modern web apps use JavaScript hosted on CDNs or outside infrastructure. Modern web apps include 3rd party JavaScript libraries for A/B testing, funnel/market analysis, and ads. We use package managers like Bower to import other peoples\xe2\x80\x99 code into our apps.What if only one of the scripts you use is compromised? Malicious\n  JavaScript can be embedded on the page, and Web Storage is\n  compromised. These types of XSS attacks can get everyone\xe2\x80\x99s Web Storage\n  that visits your site, without their knowledge. This is probably why a\n  bunch of organizations advise not to store anything of value or trust\n  any information in web storage. This includes session identifiers and\n  tokens.As a storage mechanism, Web Storage does not enforce any secure\n  standards during transfer. Whoever reads Web Storage and uses it must\n  do their due diligence to ensure they always send the JWT over HTTPS\n  and never HTTP.Problems:Cookies, when used with the HttpOnly cookie flag, are not accessible through JavaScript, and are immune to XSS. You can also set the Secure cookie flag to guarantee the cookie is only sent over HTTPS. This is one of the main reasons that cookies have been leveraged in the past to store tokens or session data. Modern developers are hesitant to use cookies because they traditionally required state to be stored on the server, thus breaking RESTful best practices. Cookies as a storage mechanism do not require state to be stored on the server if you are storing a JWT in the cookie. This is because the JWT encapsulates everything the server needs to serve the request.However, cookies are vulnerable to a different type of attack:\n  cross-site request forgery (CSRF). A CSRF attack is a type of attack\n  that occurs when a malicious web site, email, or blog causes a user\xe2\x80\x99s\n  web browser to perform an unwanted action on a trusted site on which\n  the user is currently authenticated. This is an exploit of how the\n  browser handles cookies. A cookie can only be sent to the domains in\n  which it is allowed. By default, this is the domain that originally\n  set the cookie. The cookie will be sent for a request regardless of\n  whether you are on galaxies.com or hahagonnahackyou.com.Prevention:CSRF can be prevented by using synchronized token patterns. This\n  sounds complicated, but all modern web frameworks have support for\n  this.For example, AngularJS has a solution to validate that the cookie is\n  accessible by only your domain. Straight from AngularJS docs:When performing XHR requests, the $http service reads a token from a\n  cookie (by default, XSRF-TOKEN) and sets it as an HTTP header\n  (X-XSRF-TOKEN). Since only JavaScript that runs on your domain can\n  read the cookie, your server can be assured that the XHR came from\n  JavaScript running on your domain. You can make this CSRF protection\n  stateless by including a xsrfToken JWT claim:Leveraging your web app framework\xe2\x80\x99s CSRF protection makes cookies rock\n  solid for storing a JWT. CSRF can also be partially prevented by\n  checking the HTTP Referer and Origin header from your API. CSRF\n  attacks will have Referer and Origin headers that are unrelated to\n  your application.The full article can be found here:\nhttps://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage/They also have a helpful article on how to best design and implement JWTs, with regards to the structure of the token itself:\nhttps://stormpath.com/blog/jwt-the-right-way/With localStorage, web applications can store data locally within the user\'s browser. Before HTML5, application data had to be stored in cookies, included in every server request. localStorage is more secure, and large amounts of data can be stored locally, without affecting website performance. Although localStorage is more modern, there are some pros and cons to both techniques.ProsConsProsConslocalStorage usage is almost identical with the session one. They have pretty much exact methods, so switching from session to localStorage is really child\'s play. However, if stored data is really crucial for your application, you will probably use cookies as a backup in case localStorage is not available. If you want to check browser support for localStorage, all you have to do is run this simple script:"localStorage values on Secure (SSL) pages are isolated"\n  as someone noticed keep in mind that localStorage will not be\n  available if you switch from \'http\' to \'https\' secured protocol, where\n  the cookie will still be accesible. This is kind of important to\n  be aware of if you work with secure protocols.Well, local storage speed greatly depends on the browser the client is using, as well as the operating system.  Chrome or Safari on a mac could be much faster than Firefox on a PC, especially with newer APIs.  As always though, testing is your friend (I could not find any benchmarks).I really don\'t see a huge difference in cookie vs local storage.  Also, you should be more worried about compatibility issues: not all browsers have even begun to support the new HTML5 APIs, so cookies would be your best bet for speed and compatibility.Local storage can store up to 10mb offline data,  whereas session can store up to 5 mb data. But cookies can store only 4kb data in  text format.