How do I convert a string into an integer in JavaScript?The simplest way would be to use the native Number function:If that doesn\'t work for you, then there are the parseInt, unary plus, parseFloat with floor, and Math.round methods.parseInt:unary plus\nif your string is already in the form of an integer:if your string is or might be a float and you want an integer:or, if you\'re going to be using Math.floor several times:If you\'re the type who forgets to put the radix in when you call parseInt, you can use parseFloat and round it however you like. Here I use floor.Interestingly, Math.round (like Math.floor) will do a string to number conversion, so if you want the number rounded (or if you have an integer in the string), this is a great way, maybe my favorite:Try parseInt function:But there is a problem. If you try to convert "010" using parseInt function, it detects as octal number, and will return number 8. So, you need to specify a radix (from 2 to 36). In this case base 10.Example:There are two main ways to convert a string to a number in javascript.  One way is to parse it and the other way is to change its type to a Number.  All of the tricks in the other answers (e.g. unary plus) involve implicitly coercing the type of the string to a number.  You can also do the same thing explicitly with the Number function.ParsingparseInt and parseFloat are the two functions used for parsing strings to numbers.  Parsing will stop silently if it hits a character it doesn\'t recognise, which can be useful for parsing strings like "92px", but it\'s also somewhat dangerous, since it won\'t give you any kind of error on bad input, instead you\'ll get back NaN unless the string starts with a number. Whitespace at the beginning of the string is ignored.  Here\'s an example of it doing something different to what you want, and giving no indication that anything went wrong:It\'s good practice to always specify the radix as the second argument.  In older browsers, if the string started with a 0, it would be interpreted as octal if the radix wasn\'t specified which took a lot of people by surprise.  The behaviour for hexadecimal is triggered by having the string start with 0x if no radix is specified, e.g. 0xff. The standard actually changed with ecmascript 5, so modern browsers no longer trigger octal when there\'s a leading 0 if no radix has been specified.  parseInt understands radixes up to base 36, in which case both upper and lower case letters are treated as equivalent.Changing the Type of a String to a NumberAll of the other tricks mentioned above that don\'t use parseInt, involve implicitly coercing the string into a number.  I prefer to do this explicitly,This has different behavior to the parse methods (although it still ignores whitespace).  It\'s more strict: if it doesn\'t understand the whole of the string than it returns NaN, so you can\'t use it for strings like 97px.  Since you want a primitive number rather than a Number wrapper object, make sure you don\'t put new in front of the Number function.Obviously, converting to a Number gives you a value that might be a float rather than an integer, so if you want an integer, you need to modify it.  There are a few ways of doing this:Any bitwise operator (here I\'ve done a bitwise or, but you could also do double negation as in an earlier answer or a bitshift) will convert the value to a 32bit integer, and most of them will convert to a signed integer.  Note that this will not do want you want for large integers.  If the integer cannot be represented in 32bits, it will wrap.  To work correctly with larger numbers, you should use the rounding methodsBear in mind that all of these methods understand exponential notation, so 2e2 is 200 rather than NaN.  Also, Number understands "Infinity", while the parse methods don\'t.CustomIt\'s unlikely that either of these methods do exactly what you want.  For example, usually I would want an error thrown if parsing fails, and I don\'t need support for Infinity, exponentials or leading whitespace.  Depending on your usecase, sometimes it makes sense to write a custom conversion function.Always check that the output of Number or one of the parse methods is the sort of number you expect.  You will almost certainly want to use isNaN to make sure the number is not NaN (usually the only way you find out that the parse failed).ParseInt() and + are differentThough an old question, but maybe this can be helpful to someone.I use this way of converting string to int numberSo, when multiplying by 1, the value does not change, but js automatically returns a number.But as it is shown below, this should be used if you are sure that the str is a number(or can be represented as a number), otherwise it will return NaN - not a number.you can create simple function to use, e.g.Try parseInt.I posted the wrong answer here, sorry.  fixed.This is an old question, but I love this trick:The double bitwise negative drops off anything after the decimal point AND converts it to a number format. I\'ve been told it\'s slightly faster than calling functions and whatnot, but I\'m not entirely convinced.EDIT: Another method I just saw here (a question about the javascript >>> operator, which is a zero-fill right shift) which shows that shifting a number by 0 with this operator converts the number to a uint32 which is nice if you also want it unsigned.  Again, this converts to an unsigned integer, which can lead to strange behaviors if you use a signed number.Beware if you use parseInt to convert a float in scientific notation!\nFor example:will result ininstead ofAlso as a side note: Mootools has the function toInt() which is used on any native string (or float (or integer)).Please see the below example.It will help clear your doubtby using parseint function It will only give op of integer present and not the stringI recommend using parseFloat over parseInt. Here\'s why:Using parseFloat:Using parseInt:So if you have noticed parseInt discards the values after the decimals, whereas parseFloat lets you work with floating point numbers and hence more suitable if you want to retain the values after decimals. Use parseInt if and only if you are sure that you want the integer value.we can use +(stringOfNumber) instead of using parseInt(stringOfNumber)Ex: +("21") returns int of 21 like the parseInt("21").we can use this unary "+" operator for parsing float too...Try str - 0 to convert string to number.Here are two links to compare the performance of several ways to convert string to inthttps://jsperf.com/number-vs-parseint-vs-plushttp://phrogz.net/js/string_to_number.htmlGoogle gave me this answer as result, so...I actually needed to "save" a string as an integer, for a binding between C and JavaScript, so I convert the string into a integer value:Here is little comparison of speed (Mac Os only)... :)For chrome \'plus\' and \'mul\' are fastest, \'Math.floor\' is slowest (>700,000,00 op/sec). For Firefox \'plus\' is slowest (!) \'mul\' is fastest (>900,000,000 op/sec). In Safari \'parseInt\' is fastes, \'number\' is slowest (but resulats are quite similar, >13,000,000  <31,000,000). So Safari for cast string to int is more than 10x slower than other browsers. So the winner is \'mul\' :)You can run it on your browser by this link\nhttps://jsperf.com/casttonumberIn my opinion, no answer covers all edge cases as parsing a float should result in an error.There are many ways in JavaScript to convert a string to number, all simple and handy, choose the way which works for you:My prefer way is using + sign, which is the elegant way to convert a string to number in JavaScript.all of the above are correct. Please be sure before that this is a number in a string by doing "typeot x === \'number\'" other wise it will return NaN