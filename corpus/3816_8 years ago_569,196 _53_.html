If I have the value "foo", and a HashMap<String> ftw for which ftw.containsValue("foo") returns true, how can I get the corresponding key? Do I have to loop through the hashmap? What is the best way to do that?If you choose to use the Commons Collections library instead of the standard Java Collections API, you can achieve this with ease.The BidiMap interface in the Collections library is a bi-directional map, allowing you to map a key to a value (like normal maps), and also to map a value to a key, thus allowing you to perform lookups in both directions. Obtaining a key for a value is supported by the getKey() method.There is a caveat though, bidi maps cannot have multiple values mapped to keys, and hence unless your data set has 1:1 mappings between keys and values, you cannot use bidimaps.UpdateIf you want to rely on the Java Collections API, you will have to ensure the 1:1 relationship between keys and values at the time of inserting the value into the map. This is easier said than done.Once you can ensure that, use the entrySet() method to obtain the set of entries (mappings) in the Map. Once you have obtained the set whose type is Map.Entry, iterate through the entries, comparing the stored value against the expected, and obtain the corresponding key.Update #2Support for bidi maps with generics can be found in Google Guava and the refactored Commons-Collections libraries (the latter is not an Apache project). Thanks to Esko for pointing out the missing generic support in Apache Commons Collections. Using collections with generics makes more maintainable code.If your data structure has many-to-one mapping between keys and values you should iterate over entries and pick all suitable keys:In case of one-to-one relationship, you can return the first matched key:In Java 8:Also, for Guava users, BiMap may be useful. For example:Some additional info... May be useful to youAbove method may not be good if your hashmap is really big. If your hashmap contain unique key to unique value mapping, you can maintain one more hashmap that contain mapping from Value to Key.That is you have to maintain two hashmapsIn that case you can use second hashmap to get key.You could insert both the key,value pair and its inverse into your map structureUsing map.get("theValue") will then return "theKey".It\'s a quick and dirty way that I\'ve made constant maps, which will only work for a select few datasets:I think your choices areTo find all the keys that map to that value, iterate through all the pairs in the hashmap, using map.entrySet().There is no unambiguous answer, because multiple keys can map to the same value.  If you are enforcing unique-ness with your own code, the best solution is to create a class that uses two Hashmaps to track the mappings in both directions.Decorate map with your own implementationI think this is best solution, original address: Java2sAn easy usage: \nif you put all data in hasMap and you have item = "Automobile", so you are looking its key in hashMap. that is good solution. I\'m afraid you\'ll just have to iterate your map. Shortest I could come up with:It sounds like the best way is for you to iterate over entries using map.entrySet() since map.containsValue() probably does this anyway.If you build the map in your own code, try putting the key and value in the map together:Then when you have a value, you also have the key.Using Java 8:For Android development targeting API < 19, Vitalii Fedorenko one-to-one relationship solution doesn\'t work because Objects.equals isn\'t implemented. Here\'s a simple alternative:You can get the key using values using following code..You can use the below:Yes, you have to loop through the hashmap, unless you implement something along the lines of what these various answers suggest.  Rather than fiddling with the entrySet, I\'d just get the keySet(), iterate over that set, and keep the (first) key that gets you your matching value.  If you need all the keys that match that value, obviously you have to do the whole thing.As Jonas suggests, this might already be what the containsValue method is doing, so you might just skip that test all-together, and just do the iteration every time (or maybe the compiler will already eliminate the redundancy, who knows).Also, relative to the other answers, if your reverse map looks likeyou can deal with non-unique key->value mappings, if you need that capability (untangling them aside).  That would incorporate fine into any of the solutions people suggest here using two maps.Use a thin wrapper: HMapIn java8It\'s important to note that since this question, Apache Collections supports Generic BidiMaps.  So a few of the top voted answers are no longer accurate on that point.For a Serialized BidiMap that also supports duplicate values ( 1-to-many scenario ) also consider MapDB.org.My 2 cents. \nYou can get the keys in an array and then loop through the array. This will affect performance of this code block if the map is pretty big , where in you are getting the keys in an array first which might consume some time and then you are looping. Otherwise for smaller maps it should be ok.If you want to get key from value, its best to use bidimap (bi-directional maps) , you can get key from value in O(1) time.But, the drawback with this is you can only use unique keyset and valueset.There is a data structure called Table in java, which is nothing but map of maps likeTable< A, B , C > == map < A , map < B, C > >Here you can get map<B,C> by querying T.row(a);, and you can also get map<A,C> by querying T.column(b);In your special case, insert C as some constant.So, it like  < a1, b1, 1 > \n  < a2, b2 , 1 > , ...So, if you find via T.row(a1) ---> returns map of  --> get keyset  this returned map.If you need to find key value then, T.column(b2) --> returns map of  --> get keyset of returned map.Advantages over the previous case : 