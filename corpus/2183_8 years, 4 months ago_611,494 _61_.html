If I have these strings:"abc"  =  false"123"  = true"ab2"  = falseIs there a command, like IsNumeric or something else, that can identify if a string is a valid number?This will return true if input is all numbers. Don\'t know if it\'s any better than TryParse, but it will work.If you just want to know if it has one or more numbers mixed in with characters, leave off the ^ + and $.Edit:\nActually I think it is better than TryParse because a very long string could potentially overflow TryParse.I\'ve used this function several times:But you can also use;From Benchmarking IsNumeric Optionsalt text http://aspalliance.com/images/articleimages/80/Figure1.gifalt text http://aspalliance.com/images/articleimages/80/Figure2.gifYou can also use It will return true for all Numeric Digits (not float) and false if input string is any sort of alphanumeric.Please note: stringTest should not be empty string as this would pass the test of being Numeric.This is probably the best option in C#.If you want to know if the string contains a whole number (integer):The TryParse method will try to convert the string to a number (integer) and if it succeeds it will return true and place the corresponding number in myInt. If it can\'t, it returns false.Solutions using the int.Parse(someString) alternative shown in other responses works, but it is much slower because throwing exceptions is very expensive. TryParse(...) was added to the C# language in version 2, and until then you didn\'t have a choice. Now you do: you should therefore avoid the Parse() alternative.If you want to accept decimal numbers, the decimal class also has a .TryParse(...) method. Replace int with decimal in the above discussion, and the same principles apply.You can always use the built in TryParse methods for many datatypes to see if the string in question will pass. Example.Result would then = TrueResult would then = FalseIn case you don\'t want to use int.Parse or double.Parse, you can roll your own with something like this:I know this is an old thread, but none of the answers really did it for me - either inefficient, or not encapsulated for easy reuse. I also wanted to ensure it returned false if the string was empty or null. TryParse returns true in this case (an empty string does not cause an error when parsing as a number). So, here\'s my string extension method:Simple to use:Or, if you want to test other types of number, you can specify the \'style\'.\nSo, to convert a number with an Exponent, you could use:Or to test a potential Hex string, you could use:The optional \'culture\' parameter can be used in much the same way.It is limited by not being able to convert strings that are too big to be contained in a double, but that is a limited requirement and I think if you are working with numbers larger than this, then you\'ll probably need additional specialised number handling functions anyway.If you want to catch a broader spectrum of numbers, \xc3\xa0 la PHP\'s is_numeric, you can use the following:Unit Test:Keep in mind that just because a value is numeric doesn\'t mean it can be converted to a numeric type. For example, "999999999999999999999999999999.9999999999" is a perfeclty valid numeric value, but it won\'t fit into a .NET numeric type (not one defined in the standard library, that is).If you want to check if a string is a number (I\'m assuming it\'s a string since if it\'s a number, duh, you know it\'s one).you could also do:This will take care of the usual nasties:You\'ll have to add a reference to System.Numerics and have \nusing System.Numerics; on top of your class (well, the second is a bonus I guess :)You can use TryParse to determine if the string can be parsed into an integer.The boolean will tell you if it worked or not.I guess this answer will just be lost in between all the other ones, but anyway, here goes.I ended up on this question via Google because I wanted to check if a string was numeric so that I could just use double.Parse("123") instead of the TryParse() method.Why? Because it\'s annoying to have to declare a out variable and check the result of TryParse() before you now if the parse failed or not. I want to use the ternary operator to check if the string is numerical and then just parse it in the first ternary expression or provide a default value in the second ternary expression.Like this:It\'s just a lot cleaner than:I made a couple extension methods for these cases:Example:Because IsParseableAs() tries to parse the string as the appropriate type instead of just checking if the string is "numeric" it should be pretty safe. And you can even use it for non numeric types that has a TryParse() method, like DateTime.The method uses reflection and you end up calling the TryParse() method twice which of course isn\'t as efficient, but not everything has to be fully optimized, sometimes convenience is just more important.This method can also be used to easily parse a list of numeric strings into a list of double or some other type with a default value without having to catch any exceptions:This extension method lets you parse a string as any type that has a TryParse() method and it also lets you specify a default value to return if the conversion fails.This is better than using the ternary operator with the extension method above as it only does the conversion once, still uses reflection though...Examples:Outputs:Double.TryParseIf you want to know if a string is a number, you could always try parsing it:Note that TryParse returns a bool, which you can use to check if your parsing succeeded.Hope this helpsHere is the C# method.\nInt.TryParse Method (String, Int32)Pull in a reference to Visual Basic in your project and use its Information.IsNumeric method such as shown below and be able to capture floats as well as integers unlike the answer above which only catches ints.