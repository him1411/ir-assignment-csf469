I have a Live Android application, and from market i have received following stack trace and i have no idea why its happening as its not happening in application code but its getting caused by some or the other event from the application (assumption) I am not using Fragments, still there is a reference of FragmentManager.\nIf any body can throw some light on some hidden facts to avoid this type of issue:This is the most stupid bug I have encountered so far. I had a Fragment application working perfectly for API < 11, and Force Closing on API > 11.I really couldn\'t figure out what they changed inside the Activity lifecycle in the call to saveInstance, but I here is how I solved this :I just do not make the call to .super() and everything works great. I hope this will save you some time.EDIT: after some more research, this is a known bug in the support package. If you need to save the instance, and add something to your outState Bundle you can use the following :EDIT2: this may also occur if you are trying to perform a transaction after your Activity is gone in background. To avoid this you should use commitAllowingStateLoss()EDIT3: The above solutions were fixing issues in the early support.v4 libraries from what I can remember. But if you still have issues with this you MUST also read @AlexLockwood \'s blog : Fragment Transactions & Activity State Loss\nSummary from the blog post (but I strongly recommend you to read it) :Looking in Android source code on what causes this issue gives that flag mStateSaved in FragmentManagerImpl class (instance available in Activity) has value true. It is set to true when the back stack is saved (saveAllState) on call from Activity#onSaveInstanceState.\nAfterwards the calls from ActivityThread don\'t reset this flag using available reset methods from FragmentManagerImpl#noteStateNotSaved() and dispatch().The way I see it there are some available fixes, depending on what your app is doing and using:Before anything else: I would advertise Alex Lockwood article. Then, from what I\'ve done so far:For fragments and activities that don\'t need to keep any state information, call commitAllowStateLoss. Taken from documentation: Allows the commit to be executed after an activity\'s state is saved. This is dangerous because the commit can be lost if the activity needs to later be restored from its state, so this should only be used for cases where it is okay for the UI state to change unexpectedly on the user`. I guess this is alright to use if the fragment is showing read-only information. Or even if they do show editable info, use the callbacks methods to retain the edited info.Just after the transaction is commit (you just called commit()), make a call to FragmentManager.executePendingTransactions().As Ovidiu Latcu mentioned above, don\'t call super.onSaveInstanceState(). But this means you will lose the whole state of your activity along with fragments state.Override onBackPressed and in there call only finish(). This should be OK if you application doesn\'t use Fragments API; as in super.onBackPressed there is a call to FragmentManager#popBackStackImmediate().If you are using both Fragments API and the state of your activity is important/vital, then you could try to call using reflection API FragmentManagerImpl#noteStateNotSaved(). But this is a hack, or one could say it\'s a workaround. I don\'t like it, but in my case it\'s quite acceptable since I have a code from a legacy app that uses deprecated code (TabActivity and implicitly LocalActivityManager).Below is the code that uses reflection:Cheers!Such an exception will occur if you try to perform a fragment transition after your fragment activity\'s onSaveInstanceState() gets called. One reason this can happen, is if you leave an AsyncTask (or Thread) running when an activity gets stopped.Any transitions after onSaveInstanceState() is called could potentially get lost if the system reclaims the activity for resources and recreates it later.Simply call super.onPostResume() before showing your fragment or move your code in onPostResume() method after calling super.onPostResume(). This solve the problem!This can also happen when calling dismiss() on a dialog fragment after the screen has been locked\\blanked and the Activity + dialog\'s instance state has been saved.  To get around this call:Literally every single time I\'m dismissing a dialog i don\'t care about it\'s state anymore anyway, so this is ok to do - you\'re not actually losing any state.Short And working Solution :Follow Simple Steps :Step 1 : Override onSaveInstanceState state in respective fragment. And remove super method from it.Step 2 : Use CommitAllowingStateLoss(); instead of commit(); while fragment operations.this worked for me... found this out on my own... hope it helps you!1) do NOT have a global "static" FragmentManager / FragmentTransaction.2) onCreate, ALWAYS initialize the FragmentManager again!sample below :-I was always getting this when I tried to show fragment in onActivityForResult() method, so the problem was next:What I made is next:I solved the issue with onconfigurationchanged. The trick is that according to android activity life cycle, when you explicitly called an intent(camera intent, or any other one); the activity is paused and onsavedInstance is called in that case. When rotating the device to a different position other than the one during which the activity was active; doing fragment operations such as fragment commit causes Illegal state exception. There are lots of complains about it. It\'s something about android activity lifecycle management and proper method calls.\nTo solve it I did this:\n1-Override the onsavedInstance method of your activity, and determine the current screen orientation(portrait or landscape) then set your screen orientation to it before your activity is paused. that way the activity you lock the screen rotation for your activity in case it has been rotated by another one.\n2-then , override onresume method of activity, and set your orientation mode now to sensor so that after onsaved method is called it will call one more time onconfiguration to deal with the rotation properly.You can copy/paste this code into your activity to deal with it:I had the same problem, getting IllegalStateException, but replacing all my calls to commit() with commitAllowingStateLoss() did not help.The culprit was a call to DialogFragment.show().I surround it withand that did it. OK, I don\'t get to show the dialog, but in this case that was fine.It was the only place in my app where I first called FragmentManager.beginTransaction() but never called commit() so I did not find it when I looked for "commit()".The funny thing is, the user never leaves the app. Instead the killer was an AdMob interstitial ad showing up.My solution for that problem wasIn fragment add methods:May be bad, but couldn\'t find anything better.onSaveInstance will be called if a user rotates the screen so that it can load resources associated with the new orientation.It\'s possible that this user rotated the screen followed by pressing the back button (because it\'s also possible that this user fumbled their phone while using your app)I got this issue.But I think this problem is not related to commit and commitAllowStateLoss.The following stack trace and exception message is about commit().But this exception was caused by onBackPressed()They were all caused by checkStateLoss()mStateSaved will be true after onSaveInstanceState.This problem rarely happens.I have never encountered this problem.I can not reoccurrence the problem.I found issue 25517It might have occurred in the following circumstancesBack key is called after onSaveInstanceState, but before the new activity is started.use onStop() in codeI\'m not sure what the root of the problem is.\nSo I used an ugly way.I have got the same issue in my App. I have been solved this issue just calling the super.onBackPressed(); on previous class and calling the commitAllowingStateLoss() on the current class with that fragment.Read\nhttp://chris-alexander.co.uk/on-engineering/dev/android-fragments-within-fragments/article. \nfragment.isResumed() checking helps me in onDestroyView w/o using onSaveInstanceState method.Same issue from me and after a day long analysis of all articles, blog and stackoverflow i\'ve found a simple solution. Don\'t use savedInstanceState at all, this is the condition with one line of code. On the fragment code: This is fixed in Android 4.2 and also in the support library\'s source.[*]For details of the cause (and work-arounds) refer to the the Google bug report:\nhttp://code.google.com/p/android/issues/detail?id=19917If you\'re using the support library then you shouldn\'t have to worry about this bug (for long)[*]. However, if you\'re using the API directly (i.e. Not using the support library\'s FragmentManager) and targeting an API below Android 4.2 then you will need to try one of the work-arounds.[*] At the time of writing the Android SDK Manager is still distributing an old version that exhibits this bug.Edit I\'m going to add some clarification here because I\'ve obviously somehow confused whoever down-voted this answer.There are several different (but related) circumstances that can cause this exception to be thrown. My answer above is referring to the specific instance discussed in the question i.e. a bug in Android which has subsequently been fixed. If you\'re getting this exception for another reason it\'s because you\'re adding/removing fragments when you shouldn\'t be (after fragment states have been saved). If you\'re in such a situation then perhaps "Nested Fragments - IllegalStateException \xe2\x80\x9cCan not perform this action after onSaveInstanceState\xe2\x80\x9d" can be of use to you.Well, after trying all the above solutions without success (because basically i dont have transactions).On my case i was using AlertDialogs and ProgressDialog as fragments that, sometimes, on rotation, when asking for the FragmentManager, the error rises.I found a workaround mixing some many similar posts:Its a 3 step solution, all done on your FragmentActivity (in this case, its called GenericActivity):When i use startactivity in one fragment, i will get this exception;When i change to use startactivityforresult, the exception is gone :) So the easy way to fix it is use the startActivityForResult api :)I was getting this exception when I was pressing back button to cancel intent chooser on my map fragment activity.\nI resolved this by replacing the code of onResume()(where I was initializing the fragment and committing transaction) to onStart() and the app is working fine now.\nHope it helps.you can use FragmentActivity.onStart before popBackStackImmediate like this:http://jorryliu.blogspot.com/2014/09/illegalstateexception-can-not-perform.htmlAfter researching a bit the solution to this problem is to do your fragment commits in the onresume.Source: https://wenchaojames.wordpress.com/2013/01/12/illegalstateexception-from-onactivityresult/My use case: I have used listener in fragment to notify activity that some thing happened. I did new fragment commit on callback method. This works perfectly fine on first time. But on orientation change the activity is recreated with saved instance state. In that case fragment is not created again implies that the fragment have the listener which is old destroyed activity. Any way the call back method will get triggered on action. It goes to destroyed activity which cause the issue. The solution is to reset the listener in fragment with current live activity. This solve the problem.What I found is that if another app is dialog type and allows touches to be sent to background app then almost any background app will crash with this error.\nI think we need to check every time a transaction is performed if the instance was saved or restored.In my case, with the same error exception, i put the "onBackPressed()" in a runnable (you can use any of your view):I do not understand why, but it works!You may be calling fragmentManager.popBackStackImmediate(); when activity is paused. Activity is not finished but is paused and not on foreground. You need to check whether activity is paused or not before popBackStackImmediate().Thanks @gunar, but I think there is a better way.According to doc :So use commitNow to replace:I think calling FragmentActivity.onStateNotSaved() before those operations could be the best option by now.