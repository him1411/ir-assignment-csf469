Is there a way to determine how much time a method needs to execute (in milliseconds)?Swift:Swift3:Easy to use and has sub-millisecond precision.Here are two one-line macros that I use:Use it like this:For fine-grained timing on OS X, you should use mach_absolute_time( ) declared in <mach/mach_time.h>:Of course the usual caveats about fine-grained measurements apply; you\'re probably best off invoking the routine under test many times, and averaging/taking a minimum/some other form of processing.Additionally, please note that you may find it more useful to profile your application running using a tool like Shark.  This won\'t give you exact timing information, but it will tell you what percentage of the application\'s time is being spent where, which is often more useful (but not always).I know this is an old one but even I found myself wandering past it again, so I thought I\'d submit my own option here.Best bet is to check out my blog post on this:\nTiming things in Objective-C: A stopwatchBasically, I wrote a class that does stop watching in a very basic way but is encapsulated so that you only need to do the following:And you end up with:in the log...Again, check out my post for a little more or download it here:\nMMStopwatch.zipIn Swift, I\'m using:In my Macros.swift I just addedyou can now just call anywhere I use macros based on Ron\'s solution.For lines of code:we\'ll see in console something like: TIME1: 0.096618You can get really fine timing (seconds.parts of seconds) using this StopWatch class.  It uses the high-precision timer in the iPhone.  Using NSDate will only get you second(s) accuracy.  This version is designed specifically for autorelease and objective-c.  I have a c++ version as well if needed.  You can find the c++ version here.StopWatch.hStopWatch.mThe class has a static stopWatch method that returns an autoreleased object.  Once you call start, use the seconds method to get the elapsed time.  Call start again to restart it.  Or stop to stop it.  You can still read the time (call seconds) anytime after calling stop.Example In A Function  (Timing call of execution)I use very minimal, one page class implementation inspired by code from this blog post:The usage of it is very simple: OK, if your objective is to find out what you can fix to make it faster, that\'s a little different goal. Measuring the time that functions take is a good way to find out if what you did made a difference, but to find out what to do you need a different technique. This is what I recommend, and I know you can do it on iPhones.I use this:But I\'m not sure about CLOCKS_PER_SEC on the iPhone. You might want to leave it off.I use this code:Since you want to optimize time moving from one page to another in a UIWebView, does it not mean you really are looking to optimize the Javascript used in loading these pages?To that end, I\'d look at a WebKit profiler like that talked about here:http://www.alertdebugging.com/2009/04/29/building-a-better-javascript-profiler-with-webkit/Another approach would be to start at a high level, and think how you can design the web pages in question to minimize load times using AJAX style page loading instead of refreshing the whole webview each time.Here is another way, in Swift, to do that using the defer keywordFrom Apple\'s docs: A defer statement is used for executing code just before transferring program control outside of the scope that the defer statement appears in.This is similar to a try/finally block with the advantage of having the related code grouped.Here\'s a Swift 3 solution for bisecting code anywhere to find a long running process. Usage: -Sample output:-ELAPSED TIMES [MyApp.SomeViewController.Instrumentation(title: "Start View\n  Did Load", point: 1, elapsedTime: 0.040504038333892822),\n  MyApp.SomeViewController.Instrumentation(title: "Finished Adding\n  SubViews", point: 2, elapsedTime: 0.010585010051727295),\n  MyApp.SomeViewController.Instrumentation(title: "View Did Appear",\n  point: 3, elapsedTime: 0.56564098596572876)]