I\'m trying to use Grunt as a build tool for my webapp.I want to have at least two setups: I. Development setup - load scripts from separate files, without concatenation,so my index.html would look something like:II. Production setup - load my scripts minified & concatenated in one file,with index.html accordingly:The question is, how can I make grunt make these index.html\'s depending on the configuration when I run grunt dev or grunt prod?Or maybe I\'m digging in the wrong direction and it would be easier to always generate MyApp-all.min.js but put inside it either all my scripts (concatenated) or a loader script that asynchronously loads those scripts from separate files?How do you do it, guys?I recently discovered these Grunt v0.4.0 compatible tasks:grunt-preprocess Grunt task around preprocess npm module.  grunt-env Grunt task to automate environment configuration for future tasks.Below are snippets from my Gruntfile.js.ENV setup:Preprocess:Tasks:And in the /src/tmpl/index.html template file (for example):I\'m sure my setup is different than most people, and the usefulness of the above will depend on your situation. For me, while it\'s an awesome bit of code, the Yeoman grunt-usemin is a more robust than I personally need.NOTE: I just discovered the above listed tasks today, so I might be missing a feature and/or my process may change down the road. For now, I\'m loving the simplicity and features that grunt-preprocess and grunt-env have to offer. :)Motivated by a down vote ...When I posted this answer there weren\'t many options for Grunt 0.4.x that offered a solution that worked for my needs. Now, months later, I would guess that there are more options out there that could be better than what I have posted here. While I still personally use, and enjoy using, this technique for my builds, I ask that future readers take the time to read the other answers given and to research all the options. If you find a better solution, please post your answer here.I\'m not sure if it will be of any help to anyone, but I\'ve created this demo repository on GitHub that shows a complete (and more complex setup) using the technique(s) I\'ve outlined above.I\'ve come up with my own solution. Not polished yet but I think I\'m going to move in that direction.In essense, I\'m using grunt.template.process() to generate my index.html from a template that analyzes current configuration and produces either a list of my original source files or links to a single file with minified code. The below example is for js files but the same approach can be extended to css and any other possible text files.grunt.js:index.js (the index task):Finally, index.tmpl, with generation logic baked in:UPD. Found out that Yeoman, which is based on grunt, has a built-in usemin task that integrates with Yeoman\'s build system. It generates a production version of index.html from information in development version of index.html as well as other environment settings. A bit sophisticated but interesting to look at.I dislike the solutions here (including the one I previously gave) and here\'s why:I\'ve figured out how to solve both of these issues.  I\'ve set up my grunt task so that every time a file is added or deleted, the script tags automatically get generated to reflect that.  This way, you don\'t need to modify your html file or your grunt file when you add/remove/rename your JS files.To summarize how that works, I have a html template with a variable for the script tags.  I use https://github.com/alanshaw/grunt-include-replace to populate that variable.  In dev mode, that variable comes from a globbing pattern of all my JS files.  The watch task recalculates this value when a JS file is added or removed.  Now, to get different results in dev or prod mode, you simply populate that variable with a different value.  Here\'s some code:jsSrcFileArray is your typical grunt file-globbing pattern.  jsScriptTags takes the jsSrcFileArray and concatenates them together with script tags on both sides.  destPath is the prefix I want on each file.  And here\'s what the HTML looks like:Now, as you can see in the config, I generate the value of that variable as a hard coded script tag when it\'s run in prod mode.  In dev mode, this variable will expand to a value like this:Let me know if you have any questions.  PS: This is a crazy amount of code for something I\'d want to do in every client-side JS app.  I hope someone can turn this into a reusable plugin.  Maybe I will some day.  I have been asking myself the same question for a while, and I think this grunt plugin could be configured to do what you want: https://npmjs.org/package/grunt-targethtml. It implements conditional html tags, that depend on the grunt target.I was looking for a more simple, straight forward solution so I combined the answer from this question:How to place if else block in gruntfile.jsand came up with following simple steps:Use the following logic in your Gruntfile.js\'s concat/copy block for your index.html file:run \'grunt --Release\' to choose the index-production.html  file and leave off the flag to have the development version.No new plugins to add  or configure and no new grunt tasks.This grunt task named scriptlinker looks like an easy way to add the scripts in dev mode.  You could probably run a concat task first and then point it to your concatenated file in prod mode.  grunt-dom-munger reads and manipulates HTML with CSS selectors. Ex. read  tags from your html. Remove nodes, add nodes, and more.You can use grunt-dom-munger to read all your JS files that are linked by your index.html, uglify them and then use grunt-dom-munger again to modify your index.html to only link the minified JSI found a grunt plugin called grunt-dev-prod-switch. All it does is comment out certain blocks it looks for based on an --env option you pass to grunt (although it limits you to dev, prod, and test).Once you set it up as it explains here, you can run for example:grunt serve --env=dev, and all it does is comment out the blocks which are wrapped byand it will uncomment out blocks which are wrapped byIt also works on javascript, I use it for setting up the right IP address to connect to for my backend API. The blocks just change toIn your case, it would be as simple as this:grunt-bake is a fantastic grunt script that would work great here. I use it in my JQM auto build script.https://github.com/imaginethepoet/autojqmphonegapTake a look at my grunt.coffee file: This looks at all the files in base.html and sucks them in to create index.html works fantastic for multipage apps (phonegap). This allows for easier development as all devs are not working on one long single page app (preventing lots of conflict checkins). Instead you can break up the pages and work on smaller chunks of code and compile to the full page using a watch command.Bake reads the template from base.html and injects the component html pages on watch.\n\n  \n  \n  jQuery Mobile Demos\n  \n  \n  \n  \n  \n  \n  \n  \n  \n      app.initialize();\n    \n  You can take this a step further and add injections in your pages for "menus" "popups" etc so you can really break pages into smaller manageable components.Use a combination of wiredep https://github.com/taptapship/wiredep and usemin https://github.com/yeoman/grunt-usemin in order to have grunt take care of these tasks. Wiredep will add your dependencies one script file at a time, and usemin will concatenate them all into a single file for production. This can then be accomplished with just some html comments. For instance, my bower packages are automatically included and added to the html when I run bower install && grunt bowerInstall:Consider processhtml. It allows definition of multiple "targets" for builds. Comments are used to conditionally include or exclude material from the HTML: becomesIt even purports to do nifty stuff like this (see the README): This answer is not for noobs!Use Jade templating ... passing variables to a Jade template is a bog standard use caseI am using grunt (grunt-contrib-jade) but you don\'t have to use grunt. Just use the standard npm jade module.If using grunt then your gruntfile would like something like ...We can now easily access the data passed by grunt in the Jade template.Much like the approach used by Modernizr, I set a CSS class on the HTML tag according to the value of the variable passed and can use JavaScript logic from there based on whether the CSS class is present or not.This is great if using Angular since you can do ng-if\'s to include elements in the page based on whether the class is present.For example, I might include a script if the class is present ...(For example, I might include the live reload script in dev but not in production)