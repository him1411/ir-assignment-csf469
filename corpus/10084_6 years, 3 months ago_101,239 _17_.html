Assuming I have an array that has a size of N (where N > 0), is there a more efficient way of prepending to the array that would not require O(N + 1) steps?In code, essentially, what I currently am doing isI\'m not sure about more efficient in terms of big-O but certainly using the unshift method is more concise:[Edit]This jsPerf benchmark shows that unshift is decently faster in at least a couple of browsers, regardless of possibly different big-O performance iff you are ok with modifying the array in-place.  If you really can\'t mutate the original array then you would do something like the below snippet, which doesn\'t seem to be appreciably faster than your solution:[Edit 2]For completeness, the following function can be used instead of OP\'s example prependArray(...) to take advantage of the Array unshift(...) method:If you are prepending an array to the front of another array, it is more efficient to just use concat. So:But this will still be O(N) in the size of oldArray. Still, it is more efficient than manually iterating over oldArray. Also, depending on the details, it may help you, because if you are going to prepend many values, it\'s better to put them into an array first and then concat oldArray on the end, rather than prepending each one individually.There\'s no way to do better than O(N) in the size of oldArray, because arrays are stored in contiguous memory with the first element in a fixed position. If you want to insert before the first element, you need to move all the other elements. If you need a way around this, do what @GWW said and use a linked list, or a different data structure.If you would like to prepend array (a1 with an array a2) you could use the following:With ES6, you can now use the spread operator to create a new array with your new elements inserted before the original elements.f you need to preserve the old array, \nslice the old one and unshift the new value(s) \nto the beginning of the slice.There is special method:But if you want to prepend several elements to array it would be faster to use such a method: