I\'ve to admit that I don\'t know much about functional programming. I read about it from here and there, and so came to know that in functional programming, a function returns the same output, for same input, no matter how many times the function is called.  It\'s exactly like mathematical function which evaluates to same output for same value of input parameter which involves in the function expression. For example, consider this:No matter how many times you use f(10,4), its value will always be 104. As such, wherever you\'ve written f(10,4), you can replace it with 104, without altering the value of the whole expression. This property is referred to as referential transparency of an expression.As Wikipedia says (link),Conversely, in functional code, the output value of a function depends only on the arguments that are input to the function, so calling a function f twice with the same value for an argument x will produce the same result f(x) both times. So my question is: can a time function (which returns the current time) exist in functional programming? If yes, then how can it exist? Does it not violate the principle of functional programming? It particularly violates referential transparency which is one of the property of functional programming (if I correctly understand it).Or if no, then how can one know the current time in functional programming?Another way to explain it is this: no function can get the current time (since it keeps changing), but an action can get the current time. Let\'s say that getClockTime is a constant (or a nullary function, if you like) which represents the action of getting the current time. This action is the same every time no matter when it is used so it is a real constant. Likewise, let\'s say print is a function which takes some time representation and prints it to the console. Since function calls cannot have side effects in pure functional language, we instead imagine that it is a function which takes a timestamp and returns the action of printing it to the console. Again, this is a real function, because if you give it the same timestamp, it will return the same action of printing it every time.Now, how can you print the current time to the console? Well, you have to combine the two actions. So how can we do that? We cannot just pass getClockTime to print, since print expects a timestamp, not an action. But we can imagine that there is an operator, >>=, which combines two actions, one which gets a timestamp, and one which takes one as argument and prints it. Applying this to the actions previously mentioned, the result is... tadaaa... a new action which gets the current time and prints it. And this is incidently exactly how it is done in Haskell.So, conceptually, you can view it in this way: A pure functional program does not perform any IO, it defines an action, which the runtime system then executes. The action is the same every time, but the result of executing it depends on the circumstances of when it is executed.I don\'t know if this was any clearer than the other explanations, but it sometimes helps me to think of it this way. Yes and no.Different FP languages solve them differently.In Haskell (a very pure one) all this stuff has to happen in something called the IO Monad - see here.\nYou can think of it as getting another input (and output) into your function (the world-state) or easier as a place where "impureness" like getting the changing time happens.Other languages like F# just have some impureness built in and so you can have a function that returns different values for the same input - just like normal imperative languages.As Jeffrey Burka mentioned in his comment:\nHere is the nice intro to the IO Monad straight from the HaskellWiki.In Haskell one uses a construct called monad to handle side effects. A monad basically means that you encapsulate values into a container and have some functions to chain functions from values to values inside a container. If our container has the type:we can safely implement IO actions. This type means: An action of type IO is a function, that takes a token of type RealWorld and returns a new token, together with a result.The idea behind this is that each IO action mutates the outside state, represented by the magical token RealWorld. Using monads, one can chain multiple functions that mutate the real world together. The most important function of a monad is >>=, pronounced bind:>>= takes one action and a function that takes the result of this action and creates a new action out of this. The return type is the new action. For instance, let\'s pretend there is a function now :: IO String, which returns a String representing the current time. We can chain it with the function putStrLn to print it out:Or written in do-Notation, which is more familiar to an imperative programmer:All this is pure, as we map the mutation and information about the world outside to the RealWorld token. So each time, you run this action, you get of course a different output, but the input is not the same: the RealWorld token is different. Most functional programming languages are not pure, i.e. they allow functions to not only depend on their values. In those languages it is perfectly possible to have a function returning the current time. From the languages you tagged this question with this applies to scala and f# (as well as most other variants of ML).In languages like Haskell and Clean, which are pure, the situation is different. In Haskell the current time would not be available through a function, but a so-called IO action, which is Haskell\'s way of encapsulating side effects.In Clean it would be a function, but the function would take a world value as its argument and return a fresh world value (in addition to the current time) as its result. The type system would make sure that each world value can be used only once (and each function which consumes a world value would produces a new one). This way the time function would have to be called with a different argument each time and thus would be allowed to return a different time each time."Current time" is not a function. It is a parameter. If your code depends on current time, it means your code is parameterized by time.It can absolutely be done in a purely functional way. There are several ways to do it, but the simplest is to have the time function return not just the time but also the function you must call to get the next time measurement.In C# you could implement it like this:(Keep in mind that this is an example meant to be simple, not practical. In particular, the list nodes can\'t be garbage collected because they are rooted by ProgramStartTime.)This \'ClockStamp\' class acts like an immutable linked list, but really the nodes are generated on demand so they can contain the \'current\' time. Any function that wants to measure the time should have a \'clockStamp\' parameter and must also return its last time measurement in its result (so the caller doesn\'t see old measurements), like this:Of course, it\'s a bit inconvenient to have to pass that last measurement in and out, in and out, in and out. There are many ways to hide the boilerplate, especially at the language design level. I think Haskell uses this sort of trick and then hides the ugly parts by using monads.Yes, getting time function can exist in FP using a slightly modified version on FP known as impure FP (the default or the main one is pure FP).In case of getting the time (or reading file, or launching missile) the code needs to interact with the outer world to get the job done and this outer world is not based on pure foundations of FP. To allow a pure FP world to interact with this impure outside world people have introduced impure FP. After all a software which doesn\'t interact with the outside world isn\'t any useful other than doing some mathematical computations.Few FP programming languages have this impurity feature inbuilt in them such that it is not easy to separate out which code is impure and which is pure (like F# etc) and some FP languages make sure that when you do some impure stuff that code is clearly stand out as compared to pure code, like Haskell.Another interesting way to see this would be that your get time function in FP would take a "world" object which has the current state of the world like time, number of people living in the world etc. Then getting time from which world object would be always pure i.e you pass in the same world state you will always get the same time.Yes! You are correct! Now() or CurrentTime() or any method signature of such flavour is not exhibiting referential transparency in one way. But by instruction to the compiler it is parameterized by a system clock input.By output, Now() might look like not following referential transparency. But actual behaviour of the system clock and the function on top of it is adheres to \nreferential transparency.I am surprised that none of the answers or comments mention coalgebras or coinduction.  Usually, coinduction is mentioned when reasoning about infinite data structures, but it is also applicable to an endless stream of observations, such as a time register on a CPU.  A coalgebra models hidden state; and coinduction models observing that state. (Normal induction models constructing state.)This is a hot topic in Reactive Functional Programming.  If you\'re interested in this sort of stuff, read this: http://digitalcommons.ohsu.edu/csetech/91/ (28 pp.)Yes, it\'s possible for a pure function to return the time, if it\'s given that time as a parameter. Different time argument, different time result. Then form other functions of time as well and combine them with a simple vocabulary of function(-of-time)-transforming (higher-order) functions. Since the approach is stateless, time here can be continuous (resolution-independent) rather than discrete, greatly boosting modularity. This intuition is the basis of Functional Reactive Programming (FRP).Your question conflates two related measures of a computer language:  functional/imperative and pure/impure.A functional language defines relationships between inputs and outputs of functions, and an imperative language describes specific operations in a specific order to perform.A pure language does not create or depend on side effects, and an impure language uses them throughout.One-hundred percent pure programs are basically useless.  They may perform an interesting calculation, but because they cannot have side effects they have no input or output so you would never know what they calculated.  To be useful at all, a program has to be at least a smidge impure.  One way to make a pure program useful is to put it inside a thin impure wrapper.  Like this untested Haskell program: