Is there a way to get the function parameter names of a function dynamically?Let\xe2\x80\x99s say my function looks like this:Now, how would I get a list of the parameter names and their values into an array from inside the function?The following function will return an array of the parameter names of any function passed in.Example usage:Edit:With the invent of ES6 this function can be tripped up by default parameters.  Here is a quick hack which should work in most cases:I say most cases because there are some things that will trip it upEdit:\nI also note vikasde wants the parameter values in an array also.  This is already provided in a local variable named arguments.  excerpt from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments:The arguments object is not an Array. It is similar to an Array, but does not have any Array properties except length. For example, it does not have the pop method. However it can be converted to a real Array:If Array generics are available, one can use the following instead:Below is the code taken from AngularJS which uses the technique for its dependency injection mechanism.And here is an explanation of it taken from http://docs.angularjs.org/tutorial/step_05Angular\'s dependency injector provides services to your controller\n  when the controller is being constructed. The dependency injector also\n  takes care of creating any transitive dependencies the service may\n  have (services often depend upon other services).Note that the names of arguments are significant, because the injector\n  uses these to look up the dependencies.Solution that is less error prone to spaces and comments would be:Here is an updated solution that attempts to address all the edge cases mentioned above in a compact way:Abbreviated test output (full test cases are attached below):A lot of the answers on here use regexes, this is fine but it doesn\'t handle new additions to the language too well (like arrow functions and classes). Also of note is that if you use any of these functions on minified code it\'s going to go \xf0\x9f\x94\xa5. It will use whatever the minified name is. Angular gets around this by allowing you to pass in an ordered array of strings that matches the order of the arguments when registering them with the DI container. So on with the solution: This handles the original parse issue and a few more function types (e.g. arrow functions). Here\'s an idea of what it can and can\'t handle as is: Depending on what you want to use it for ES6 Proxies and destructuring may be your best bet. For example if you wanted to use it for dependency injection (using the names of the params) then you can do it as follows: It\'s not the most advanced resolver out there but it gives an idea of how you can use a Proxy to handle it if you want to use args parser for simple DI. There is however one slight caveat in this approach. We need to use destructuring assignments instead of normal params. When we pass in the injector proxy the destructuring is the same as calling the getter on the object. This outputs the following:Its wired up the entire application. The best bit is that the app is easy to test (you can just instantiate each class and pass in mocks/stubs/etc). Also if you need to swap out implementations, you can do that from a single place. All this is possible because of JS Proxy objects. Note: There is a lot of work that would need to be done to this before it would be ready for production use but it does give an idea of what it would look like.It\'s a bit late in the answer but it may help others who are thinking of the same thing. \xf0\x9f\x91\x8dI know this is an old question, but beginners have been copypasting this around as if this was good practice in any code. Most of the time, having to parse a function\'s string representation to use its parameter names just hides a flaw in the code\'s logic.Parameters of a function are actually stored in an array-like object called arguments, where the first argument is arguments[0], the second is arguments[1] and so on. Writing parameter names in the parentheses can be seen as a shorthand syntax. This:...is the same as:The variables themselves are stored in the function\'s scope, not as properties in an object. There is no way to retrieve the parameter name through code as it is merely a symbol representing the variable in human-language.I always considered the string representation of a function as a tool for debugging purposes, especially because of this arguments array-like object. You are not required to give names to the arguments in the first place. If you try parsing a stringified function, it doesn\'t actually tell you about extra unnamed parameters it might take.Here\'s an even worse and more common situation. If a function has more than 3 or 4 arguments, it might be logical to pass it an object instead, which is easier to work with.In this case, the function itself will be able to read through the object it receives and look for its properties and get both their names and values, but trying to parse the string representation of the function would only give you "obj" for parameters, which isn\'t useful at all.=> [ "a", "b", "c" ]I\'ve tried doing this before, but never found a praticial way to get it done. I ended up passing in an object instead and then looping through it.I don\'t know if this solution suits your problem, but it lets you redefine whatever function you want, without having to change code that uses it. Existing calls will use positioned params, while the function implementation may use "named params" (a single hash param).I thought that you will anyway modify existing function definitions so, why not having a factory function that makes just what you want:Hope it helps.You can also use "esprima" parser to avoid many issues with comments, whitespace and other things inside parameters list.It works even with code like this:And I would like to advertise my lib which does this under Node.js also: https://github.com/cruks/cruks-lib-functionI don\'t know how to get a list of the parameters but you can do this to get how many it expects.How I typically do it:You can even ref the args by the functions name like: Hope this helps!Taking the answer from @jack-allan I modified the function slightly to allow ES6 default properties such as:to still return [ \'a\', \'b\' ]The answer to this requires 3 steps:The code will be like thisand the logged object will be And here\'s a working example https://tonicdev.com/5763eb77a945f41300f62a79/5763eb77a945f41300f62a7aI have read most of the answers here, and I would like to add my one-liner.orLet\'s say you have a functionThe below code will return "abc,def,ghi,jkl"That code will also work with the setup of a function that Camilo Martin gave:Also with Bubersson\'s comment on Jack Allan\'s answer:__This creates a Regular Exponent with the new RegExp(Function.name+\'\\\\s*\\\\((.*?)\\\\)\').  I have to use new RegExp because I am injecting a variable (Function.name, the name of the function being targeted) into the RegExp.Example If the function name is "foo" (function foo()), the RegExp will be /foo\\s*\\((.*?)\\)/.Then it converts the entire function into a string, and removes all newlines.  Removing newlines helps with the function setup Camilo Martin gave.This is the RegExp.prototype.exec function. It basically matches the Regular Exponent (new RegExp()) into the String (Function.toString()).  Then the [1] will return the first Capture Group found in the Regular Exponent ((.*?)).This will remove every comment inside /* and */, and remove all spaces.If you want to make all the parameters into an Array instead of a String separated by commas, at the end just add .split(\',\').Wow so many answers already.. Im pretty sure this gets buried. Even so I figured this might be useful for some.I wasn\'t fully satisfied with the chosen answers as in ES6 it doesn\'t work well with default values. And it also does not provide the default value information. I also wanted a lightweight function that does not depend on an external lib.This function is very useful for debugging purposes, for example: logging called function with its params, default param values and arguments.I spent some time on this yesterday, cracking the right RegExp to solve this issue and this is what I came up with. It works very well and I\'m very pleased with the outcome:As you can tell some of the parameter names disappear because the Babel transpiler removes them from the function. If you would run this in the latest NodeJS it works as expected (The commented results are from NodeJS).Another note, as stated in the comment is that is does not work with inlined arrow functions as a default value. This simply makes it far to complex to extract the values using a RegExp.Please let me know if this was useful for you! Would love to hear some feedback!You can access the argument values passed to a function using the "arguments" property.Here\'s one way:Note: This only works on browsers that support arguments.callee.It\'s pretty easy.At the first there is a deprecated arguments.callee \xe2\x80\x94 a reference to called function.\nAt the second if you have a reference to your function you can easily get their textual representation.\nAt the third if you calling your function as constructor you can also have a link via yourObject.constructor.\nNB: The first solution deprecated so if you can\'t to not use it you must also think about your app architecture.\nIf you don\'t need exact variable names just use inside a function internal variable arguments without any magic.https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/arguments/calleeAll of them going to call toString and replace with re so we can create a helper:Some examples:Enjoy with JS!UPD: Jack Allan was provided a little bit better solution actually. GJ Jack!Whatever the solution, it must not break on wierd functions, whose toString() looks just as wierd:Also, why use complex regular expressions? This can be done like:This works everywhere with every function, and the only regex is whitespace removal that doesn\'t even process the whole string due to the .split trick.Ok so an old question with plenty of adequate answers.\nhere is my offering that does not use regex, except for the menial task of stripping whitespace . (I should note that the "strips_comments" function actually spaces them out, rather than physically remove them. that\'s because i use it elsewhere and for various reasons need the locations of the original non comment tokens to stay intact)It\'s a fairly lengthy block of code as this pasting includes a mini test framework.By using the arguments array in JS:function parameter string value image dynamically from JSON. Since item.product_image2 is a URL string, you need to put it in quotes when you call changeImage inside parameter.My Function OnclickMy FunctionI\'ll give you a short example below: