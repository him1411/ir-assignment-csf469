I have an AngularJS service that I want to initialize with some asynchronous data. Something like this:Obviously this won\'t work because if something tries to call doStuff() before myData gets back I will get a null pointer exception. As far as I can tell from reading some of the other questions asked here and here I have a few options, but none of them seem very clean (perhaps I am missing something):Setup Service with "run"When setting up my app do this:Then my service would look like this:This works some of the time but if the asynchronous data happens to take longer than it takes for everything to get initialized I get a null pointer exception when I call doStuff()Use promise objectsThis would probably work. The only downside it everywhere I call MyService I will have to know that doStuff() returns a promise and all the code will have to us then to interact with the promise. I would rather just wait until myData is back before loading the my application.Manual Bootstrap Global Javascript Var\nI could send my JSON directly to a global Javascript variable:HTML:data.js:Then it would be available when initializing MyService:This would work too, but then I have a global javascript variable which smells bad.Are these my only options? Are one of these options better than the others? I know this is a pretty long question, but I wanted to show that I have tried to explore all my options. Any guidance would greatly be appreciated. Have you had a look at $routeProvider.when(\'/path\',{ resolve:{...}? It can make the promise approach a bit cleaner:Expose a promise in your service:\nAdd resolve to your route config:Your controller won\'t get instantiated before all dependencies are resolved:I\'ve made an example at plnkr: http://plnkr.co/edit/GKg21XH0RwCMEQGUdZKH?p=previewBased on Martin Atkins\' solution, here is a complete, concise pure-Angular solution:This solution uses a self-executing anonymous function to get the $http service, request the config, and inject it into a constant called CONFIG when it becomes available. Once completely, we wait until the document is ready and then bootstrap the Angular app. This is a slight enhancement over Martin\'s solution, which deferred fetching the config until after the document is ready. As far as I know, there is no reason to delay the $http call for that. Unit TestingNote: I have discovered this solution does not work well when unit-testing when the code is included in your app.js file. The reason for this is that the above code runs immediately when the JS file is loaded. This means the test framework (Jasmine in my case) doesn\'t have a chance to provide a mock implementation of $http. My solution, which I\'m not completely satisfied with, was to move this code to our index.html file, so the Grunt/Karma/Jasmine unit test infrastructure does not see it.I used a similar approach to the one described by @XMLilley but wanted to have the ability to use AngularJS services like $http to load the configuration and do further initialization without the use of low level APIs or jQuery.Using resolve on routes was also not an option because I needed the values to be available as constants when my app is started, even in module.config() blocks.I created a small AngularJS app that loads the config, sets them as constants on the actual app and bootstraps it.See it in action (using $timeout instead of $http) here: http://plnkr.co/edit/FYznxP3xe8dxzwxs37hi?p=previewUPDATEI would recommend to use the approach described below by Martin Atkins and JBCP.UPDATE 2Because I needed it in multiple projects, I just released a bower module that takes care of this: https://github.com/philippd/angular-deferred-bootstrapExample that loads data from the back-end and sets a constant called APP_CONFIG on the AngularJS module:The "manual bootstrap" case can gain access to Angular services by manually creating an injector before bootstrap. This initial injector will stand alone (not be attached to any elements) and include only a subset of the modules that are loaded. If all you need is core Angular services, it\'s sufficient to just load ng, like this:You can, for example, use the module.constant mechanism to make data available to your app:This myAppConfig can now be injected just like any other service, and in particular it\'s available during the configuration phase:or, for a smaller app, you could just inject the global config directly into your service, at the expense of spreading knowledge about the configuration format throughout the application.Of course, since the async operations here will block the bootstrap of the application, and thus block the compilation/linking of the template, it\'s wise to use the ng-cloak directive to prevent the unparsed template from showing up during the work. You could also provide some sort of loading indication in the DOM , by providing some HTML that gets shown only until AngularJS initializes:I created a complete, working example of this approach on Plunker, loading the configuration from a static JSON file as an example.I had the same problem: I love the resolve object, but that only works for the content of ng-view. What if you have controllers (for top-level nav, let\'s say) that exist outside of ng-view and which need to be initialized with data before the routing even begins to happen? How do we avoid mucking around on the server-side just to make that work?Use manual bootstrap and an angular constant. A naiive XHR gets you your data, and you bootstrap angular in its callback, which deals with your async issues. In the example below, you don\'t even need to create a global variable. The returned data exists only in angular scope as an injectable, and isn\'t even present inside of controllers, services, etc. unless you inject it. (Much as you would inject the output of your resolve object into the controller for a routed view.) If you prefer to thereafter interact with that data as a service, you can create a service, inject the data, and nobody will ever be the wiser.Example:Now, your NavData constant exists. Go ahead and inject it into a controller or service: Of course, using a bare XHR object strips away a number of the niceties that $http or JQuery would take care of for you, but this example works with no special dependencies, at least for a simple get. If you want a little more power for your request, load up an external library to help you out. But I don\'t think it\'s possible to access angular\'s $http or other tools in this context. (SO related post)What you can do is in your .config for the app is create the resolve object for the route and in the function pass in $q (promise object) and the name of the service you\'re depending on, and resolve the promise in the callback function for the $http in the service like so:ROUTE CONFIGAngular won\'t render the template or make the controller available until defer.resolve() has been called. We can do that in our service:SERVICENow that MyService has the data assigned to it\'s data property, and the promise in the route resolve object has been resolved, our controller for the route kicks into life, and we can assign the data from the service to our controller object.CONTROLLERNow all our binding in the scope of the controller will be able to use the data which originated from MyService.So I found a solution. I created an angularJS service, we\'ll call it MyDataRepository and I  created a module for it. I then serve up this javascript file from my server-side controller:HTML:Server-side:I can then inject MyDataRepository where ever I need it:This worked great for me, but I am open to any feedback if anyone has any.\n}Also, you can use the following techniques to provision your service globally, before actual controllers are executed: https://stackoverflow.com/a/27050497/1056679. Just resolve your data globally and then pass it to your service in run block for example.You can use JSONP to asynchronously load service data.\nThe JSONP request will be made during the initial page load and the results will be available before your application starts. This way you won\'t have to bloat your routing with redundant resolves.You html would look like this:Easiest way to fetch any initialize use ng-init directory.Just put ng-init div scope where you want to fetch init dataindex.htmlindex.jsNOTE: you can use this methodology if you do not have same code more then one place.