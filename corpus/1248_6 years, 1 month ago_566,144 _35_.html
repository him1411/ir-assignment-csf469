Sometimes git suggests git rm --cached to unstage a file, sometimes git reset HEAD file. When should I use which?EDIT:git rm --cached <filePath> does not unstage a file, it actually stages the removal of the file(s) from the repo (assuming it was already committed before) but leaves the file in your working tree (leaving you with an untracked file).git reset -- <filePath> will unstage any staged changes for the given file(s).Edit: Thinking about it, though, if you used git rm --cached on a new file that is staged, it would basically look like you had just unstaged it since it had never been committed before. Maybe that\'s what you were seeing?git rm --cached is used to remove a file from the index. In the case where the file is already in the repo, git rm --cached will remove the file from the index, leaving it in the working directory and a commit will now remove it from the repo as well. Basically, after the commit, you would have unversioned the file and kept a local copy.git reset HEAD file ( which by default is using the --mixed flag) is different in that in the case where the file is already in the repo, it replaces the index version of the file with the one from repo (HEAD), effectively unstaging the modifications to it.In the case of unversioned file, it is going to unstage the entire file as the file was not there in the HEAD. In this aspect git reset HEAD file and git rm --cached are same, but they are not same ( as explained in the case of files already in the repo)To the question of Why are there 2 ways to unstage a file in git? - there is never really only one way to do anything in git. that is the beauty of it :)Quite simply: If the file wasn\'t in revision control before (i.e. you\'re unstaging a file that you had just git added for the first time), then the two commands have the same effect, hence the appearance of these being "two ways of doing something".* Keep in mind the caveat @DrewT mentions in his answer, regarding git rm --cached of a file that was previously committed to the repository. In the context of this question, of a file just added and not committed yet, there\'s nothing to worry about.** I was scared for an embarrassingly long time to use the git reset command because of its name -- and still today I often look up the syntax to make sure I don\'t screw up. (update: I finally took the time to summarize the usage of git reset in a tldr page, so now I have a better mental model of how it works, and a quick reference for when I forget some detail.)This thread is a bit old, but I still want to add a little demonstration since it is still not an intuitive problem:git reset HEAD (without -q) gives a warning about the modified file and its exit code is 1 which will be considered as an error in a script.Edit: git checkout HEAD to-be-modified to-be-removed also works for unstaging, but removes the change completely from the workspaceif you\'ve accidentally staged files that you would not like to commit, and want to be certain you keep the changes, you can also use:this performs a reset to HEAD and re-applies your changes, allowing you to re-stage individual files for commit. this is also helpful if you\'ve forgotten to create a feature branch for pull requests (git stash ; git checkout -b <feature> ; git stash pop).These 2 commands have several subtle differences if the file in question is already in the repo and under version control (previously committed etc.):And there\'s one more important difference:This last difference is important for projects which include a config file where each developer on the team has a different config (i.e. different base url, ip or port setting) so if you\'re using git rm --cached <file> anyone who pulls your branch will have to manually re-create the config, or you can send them yours and they can re-edit it back to their ip settings (etc.), because the delete only effects people pulling your branch from the remote.Let\'s say you stage a whole directory via git add <folder>, but you want to exclude a file from the staged list (i.e. the list that generates when running git status) and keep the modifications within the excluded file (you were working on something and it\'s not ready for commit, but you don\'t want to lose your work...). You could simply use: git reset <file>When you run git status, you will see that whatever file(s) you reset are unstaged and the rest of the files you added are still in the staged list.I\'m surprised noone mentioned the git reflog (http://git-scm.com/docs/git-reflog):The reflog is a git history that not only tracks the changes to the repo, but also tracks the user actions (Eg. pull, checkout to different branch, etc) and allows to undo those actions. So instead of unstaging the file that was mistakingly staged, where you can revert to the point where you didn\'t stage the files.This is similar to git reset HEAD <file> but in certain cases may be more granular. Sorry - not really answering your question, but just pointing yet another way to unstage files that I use quite often (I for one like answers by Ryan Stewart and waldyrious very much.) ;) I hope it helps.It would seem to me that git rm --cached <file> removes the file from the index without removing it from the directory where a plain git rm <file> would do both, just as an OS rm <file> would remove the file from the directory without removing its versioning.  (use "git rm --cached ..." to unstage)git is a system of pointersyou do not have a commit yet to change your pointer tothe only way to \'take files out of the bucket being pointed to\' is to remove files you told git to watch for changesgit commit -m a(use "git reset HEAD ..." to unstage)