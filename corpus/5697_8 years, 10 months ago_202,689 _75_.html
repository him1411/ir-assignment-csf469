I\'m working on a linux machine through SSH (Putty).\nI need to leave a process running during the night, so I thought I could do that by starting the process in background (with an ampersand at the end of the command) and redirecting stdout to a file.\nTo my surprise, that doesn\'t work. As soon as I close the Putty window, the process is stopped.How can I prevent that from happening??Check out the "nohup" program.I would recommend using GNU Screen.  It allows you to disconnect from the server while all of your processes continue to run.  I don\'t know how I lived without it before I knew it existed.  When the session is closed the process receives the SIGHUP signal which it is apparently not catching.  You can use the nohup command when launching the process or the bash built-in command disown -h after starting the process to prevent this from happening:Substitute your process name for blah!i know this thread is old, but ...daemonize? nohup? SCREEN? (tmux ftw, screen is junk ;-)just do what every other app has done since the beginning -- double fork.bang! done :-)  I\'ve used this countless times on all types of apps and many old machines. you can combine with redirects and whatnot to open a private channel between you and the process ...... save as coproc.sh ...... and there you go, spawn whatever.  the <(:) opens an anonymous pipe via process substitution, which dies, but the pipe sticks around because you have a handle to it. i usually do a sleep 1 instead of : because its slightly racy, and i\'d get a "file busy" error -- never happens if a real command is ran (eg, command true)... "heredoc sourcing":... works on every single shell i\'ve ever tried, including busybox/etc (initramfs).  i\'ve never seen it done before -- i independently discovered it while prodding, who knew source could accept args?? -- but it often serves as a much more manageable form of eval, if there is such a thing ...Personally, I like the \'batch\' command.This stuffs it in to the background, and then mails the results to you. It\'s a part of cron.As others have noted, to run a process in the background so that you can disconnect from your SSH session, you need to have the background process properly disassociate itself from its controlling terminal - which is the pseudo-tty that the SSH session uses.You can find information about daemonizing processes in books such as Stevens\' "Advanced Network Program, Vol 1, 3rd Edn" or Rochkind\'s "Advanced Unix Programming".I recently (in the last couple of years) had to deal with a recalcitrant program that did not daemonize itself properly.  I ended up dealing with that by creating a generic daemonizing program - similar to nohup but with more controls available.The double-dash is optional on systems not using the GNU getopt() function; it is necessary (or you have to specify POSIXLY_CORRECT in the environment) on Linux etc.  Since double-dash works everywhere, it is best to use it.Contact me (firstname dot lastname at gmail dot com) if you want the source for daemonize.Nohup allows a client process to not be killed if a the parent process is killed, for argument when you logout.  Even better still use:Nohup makes the process you start immune to termination which your SSH session and its child processes are kill upon you logging out.  The command i gave provides you with a  way you can store the pid of the application in a pid file so that you can correcly kill it later and allows the process to run after you have logged out.Use screen. It is very simple to use and works like vnc for terminals.\nhttp://www.bangmoney.org/presentations/screen.htmlIf you use screen to run a process as root, beware of the possibility of privilege elevation attacks. If your own account gets compromised somehow, there will be a direct way to take over the entire server.If this process needs to be run regularly and you have sufficient access on the server, a better option would be to use cron the run the job. You could also use init.d (the super daemon) to start your process in the background, and it can terminate as soon as it\'s done.On a Debian-based system (on the remote machine)\nInstall:sudo apt-get install tmuxUsage:tmuxrun commands you wantTo rename session:Ctrl+B then $set NameTo exit session:Ctrl+B then D(this leaves the tmux session). Then, you can log out of SSH.When you need to come back/check on it again, start up SSH, and entertmux attach session_nameIt will take you back to your tmux session.nohup is very good if you want to log your details to a file. But when it goes to background you are unable to give it a password if your scripts ask for. I think you must try screen. its a utility you can install on your linux distribution using yum for example on CentOS yum install screen then access your server via putty or another software, in your shell type screen. It will open screen[0] in putty. Do your work. You can create more screen[1], screen[2], etc in same putty session. Basic commands you need to know:To start screenTo create next screenTo move to next screen you createdTo detachDuring work close your putty. And next time when you login via putty typeTo reconnect to your screen, and you can see your process still running on screen. And to exit the screen type #exit.For more details see man screen.i would also go for screen program (i know that some1 else answer was screen but this is a completion)not only the fact that &, ctrl+z bg disown, nohup, etc. may give you a nasty surprise that when you logoff job will still be killed (i dunno why, but it did happened to me, and it didn\'t bother with it be cause i switched to use screen, but i guess anthonyrisinger solution as double forking would solve that), also screen have a major advantage over just back-grounding:and btw, this is a question i would never ask in the first place :) ... i use screen from my beginning of doing anything in any unix ... i (almost) NEVER work in a unix/linux shell without starting screen first ... and i should stop now, or i\'ll start an endless presentation of what good screen is and what can do for ya ... look it up by yourself, it is worth it ;)There\'s also the daemon command of the open-source libslack package.daemon is quite configurable and does care about all the tedious daemon stuff such as automatic restart, logging or pidfile handling.Append this string to your command: >&- 2>&- <&- &. >&- means close stdout. 2>&- means close stderr. <&- means close stdin. & means run in the background. This works to programmatically start a job via ssh, too:For most processes you can pseudo-daemonize using this old Linux command-line trick:For example:Then start a new terminal window and:Will show that sleep 30 is still running.What you have done is started the process as a child of a child, and when you exit, the nohup command that would normally trigger the process to exit doesn\'t cascade down to the grand-child, leaving it as an orphan process, still running.I prefer this "set it and forget it" approach, no need to deal with nohup, screen, tmux, I/o redirection, or any of that stuff.If you\'re willing to run X applications as well - use xpra together with "screen".I used screen command. This link has detail as to how to do thishttps://www.rackaid.com/blog/linux-screen-tutorial-and-how-to/#startingAccepted answer suggest using nohup. I would rather suggest using pm2. Using pm2 over nohup has many advantages, like keeping the application alive, maintain log files for application and lot more other features. For more detail check this out. To install pm2 you need to download npm. For Debian based systemand for Redhat  Or you can follow these instruction.\nAfter installing npm use it to install pm2 Once its done you can start your application by  For process monitoring use following commands:  Manage processes using either app name or process id or manage all processes together:  Log files can be found in  Binary executable files can also be run using pm2. You have to made a change into the jason file. Change the "exec_interpreter" : "node", to "exec_interpreter" : "none". (see the attributes section). Compiling above code  and run it with np2 in the background  