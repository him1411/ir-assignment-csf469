From Apple\'s documentation:You can use if and let together to work with values that might be missing. These values are represented as optionals. An optional value either contains a value or contains nil to indicate that the value is missing. Write a question mark (?) after the type of a value to mark the value as optional.Why would you want to use an optional value?An optional in Swift is a type that can hold either a value or no value. Optionals are written by appending a ? to any type:Optionals (along with Generics) are one of the most difficult Swift concepts to understand. Because of how they are written and used, it\'s easy to get a wrong idea of what they are. Compare the optional above to creating a normal String:From the syntax it looks like an optional String is very similar to an ordinary String. It\'s not. An optional String is not a String with some "optional" setting turned on. It\'s not a special variety of String. A String and an optional String are completely different types.Here\'s the most important thing to know: An optional is a kind of container. An optional String is a container which might contain a String. An optional Int is a container which might contain an Int. Think of an optional as a kind of parcel. Before you open it (or "unwrap" in the language of optionals) you won\'t know if it contains something or nothing.You can see how optionals are implemented in the Swift Standard Library by typing "Optional" into any Swift file and \xe2\x8c\x98-clicking on it. Here\'s the important part of the definition:Optional is just an enum which can be one of two cases: .none or .some. If it\'s .some, there\'s an associated value which, in the example above, would be the String "Hello". An optional uses Generics to give a type to the associated value. The type of an optional String isn\'t String, it\'s Optional, or more precisely Optional<String>.Everything Swift does with optionals is magic to make reading and writing code more fluent. Unfortunately this obscures the way it actually works. I\'ll go through some of the tricks later.Note: I\'ll be talking about optional variables a lot, but it\'s fine to create optional constants too. I mark all variables with their type to make it easier to understand type types being created, but you don\'t have to in your own code.To create an optional, append a ? after the type you wish to wrap. Any type can be optional, even your own custom types. You can\'t have a space between the type and the ?.You can compare an optional to nil to see if it has a value:This is a little confusing. It implies that an optional is either one thing or another. It\'s either nil or it\'s "Bob". This is not true, the optional doesn\'t transform into something else. Comparing it to nil is a trick to make easier-to-read code. If an optional equals nil, this just means that the enum is currently set to .none.If you try to set a non-optional variable to nil, you\'ll get an error.Another way of looking at optionals is as a complement to normal Swift variables. They are a counterpart to a variable which is guaranteed to have a value. Swift is a careful language that hates ambiguity. Most variables are define as non-optionals, but sometimes this isn\'t possible. For example, imagine a view controller which loads an image either from a cache or from the network. It may or may not have that image at the time the view controller is created. There\'s no way to guarantee the value for the image variable. In this case you would have to make it optional. It starts as nil and when the image is retrieved, the optional gets a value.Using an optional reveals the programmers intent. Compared to Objective-C, where any object could be nil, Swift needs you to be clear about when a value can be missing and when it\'s guaranteed to exist.An optional String cannot be used in place of an actual String. To use the wrapped value inside an optional, you have to unwrap it. The simplest way to unwrap an optional is to add a ! after the optional name. This is called "force unwrapping". It returns the value inside the optional (as the original type) but if the optional is nil, it causes a runtime crash. Before unwrapping you should be sure there\'s a value.Because you should always check for nil before unwrapping and using an optional, this is a common pattern:In this pattern you check that a value is present, then when you are sure it is, you force unwrap it into a temporary constant to use. Because this is such a common thing to do, Swift offers a shortcut using "if let". This is called "optional binding".This creates a temporary constant (or variable if you replace let with var) whose scope is only within the if\'s braces. Because having to use a name like "unwrappedMealPreference" or "realMealPreference" is a burden, Swift allows you to reuse the original variable name, creating a temporary one within the bracket scopeHere\'s some code to demonstrate that a different variable is used:Optional binding works by checking to see if the optional equals nil. If it doesn\'t, it unwraps the optional into the provided constant and executes the block. In Xcode 8.3 and later (Swift 3.1), trying to print an optional like this will cause a useless warning. Use the optional\'s debugDescription to silence it:Optionals have two use cases:Some concrete examples:Optionals don\'t exist in Objective-C but there is an equivalent concept, returning nil. Methods that can return an object can return nil instead. This is taken to mean "the absence of a valid object" and is often used to say that something went wrong. It only works with Objective-C objects, not with primitives or basic C-types (enums, structs). Objective-C often had specialized types to represent the absence of these values (NSNotFound which is really NSIntegerMax, kCLLocationCoordinate2DInvalid to represent an invalid coordinate, -1 or some negative value are also used). The coder has to know about these special values so they must be documented and learned for each case. If a method can\'t take nil as a parameter, this has to be documented. In Objective-C, nil was a pointer just as all objects were defined as pointers, but nil pointed to a specific (zero) address. In Swift, nil is a literal which means the absence of a certain type.You used to be able to use any optional as a Boolean:In more recent versions of Swift you have to use leatherTrim != nil. Why is this? The problem is that a Boolean can be wrapped in an optional. If you have Boolean like this:it has two kinds of "false", one where there is no value and one where it has a value but the value is false. Swift hates ambiguity so now you must always check an optional against nil.You might wonder what the point of an optional Boolean is? As with other optionals the .none state could indicate that the value is as-yet unknown. There might be something on the other end of a network call which takes some time to poll. Optional Booleans are also called "Three-Value Booleans"Swift uses some tricks to allow optionals to work. Consider these three lines of ordinary looking optional code;None of these lines should compile.I\'ll go through some of the implementation details of optionals that allow these lines to work.Using ? to create an optional is syntactic sugar, enabled by the Swift compiler. If you want to do it the long way, you can create an optional like this:This calls Optional\'s first initializer, public init(_ some: Wrapped), which infers the optional\'s associated type from the type used within the parentheses.The even longer way of creating and setting an optional:You can create an optional with no initial value, or create one with the initial value of nil (both have the same outcome).Allowing optionals to equal nil is enabled by the protocol ExpressibleByNilLiteral (previously named NilLiteralConvertible). The optional is created with Optional\'s second initializer, public init(nilLiteral: ()). The docs say that you shouldn\'t use ExpressibleByNilLiteral for anything except optionals, since that would change the meaning of nil in your code, but it\'s possible to do it:The same protocol allows you to set an already-created optional to nil. Although it\'s not recommended, you can use the nil literal initializer directly:Optionals define two special "==" and "!=" operators, which you can see in the Optional definition. The first == allows you to check if any optional is equal to nil. Two different optionals which are set to .none will always be equal if the associated types are the same. When you compare to nil, behind the scenes Swift creates an optional of the same associated type, set to .none then uses that for the comparison.The second == operator allows you to compare two optionals. Both have to be the same type and that type needs to conform to Equatable (the protocol which allows comparing things with the regular "==" operator). Swift (presumably) unwraps the two values and compares them directly. It also handles the case where one or both of the optionals are .none. Note the distinction between comparing to the nil literal.Furthermore, it allows you to compare any Equatable type to an optional wrapping that type:Behind the scenes, Swift wraps the non-optional as an optional before the comparison. It works with literals too (if 23 == numberFromString {)I said there are two == operators, but there\'s actually a third which allow you to put nil on the left-hand side of the comparisonThere is no Swift convention for naming optional types differently from non-optional types. People avoid adding something to the name to show that it\'s an optional (like "optionalMiddleName", or "possibleNumberAsString") and let the declaration show that it\'s an optional type. This gets difficult when you want to name something to hold the value from an optional. The name "middleName" implies that it\'s a String type, so when you extract the String value from it, you can often end up with names like "actualMiddleName" or "unwrappedMiddleName" or "realMiddleName". Use optional binding and reuse the variable name to get around this.From "The Basics" in the Swift Programming Language:Swift also introduces optional types, which handle the absence of a value. Optionals say either \xe2\x80\x9cthere is a value, and it equals x\xe2\x80\x9d or \xe2\x80\x9cthere isn\xe2\x80\x99t a value at all\xe2\x80\x9d. Optionals are similar to using nil with pointers in Objective-C, but they work for any type, not just classes. Optionals are safer and more expressive than nil pointers in Objective-C and are at the heart of many of Swift\xe2\x80\x99s most powerful features.Optionals are an example of the fact that Swift is a type safe language. Swift helps you to be clear about the types of values your code can work with. If part of your code expects a String, type safety prevents you from passing it an Int by mistake. This enables you to catch and fix errors as early as possible in the development process.To finish, here\'s a poem from 1899 about optionals:Yesterday upon the stair\nI met a man who wasn\xe2\x80\x99t there\nHe wasn\xe2\x80\x99t there again today\nI wish, I wish he\xe2\x80\x99d go away\nAntigonishLet\'s take the example of an NSError, if there isn\'t an error being returned you\'d want to make it optional to return Nil. There\'s no point in assigning a value to it if there isn\'t an error..This also allows you to have a default value. So you can set a method a default value if the function isn\'t passed anythingYou can\'t have a variable that points to nil in Swift \xe2\x80\x94 there are no pointers, and no null pointers. But in an API, you often want to be able to indicate either a specific kind of value, or a lack of value \xe2\x80\x94 e.g. does my window have a delegate, and if so, who is it? Optionals are Swift\'s type-safe, memory-safe way to do this.I made a short answer, that sums up most of the above, to clean the uncertainty that was in my head as a beginner:Opposed to Objective-C, no variable can contain nil in Swift, so the Optional variable type was added (variables suffixed by "?"):The big difference is that the Optional variables don\'t directly store values (as a normal Obj-C variables would) they contain two states: "has a value" or "has nil":That being, you can check those variables in different situations:By using the "!" suffix, you can also access the values wrapped in them, only if those exist. (i.e it is not nil):That\'s why you need to use "?" and "!" and not use all of them by default. (this was my biggest bewilderment)I also agree with the answer above: Optional type cannot be used as a boolean.In objective C variables with no value were equal to \'nil\'(it was also possible to use \'nil\' values same as 0 and false), hence it was possible to use variables in conditional statements (Variables having values are same as \'TRUE\' and those with no values were equal to \'FALSE\').Swift provides type safety by providing \'optional value\'. i.e. It prevents errors formed from assigning variables of different types.So in Swift, only booleans can be provided on conditional statements.Here, even-though \'hw\' is a string, it can\'t be used in an if statement like in objective C.For that it needs to be created as,Optional value allows you to show absence of value. Little bit like NULL in SQL or NSNull in Objective-C. I guess this will be an improvement as you can use this even for "primitive" types.Excerpt From: Apple Inc. \xe2\x80\x9cThe Swift Programming Language.\xe2\x80\x9d iBooks. https://itun.es/gb/jEUH0.lAn optional means that Swift is not entirely sure if the value corresponds to the type: for example, Int? means that Swift is not entirely sure whether the number is an Int.To remove it, there are three methods you could employ.1) If you are absolutely sure of the type, you can use an exclamation mark to force unwrap it, like this:If you do force unwrap an optional and it is equal to nil, you may encounter this crash error:This is not necessarily safe, so here\'s a method that might prevent crashing in case you are not certain of the type and value:Methods 2 and three safeguard against this problem.2) The Implicitly Unwrapped OptionalNote that the unwrapped type is now Int, rather than Int?.3) The guard statementFrom here, you can go ahead and use the unwrapped variable. Make sure only to force unwrap (with an !), if you are sure of the type of the variable.Good luck with your project!Optional chaining is a process for querying and calling properties, methods, and subscripts on an optional that might currently be nil. If the optional contains a value, the property, method, or subscript call succeeds; if the optional is nil, the property, method, or subscript call returns nil. Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is nil.refer below resource to understand deeply..\nhttps://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.htmlLets Experiment with below code  Playground.I Hope will clear idea what is optional and reason of using it.When i started to learn Swift it was very difficult to realize why optional.Lets think in this way.\nLet consider a class Person which has two property name and company.Now lets create few objects of PersonBut we can not pass Nil to nameNow Lets talk about why we use optional?.\nLets consider a situation where we want to add Inc after company name like apple will be apple Inc. We need to append Inc after company name and print.Now lets study why optional takes into place.Lets replace bob with tomAnd Congratulation! we have properly deal with optional?So the realization points areThank you...Happy CodingWell...? (Optional) indicates your variable may contain a nil value while ! (unwrapper) indicates your variable must have a memory (or value) when it is used (tried to get a value from it) at runtime.The main difference is that optional chaining fails gracefully when the optional is nil, whereas forced unwrapping triggers a runtime error when the optional is nil.To reflect the fact that optional chaining can be called on a nil value, the result of an optional chaining call is always an optional value, even if the property, method, or subscript you are querying returns a nonoptional value. You can use this optional return value to check whether the optional chaining call was successful (the returned optional contains a value), or did not succeed due to a nil value in the chain (the returned optional value is nil).Specifically, the result of an optional chaining call is of the same type as the expected return value, but wrapped in an optional. A property that normally returns an Int will return an Int? when accessed through optional chaining.Here is basic tutorial in detail, by Apple Developer Committee.Here is an equivalent optional declaration in Swift:This declaration creates a variable named middleName of type String. The question mark (?) after the String variable type indicates that the middleName variable can contain a value that can either be a String or nil. Anyone looking at this code immediately knows that middleName can be nil. It\'s self-documenting!If you don\'t specify an initial value for an optional constant or variable (as shown above) the value is automatically set to nil for you. If you prefer, you can explicitly set the initial value to nil:for more detail for optional read below linkhttp://www.iphonelife.com/blog/31369/swift-101-working-swifts-new-optional-values