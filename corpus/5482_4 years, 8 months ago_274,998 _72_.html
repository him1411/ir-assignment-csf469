I have a controller responsible for communicating with an API to update properties of a user, name, email, etc. Each user has an \'id\' which is passed from the server when the profile page is viewed. I would like to pass this value to the AngularJS controller so it knows what the API entry point is for the current user. I\'ve tried passing the value in ng-controller. For example:and in the HTMLwhere {% id %} print the id sent from the server. but I get errors. What is the correct way to pass a value into a controller on its creation?Notes:This answer is old. This is just a proof of concept on how the desired outcome can be achieved. However, it may not be the best solution as per some comments below. I don\'t have any documentation to support or reject the following approach. Please refer to some of the comments below for further discussion on this topic.Original Answer:I answered this to \nYes you absolutely can do so using ng-init and a simple init function.Here is the example of it on plunkerHTML JavaScriptI\'m very late to this and I have no idea if this is a good idea, but you can include the $attrs injectable in the controller function allowing the controller to be initialized using "arguments" provided on an element, e.g.Again, no idea if this is a good idea, but it seems to work and is another alternative.This also works.Javascript:Html:Like @akonsu and Nigel Findlater suggest, you can read the url where url is index.html#/user/:id with $routeParams.id and use it inside the controller. your app: the resource servicethe controller then, elm is accessible in the view depending on the id. The view should not dictate configIn Angular, the template should never dictate configuration, which is inherently what people desire when they want to pass arguments to controllers from a template file. This becomes a slippery slope. If config settings are hard-coded in templates (such as by a directive or controller argument attribute), you can no longer re-use that template for anything but that single use. Soon you\'ll want to re-use that template, but with different config and now in order to do so you\'ll either be pre-processing the templates to inject variables before it gets passed to angular or using massive directives to spit out giant blocks of HTML so you re-use all of the controller HTML except for the wrapper div and it\'s arguments. For small projects it\'s no big deal. For something big (what angular excels at), it gets ugly quick.The Alternative: ModulesThis type of configuration is what modules were designed to handle. In many angular tutorials people have a single module for their entire application, but really the system is designed and fully supports many small modules each which wrap small pieces of the total application. Ideally, controllers, modules etc would be declared in separate files and stitched together in specific re-usable chunks. When your application is designed this way, you get a lot of re-use in addition to easy controller arguments.The example below has 2 modules, re-using the same controller, but each with their own config settings. That config settings are passed in via dependency injection using module.value. This adheres to the angular way because we have the following: constructor dependency injection, reusable controller code, reusable controller templates (the controller div could easily be included with ng-include), easily unit-testable system without HTML, and lastly re-usable modules as the vehicle for stitching the pieces together.Here\'s an example:See it in action: jsFiddle.If ng-init is not for passing objects into $scope, you can always write your own directive. So here is what I got:http://jsfiddle.net/goliney/89bLj/Javasript:Html:But my approach can only modify objects, which are already defined at controller.It looks like the best solution for you is actually a directive.  This allows you to still have your controller, but define custom properties for it.Use this if you need access to variables in the wrapping scope:Use this if you don\'t need access to variables in the wrapping scope:I found passing variables from $routeProvider usefull.For example, you use one controller MyController for multiple screens, passing some very important variable "mySuperConstant" inside.Use that simple structure:You can do it when setting up the routes for e.g.And later use it as So here when we set up the route we sent :itemType and retrive it later from $routeParams.There is another way to pass parameters to a controller by injecting $routeParams into your controller and then using url parameters described here What's the most concise way to read query parameters in AngularJS?If using angular-ui-router, then this is the correct solution: https://github.com/angular-ui/ui-router/wiki#resolveBasically, you declare a set of dependecies to "resolve" before the controller is instantiated. You may declare dependencies for each of your "states". These dependencies are then passed in the controller\'s "constructor".This question is old but I struggled for a long time trying to get an answer to this problem that would work for my needs and did not easily find it.  I believe my following solution is much better than the currently accepted one, perhaps because angular has added functionality since this question was originally posed.  Short answer, using the Module.value method allows you to pass data into a controller constructor.See my plunker hereI create a model object, then associate it with the module\'s controller, referencing it with the name \'model\'HTML / JSThe constructor in my controller then accepts a parameter with that same identifier \'model\' which it can then access.  ControllerNotes: I\'m using manual initialization of bootstrapping, which allows me to initialize my model before sending it over to angular.  This plays much more nicely with existing code, as you can wait to set up your relevant data and only compile the angular subset of your app on demand when you want to.In the plunker I\'ve added a button to alert the values of the model object that was initially defined in javascript and passed to angular, just to confirm that angular is truly referencing the model object, rather than copying it and working with a copy.  On this line:I\'m passing the MyController object into the Module.controller function, rather than declaring as a function inline.  I think this allows us to far more clearly define our controller object, but Angular documentation tends to do it inline so I thought it bears clarification.I\'m using the "controller as" syntax and assigning values to the "this" property of MyController, rather than using the "$scope" variable.  I believe this would work fine using $scope just as well, the controller assignment would then look something like this:and the controller constructor would have a signature like this:If for whatever reason you wanted to, you could also attach this model as a value of a second module, which you then attach as a dependency to your primary module.I believe his solution is much better than the currently accepted one becauseThe way Angular seems to work in most all other examples I\'ve seen has the controller defining the data of the model, which never made sense to me, there is no separation between the model and the controller, that doesn\'t really seem like MVC to me.  This solution allows you to really have a completely separate model object which you pass into the controller.  Also of note, if you use the ng-include directive you can put all your angular html in a separate file, fully separating your model view and controller into separate modular pieces.One way of doing that would be having a separate service that can be used as a \'vessel\' for those arguments where they\'re public data members.No, It is not possible. I think you can use ng-init as hack http://docs.angularjs.org/api/ng.directive:ngInit.Here is a solution (based on Marcin Wyszynski\'s suggestion) which works where you want to pass a value into your controller but you aren\'t explicitly declaring the controller in your html (which ng-init seems to require) - if, for example, you are rendering your templates with ng-view and declaring each controller for the corresponding route via routeProvider.JShtmlIn this solution, CurrentUser is a service which can be injected into any controller, with the .name property then available. Two notes:a problem I\'ve encountered is that .name gets set after the controller loads, so as a workaround I have a short timeout before rendering username on the controller\'s scope. Is there a neat way of waiting until .name has been set on the service?this feels like a very easy way to get a current user into your Angular App with all the authentication kept outside Angular. You could have a before_filter to prevent non-logged in users getting to the html where your Angular app is bootstrapped in, and within that html you could just interpolate the logged in user\'s name and even their ID if you wanted to interact with the user\'s details via http requests from your Angular app. You could allow non-logged in users to use the Angular App with a default \'guest user\'. Any advice on why this approach would be bad would be welcome - it feels too easy to be sensible!)