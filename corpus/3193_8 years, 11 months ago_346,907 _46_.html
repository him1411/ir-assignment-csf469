What is the best way to initialize a private, static data member in C++?  I tried this but it gives me weird linker errors:I\'m guessing this is because I can\'t initialize a private member from outside the class.  So what\'s the best way to do this?The class declaration should be in the header file (Or in the source file if not shared).\nFile: foo.hBut the initialization should be in source file.\nFile: foo.cppIf the initialization is in the header file then each file that includes the header file will have a definition of the static member. Thus during the link phase you will get linker errors as the code to initialize the variable will be defined in multiple source files.Note: Matt Curtis: points out that C++ allows the simplification of the above if the static member variable is of const int type (e.g. int, bool, char). You can then declare and initialize the member variable directly inside the class declaration in the header file:For a variable:foo.h:foo.cpp:This is because there can only be one instance of foo::i in your program. It\'s sort of the equivalent of extern int i in a header file and int i in a source file.For a constant you can put the value straight in the class declaration:For future viewers of this question, I want to point out that you should avoid what monkey0506 is suggesting.Header files are for declarations.Header files get compiled once for every .cpp file that directly or indirectly #includes them, and code outside of any function is run at program initialization, before main().By putting: foo::i = VALUE; into the header, foo:i will be assigned the value VALUE (whatever that is) for every .cpp file, and these assignments will happen in an indeterminate order (determined by the linker) before main() is run.What if we #define VALUE to be a different number in one of our .cpp files? It will compile fine and we will have no way of knowing which one wins until we run the program.Never put executed code into a header for the same reason that you never #include a .cpp file.include guards (which I agree you should always use) protect you from something different: the same header being indirectly #included multiple times while compiling a single .cpp fileWith a Microsoft compiler[1], static variables that are not int-like can also be defined in a header file, but outside of the class declaration, using the Microsoft specific __declspec(selectany).Note that I\'m not saying this is good, I just say it can be done.[1] These days, more compilers than MSC support __declspec(selectany) - at least gcc and clang. Maybe even more.Is the correct syntax for initializing the variable, but it must go in the source file (.cpp) rather than in the header. Because it is a static variable the compiler needs to create only one copy of it. You have to have a line "int foo:i" some where in your code to tell the compiler where to put it otherwise you get a link error. If that is in a header you will get a copy in every file that includes the header, so get multiply defined symbol errors from the linker. I don\'t have enough rep here to add this as a comment, but IMO it\'s good style to write your headers with #include guards anyway, which as noted by Paranaix a few hours ago would prevent a multiple-definition error. Unless you\'re already using a separate CPP file, it\'s not necessary to use one just to initialize static non-integral members.I see no need to use a separate CPP file for this. Sure, you can, but there\'s no technical reason why you should have to.If you want to initialize some compound type (f.e. string) you can do something like that:As the ListInitializationGuard is a static variable inside SomeClass::getList() method it will be constructed only once, which means that constructor is called once. This will initialize _list variable to value you need. Any subsequent call to getList will simply return already initialized _list object.Of course you have to access _list object always by calling getList() method.You can also include the assignment in the header file if you use header guards. I have used this technique for a C++ library I have created. Another way to achieve the same result is to use static methods. For example...The above code has the "bonus" of not requiring a CPP/source file. Again, a method I use for my C++ libraries.I follow the idea from Karl. I like it and now I use it as well. \nI\'ve changed a little bit the notation and add some functionalitythis outputs Also working in privateStatic.cpp file :What about a set_default() method?We would only have to use the set_default(int x) method and our static variable would be initialized.This would not be in disagreement with the rest of the comments, actually it follows the same principle of initializing the variable in a global scope, but by using this method we make it explicit (and easy to see-understand) instead of having the definition of the variable hanging there.Since C++17, static members may be defined in the header with the inline keyword.http://en.cppreference.com/w/cpp/language/static"A static data member may be declared inline. An inline static data member can be defined in the class definition and may specify a default member initializer. It does not need an out-of-class definition:"Does this serves your purpose?I just wanted to mention something a little strange to me when I first encountered this.I needed to initialize a private static data member in a template class.in the .h or .hpp, it looks something like this to initialize a static data member of a template class:The linker problem you encountered is probably caused by:This is a common problem for those who starts with C++. Static class member must be initialized in single translation unit i.e. in single source file.Unfortunately, the static class member must be initialized outside of the class body. This complicates writing header-only code, and, therefore, I am using quite different approach. You can provide your static object through static or non-static class function for example: