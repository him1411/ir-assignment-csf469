I need to generate a unique temporary file with a .csv extension.What I do right now is However, this doesn\'t guarantee that my .csv file will be unique.I know the chances I ever got a collision are very low (especially if you consider that I don\'t delete the .tmp files), but this code doesn\'t looks good to me.Of course I could manually generate random file names until I eventually find a unique one (which shouldn\'t be a problem), but I\'m curious to know if others have found a nice way to deal with this problem.Guaranteed to be (statistically) unique:(To quote from the wiki article on the probabilty of a collision:...one\'s annual risk of being hit by a\n  meteorite is estimated to be one\n  chance in 17 billion [19], that means\n  the probability is about 0.00000000006\n  (6 \xc3\x97 10\xe2\x88\x9211), equivalent to the odds of\n  creating a few tens of trillions of\n  UUIDs in a year and having one\n  duplicate. In other words, only after\n  generating 1 billion UUIDs every\n  second for the next 100 years, the\n  probability of creating just one\n  duplicate would be about 50%. The\n  probability of one duplicate would be\n  about 50% if every person on earth\n  owns 600 million UUIDsEDIT: Please also see JaredPar\'s comments.Try this function ...It will return a full path with the extension of your choice. Note, it\'s not guaranteed to produce a unique file name since someone else could have technically already created that file.  However the chances of someone guessing the next guid produced by your app and creating it is very very low.  It\'s pretty safe to assume this will be unique.  Note: this works like Path.GetTempFileName. An empty file is created to reserve the file name. It makes 10 attempts, in case of collisions generated by Path.GetRandomFileName();You can also alternatively use System.CodeDom.Compiler.TempFileCollection.Here I used a txt extension but you can specify whatever you want. I also set the keep flag to true so that the temp file is kept around after use. Unfortunately, TempFileCollection creates one random file per extension. If you need more temp files, you can create multiple instances of TempFileCollection.The MSDN documentation for C++\'s GetTempFileName discusses your concern and answers it:GetTempFileName is not able to guarantee that the file name is unique.Only the lower 16 bits of the uUnique parameter are used. This limits GetTempFileName to a maximum of 65,535 unique file names if the lpPathName and lpPrefixString parameters remain the same.Due to the algorithm used to generate file names, GetTempFileName can perform poorly when creating a large number of files with the same prefix. In such cases, it is recommended that you construct unique file names based on GUIDs.Why not checking if the file exists?How about:It is highly improbable that the computer will generate the same Guid at the same instant of time. The only weakness i see here is the performance impact DateTime.Now.Ticks will add.You can also do the followingand this also works as expectedThis could be handy for you... It\'s to create a temp. folder and return it as a string in VB.NET.Easily convertible to C#:This seems to work fine for me: it checks for file existance and creates the file to be sure it\'s a writable location.\nShould work fine, you can change it to return directly the FileStream (which is normally what you need for a temp file):In my opinion, most answers proposed here as sub-optimal. The one coming closest is the original one proposed initially by Brann.A Temp Filename must beBecause of these requirements, it is not a godd idea to program such a beast on your own. Smart People writing IO Libraries worry about things like locking (if needed) etc.\nTherefore, I see no need to rewrite System.IO.Path.GetTempFileName().This, even if it looks clumsy, should do the job:This is what I am doing:I think you should try  this:It generates a unique filename and creates a file with that file name at a specified location.