In Git I can do this:I want to know how to do the same thing in Mercurial, and I\'ve scoured the web for an answer, but the best I could find was: git rebase - can hg do thatThat link provides 2 examples:\n1. I\'ll admit that this: (replacing the revisions from the example with those from my own example)is not too bad, except that it leaves behind the pre-rebase M-N-O as an unmerged head and creates 3 new commits M\',N\',O\' that represent them branching off the updated mainline.Basically the problem is that I end up with this:this is not good because it leaves behind local, unwanted commits that should be dropped.and this does result in the desired graph:but these commands (all 6 of them!) seem so much more complicated than I want to know if this is the only equivalent in Hg or if there is some other way available that is simple like Git.VonC has the answer you\'re looking for, the Rebase Extension.  It is, however, worth spending a second or two thinking about why neither mq nor rebase are enabled by default in mercurial: because mercurial is all about indelible changesets.  When I work in the manner you\'re describing, which is nearly daily, here\'s the pattern I take:and that\'s really all that\'s necessary.  I end up with a newfeature-123 clone I can easily push back to the mainline when I\'m happy with it.  Most importantly, however, I never changed history.  Someone can look at my csets and see what they were originally coded against and how I reacted to changes in the mainline throughout my work.  Not everyone thinks that has value, but I\'m a firm believer that it\'s the job of source control to show us not what we wished had happened, but what actually happened -- every deadend and every refactor should leave an indelible trace, and rebasing and other history editing techniques hide that.Now go pick VonC\'s answer while I put my soapbox away. :)You might be looking for Rebase Extension. (implemented as part of the SummerOfCode 2008)In those cases it can be useful to "detach" the local changes, synchronize the repository with the mainstream and then append the private changes on top of the new remote changes. This operation is called rebase.Getting from:to:Assuming you have a modern Hg installation, you can simply add:to ~/.hgrc.Then you can use the commands hg rebase, hg pull --rebase, or hg help rebase.I don\'t think the answers above achieve the OP\'s goal, which was to maintain his task branch, just rebased against a later point on the parent branch.Let\'s say I start with this graph (generated using the graphlog extension.  Serious geek love for graphlog).If I\'m on the feature3 branch and want to rebase it off of the againagainagain commit, I understand that I would run hg rebase -d default.  This has the following result:Mission accomplished?  I don\'t think so.  The problem is that when the commits on the feature3 branch were rebased on againagainagain, the feature3 branch was deleted.  My commits have been moved to the default branch, which was what I was trying to avoid in the first place.In Git, the result would look like this:Notice that the feature3 branch still exists, the two commits are still on the feature3 branch, and not visible on default. Without preserving the task branch, I don\'t see how this is functionally different from a merge.UPDATE:  I discovered the --keepbranches flag supported by hg rebase, and I\'m happy to report everything is okey-dokey. Using hg rebase -d default --keepbranches, I exactly replicate the Git behavior I craved.  A couple of aliases later and I\'m rebasing like nobody\'s business.Since some people have chimed in saying they think it\'s good to keep every iteration of everything, I\'ll point out that for larger open-source projects, accepting changes full of merges and development iteration would make for a messy mainline revision history, and make the revision history less useful for seeing how the current version got there.This works well when submitted changes are reviewed by people that didn\'t write them, before they\'re accepted, so changes that do go into the mainline are generally debugged and working.  Then when you backtrack to the origin of a line, you see all the changes that go with it, not some point in the middle of development of the change it\'s part of.The x265 contributors page explains how to re-commit a set of changes you\'re working on, to get them ready for submission to the x265 project.  (Including use of TortoiseHG to commit some but not all changes in an individual file, like git gui\'s stage/unstage diff hunk for commit).The process is to get hg updated to the upstream tip, and then get all your changes uncommitted in the working directory.  Shelve any that aren\'t part of what you want to submit, then break the rest into as many separate commits are appropriate, with nice commit messages.I guess you\'d copy/paste and then edit commit messages from previous iterations of a patchset that you\'re revising.  Or maybe you could graft your old commits (cherry-pick in git language), and then amend them one by one, to get your old commit messages as a start point for editting.