What is the best way of searching the whole classpath for an annotated class?I\'m doing a library and I want to allow the users to annotate their classes, so when the Web application starts I need to scan the whole classpath for certain annotation.Do you know a library or a Java facility to do this?Edit: I\'m thinking about something like the new functionality for Java EE 5 Web Services or EJB\'s. You annotate your class with @WebService or @EJB and the system finds these classes while loading so they are accessible remotely.Use org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider APIA component provider that scans the classpath from a base package. It then applies exclude and include filters to the resulting classes to find candidates. And another solution is Google reflections.Quick review: I just released an uber-fast and lightweight classpath scanner (git repo here) that does not call the classloader to load classes on the classpath in order to determine subclasses, superclasses, annotations etc., but rather reads the classfile binary headers directly (inspired by, but simpler than, rmueller\'s classpath scanner, linked in another comment).My classpath scanner can find classes on the classpath that extend a given superclass, that implement a given interface, or that have a given class annotation, and can find files within the classpath of any type whose path matches a given regular expression.Here is an example of usage:The scanner also records the latest last-modified timestamp of any file or directory encountered, and you can see if that latest last-modified timestamp has increased (indicating that something on the classpath has been updated) by calling:This can be used to enable dynamic class-reloading if something on the classpath is updated, for example to support hot-replace of route handler classes in a webserver. The above call is several times faster than the original call to scan(), since only modification timestamps need to be checked.If you want a really light weight (no dependencies, simple API, 15 kb jar file) and very fast solution, take a look at annotation-detector found at https://github.com/rmuller/infomas-asl Disclaimer: I am the author.You can use Java Pluggable Annotation Processing API to write annotation processor which will be executed during the compilation process and will collect all annotated classes and build the index file for runtime use.This is the fastest way possible to do annotated class discovery because you don\'t need to scan your classpath at runtime, which is usually very slow operation. Also this approach works with any classloader and not only with URLClassLoaders usually supported by runtime scanners.The above mechanism is already implemented in ClassIndex library.To use it annotate your custom annotation with @IndexAnnotated meta-annotation. This will create at compile time an index file: META-INF/annotations/com/test/YourCustomAnnotation listing all annotated classes. You can acccess the index at runtime by executing:Use the ServiceLoader, or implement your own if you are not in Java 6.Perhaps an annotation processor could produce the necessary files under META-INF/services at compile-time.Try Scannotation.It can be used to search the classpath or your web application lib directory for specific annotations.You might want to use http://code.google.com/p/annovention/ Slightly offtopic, but Spring also does something similar, using <context:component-scan>, which you could perhaps study the source code of?Spring provides the capability of automatically detecting \'stereotyped\' classes [...]. To autodetect these classes and register the corresponding beans requires the inclusion of the  [context:component-scan element].I\'m not sure if it will help you or not, but you could look into the apache commons-discovery project.discovery projectWith Spring you can also just write the following using AnnotationUtils class. i.e.:For more details and all different methods check official docs: \nhttps://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/annotation/AnnotationUtils.htmlJava does not have "Discovery".  The only way I know of is to scan the directory that the .class files should be in, parse the names and use that.  Horribly ugly, maybe there is a better package these days--I haven\'t looked in a few years.Usually this problem used to be addressed by including a properties file or a .xml file with the classnames in it.I\'d be interested in hearing a better answer as well.The Classloader API doesn\'t have an "enumerate" method, because class loading is an "on-demand" activity -- you usually have thousands of classes in your classpath, only a fraction of which will ever be needed (the rt.jar alone is 48MB nowadays!).So, even if you could enumerate all classes, this would be very time- and memory-consuming. The simple approach is to list the concerned classes in a setup file (xml or whatever suits your fancy); if you want to do this automatically, restrict yourself to one JAR or one class directory. Google Reflections seems to be much faster than Spring. Found this feature request that adresses this difference: http://www.opensaga.org/jira/browse/OS-738This is a reason to use Reflections as startup time of my application is really important during development. Reflections seems also to be very easy to use for my use case (find all implementers of an interface).If you want a Scala library, use Sclasner:\nhttps://github.com/ngocdaothanh/sclasner