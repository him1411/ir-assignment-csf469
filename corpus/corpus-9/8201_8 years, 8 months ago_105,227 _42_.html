I have now seen 2 methods for determining if an argument has been passed to a JavaScript function. I\'m wondering if one method is better than the other or if one is just bad to use?OrAs far as I can tell, they both result in the same thing, but I\'ve only used the first one before in production.Another Option as mentioned by Tom:As per Juan\'s comment, it would be better to change Tom\'s suggestion to:There are several different ways to check if an argument was passed to a function. In addition to the two you mentioned in your (original) question - checking arguments.length or using the || operator to provide default values - one can also explicitly check the arguments for undefined via argument2 === undefined or typeof argument2 === \'undefined\' if one is paranoid (see comments).Using the || operator has become standard practice - all the cool kids do it - but be careful: The default value will be triggered if the argument evaluates to false, which means it might actually be undefined, null, false, 0, \'\' (or anything else for which Boolean(...) returns false).So the question is when to use which check, as they all yield slightly different results.Checking arguments.length exhibits the \'most correct\' behaviour, but it might not be feasible if there\'s more than one optional argument.The test for undefined is next \'best\' - it only \'fails\' if the function is explicitly called with an undefined value, which in all likelyhood should be treated the same way as omitting the argument.The use of the || operator might trigger usage of the default value even if a valid argument is provided. On the other hand, its behaviour might actually be desired.To summarize: Only use it if you know what you\'re doing!In my opinion, using || is also the way to go if there\'s more than one optional argument and one doesn\'t want to pass an object literal as a workaround for named parameters.Another nice way to provide default values using arguments.length is possible by falling through the labels of a switch statement:This has the downside that the programmer\'s intention is not (visually) obvious and uses \'magic numbers\'; it is therefore possibly error prone.If you are using jQuery, one option that is nice (especially for complicated situations) is to use jQuery\'s extend method.If you call the function then like this:The options variable would then be:This is one of the few cases where I find the test:  works quite nicely and carries the correct implication syntactically.(With the simultaneous restriction that I wouldn\'t allow a legitimate null value for argument2 which has some other meaning; but that would be really confusing.)EDIT:This is a really good example of a stylistic difference between loosely-typed and strongly-typed languages; and a stylistic option that javascript affords in spades.  My personal preference (with no criticism meant for other preferences) is minimalism. The less the code has to say, as long as I\'m consistent and concise, the less someone else has to comprehend to correctly infer my meaning.  One implication of that preference is that I don\'t want to - don\'t find it useful to - pile up a bunch of type-dependency tests. Instead, I try to make the code mean what it looks like it means; and test only for what I really will need to test for.  One of the aggravations I find in some other peoples\' code is needing to figure out whether or not they expect, in the larger context, to actually run into the cases they are testing for. Or if they are trying to test for everything possible, on the chance that they don\'t anticipate the context completely enough. Which means I end up needing to track them down exhaustively in both directions before I can confidently refactor or modify anything. I figure that there\'s a good chance they might have put those various tests in place because they foresaw circumstances where they would be needed (and which usually aren\'t apparent to me).(I consider that a serious downside in the way these folks use dynamic languages. Too often people don\'t want to give up all the static tests, and end up faking it.)I\'ve seen this most glaringly in comparing comprehensive ActionScript 3 code with elegant javascript code. The AS3 can be 3 or 4 times the bulk of the js, and the reliability I suspect is at least no better, just because of the number (3-4X) of coding decisions that were made.As you say, Shog9, YMMV. :DThere are significant differences. Let\'s set up some test cases:With the first method you describe, only the second test will use the default value. The second method will default all but the first (as JS will convert undefined, null, 0, and "" into the boolean false. And if you were to use Tom\'s method, only the fourth test will use the default!Which method you choose really depends on your intended behavior. If values other than undefined are allowable for argument2, then you\'ll probably want some variation on the first; if a non-zero, non-null, non-empty value is desired, then the second method is ideal - indeed, it is often used to quickly eliminate such a wide range of values from consideration.I\'m sorry, I still yet cant comment, so to answer Tom\'s answer...\nIn javascript (undefined != null) == false\nIn fact that function wont work with "null", you should use "undefined"It can be convenient to approach argument detection by evoking your function with an Object of optional properties:Why not using the !! operator? This operator, placed before the variable, turn it to a boolean (if I\'ve understood well), so !!undefined and !!null (and even !!NaN, which can be quite interesting) will return false.Here is an exemple:Some times you may also want to check for type, specially if you are using the function as getter and setter. The following code is ES6 (will not run in EcmaScript 5 or older):In ES6 (ES2015) you can use Default parametersThere is a tricky way as well to find, whether a parameter is passed to a function or not. Have a look at the below example:This necessary means that if the value of value is not present/passed - set it to 0.Pretty cool huh!