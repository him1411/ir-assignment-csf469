I\'m writing some JavaScript code to parse user-entered functions (for spreadsheet-like functionality). Having parsed the formula I could convert it into JavaScript and run eval() on it to yield the result.However, I\'ve always shied away from using eval() if I can avoid it because it\'s evil (and, rightly or wrongly, I\'ve always thought it is even more evil in JavaScript, because the code to be evaluated might be changed by the user).So, when it is OK to use it?I\'d like to take a moment to address the premise of your question - that eval() is "evil". The word "evil", as used by programming language people, usually means "dangerous", or more precisely "able to cause lots of harm with a simple-looking command". So, when is it OK to use something dangerous? When you know what the danger is, and when you\'re taking the appropriate precautions.To the point, let\'s look at the dangers in the use of eval(). There are probably many small hidden dangers just like everything else, but the two big risks - the reason why eval() is considered evil - are performance and code injection.On to your specific case. From what I understand, you\'re generating the strings yourself, so assuming you\'re careful not to allow a string like "rm -rf something-important" to be generated, there\'s no code injection risk (but please remember, it\'s very very hard to ensure this in the general case). Also, if you\'re running in the browser then code injection is a pretty minor risk, I believe.As for performance, you\'ll have to weight that against ease of coding. It is my opinion that if you\'re parsing the formula, you might as well compute the result during the parse rather than run another parser (the one inside eval()). But it may be easier to code using eval(), and the performance hit will probably be unnoticeable. It looks like eval() in this case is no more evil than any other function that could possibly save you some time.eval() isn\'t evil. Or, if it is, it\'s evil in the same way that reflection, file/network IO, threading, and IPC are "evil" in other languages.If, for your purpose, eval() is faster than manual interpretation, or makes your code simpler, or more clear... then you should use it. If neither, then you shouldn\'t. Simple as that.When you trust the source. In case of JSON, it is more or less hard to tamper with the source, because it comes from a web server you control. As long as the JSON itself contains no data a user has uploaded, there is no major drawback to use eval.In all other cases I would go great lengths to ensure user supplied data conforms to my rules before feeding it to eval().Let\'s get real folks:Every major browser now has a built-in console which your would-be hacker can use with abundance to invoke any function with any value - why would they bother to use an eval statement - even if they could?If it takes 0.2 seconds to compile 2000 lines of JavaScript, what is my performance degradation if I eval four lines of JSON?Even Crockford\'s explanation for \'eval is evil\' is weak. As Crockford himself might say "This kind of statement tends to generate irrational neurosis. Don\'t buy it." Understanding eval and knowing when it might be useful is way more important. For example, eval is a sensible tool for evaluating server responses that were generated by your software. BTW: Prototype.js calls eval directly five times (including in evalJSON() and evalResponse()). jQuery uses it in parseJSON (via Function constructor).I tend to follow Crockford\'s advice for eval(), and avoid it altogether. Even ways that appear to require it do not. For example, the setTimeout() allows you to pass a function rather than eval.Even if it\'s a trusted source, I don\'t use it, because the code returned by JSON might be garbled, which could at best do something wonky, at worst, expose something bad.Eval is complementary to compilation which is used in templating the code. By templating I mean that you write a simplified template generator that generates useful template code which increases development speed.I have written a framework, where developers don\'t use EVAL, but they use our framework and in turn that framework has to use EVAL to generate templates.Performance of EVAL can be increased by using the following method; instead of executing the script, you must return a function.It should be organized asCaching f will certainly improve the speed.Also Chrome allows debugging of such functions very easily.Regarding security, using eval or not will hardly make any difference,If your server-side security is solid enough for anyone to attack from anywhere, you should not worry about EVAL. As I mentioned, if EVAL would not exist, attackers have many tools to hack into your server irrespective of your browser\'s EVAL capability.Eval is only good for generating some templates to do complex string processing based on something that is not used in advance. For example, I will preferAs opposed toAs my display name, which can come from a database and which is not hardcoded.The only instance when you should be using eval() is when you need to run dynamic JS on the fly. I\'m talking about JS that you download asynchronously from the server... ...And 9 times of 10 you could easily avoid doing that by refactoring.Microsoft explains why eval() is slow in their browser on IE BlogI saw people advocate to not use eval, because is evil, but I saw the same people use Function and setTimeout dynamically, so they use eval under the hoods :DBTW, if your sandbox is not sure enough (for example, if you\'re working on a site that allow code injection) eval is the last of your problems. The basic rule of security is that all input is evil, but in case of JavaScript even JavaScript itself could be evil, because in JavaScript you can overwrite any function and you just can\'t be sure you\'re using the real one, so, if a malicious code start before you, you can\'t trust any JavaScript built-in function :DNow the epilogue to this post is:If you REALLY need it (80% of the time eval is NOT needed) and you\'re sure of what you\' re doing, just use eval (or better Function ;) ), closures and OOP cover the 80/90% of the case where eval can be replaced using another kind of logic, the rest is dynamically generated code (for example, if you\'re writing an interpreter) and as you already said evaluating JSON (here you can use the Crockford safe evaluation ;) )It\'s okay to use it if you have complete control over the code that\'s passed to the eval function.When debugging in Chrome (v28.0.1500.72), I found that variables are not bound to closures if they are not used in a nested function that produces the closure. I guess, that\'s an optimization of the JavaScript engine.BUT: when eval() is used inside a function that causes a closure, ALL the variables of outer functions are bound to the closure, even if they are not used at all. If someone has the time to test if memory leaks can be produced by that, please leave me a comment below.Here\'s my test code:What I like to point out here is, that eval() must not necessarily refer to the native eval() function. It all depends on the name of the function. So when calling the native eval() with an alias name (say var noval = eval; and then in an inner function noval(expression);) then the evaluation of expression may fail when it refers to variables that should be part of the closure, but is actually not.eval is rarely the right choice. While there may be numerous instances where you can accomplish what you need to accomplish by concatenating a script together and running it on the fly, you typically have much more powerful and maintainable techniques at your disposal: associative-array notation (obj["prop"] is the same as obj.prop), closures, object-oriented techniques, functional techniques - use them instead.My belief is that eval is a very powerful function for client-side web applications and safe... As safe as JavaScript, which are not. :-) The security issues are essentially a server-side problem because, now, with tool like Firebug, you can attack any JavaScript application.As far as client script goes, I think the issue of security is a moot point. Everything loaded into the browser is subject to manipulation and should be treated as such. There is zero risk in using an eval() statement when there are much easier ways to execute JavaScript code and/or manipulate objects in the DOM, such as the URL bar in your browser.If someone wants to manipulate their DOM, I say swing away. Security to prevent any type of attack should always be the responsibility of the server application, period.From a pragmatic standpoint, there\'s no benefit to using an eval() in a situation where things can be done otherwise. However, there are specific cases where an eval SHOULD be used. When so, it can definitely be done without any risk of blowing up the page.When is JavaScript\'s eval() not evil?I\'m always trying to discourage from using eval. Almost always, a more clean and maintainable solution is available. Eval is not needed even for JSON parsing. Eval adds to maintenance hell. Not without reason, it is frowned upon by  masters like Douglas Crockford.But I found one example where it should be used:For example, I have a function that constructs a general google.maps.ImageMapType object for me, but I need to tell it the recipe, how should it construct the tile URL from the zoom and coord parameters:My example of using eval: import.How it\'s usually done.But with the help of eval and a little helper function it gets a much better look:importable might look like (this version doesn\'t support importing concrete members).Only during testing, if possible. Also note that eval() is much slower than other specialized JSON etc. evaluators.Code generation. I recently wrote a library called Hyperbars which bridges the gap between virtual-dom and handlebars. It does this by parsing a handlebars template and converting it to hyperscript. The hyperscript is generated as a string first and before returning it, eval() it to turn it into executable code. I have found eval() in this particular situation the exact opposite of evil. Basically fromTo thisThe performance of eval() isn\'t an issue in a situation like this too because you only need to interpret the generated string once and then reuse the executable output many times over.You can see how the code generation was achieved if you\'re curious here.There is no reason not to use eval() as long as you can be sure that the source of the code comes from you or the actual user. Even though he can manipulate what gets sent into the eval() function, that\'s not a security problem, because he is able to manipulate the source code of the web site and could therefore change the JavaScript code itself.So... when to not use eval()? Eval() should only not be used when there is a chance that a third party could change it. Like intercepting the connection between the client and your server (but if that is a problem use HTTPS). You shouldn\'t eval() for parsing code that is written by others like in a forum.If it\'s really needed eval is not evil. But 99.9% of the uses of eval that I stumble across are not needed (not including setTimeout stuff).For me the evil is not a performance or even a security issue (well, indirectly it\'s both). All such unnecessary uses of eval add to a maintenance hell. Refactoring tools are thrown off. Searching for code is hard. Unanticipated effects of those evals are legion.Eval is useful for code generation when you don\'t have macros.For (a stupid) example, if you\'re writing a Brainfuck compiler, you\'ll probably want to construct a function that performs the sequence of instructions as a string, and eval it to return a function.When you parse a JSON structure with a parse function (for example, jQuery.parseJSON), it expects a perfect structure of the JSON file (each property name is in double quotes). However, JavaScript is more flexible. Therefore, you can use eval() to avoid it.