How do I get user\'s IP in django?I have a view like this:But I get this error:Make sure you have reverse proxy (if any) configured correctly (e.g. mod_rpaf installed for Apache).Note: the above uses the first item in X-Forwarded-For, but you might want to use the last item (e.g., in the case of Heroku: Get client's real IP address on Heroku)And then just pass the request as argument to it;You can stay DRY and just use django-ipware that supports both IPv4 and IPv6 as well as Python 3.Install:In your view or middleware:It will make the best attempt to get the user\'s IP address or returns None to indicate that it could not determine the user\'s IP address.Update: (Advanced Users)ipware=>1.1.5 adds support for trusted proxy server configuration.Alexander\'s answer is great, but lacks the handling of proxies that sometimes return multiple IP\'s in the HTTP_X_FORWARDED_FOR header.The real IP is usually at the end of the list, as explained here: http://en.wikipedia.org/wiki/X-Forwarded-ForThe solution is a simple modification of Alexander\'s code:I would like to suggest an improvement to yanchenko\'s answer.Instead of taking the first ip in the X_FORWARDED_FOR list, I take the first one which in not a known internal ip, as some routers don\'t respect the protocol, and you can see internal ips as the first value of the list.I hope this helps fellow Googlers who have the same problem.The simpliest solution (in case you are using fastcgi+nignx) is what itgorilla commented: Thank you for this great question. My fastcgi was not passing the REMOTE_ADDR meta key. I added the line below in the nginx.conf and fixed the problem: fastcgi_param REMOTE_ADDR $remote_addr; \xe2\x80\x93 itgorillaPs: I added this answer just to make his solution more visible.In my case none of above works, so I have to check uwsgi + django source code and pass static param in nginx and see why/how, and below is what I have found.Env info:\npython version: 2.7.5\nDjango version: (1, 6, 6, \'final\', 0)\nnginx version: nginx/1.6.0\nuwsgi: 2.0.7 Env setting info:\nnginx as reverse proxy listening at port 80\nuwsgi as upstream unix socket, will response to the request eventuallyDjango config info:nginx config:getting all the params in django app:Conclusion: So basically, you have to specify exactly the same field/param name in nginx, and use request.META[field/param] in django app.And now you can decide whether to add a middleware (interceptor) or just parse HTTP_X_FORWARDED_FOR in certain views.The reason the functionality was removed from Django originally was that the header cannot ultimately be trusted. The reason is that it is easy to spoof. For example the recommended way to configure an nginx reverse proxy is to:When you do:Your nginx in myhost.com will send onwards:The X-Real-IP will be the IP of the first previous proxy if you follow the instructions blindly.In case trusting who your users are is an issue, you could try something like django-xff: https://pypi.python.org/pypi/django-xff/I was also missing proxy in above answer. I used get_ip_address_from_request from django_easy_timezones.  And here is method get_ip_address_from_request, IPv4 and IPv6 ready:  request.META.get(\'REMOTE_ADDR\') would be good enough here.here is a short one liner to accomplish this:The most easy solution to this is:and then use it like: