I just bombed an interview and made pretty much zero progress on my interview question. Can anyone let me know how to do this? I tried searching online but couldn\'t find anything:Given a number, find the next higher number which has the exact same\n  set of digits as the original number. For example: given 38276 return\n  38627I wanted to begin by finding the index of the first digit (from the right) that was less than the ones digit. Then I would rotate the last digits in the subset such that it was the next biggest number comprised of the same digits, but got stuck.The interviewer also suggested trying to swap digits one at a time, but I couldn\'t figure out the algorithm and just stared at a screen for like 20-30 minutes. Needless to say, I think I\'m going to have to continue the job hunt.edit: for what its worth, I was invited to the next round of interviewsYou can do it in O(n) (where n is the number of digits) like this:Starting from the right, you find the first pair-of-digits such that the left-digit is smaller than the right-digit.  Let\'s refer to the left-digit by "digit-x".  Find the smallest number larger than digit-x to the right of digit-x, and place it immediately left of digit-x.  Finally, sort the remaining digits in ascending order - since they were already in descending order, all you need to do is reverse them (save for digit-x, which can be placed in the correct place in O(n)).An example will make this more clear:Proof of correctness:Let\'s use capital letters to define digit-strings and lower-case for digits. The syntax AB means "the concatenation of strings A and B".  < is lexicographical ordering, which is the same as integer ordering when the digit-strings are of equal length.Our original number N is of the form AxB, where x is a single digit and B is sorted descending.\nThe number found by our algorithm is AyC, where y \xe2\x88\x88 B is the smallest digit > x (it must exist due to the way x was chosen, see above), and C is sorted ascending.Assume there is some number (using the same digits) N\' such that AxB < N\' < AyC.  N\' must begin with A or else it could not fall between them, so we can write it in the form AzD.  Now our inequality is AxB < AzD < AyC, which is equivalent to xB < zD < yC where all three digit-strings contain the same digits.In order for that to be true, we must have x <= z <= y.  Since y is the smallest digit > x, z cannot be between them, so either z = x or z = y.  Say z = x.  Then our inequality is xB < xD < yC, which means B < D where both B and D have the same digits.  However, B is sorted descending, so there is no string with those digits larger than it.  Thus we cannot have B < D.  Following the same steps, we see that if z = y, we cannot have D < C.Therefore N\' cannot exist, which means our algorithm correctly finds the next largest number.An almost-identical problem appeared as a Code Jam problem and has a solution here:http://code.google.com/codejam/contest/dashboard?c=186264#s=a&a=1Here\'s a summary of the method using an example:A. Split the sequence of digits in two, so that the right part is as long as possible while remaining in decreasing order:(If the entire number is in decreasing order, there\'s no bigger number to be made without adding digits.)B.1. Select the last digit of the first sequence:B.2. Find the smallest digit in the second sequence that is larger than it:B.3. Swap them:C. Sort the second sequence into increasing order:D. Done!Here\'s a compact (but partly brute force) solution in PythonIn C++ you could make the permutations like this: https://stackoverflow.com/a/9243091/1149664 (It\'s the same algorithm as the one in itertools)Here\'s an implementation of the top answer described by Weeble and BlueRaja, (other answers). I doubt there\'s anything better.At minimum, here are a couple of example brute force String based solutions, that you should have been able to come up with right off the top of your head:the list of digits in 38276 sorted is 23678the list of digits in 38627 sorted is 23678brute force increment, sort and compareAlong the brute force solutions would be convert to a String\nand brute force all the possible numbers using those digits.Create ints out of them all, put them in a list and sort it,\nget the next entry after the target entry.If you spent 30 minutes on this and didn\'t at least come up with at least a brute force approach, I wouldn\'t hire you either.In the business world, a solution that is inelegant, slow and clunky but gets the job done is always more valuable than no solution at all, matter of fact that pretty much describes all business software, inelegant, slow and clunky.Your ideaI wanted to begin by finding the index of the first digit (from the right) that was less than the ones digit. Then I would rotate the last digits in the subset such that it was the next biggest number comprised of the same digits, but got stuck.is pretty good, actually. You just have to consider not only the last digit but all digits of less significance than the currently considered. Since before that is reached, we have a monotonic sequence of digits, that is the rightmost digit smaller than its right neighbour. RegardThe next larger number having the same digits isThe found digit is exchanged for the last digit - the smallest of the considered digits - and the remaining digits are arranged in increasing order.I\'m fairly sure your interviewer was trying to push you gently towards something like this:Not necessarily the most efficient or elegant solution but it solves the provided example in two cycles and swaps digits one at a time like he suggested.That is very interesting question.Here is my java version. Take me about 3 hours from figuring out the pattern to completely finish the code before I checked other contributors\' comments. Glad to see my idea is quite same with others.O(n) solution. Honestly, I will fail this interview if the time is only 15 minutes and require complete code finish on white board.Here are some points of interesting for my solution:I put detail comment in my code, and the Big O in each step.Here is result running in Intellj:Take a number and split it into digits. So if we have a 5 digit number, we have 5 digits: abcdeNow swap d and e and compare with the original number, if it is larger, you have your answer.If it isn\'t larger, swap e and c. Now compare and if it is smaller swap d and e again (notice recursion), take smallest.Carry on through until you find a larger number. With recursion it should work out as about 9 lines of scheme, or 20 of c#.A javascript implementation of @BlueRaja\'s algorithm.I\'ve only tested this with two numbers. They worked.\nAs IT Manager for 8 years until retiring last December, I cared about three things:\n1) Accuracy: it\'s good if it works - always.\n2) Speed: has to be acceptable to the user.\n3) Clarity: I\'m probably not as smart as you are, but I\'m paying you. Make sure you explain what you\'re doing, in English.Omar, best of luck going forward.If you are programming in C++, you could use next_permutation:I didn\'t know anything about the brute force algorithm when answering this question, so I approached it from another angle.  I decided to search the entire range of possible solutions that this number could possibly be rearranged into, starting from the number_given+1 up to the max number available (999 for a 3 digit number, 9999 for 4 digits, etc.).  I did this kind of like finding a palindrome with words, by sorting the numbers of each solution and comparing it to the sorted number given as the parameter.  I then simply returned the first solution in the array of solutions, as this would be the next possible value.Here is my code in Ruby:def PermutationStep(num)endA solution (in Java) could be the following (I am sure friends here can find a better):\nStart swapping digits from the end of the string until you get a higher number.\nI.e. first start moving up the lower digit.Then the next higher etc until you hit the next higher.\nThen sort the rest.\nIn your example you would get:  For a nice write-up of how to do this, see "Algorithm L" in Knuth\'s "The Art of Computer Programming: Generating all Permutations" (.ps.gz).Here is my code, it\'s a modified version of this exampleLibrary:Test:Add 9 to the given n digit number. Then check if it is within the limit(the first (n+1) digit number). If it is then check if the digits in the new number are the same as the digits in the original number.\nRepeat adding 9 until both the conditions are true.\nStop the algo when the number goes beyond the limit.I could not come up with a contradicting test case for this method./-----------------------------------------------/Just another solution using python:Output:Below is the code to generate all permutations of a number .. though one has to convert that integer to string using String.valueOf(integer) first.here is my implementation of it in ruby:you can read more hereYet another Java implementation, runnable out of the box and completed with tests.\nThis solution is O(n) space and time using good old dynamic programming.If one wants to bruteforce, there are 2 kinds of bruteforce:Permute all the things, then pick min higher: O(n!)Similar to this implementation, but instead of DP, bruteforcing the step of populating the \nindexToIndexOfNextSmallerLeft map will run in O(n^2).We need to find the right most bit 0 followed by a 1 and flip this right most 0 bit to a 1.for example lets say our input is 487, which is 111100111 in binary.we flip the right most 0 that has 1 following itso we get \n111101111but now we have a extra 1 and one less 0, so we reduce the number of 1\'s on the right of the flip\nbit by 1 and increase the no of 0 bits by 1, yielding111101011 - binary 491Here is the Java Implementation Here is the Unit Tests private static int GetNextHigherNumber(int num)\n        {\n            //given 38276 return 38627The simple approach to sove this question are:Case 1:- If All digits of given number are in descending order then print \xe2\x80\x9cNO\xe2\x80\x9dCase 2:- Else find the first number from right-most digit which is lesser than it\xe2\x80\x99s right digit (because this is the first digit responsible for violation of CASE 1).keeping in mind with these two cases we can easily reach out to the solution.You can see the C implementation at best explained What is nextAnswer in java with one more condition addedNext number should also be an Even number