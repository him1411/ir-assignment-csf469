How do you perform debounce in React.js?I want to debounce the handleOnChange.I tried with debounce(this.handleOnChange, 200) but it doesn\'t work.The important part here is to create a single debounced (or throttled) function per component instance. You don\'t want to recreate the debounce (or throttle) function everytime, and you don\'t want either multiple instances to share the same debounced function.I\'m not defining debouncing function in this answer as it\'s not really relevant, but this answer will work perfectly fine with _.debounce of underscore or lodash, as well as user-provided debouncing function.It won\'t work, because during class description object creation, this is not the object created itself. this.method does not return what you expect because the this context is not the object itself (which actually does not really exist yet BTW as it is just being created).This time you are effectively creating a debounced function that calls your this.method. The problem is that you are recreating it on every debouncedMethod call, so the newly created debounce function does not know anything about former calls! You must reuse the same debounced function over time or the debouncing will not happen.This is a little bit tricky here. All the mounted instances of the class will share the same debounced function, and most often this is not what you want!. See JsFiddle: 3 instances are producting only 1 log entry globally.You have to create a debounced function for each component instance, and not a singe debounced function at the class level, shared by each component instance.Because debounced functions are stateful, we have to create one debounced function per component instance.ES5ES6 (class constructor)ES6 (class property)I\'d recommend using class properties because it raally looks like an idiomatic solution and it\'s pretty easy to see the function is debounced.See JsFiddle: 3 instances are producting 1 log entry per instance (that makes 3 globally).This is related because we often want to debounce or throttle DOM events.In React, the event objects (ie, SyntheticEvent) that you receive in callbacks are pooled (this is now documented). This means that after the event callback has be called, the SyntheticEvent you receive will be put back in the pool with empty attributes to reduce the GC pressure.So if you access SyntheticEvent properties async to the original callback (as it may be the case if you throttle/debounce), the properties you access may be erased. If you want the event to never be put back in the pool, you can use the persist() method.The 2nd (async) will print hasNativeEvent=false because the event properties have been cleaned up.The 2nd (async) will print hasNativeEvent=true because persist() permits to avoid putting back the event in the pool.You can test these 2 behaviors here JsFiddleRead Julen\'s answer for an example of using persist() with a throttle/debounce function.You can use the event.persist() method.An example follows using underscore\'s _.debounce():Edit: See this JSFiddleUpdate: the example above shows an uncontrolled component. I use controlled elements all the time so here\'s another example of the above, but without using the event.persist() "trickery".A JSFiddle is available as well. Example without underscore Edit: updated examples and JSFiddles to React 0.12Edit: updated examples to address the issue raised by Sebastien LorberEdit: updated with jsfiddle that does not use underscore and uses plain javascript debounce.If all you need from the event object is to get the DOM input element, the solution is much simpler \xe2\x80\x93 just use refHere is an example I came up with that wraps another class with a debouncer. This lends itself nicely to being made into a decorator/higher order function:I found this post by Justin Tulk very helpful. After a couple of attempts, in what one would perceive to be the more official way with react/redux, it shows that it fails due to React\'s synthetic event pooling. His solution then uses some internal state to track the value changed/entered in the input, with a callback right after setState which calls a throttled/debounced redux action that shows some results in realtime. Instead of wrapping the handleOnChange in a debounce(), why not wrap the ajax call inside the callback function inside the debounce, thereby not destroying the event object.  So something like this:I was searching for a solution to the same problem and came across this thread as well as some others but they had the same problem: if you are trying to do a handleOnChange function and you need the value from an event target, you will get cannot read property value of null or some such error. In my case, I also needed to preserve the context of this inside the debounced function since I\'m executing a fluxible action. Here\'s my solution, it works well for my use case so I\'m leaving it here in case anyone comes across this thread:If you are using redux you can do this in a very elegant way with middleware.  You can define a Debounce middleware as:You can then add debouncing to action creators, such as:There\'s actually already middleware you can get off npm to do this for you.Julen solution is kind of hard to read, here\'s clearer and to-the-point react code for anyone who stumbled him based on title and not the tiny details of the question.tl;dr version: when you would update to observers send call a schedule method instead and that in turn will actually notify the observers (or perform ajax, etc)Complete jsfiddle with example component http://jsfiddle.net/7L655p5L/4/You can also use a self-written mixin, something like this:And then use it in your component like this:for throttle or debounce the best way is to create a function creator so you can use it any where, for example:and in your render method you can do:the updateUserProfileField method will create a separated function each time you call it.Note don\'t try to return the handler directly for example this will not work:the reason why this will not work because this will generate a new throttle function each time the event called instead of using the same throttle function, so basically the throttle will be useless ;)Also if you use debounce or throttle you don\'t need setTimeout or clearTimeout, this is actually why we use them :P