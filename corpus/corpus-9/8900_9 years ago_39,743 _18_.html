Why is it wrong to use std::auto_ptr<> with standard containers?The C++ Standard says that an STL element must be "copy-constructible" and "assignable."  In other words, an element must be able to be assigned or copied and the two elements are logically independent. std::auto_ptr does not fulfill this requirement.Take for example this code:To overcome this limitation, you should use the std::unique_ptr, std::shared_ptr or std::weak_ptr smart pointers or the boost equivalents if you don\'t have C++11.   Here is the boost library documentation for these smart pointers. The copy semantics of auto_ptr are not compatible with the containers.Specifically, copying one auto_ptr to another does not create two equal objects since one has lost its ownership of the pointer.More specifically, copying an auto_ptr causes one of the copies to let go of the pointer. Which of these remains in the container is not defined. Therefore, you can randomly lose access to pointers if you store auto_ptrs in the containers.Two super excellent articles on the subject:The STL containers need to be able to copy the items you store in them, and are designed to expect the original and the copy to be equivalent. auto pointer objects have a completely different contract, whereby copying creates a transfer of ownership. This means that containers of auto_ptr will exhibit strange behaviour, depending on usage.There is a detailed description of what can go wrong in Effective STL (Scott Meyers) item 8 and also a not-so-detailed description in Effective C++ (Scott Meyers) item 13.STL containers store copies of contained items.  When an auto_ptr is copied, it sets the old ptr to null.  Many container methods are broken by this behavior.C++03 Standard (ISO-IEC 14882-2003) says in clause 20.4.5 paragraph 3:[...]\n  [Note: [...]\n  auto_ptr does not meet the CopyConstructible and Assignable requirements for Standard Library\n  container elements and thus instantiating a Standard Library container\n  with an auto_ptr results in undefined behavior. \xe2\x80\x94 end note]C++11 Standard (ISO-IEC 14882-2011) says in appendix D.10.1 paragraph 3:[...]\n  Note: [...] Instances of auto_ptr meet the requirements of\n  MoveConstructible and MoveAssignable, but do not meet the requirements\n  of CopyConstructible and CopyAssignable. \xe2\x80\x94 end note ]C++14 Standard (ISO-IEC 14882-2014) says in appendix C.4.2\n Annex D: compatibility features:  Change: The class templates auto_ptr, unary_function, and binary_function, the function templates random_shuffle, and the\n  function templates (and their return types) ptr_fun, mem_fun,\n  mem_fun_ref, bind1st, and bind2nd are not defined.\n  Rationale: Superseded by new features.\n  Effect on original feature: Valid C ++ 2014 code that uses these class templates and function templates may fail to compile in this\n  International Standard.You cannot put auto_ptr object to std::vector anyway, due to const-correctness.\nYou should get a compile error. 