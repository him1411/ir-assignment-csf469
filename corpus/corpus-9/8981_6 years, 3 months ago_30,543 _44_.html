scipy appears to provide most (but not all [1]) of numpy\'s functions in its own namespace. In other words, if there\'s a function named numpy.foo, there\'s almost certainly a scipy.foo. Most of the time, the two appear to be exactly the same, oftentimes even pointing to the same function object.Sometimes, they\'re different. To give an example that came up recently:The same can be said about log, log2 and logn, but not about log1p [2].On the other hand, numpy.exp and scipy.exp appear to be different names for the same ufunc. This is also true of scipy.log1p and numpy.log1p.Another example is numpy.linalg.solve vs scipy.linalg.solve. They\'re similar, but the latter offers some additional features over the former.Why the apparent duplication? If this is meant to be a wholesale import of numpy into the scipy namespace, why the subtle differences in behaviour and the missing functions? Is there some overarching logic that would help clear up the confusion?[1] numpy.min, numpy.max, numpy.abs and a few others have no counterparts in the scipy namespace.[2] Tested using numpy 1.5.1 and scipy 0.9.0rc2.Last time I checked it, the scipy __init__ method executes aso that the whole numpy namespace is included into scipy when the scipy module is imported.The log10 behavior you are describing is interesting, because both versions are coming from numpy. One is a ufunc, the other is a numpy.lib function. Why scipy is preferring the library function over the ufunc, I don\'t know off the top of my head.EDIT: In fact, I can answer the log10 question. Looking in the scipy __init__ method I see this:The log10 function you get in scipy comes from numpy.lib.scimath. Looking at that code, it says:It seems that module overlays the base numpy ufuncs for sqrt, log, log2, logn, log10, power, arccos, arcsin, and arctanh. That explains the behavior you are seeing. The underlying design reason why it is done like that is probably buried in a mailing list post somewhere.From the SciPy Reference Guide:... all of the Numpy functions have\n  been subsumed into the scipy\n  namespace so that all of those\n  functions are available without\n  additionally importing Numpy.The intention is for users not to have to know the distinction between the scipy and numpy namespaces, though apparently you\'ve found an exception. It seems from the scipy FAQ\nthat some functions from numpy are here for historical reasons while it should\nonly be in scipy:In an ideal world, NumPy would contain nothing but the array data type and\n  the most  basic operations: indexing, sorting, reshaping, basic\n  elementwise functions, et cetera. All numerical code would reside in\n  SciPy. However, one of NumPy\xe2\x80\x99s important goals is compatibility, so NumPy\n  tries to retain all features supported by either of its predecessors. Thus\n  NumPy contains some linear algebra functions, even though these more\n  properly belong in SciPy. In any case, SciPy contains more fully-featured\n  versions of the linear algebra modules, as well as many other numerical\n  algorithms. If you are doing scientific computing with python, you should\n  probably install both NumPy and SciPy. Most new features belong in SciPy\n  rather than NumPy.That explains why scipy.linalg.solve offers some additional features over\nnumpy.linalg.solve.EDIT:I did not see the answer of SethMMorton to the related questionThere is a short comment at the end of the introduction to SciPy documentation:Another useful command issource. When given a function written in Python as an argument, it  prints out a listing of the source code for that function. This can be helpful in learning  about an algorithm or understanding exactly what a function is \n  doing with its arguments. Also don\xe2\x80\x99t forget about the Python command dir which can be \n  used to look at the namespace of a module or package.I think this will allow someone with enough knowledge of all the packages involved to pick apart exactly what the differences are between some scipy and numpy functions (it didn\'t help me with the log10 question at all). I definitely don\'t have that knowledge but source does indicate that scipy.linalg.solve and numpy.linalg.solve interact with lapack in different ways;This is also my first post so if I should change something here please let me know.From Wikipedia ( http://en.wikipedia.org/wiki/NumPy#History ):The Numeric code was adapted to make\n  it more maintainable and flexible\n  enough to implement the novel features\n  of Numarray. This new project was part\n  of SciPy. To avoid installing a whole\n  package just to get an array object,\n  this new package was separated and\n  called NumPy.scipy depends on numpy and imports many numpy functions into its namespace for convenience.Regarding the linalg package - the scipy functions will call lapack and blas, which are available in highly optimised versions on many platforms and offer very good performance, particularly for operations on reasonably large dense matrices.  On the other hand, they are not easy libraries to compile, requiring a fortran compiler and many platform specific tweaks to get full performance. Therefore, numpy provides simple implementations of many common linear algebra functions which are often good enough for many purposes.In addition to the SciPy FAQ describing the duplication is mainly for backwards compatibility, it is further clarified in the NumPy docs to say thatOptionally Scipy-accelerated routines (numpy.dual)Aliases for functions which may be accelerated by Scipy.Scipy can be built to use accelerated or otherwise improved libraries\n  for FFTs, linear algebra, and special functions. This module allows\n  developers to transparently support these accelerated functions when\n  scipy is available but still support users who have only installed\n  Numpy.For brevity, these are:Also, from the SciPy Tutorial:The top level of scipy also contains functions from numpy and\n  numpy.lib.scimath. However, it is better to use them directly from the\n  numpy module instead.So, for new applications, you should prefer the NumPy version of the array operations that are duplicated in the top level of SciPy. For the domains listed above, you should prefer those in SciPy and check backward compatibility if necessary in NumPy. In my personal experience, most of the array functions I use exist in the top level of NumPy (except for random). However, all the domain specific routines exist in subpackages of SciPy so I rarely use anything from the top level of SciPy.From Lectures on \'Quantitative Economics\' SciPy is a package that contains various tools that are built on top of NumPy, using its array data type and related functionalityIn fact, when we import SciPy we also get NumPy, as can be seen from the SciPy initialization fileHowever, it\xe2\x80\x99s more common and better practice to use NumPy functionality explicitlyWhat is useful in SciPy is the functionality in its subpackages