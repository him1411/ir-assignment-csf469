I have a <select> where one of its <option>\xe2\x80\x99s text values is very long. I want the <select> to resize so it is never wider than its parent, even if it has to cut off its displayed text. max-width: 100% should do that.Before resize:What I want after resize:But if you load this jsFiddle example and resize the Result panel\xe2\x80\x99s width to be smaller than that of the <select>, you can see that the select inside the <fieldset> fails to scale its width down.What I\xe2\x80\x99m actually seeing after resize:However, the equivalent page with a <div> instead of a <fieldset> does scale properly. You can see that and test your changes more easily if you have a <fieldset> and a <div> next to each other on one page. And if you delete the surrounding <fieldset> tags, the resizing works. The <fieldset> tag is somehow causing horizontal resizing to break.The <fieldset> acts is as if there is a CSS rule fieldset { min-width: min-content; }. (min-content means, roughly, the smallest width that doesn\xe2\x80\x99t cause a child to overflow.) If I replace the <fieldset> with a <div> with min-width: min-content, it looks exactly the same. Yet there is no rule with min-content in my styles, in the browser default stylesheet, or visible in Firebug\xe2\x80\x99s CSS Inspector. I tried to override every style visible on the <fieldset> in Firebug\xe2\x80\x99s CSS Inspector and in Firefox\xe2\x80\x99s default stylesheet forms.css, but that didn\xe2\x80\x99t help. Specifically overriding min-width and width didn\xe2\x80\x99t do anything either.HTML of the fieldset:My CSS that should be working but isn\xe2\x80\x99t:Resetting the width properties to the defaults does nothing:Further CSS in which I try and fail to fix the problem:The problem also occurs in this more comprehensive, more complicated jsFiddle example, which is more similar to the web page I\xe2\x80\x99m actually trying to fix. You can see from that that the <select> is not the problem \xe2\x80\x93 an inline-block div also fails to resize. Though this example is more complicated, I assume that the fix for the simple case above will also fix this more complicated case.[Edit: see browser support details below.]One curious thing about this problem is that if you set div.wrapper { width: 50%; }, the <fieldset> stops resizing itself at the point then the full-size <select> would have hit the edge of the viewport. The resizing happens as if the <select> has width: 100%, even though the <select> looks like it has width: 50%.If you give the <select> itself width: 50%, that behavior does not occur; the width is simply correctly set.I don\xe2\x80\x99t understand the reason for that difference. But it may not be relevant.I also found the very similar question HTML fieldset allows children to expand indefinitely. The asker couldn\xe2\x80\x99t find a solution and guesses that there is no solution apart from removing the <fieldset>. But I\xe2\x80\x99m wondering, if it really is impossible to make the <fieldset> display right, why is that? What in <fieldset>\xe2\x80\x99s spec or default CSS causes this behavior? This special behavior is probably be documented somewhere, since multiple browsers work like this.The reason I\xe2\x80\x99m trying to do this is as part of writing mobile styles for an existing page with a big form. The form has multiple sections, and one part of it is wrapped in a <fieldset>. On a smartphone (or if you make your browser window small), the part of the page with the <fieldset> is much wider than the rest of the form. Most of the form constrains its width just fine, but the section with the <fieldset> does not, forcing the user to zoom out or scroll right to see all of that section.I\xe2\x80\x99m wary of simply removing the <fieldset>, as it is generated on many pages in a big app, and I\xe2\x80\x99m not sure what selectors in CSS or JavaScript might depend on it.I can use JavaScript if I need to, and a JavaScript solution is better than nothing. But if JavaScript is the only way to do this, I\xe2\x80\x99d be curious to hear an explanation for why this is not possible using only CSS and HTML.On the site, I need to support Internet Explorer 8 and later (we just dropped support for IE7), the latest Firefox, and the latest Chrome. This particular page should also work on iOS and Android smartphones. Slightly degraded but still usable behavior is acceptable for Internet Explorer 8.I retested my broken fieldset example on different browsers. It actually already works in these browsers:It breaks in these browsers:Thus, the only browser I care about that the current code breaks in is Firefox (on both desktop and mobile). If the code were fixed so it worked in Firefox without breaking it in any other browsers, that would solve my problem.The site HTML template uses Internet Explorer conditional comments to add classes such .ie8 and .oldie to the <html> element. You can use those classes in your CSS if you need to work around styling differences in IE. The classes added are the same as in this old version of HTML5 Boilerplate.In WebKit, you just set min-width: 0; on the fieldset to override the default value of -webkit-min-content. (Unfortunately, in Android 4.1.2 Stock Browser and possibly other similarly old versions, this has no effect.)Firefox, however, is a bit\xe2\x80\xa6 odd when it comes to fieldsets. The fix is to change the display property of the fieldset to one of the following values:Of these, I recommend table-cell. Both table-row and table-row-group prevent you from changing width, while table-column and table-column-group prevent you from changing height.This will (somewhat reasonably) break rendering in IE. Since only Gecko needs this, you can justifiably use @-moz-document\xe2\x80\x94one of Mozilla\'s proprietary CSS extensions\xe2\x80\x94to hide it from other browsers:(Here\'s a jsFiddle demo.)That fixes things, but if you\'re anything like me your reaction was something like\xe2\x80\xa6There is a reason, but it\'s not pretty.First off, the default presentation of the fieldset element is absurd and essentially impossible to specify in CSS. Think about it: the fieldset\'s border disappears where it\'s overlapped by a legend element, but the background remains visible! There\'s no way to reproduce this with any other combination of elements.To top it off, implementations are chock-full of concessions to legacy behaviour. One such is that the minimum width of a fieldset is never less than the intrinsic width of its content. WebKit gives you a way to override this behaviour by specifying it in the default stylesheet, but Gecko\xc2\xb9 goes a step further and enforces it in the rendering engine.However, internal table elements constitute a special frame type in Gecko. Dimensional constraints for elements with these display values set are calculated in a separate code path, entirely circumventing the enforced minimum width imposed on fieldsets.There is an open bug for this, though it may be difficult to convince anyone to accept patches without also presenting evidence that it won\'t break existing sites that rely on the legacy behaviour.This is a hack. In my opinion, it\'s justifiable and relatively safe.Only Gecko treats fieldsets this way, so we are using a proprietary Gecko feature to target a well-understood Gecko behaviour as a workaround to another well-understood Gecko behaviour which is both unique and undesirable.The Gecko targeting hack has been around for a while. Given its widespread use as a means to target Gecko issues\xc2\xb2 I believe Mozilla will be conservative about removing it.Changes to fieldset behaviour tend to meet resistance out of concern for legacy support.Given how fundamental table layout is, I strongly doubt that the codepath for calculating the dimensions of internal table elements will be significantly changed in the near future.It\'s your call if you are comfortable with this approach. I hope the explanation above inclines you to agree that it is appropriate.\xc2\xb9 All links to the Gecko source in this answer refer to the 5065fdc12408 changeset, commited 29\xe1\xb5\x97\xca\xb0 July 2013; you may wish to compare notes with the most recent revision from Mozilla Central.\xc2\xb2 See e.g. SO #953491: Targeting only Firefox with CSS and CSS Tricks: CSS hacks targeting Firefox for widely referenced explanations on high-profile sites.Safari on iOS issue with selected answerI found the answer from Jordan Gray to be particularly helpful. \nHowever it didn\'t seem to solve this issue on Safari iOS for me. The issue for me is simply that the fieldset cannot have an auto width if the element within has a max-width as a % width. Fix for issueSimply setting the fieldset to have a 100% width of it\'s container seems to get around this issue. ExamplePlease refer to the below for working examples - if you remove the % width off the fieldset or replace it with auto, it will not continue to function.JSFiddle | Codepen I\xe2\x80\x99ve struggled for many hours with this, and basically, the browser is applying computed styling that you need to override in your CSS. I forget the exact property that is being set on fieldset elements versus divs (perhaps min-width?).My best advice would be to change your element to a div, copy the computed styles from your inspector, then change your element back to fieldset and compare the computed styles to find the culprit.Hope that helps.Update: Adding display: table-cell helps in non-Chrome browsers..fake-select { white-space:nowrap; } caused the fieldset to interpret the .fake-select element by its original width, rather than its forced width (even when the overflow is hidden).Remove that rule, and change .fake-select\'s max-width:100% to just width:100% and everything fits. The caveat is that you see all of the content of the fake-select, but I don\'t think this is all that bad, and it fits horizontally now.Update: with the current rules in the following fiddle (which contains only real selects), the fieldset\'s children are constrained to correct widths. Other than removing rules for .fake-select and fixing comments (from // comment to /* comment */, I\'ve noted changes in the fiddle\'s CSS.I understand your problem better now, and the fiddle reflects some progress. I set default rules for all <select>s, and reserve .xxlarge for those which you know will be wider than 480px (and this only works because you know the width of #viewport, and can manually add the class to those too wide. Just requires a little bit of testing)Proof