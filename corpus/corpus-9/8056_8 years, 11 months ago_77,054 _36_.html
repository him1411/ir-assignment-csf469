I found the discussion on Do you test private method informative.I have decided, that in some classes, I want to have protected methods, but test them.\nSome of these methods are static and short. Because most of the public methods make use of them, I will probably be able to safely remove the tests later. But for starting with a TDD approach and avoid debugging, I really want to test them.I thought of the following:Which is best practice? Is there anything else?It seems, that JUnit automatically changes protected methods to be public, but I did not have a deeper look at it. PHP does not allow this via reflection.If you\'re using PHP5 (>= 5.3.2) with PHPUnit, you can test your private and protected methods by using reflection to set them to be public prior to running your tests:You seem to be aware already, but I\'ll just restate it anyway; It\'s a bad sign, if you need to test protected methods. The aim of a unit test, is to test the interface of a class, and protected methods are implementation details. That said, there are cases where it makes sense. If you use inheritance, you can see a superclass as providing an interface for the subclass. So here, you would have to test the protected method (But never a private one). The solution to this, is to create a subclass for testing purpose, and use this to expose the methods. Eg.:Note that you can always replace inheritance with composition. When testing code, it\'s usually a lot easier to deal with code that uses this pattern, so you may want to consider that option.teastburn has the right approach. Even simpler is to call the method directly and return the answer:You can call this simply in your tests by:I\'d like to propose a slight variation to getMethod() defined in uckelman\'s answer. This version changes getMethod() by removing hard-coded values and simplifying usage a little. I recommend adding it to your PHPUnitUtil class as in the example below or to your PHPUnit_Framework_TestCase-extending class (or, I suppose, globally to your PHPUnitUtil file).Since MyClass is being instantiated anyways and ReflectionClass can take a string or an object...I also created an alias function getProtectedMethod() to be explicit what is expected, but that one\'s up to you.Cheers!I think troelskn is close. I would do this instead:Then, implement something like this:You then run your tests against TestClassToTest.It should be possible to automatically generate such extension classes by parsing the code. I wouldn\'t be surprised if PHPUnit already offers such a mechanism (though I haven\'t checked).I\'m going to throw my hat into the ring here:I\'ve used the __call hack with mixed degrees of success. \nThe alternative I came up with was to use the Visitor pattern:1: generate a stdClass or custom class (to enforce type)2: prime that with the required method and arguments3: ensure that your SUT has an acceptVisitor method which will execute the method with the arguments specified in the visiting class4: inject it into the class you wish to test5: SUT injects the result of operation into the visitor6: apply your test conditions to the Visitor\'s result attributeYou can indeed use __call() in a generic fashion to access protected methods. To be able to test this classyou create a subclass in ExampleTest.php:Note that the __call() method does not reference the class in any way so you can copy the above for each class with protected methods you want to test and just change the class declaration. You may be able to place this function in a common base class, but I haven\'t tried it.Now the test case itself only differs in where you construct the object to be tested, swapping in ExampleExposed for Example.I believe PHP 5.3 allows you to use reflection to change the accessibility of methods directly, but I assume you\'d have to do so for each method individually.I suggest following workaround for "Henrik Paul"\'s workaround/idea :)You know names of private methods of your class. For example they are like _add(), _edit(), _delete() etc.Hence when you want to test it from aspect of unit-testing, just call private methods by prefixing and/or suffixing some common word (for example _addPhpunit) so that when __call() method is called (since method _addPhpunit() doesn\'t exist) of owner class, you just put necessary code in __call() method to remove prefixed/suffixed word/s (Phpunit) and then to call that deduced private method from there. This is another good use of magic methods.Try it out.