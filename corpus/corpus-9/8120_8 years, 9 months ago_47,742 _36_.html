What are all the common undefined behaviours that a C++ programmer should know about?Say, like:The order that function parameters are evaluated is unspecified behavior. (This won\'t make your program crash, explode, or order pizza... unlike undefined behavior.)The only requirement is that all parameters must be fully evaluated before the function is called.This:Can be equivalent to this:Or this:It can be either; it\'s up to the compiler. The result can matter, depending on the side effects.The compiler is free to re-order the evaluation parts of an expression (assuming the meaning is unchanged).From the original question:Double Checked locking.\nAnd one easy mistake to make.My favourite is "Infinite recursion in the instantiation of templates" because I believe it\'s the only one where the undefined behaviour occurs at compile time.Besides undefined behaviour, there is also the equally nasty implementation-defined behaviour.Undefined behaviour occurs when a program does something the result of which is not specified by the standard.Implementation-defined behaviour is an action by a program the result of which is not defined by the standard, but which the implementation is required to document. An example is "Multibyte character literals", from Stack Overflow question Is there a C compiler that fails to compile this?.Implementation-defined behaviour only bites you when you start porting (but upgrading to new version of compiler is also porting!)Assigning to a constant after stripping constness using const_cast<>:Variables may only be updated once in an expression (technically once between sequence points).A basic understanding of the various environmental limits. The full list is in section 5.2.4.1 of the C specification. Here are a few;I was actually a bit surprised at the limit of 1023 case labels for a switch statement, I can forsee that being exceeded for generated code/lex/parsers fairly easially.If these limits are exceeded, you have undefined behavior (crashes, security flaws, etc...).Right, I know this is from the C specification, but C++ shares these basic supports.Using memcpy to copy between overlapping memory regions.  For example:The behavior is undefined according to the C Standard, which is subsumed by the C++03 Standard.Synopsis 1/ #include  void *memcpy(void * restrict s1, const\n  void * restrict s2, size_t n); Description 2/ The memcpy function\n  copies n characters from the object pointed to by s2 into the object\n  pointed to by s1. If copying takes place between objects that overlap,\n  the behavior is undefined. Returns 3 The memcpy function returns the\n  value of s1.Synopsis1 #include  void *memmove(void *s1, const void *s2, size_t\n  n);Description2 The memmove function copies n characters from the object pointed to\n  by s2 into the object pointed to by s1. Copying takes place as if the\n  n characters from the object pointed to by s2 are first copied into a\n  temporary array of n characters that does not overlap the objects\n  pointed to by s1 and s2, and then the n characters from the temporary\n  array are copied into the object pointed to by s1. Returns3 The memmove function returns the value of s1.The only type for which C++ guarantees a size is char. And the size is 1. The size of all other types is platform dependent.Namespace-level objects in a different compilation units should never depend on each other for initialization, because their initialization order is undefined.