Program is part of the Xenomai test suite, cross-compiled from Linux PC into Linux+Xenomai ARM toolchain.Edit: OK I didn\'t notice the .1 at the end was part of the filename. What does that mean anyway?Update While what I write below is true as a general answer about shared libraries, I think the most frequent cause of these sorts of message is because you\'ve installed a package, but not installed the "-dev" version of that package. Well, it\'s not lying - there is no libpthread_rt.so.1 in that listing.  You probably need to re-configure and re-build it so that it depends on the library you have, or install whatever provides libpthread_rt.so.1.Generally, the numbers after the .so are version numbers, and you\'ll often find that they are symlinks to each other, so if you have version 1.1 of libfoo.so, you\'ll have a real file libfoo.so.1.0, and symlinks foo.so and foo.so.1 pointing to the libfoo.so.1.0.  And if you install version 1.1 without removing the other one, you\'ll have a libfoo.so.1.1, and libfoo.so.1 and libfoo.so will now point to the new one, but any code that requires that exact version can use the libfoo.so.1.0 file.  Code that just relies on the version 1 API, but doesn\'t care if it\'s 1.0 or 1.1 will specify libfoo.so.1.  As orip pointed out in the comments, this is explained well at http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html.In your case, you might get away with symlinking libpthread_rt.so.1 to libpthread_rt.so.  No guarantees that it won\'t break your code and eat your TV dinners, though.Your library is a dynamic library.\nYou need to tell the operating system where it can locate it at runtime.To do so,\nwe will need to do those easy steps:(1 ) Find where the library is placed if you don\'t know it.(2) Check for the existence of the dynamic library path environment variable(LD_LIBRARY_PATH)if there is nothing to be display we need to add the default path value (or not as you wich)(3) We add the desire path, export it and try the application.Note that the path should be the directory where the path.so.something is.\nSo if path.so.something is in /my_library/path.so.something it should be :source : http://www.gnu.org/software/gsl/manual/html_node/Shared-Libraries.htmlHere are a few solutions you can try:As AbiusX pointed out: If you have just now installed the library, you may simply need to run ldconfig.ldconfig creates the necessary links and cache to the most recent\n  shared libraries found in the directories specified on the command\n  line, in the file /etc/ld.so.conf, and in the trusted directories\n  (/lib and /usr/lib).Usually your package manager will take care of this when you install a new library, but not always, and it won\'t hurt to run ldconfig even if that is not your issue.If that doesn\'t work, I would also check out Paul\'s suggestion and look for a "-dev" version of the library. Many libraries are split into dev and non-dev packages. You can use this command to look for it:This can also help if you simply have the wrong version of the library installed. Some libraries are published in different versions simultaneously, for example, Python.If you are sure that the right package is installed, and ldconfig didn\'t find it, it may just be in a nonstandard directory. By default, ldconfig looks in /lib, /usr/lib, and directories listed in /etc/ld.so.conf and $LD_LIBRARY_PATH. If your library is somewhere else, you can either add the directory on its own line in /etc/ld.so.conf, append the library\'s path to $LD_LIBRARY_PATH, or move the library into /usr/lib. Then run ldconfig.To find out where the library is, try this:(Replace libraryname with the name of your library)If you go the $LD_LIBRARY_PATH route, you\'ll want to put that into your ~/.bashrc file so it will run every time you log in:I had the similar error, I could resolve it by giving, Hope this helps. You need to ensure that you specify the library path during\nlinking when you compile your .c file:gcc -I/usr/local/include xxx.c -o xxx -L/usr/local/lib\n  -Wl,-R/usr/local/libThe -Wl,-R part tells the resulting binary to also look for library\nin /usr/local/lib at runtime before trying to use the one in /usr/lib/Hope it will help you.The linux.org reference page explains the mechanics, but doesn\'t explain any of the motivation behind it :-(For that, see Sun Linker and Libraries GuideIn addition, note that "external versioning" is largely obsolete on Linux, because symbol versioning (a GNU extension) allows you to have multiple incompatible versions of the same function to be present in a single library. This extension allowed glibc to have the same external version: libc.so.6 for the last 10 years.Try adding\nexport LD_LIBRARY_PATH=path_to_your_library in ~/.bashrcIt works!add these lines at the endAnother possible solution depending on your situation.If you know that libpthread_rt.so.1 is the same as libpthread_rt.so then you can create a symlink by:Then ls -l /lib should now show the symlink and what it points to.If you are running your application on Microsoft Windows, the path to dynamic libraries (.dll) need to be defined in the PATH environment variable.If you are running your application on UNIX, the path to your dynamic libraries (.so) need to be defined in the LD_LIBRARY_PATH environment variable.try installing sudo lib32z1sudo apt-get install lib32z1All I had to do was run:I was in the folder located at /usr/lib/x86_64-linux-gnu and it worked perfectly.The error occurs as the system cannot refer to the library file mentioned. Take the following steps: