Array literals and Object literals match...Why don\'t all of them? Or, why don\'t they all not?\nAnd, what are they an instance of, then?It\'s the same in FF3, IE7, Opera, and Chrome. So, at least it\'s consistent.Missed a few.Primitives are a different kind of type than objects created from within Javascript. From the Mozilla API docs:I can\'t find any way to construct primitive types with code, perhaps it\'s not possible. This is probably why people use typeof "foo" === "string" instead of instanceof.An easy way to remember things like this is asking yourself "I wonder what would be sane and easy to learn"? Whatever the answer is, Javascript does the other thing.I use:Because in JavaScript strings can be literals or objects.In JavaScript everything is an object (or may at least be treated as an object), except primitives (booleans, null, numbers, strings and the value undefined (and symbol in ES6)):As you can see objects, arrays and the value null are all considered objects (null is a reference to an object which doesn\'t exist). Functions are distinguished because they are a special type of callable objects. However they are still objects.On the other hand the literals true, 0, "" and undefined are not objects. They are primitive values in JavaScript. However booleans, numbers and strings also have constructors Boolean, Number and String respectively which wrap their respective primitives to provide added functionality:As you can see when primitive values are wrapped within the Boolean, Number and String constructors respectively they become objects. The instanceof operator only works for objects (which is why it returns false for primitive values):As you can see both typeof and instanceof are insufficient to test whether a value is a boolean, a number or a string - typeof only works for primitive booleans, numbers and strings; and instanceof doesn\'t work for primitive booleans, numbers and strings.Fortunately there\'s a simple solution to this problem. The default implementation of toString (i.e. as it\'s natively defined on Object.prototype.toString) returns the internal [[Class]] property of both primitive values and objects:The internal [[Class]] property of a value is much more useful than the typeof the value. We can use Object.prototype.toString to create our own (more useful) version of the typeof operator as follows:Hope this article helped. To know more about the differences between primitives and wrapped objects read the following blog post: The Secret Life of JavaScript\xc2\xa0PrimitivesYou can use constructor property:you can use this, it will work for both case as var text="foo";  // typeof will workString text= new String("foo");  // instanceof will workI believe I have come up with a viable solution:For me the confusion caused by So "str" istanceof String should return true because how istanceof works as below:Results of expression #1 and #2 conflict each other, so there should be one of them wrong.#1 is wrongI figure out that it caused by the __proto__ is non standard property, so use the standard one:Object.getPrototypeOfNow there\'s no confusion between expression #2 and #3I use this to solve:Or you can just make your own function like so:usage:These should both return true.That\'s because those things are primitives, and unless they need to be used as objects (when you are calling methods on them, for example) they remain so. The only time they "become" objects is when they need to be wrapped. If you are familiar with the concept of "boxing" in .NET, then think of it in that way.Here is an example - take a look at this code:So, the following code will fail:3, by itself is a primitive. That said, the following will work:That would display the numbers 1, 2, and 3. Because of the parenthesis, the JavaScript interpreter will temporarily wrap the primitive 3 in a Number object, call the method, and then garbage collect the object since it isn\'t needed any longer.Anyway, a full discussion of this can be found in "JavaScript: The Definitive Guide."