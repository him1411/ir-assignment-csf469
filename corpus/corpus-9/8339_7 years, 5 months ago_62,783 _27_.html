I\'m registering a preference change listener like this (in the onCreate() of my main activity):The trouble is, the listener is not always called. It works for the first few times a preference is changed, and then it is no longer called until I uninstall and reinstall the app. No amount of restarting the application seems to fix it.I found a mailing list thread reporting the same problem, but no one really answered him. What am I doing wrong?This is a sneaky one. SharedPreferences keeps listeners in a WeakHashMap. This means that you cannot use an anonymous inner class as a listener, as it will become the target of garbage collection as soon as you leave the current scope. It will work at first, but eventually, will get garbage collected, removed from the WeakHashMap and stop working.Keep a reference to the listener in a field of your class and you will be OK, provided your class instance is not destroyed.i.e. instead of:do this:The reason unregistering in the onDestroy method fixes the problem is because to do that you had to save the listener in a field, therefore preventing the issue. It\'s the saving the listener in a field that fixes the problem, not the unregistering in onDestroy.UPDATE: The Android docs have been updated with warnings about this behavior. So, oddball behavior remains. But now it\'s documented.As this is the most detailed page for the topic I want to add my 50ct.I had the problem that OnSharedPreferenceChangeListener wasn\'t called. My SharedPreferences are retrieved at the start of the main Activity by:My PreferenceActivity code is short and does nothing except showing the preferences:Every time the menu button is pressed I create the PreferenceActivity from the main Activity:Note that registering the OnSharedPreferenceChangeListener needs to be done AFTER creating the PreferenceActivity in this case, else the Handler in the main Activity won\'t be called!!! It took me some sweet time to realize that...this accepted answer is ok, as for me it is creating new instance each time the activity resumesso how about keeping the reference to the listener within the activityand in your onResume and onPausethis will very similar to what you are doing except we are maintaining a hard reference.While reading Word readable data shared by first app,we shouldReplacewithin second app to get updated value in second app.But still it is not working...It make sense that the listeners are kept in WeakHashMap.Because most of the time, developers prefer to writing the code like this.This may seem not bad. But if the OnSharedPreferenceChangeListeners\' container was not WeakHashMap, it would be very bad.If the above code was written in an Activity . Since you are using non-static (anonymous) inner class which will implicitly holds the reference of the enclosing instance. This will cause memory leak.What\'s more, If you keep the listener as a field, you could use registerOnSharedPreferenceChangeListener at the start and call unregisterOnSharedPreferenceChangeListener in the end. But you can not access a local variable in a method out of it\'s scope. So you just have the opportunity to register but no chance to unregister the listener. Thus using WeakHashMap will resolve the problem. This is the way I recommend.If you make the listener instance as a static field, It will avoid the memory leak caused by non-static inner class. But as the listeners could be multiple, It should be instance-related. This will reduce the cost of handling the onSharedPreferenceChanged callback.