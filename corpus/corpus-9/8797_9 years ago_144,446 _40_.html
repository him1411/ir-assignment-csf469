What is the most efficient way given to raise an integer to the power of another integer in C?Exponentiation by squaring.This is the standard method for doing modular exponentiation for huge numbers in asymmetric cryptography.Note that exponentiation by squaring is not the most optimal method. It is probably the best you can do as a general method that works for all exponent values, but for a specific exponent value there might be a better sequence that needs fewer multiplications.For instance, if you want to compute x^15, the method of exponentiation by squaring will give you:This is a total of 6 multiplications.It turns out this can be done using "just" 5 multiplications.I don\'t remember the source now, but I vaguely remember that there are no efficient algorithms to find this optimal sequence of multiplications.Here is the method in JavaIf you need to raise 2 to a power. The fastest way to do so is to bit shift by the power.If you want to get the value of an integer for 2 raised to the power of something it is always better to use the shift option:pow(2,5) can be replaced by 1<<5This is much more efficient.An extremely specialized case is, when you need say 2^(-x to the y), where x, is of course is negative and y is too large to do shifting on an int. You can still do 2^x in constant time by screwing with a float.You can get more powers of 2 by using a double as the base type.\n(Thanks a lot to commenters for helping to square this post away).There\'s also the possibility that learning more about IEEE floats, other special cases of exponentiation might present themselves.Just as a follow up to comments on the efficiency of exponentiation by squaring.The advantage of that approach is that it runs in log(n) time.  For example, if you were going to calculate something huge, such as x^1048575 (2^20 - 1), you only have to go thru the loop 20 times, not 1 million+ using the naive approach.Also, in terms of code complexity, it is simpler than trying to find the most optimal sequence of multiplications, a la Pramod\'s suggestion.Edit:I guess I should clarify before someone tags me for the potential for overflow.  This approach assumes that you have some sort of hugeint library.power() function to work for Integers Only Complexity = O(log(exp))power() function to work for negative exp and float base.Complexity = O(log(exp))Late to the party:  Below is a solution that also deals with y < 0 as best as it can.  pow(0,negative), another undefined result, returns INTMAX_MAXThis code uses a forever loop for(;;) to avoid the final base *= base common in other looped solutions.  That multiplication is 1) not needed and 2) could be int*int overflow which is UB.One more implementation (in Java). May not be most efficient solution but # of iterations is same as that of Exponential solution.more generic solution considering negative exponenetI have implemented algorithm that memorizes all computed powers and then uses them when need. So for example x^13 is equal to (x^2)^2^2 * x^2^2 * x where x^2^2 it taken from the table instead of computing it once again. \nThe number of multiplication needed is Ceil(Log n)I use recursive, if the exp is even,5^10 =25^5.I\'ve found a way that seems kinda fast compared to a for loop, a giant switch statement.\nOk, maybe it\'s not the fanciest way to do it, but having a switch with cases ranging from -50 (or another number, depends on your needs) to +50 and in each of them having something like return number * number * ...; break; and so on.\nThis takes 0.001 seconds for 1M runs with double precision numbers.\nFor integers it is way faster.\nYou can find an example header at upitasoft.com/links/powLUT.txtThe only flaw I can think of is cache memory, with such a big statement you can have some problems, but it\'s only hypotetic.However, you can still limit the size of the switch, usually the power is not higher then 20-25.My case is a little different, I\'m trying to create a mask from a power, but I thought I\'d share the solution I found anyway.Obviously, it only works for powers of 2.Ignoring the special case of 2 raised to a power, the most efficient way is going to be simple iteration.EDIT: As has been pointed out this is not the most efficient way... so long as you define efficiency as cpu cycles which I guess is fair enough.