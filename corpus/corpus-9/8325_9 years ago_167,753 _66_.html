For example:Expected output:Try:You might have to activate RTTI in your compiler options for this to work. Additionally, the output of this depends on the compiler. It might be a raw type name or a name mangling symbol or anything in between.C++11 update to a very old question: Print variable type in C++.The accepted (and good) answer is to use typeid(a).name(), where a is a variable name.Now in C++11 we have decltype(x), which can turn an expression into a type.  And decltype() comes with its own set of very interesting rules.  For example decltype(a) and decltype((a)) will generally be different types (and for good and understandable reasons once those reasons are exposed).Will our trusty typeid(a).name() help us explore this brave new world?No.But the tool that will is not that complicated.  And it is that tool which I am using as an answer to this question.  I will compare and contrast this new tool to typeid(a).name().  And this new tool is actually built on top of typeid(a).name().The fundamental issue:throws away cv-qualifiers, references, and lvalue/rvalue-ness.  For example:For me outputs:and I\'m guessing on MSVC outputs:I.e. the const is gone.  This is not a QOI (Quality Of Implementation) issue.  The standard mandates this behavior.What I\'m recommending below is:which would be used like this:and for me outputs:<disclaimer> I have not tested this on MSVC. </disclaimer>  But I welcome feedback from those who do.The C++11 SolutionI am using __cxa_demangle for non-MSVC platforms as recommend by ipapadop in his answer to demangle types.  But on MSVC I\'m trusting typeid to demangle names (untested).  And this core is wrapped around some simple testing that detects, restores and reports cv-qualifiers and references to the input type.The ResultsWith this solution I can do this:and the output is:Note (for example) the difference between decltype(i) and decltype((i)).  The former is the type of the declaration of i.  The latter is the "type" of the expression i. (expressions never have reference type, but as a convention decltype represents lvalue expressions with lvalue references).Thus this tool is an excellent vehicle just to learn about decltype, in addition to exploring and debugging your own code.In contrast, if I were to build this just on typeid(a).name(), without adding back lost cv-qualifiers or references, the output would be:I.e. Every reference and cv-qualifier is stripped off.C++14 UpdateJust when you think you\'ve got a solution to a problem nailed, someone always comes out of nowhere and shows you a much better way. :-)This answer from Jamboree shows how to get the type name in C++14 at compile time.  It is a brilliant solution for a couple reasons:Jamboree\'s answer doesn\'t quite lay everything out for VS, and I\'m tweaking his code a little bit.  But since this answer gets a lot of views, take some time to go over there and upvote his answer, without which, this update would never have happened.This code will auto-backoff on the constexpr if you\'re still stuck in ancient C++11.  And if you\'re painting on the cave wall with C++98/03, the noexcept is sacrificed as well.C++17 UpdateIn the comments below Lyberta points out that the new std::string_view can replace static_string:Don\'t forget to include <typeinfo>I believe what you are referring to is runtime type identification. You can achieve the above by doing .Very ugly but does the trick if you only want compile time info (e.g. for debugging):Returns:Note that the names generated by the RTTI feature of C++ is not portable.\nFor example, the classwill have the following names:So you can\'t use this information for serialization. But still, the typeid(a).name() property can still be used for log/debug purposesYou can use templates.In the example above, when the type is not matched it will print "unknown". As mentioned, typeid().name() may return a mangled name. In GCC (and some other compilers) you can work around it with the following code:}You could use a traits class for this. Something like:The DECLARE_TYPE_NAME define exists to make your life easier in declaring this traits class for all the types you expect to need.This might be more useful than the solutions involving typeid because you get to control the output. For example, using typeid for long long on my compiler gives "x".The other answers involving RTTI (typeid) are probably what you want, as long as:The alternative, (similar to Greg Hewgill\'s answer), is to build a compile-time table of traits.Be aware that if you wrap the declarations in a macro, you\'ll have trouble declaring names for template types taking more than one parameter (e.g. std::map), due to the comma.To access the name of the type of a variable, all you need isA more generic solution without function overloading than my previous one:Here MyClass is user defined class. More conditions can be added here as well.Example:Output:I like Nick\'s method, A complete form might be this (for all basic data types):You may also use c++filt with option -t (type) to demangle the type name:Tested on linux only.In C++11, we have decltype. There is no way in standard c++ to display exact type of variable declared using decltype. We can use boost typeindex i.e type_id_with_cvr (cvr stands for const, volatile, reference) to print type like below.Output:As I challenge I decided to test how far can one go with platform-independent (hopefully) template trickery.The names are assembled completely at compilation time. (Which means typeid(T).name() couldn\'t be used, thus you have to explicitly provide names for non-compound types. Otherwise placeholders will be displayed instead.)Example usage:Code: