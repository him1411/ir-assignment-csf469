If I include <stdlib.h> or <stdio.h> in a C program I don\'t have to link these when compiling but I do have to link to <math.h>, using -lm with gcc, for example:What is the reason for this? Why do I have to explicitly link the math library but not the other libraries?The functions in stdlib.h and stdio.h have implementations in libc.so (or libc.a for static linking), which is linked into your executable by default (as if -lc were specified).  GCC can be instructed to avoid this automatic link with the -nostdlib or -nodefaultlibs options.The math functions in math.h have implementations in libm.so (or libm.a for static linking), and libm is not linked in by default.  There are historical reasons for this libm/libc split, none of them very convincing.Interestingly, the C++ runtime libstdc++ requires libm, so if you compile a C++ program with GCC (g++), you will automatically get libm linked in.Remember that C is an old language and that FPUs are a relatively recent phenomenon. I first saw C on 8-bit processors where it was a lot of work to do even 32-bit integer arithmetic. Many of these implementations didn\'t even have a floating point math library available!Even on the first 68000 machines (Mac, Atari ST, Amiga), floating point coprocessors were often expensive add-ons.To do all that floating point math, you needed a pretty sizable library. And the math was going to be slow. So you rarely used floats. You tried to do everything with integers or scaled integers. When you had to include math.h, you gritted your teeth. Often, you\'d write your own approximations and lookup tables to avoid it.Trade-offs existed for a long time. Sometimes there were competing math packages called "fastmath" or such. What\'s the best solution for math? Really accurate but slow stuff? Inaccurate but fast? Big tables for trig functions? It wasn\'t until coprocessors were guaranteed to be in the computer that most implementations became obvious. I imagine that there\'s some programmer out there somewhere right now, working on an embedded chip, trying to decide whether to bring in the math library to handle some math problem.That\'s why math wasn\'t standard. Many or maybe most programs didn\'t use a single float. If FPUs had always been around and floats and doubles were always cheap to operate on, no doubt there would have been a "stdmath".An explanation is given here:So if your program is using math functions and including math.h, then you need to explicitly link the math library by passing the -lm flag. The reason for this particular separation is that mathematicians are very picky about the way their math is being computed and they may want to use their own implementation of the math functions instead of the standard implementation. If the math functions were lumped into libc.a it wouldn\'t be possible to do that.[Edit]I\'m not sure I agree with this, though. If you have a library which provides, say, sqrt(), and you pass it before the standard library, a Unix linker will take your version, right?As ephemient said, the C library libc is linked by default and this library contains the implementations of stdlib.h, stdio.h and several other standard header files. Just to add to it, according to "An Introduction to GCC" the linker command for a basic "Hello World" program in C is as below:Notice the option -lc in the third line that links the C library.stdio is part of the standard C library which, by default, gcc will link against.The math function implementations are in a separate libm file that is not linked to by default so you have to specify it -lm. By the way, there is no relation between those header files and library files. I think it\'s kind of arbitrary.  You have to draw a line somewhere (which libraries are default and which need to be specified).It gives you the opportunity to replace it with a different one that has the same functions, but I don\'t think it\'s very common to do so.EDIT: (from my own comments): I think gcc does this to maintain backwards compatibility with the original cc.  My guess for why cc does this is because of build time -- cc was written for machines with far less power than we have now.  A lot of programs have no floating-point math and they probably took every library that wasn\'t commonly used out of the default.  I\'m guessing that the build time of the UNIX OS and the tools that go along with it were the driving force.There\'s a thorough discussion of linking to external libraries in An Introduction to GCC - Linking with external libraries.  If a library is a member of the standard libraries (like stdio), then you don\'t need to specify to the compiler (really the linker) to link them.EDIT: After reading some of the other answers and comments, I think the libc.a reference and the libm reference that it links to both have a lot to say about why the two are separate.Note that many of the functions in \'libm.a\' (the math library) are defined in \'math.h\' but are not present in libc.a. Some are, which may get confusing, but the rule of thumb is this--the C library contains those functions that ANSI dictates must exist, so that you don\'t need the -lm if you only use ANSI functions. In contrast, `libm.a\' contains more functions and supports additional functionality such as the matherr call-back and compliance to several alternative standards of behavior in case of FP errors. See section libm, for more details. If I put stdlib.h or stdio.h, I don\'t have to link those but I have to link when I compile:stdlib.h, stdio.h are the header files. You include them for your convenience. They only forecast what symbols will become available if you link in the proper library. The implementations are in the library files, that\'s where the functions really live.Including math.h is only the first step to gaining access to all the math functions.Also, you don\'t have to link against libm if you don\'t use it\'s functions, even if you do a #include <math.h> which is only an informational step for you, for the compiler about the symbols.stdlib.h, stdio.h refer to functions available in libc, which happens to be always linked in so that the user doesn\'t have to do it himself.I would guess that it is a way to make apps which don\'t use it at all perform slightly better. Here\'s my thinking on this.x86 OSes (and I imagine others) need to store FPU state on context switch. However, most OSes only bother to save/restore this state after the app attempts to use the FPU for the first time.In addition to this, there is probably some basic code in the math library which will set the FPU to a sane base state when the library is loaded.So, if you don\'t link in any math code at all, none of this will happen, therefore the OS doesn\'t have to save/restore any FPU state at all, making context switches slightly more efficient.Just a guess though.EDIT: in response to some of the comments, the same base premise still applies to non-FPU cases (the premise being that it was to make apps which didn\'t make use libm perform slightly better).For example, if there is a soft-FPU which was likley in the early days of C. Then having libm separate could prevent a lot of large (and slow if it was used) code from unnecessarily being linked in.In addition, if there is only static linking available, then a similar argument applies that it would keep executable sizes and compile times down.