I just noticed that you can not use standard math operators on an enum such as ++ or +=So what is the best way to iterate through all of the values in a C++ enum?The typical way is as follows:Of course, this breaks down if the enum values are specified:This illustrates that an enum is not really meant to iterate through. The typical way to deal with an enum is to use it in a switch statement.If you really want to enumerate, stuff the enum values in a vector and iterate over that. This will properly deal with the specified enum values as well.One of many approaches: When enum Just Isn\'t Enough: Enumeration Classes for C++.And, if you want something more encapsulated, try this approach from James Kanze.If your enum starts with 0 and the increment is always 1.If not I guess the only why is to create something like aadd the items, and use normal iterators....With c++11, there actually is an alternative: writing a simple templatized custom iterator.let\'s assume your enum isThis generic code will do the trick, quite efficiently - place in a generic header, it\'ll serve you for any enum you may need to iterate over:You\'ll need to specialize itAnd then you can iterate using range-forThe assumption that you don\'t have gaps in your enum is still true; there is no assumption on the number of bits actually needed to store the enum value (thanks to std::underlying_type)You can\'t with an enum.  Maybe an enum isn\'t the best fit for your situation.A common convention is to name the last enum value something like MAX and use that to control a loop using an int.too much complicated these solution, i do like that :You can try and define the following macro:Now you can use it:It can be used to iterate backwards and forwards through unsigned, integers, enums and chars:Despite its awkward definition it is optimized very well. I looked at disassembler in VC++.\nThe code is extremely efficient. Don\'t be put off but the three for statements: the compiler will produce only one loop after optimization! You can even define enclosed loops:You obviously cannot iterate through enumerated types with gaps. Something that hasn\'t been covered in the other answers = if you\'re using strongly typed C++11 enums, you cannot use ++ or + int on them.  In that case, a bit of a messier solution is required:You can also overload the increment/decrement operators for your enumerated type.If you do not like to pollute you enum with a final COUNT item (because maybe if you also use the enum in a switch then then the compiler will warn you of a missing case COUNT:), you can do this:For MS compilers:Note: this is a lot less code than the simple templatized custom iterator answer.You can get this to work with GCC by using typeof instead of decltype, but I don\'t have that compiler handy at the moment to make sure it compiles.C++ doesn\'t have introspection, so you can\'t determine this kind of thing at run-time.If you knew that the enum values were sequential, for example the Qt:Key enum, you could:It works as expected.I often do it like thator if not successive, but with regular step (e.g. bit flags)