In C, there appear to be differences between various values of zero -- NULL, NUL and 0.I know that the ASCII character \'0\' evaluates to 48 or 0x30.The NULL pointer is usually defined as:OrIn addition, there is the NUL character \'\\0\' which seems to evaluate to 0 as well.Are there times when these three values can not be equal?Is this also true on 64 bit systems?Note: This answer applies to the C language, not C++.The integer constant literal 0 has different meanings depending upon the context in which it\'s used. In all cases, it is still an integer constant with the value 0, it is just described in different ways.If a pointer is being compared to the constant literal 0, then this is a check to see if the pointer is a null pointer. This 0 is then referred to as a null pointer constant. The C standard defines that 0 cast to the type void * is both a null pointer and a null pointer constant.Additionally, to help readability, the macro NULL is provided in the header file stddef.h. Depending upon your compiler it might be possible to #undef NULL and redefine it to something wacky.Therefore, here are some valid ways to check for a null pointer:NULL is defined to compare equal to a null pointer.  It is implementation defined what the actual definition of NULL is, as long as it is a valid null pointer constant.0 is another representation of the null pointer constant.This if statement implicitly checks "is not 0", so we reverse that to mean "is 0".The following are INVALID ways to check for a null pointer:To the compiler this is not a check for a null pointer, but an equality check on two variables. This might work if mynull never changes in the code and the compiler optimizations constant fold the 0 into the if statement, but this is not guaranteed and the compiler has to produce at least one diagnostic message (warning or error) according to the C Standard.Note that what is a null pointer in the C language. It does not matter on the underlying architecture. If the underlying architecture has a null pointer value defined as address 0xDEADBEEF, then it is up to the compiler to sort this mess out.As such, even on this funny architecture, the following ways are still valid ways to check for a null pointer:The following are INVALID ways to check for a null pointer:as these are seen by a compiler as normal comparisons. \'\\0\' is defined to be a null character - that is a character with all bits set to zero. This has nothing to do with pointers. However you may see something similar to this code:checks if the string pointer is pointing at a null characterchecks if the string pointer is pointing at a non-null characterDon\'t get these confused with null pointers. Just because the bit representation is the same, and this allows for some convenient cross over cases, they are not really the same thing. Additionally, \'\\0\' is (like all character literals) an integer constant, in this case with the value zero.  So \'\\0\' is completely equivalent to an unadorned 0 integer constant - the only difference is in the intent that it conveys to a human reader ("I\'m using this as a null character.").See Question 5.3 of the comp.lang.c FAQ for more.\nSee this pdf for the C standard. Check out sections 6.3.2.3 Pointers, paragraph 3.It appears that a number of people misunderstand what the differences between NULL, \'\\0\' and 0 are. So, to explain, and in attempt to avoid repeating things said earlier:A constant expression of type int with the value 0, or an expression of this type, cast to type void * is a null pointer constant, which if converted to a pointer becomes a null pointer. It is guaranteed by the standard to compare unequal to any pointer to any object or function.NULL is a macro, defined in  as a null pointer constant.\'\\0\' is a construction used to represent the null character, used to terminate a string. A null character is a byte which has all its bits set to 0.All three define the meaning of zero in different context.These three are always different when you look at the memory:I hope this clarifies it.What is the difference between NULL, \xe2\x80\x98\\0\xe2\x80\x99 and 0"null character (NUL)" is easiest to rule out.  \'\\0\' is a character literal.\nIn C, it is implemented as int, so, it\'s the same as 0, which is of INT_TYPE_SIZE. In C++, character literal is implemented as char, which is 1 byte. This is normally different from NULL or 0.Next, NULL is a pointer value that specifies that a variable does not point to any address space. Set aside the fact that it is usually implemented as zeros, it must be able to express the full address space of the architecture. Thus, on a 32-bit architecture NULL (likely) is 4-byte and on 64-bit architecture 8-byte. This is up to the implementation of C.Finally, the literal 0 is of type int, which is of size INT_TYPE_SIZE. The default value of INT_TYPE_SIZE could be different depending on architecture.Apple wrote:The 64-bit data model used by Mac OS X is known as "LP64". This is the common data model used by other 64-bit UNIX systems from Sun and SGI as well as 64-bit Linux. The LP64 data model defines the primitive types as follows:Wikipedia 64-bit:Microsoft\'s VC++ compiler uses the LLP64 model.Edit:\nAdded more on the character literal.The above code returns 4 on gcc and 1 on g++.If NULL and 0 are equivalent as null pointer constants, which should I use? in the C FAQ list addresses this issue as well:C programmers must understand that\n  NULL and 0 are interchangeable in\n  pointer contexts, and that an uncast 0\n  is perfectly acceptable. Any usage of\n  NULL (as opposed to 0) should be\n  considered a gentle reminder that a\n  pointer is involved; programmers\n  should not depend on it (either for\n  their own understanding or the\n  compiler\'s) for distinguishing pointer\n  0\'s from integer 0\'s.It is only in pointer contexts that\n  NULL and 0 are equivalent. NULL should\n  not be used when another kind of 0 is\n  required, even though it might work,\n  because doing so sends the wrong\n  stylistic message. (Furthermore, ANSI\n  allows the definition of NULL to be\n  ((void *)0), which will not work at\n  all in non-pointer contexts.) In\n  particular, do not use NULL when the\n  ASCII null character (NUL) is desired.\n  Provide your own definitionif you must.A one-L NUL, it ends a string. A two-L NULL points to no thing. And I will bet a golden bull That there is no three-L NULLL.How do you deal with NUL?"NUL" is not 0, but refers to the ASCII NUL character. At least, that\'s how I\'ve seen it used.  The null pointer is often defined as 0, but this depends on the environment you are running in, and the specification of whatever operating system or language you are using.In ANSI C, the null pointer is specified as the integer value 0.  So any world where that\'s not true is not ANSI C compliant.One good piece which helps me when starting with C(Taken from the Expert C Programming by Linden)The One \'l\' nul and the Two \'l\' nullMemorize this little rhyme to recall the correct terminology for pointers and ASCII zero:The one "l" NULends an ASCII string,The two "l" NULLpoints to no thing.Apologies to Ogden Nash, but the three "l" nulll means check your spelling. The ASCII \ncharacter with the bit pattern of zero is termed a "NUL". The special pointer value that \nmeans the pointer points nowhere is "NULL". The two terms are not interchangeable in \nmeaning. A byte with a value of 0x00 is, on the ASCII table, the special character called "NUL" or "NULL". In C, since you shouldn\'t embed control characters in your source code, this is represented in C strings with an escaped 0, i.e., "\\0".But a true NULL is not a value. It is the absence of a value. For a pointer, it means the pointer has nothing to point to. In a database, it means there is no value in a field (which is not the same thing as saying the field is blank, 0, or filled with spaces).The actual value a given system or database file format uses to represent a NULL isn\'t necessarily 0x00.NULL is not guaranteed to be 0 -- its exact value is architecture-dependent. Most major architectures define it to (void*)0.\'\\0\' will always equal 0, because that is how byte 0 is encoded in a character literal.I don\'t remember whether C compilers are required to use ASCII -- if not, \'0\' might not always equal 48. Regardless, it\'s unlikely you\'ll ever encounter a system which uses an alternative character set like EBCDIC unless you\'re working on very obscure systems.The sizes of the various types will differ on 64-bit systems, but the integer values will be the same.Some commenters have expressed doubt that NULL be equal to 0, but not be zero. Here is an example program, along with expected output on such a system:That program could print:(void*) 0 is NULL, and \'\\0\' represents the end of a string.