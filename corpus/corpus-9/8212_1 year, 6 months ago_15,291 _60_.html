I was told today that it\'s possible to invoke a function without parentheses. The only ways I could think of was using functions like apply or call.But these require parentheses on apply and call leaving us at square one. I also considered the idea of passing the function to some sort of event handler such as setTimeout:But then the question becomes "how do you invoke setTimeout without parentheses?"So what\'s the solution to this riddle? How can you invoke a function in Javascript without using parentheses?The easiest way to do that is with the new operator:While that\'s unorthodox and unnatural, it works and is perfectly legal.The new operator doesn\'t require parentheses if no parameters are used.There are several different ways to call a function without parentheses. Let\'s assume you have this function defined:Then here follow some ways to call greet without parentheses:With new you can invoke a function without parentheses:From MDN on the new oprator:SyntaxtoString and valueOf are special methods: they get called implicitly when a conversion is necessary:You could (ab)use this pattern to call greet without parentheses:Or with valueOf:You could take the previous idea to override the valueOf method on the Function prototype: Once you have done that, you can write:And although there are parentheses involved down the line, the actual triggering invocation has no parentheses. See more about this in the blog "Calling methods in JavaScript, without really calling them"You could define a generator function (with *), which returns an iterator. You can call it using the spread syntax or with the for...of syntax. First we need a generator variant of the original greet function:And then we call it without parentheses: Normally generators would have a yield keyword somewhere, but it is not needed for the function to get called.The last statement invokes the function, but that could also be done with destructuring:or a for ... of construct:Note that you can do the above with the original greet function as well, but it will trigger an exception in the process, after greet has been executed (tested on FF and Chrome). You could manage the exception with a try...catch block.@jehna1 has a full answer on this, so give him credit. Here is a way to call a function parentheses-less on the global scope, avoiding the deprecated __defineGetter__ method. It uses Object.defineProperty instead.We need to create a variant of the original greet function for this:And then:Replace window with whatever your global object is.You could call the original greet function without leaving a trace on the global object like this:But one could argue we do have parentheses here (although they are not involved in the actual invocation).With ES6 you can call a function passing it a template literal with this syntax:See "Tagged Template Literals". Normally you would not pass an empty literal like here, but as example of a parentheses-less call, it will do.In ES6, you can define a proxy:And then reading any property value will invoke greet:There are many variations of this. One more example:You can use getters and setters.Run this script just with:Edit:We can even do arguments!Edit 2:You can also define global functions that can be run without parenthesis:And with arguments:Disclaimer:As @MonkeyZeus stated: Never ever shall you use this piece of code in production, no matter how good your intentions.Here\'s an example for a particular situation:Although that statement is not actually invoking but will lead to a future invocation.But, I figure grey-areas might be ok for riddles like this :)If we accept a lateral thinking approach, in a browser there are several API\'s we can abuse to execute arbitrary JavaScript, including calling a function, without any actual parenthesis characters.One such technique is to abuse the javascript: protocol on location assignment.Working Example:Although technically \\x28 and \\x29 are still parenthesis once the code is evaluated, the actual ( and ) character does not appear. The parentheses are escaped in a string of JavaScript which gets evaluated on assignment.Similarly, depending on the browser we can abuse the global onerror, by setting it to eval, and throwing something that will stringify to valid JavaScript. This one is trickier, because browsers are inconsistent in this behavior, but here\'s an example for Chrome.Working example for Chrome (not Firefox, others untested):This works in Chrome because throw\'test\' will pass \'Uncaught test\' as the first argument to onerror, which is almost valid JavaScript. If we instead do throw\';test\' it will pass \'Uncaught ;test\'. Now we have valid JavaScript! Just define Uncaught, and replace test with the payload.Such code is truly awful, and should never be used, but is sometimes used in XSS attacks, so the moral of the story is don\'t rely on filtering parenthesis to prevent XSS. Using a CSP to prevent such code would also be a good idea.