I have a generic method defined like this:The first thing I want to do is check if the value of myArgument is the default value for that type, something like this:But this doesn\'t compile because I haven\'t guaranteed that T will implement the == operator.  So I switched the code to this:Now this compiles, but will fail if myArgument is null, which is part of what I\'m testing for.  I can add an explicit null check like this:Now this feels redundant to me.  ReSharper is even suggesting that I change the myArgument == null part into myArgument == default(T) which is where I started.  Is there a better way to solve this problem?I need to support both references types and value types.To avoid boxing, the best way to compare generics for equality is with EqualityComparer<T>.Default. This respects IEquatable<T> (without boxing) as well as object.Equals, and handles all the Nullable<T> "lifted" nuances. Hence:This will match:How about this:Using the static object.Equals() method avoids the need for you to do the null check yourself. Explicitly qualifying the call with object. probably isn\'t necessary depending on your context, but I normally prefix static calls with the type name just to make the code more soluble.I was able to locate a Microsoft Connect article that discusses this issue in some detail:Unfortunately, this behavior is by design and there is not an easy solution to enable use of with type parameters that may contain value types.If the types are known to be reference types, the default overload of defined on object tests variables for reference equality, although a type may specify its own custom overload. The compiler determines which overload to use based on the static type of the variable (the determination is not polymorphic). Therefore, if you change your example to constrain the generic type parameter T to a non-sealed reference type (such as Exception), the compiler can determine the specific overload to use and the following code would compile:If the types are known to be value types, performs specific value equality tests based on the exact types used. There is no good "default" comparison here since reference comparisons are not meaningful on value types and the compiler cannot know which specific value comparison to emit. The compiler could emit a call to ValueType.Equals(Object) but this method uses reflection and is quite inefficient compared to the specific value comparisons. Therefore, even if you were to specify a value-type constraint on T, there is nothing reasonable for the compiler to generate here:In the case you presented, where the compiler does not even know whether T is a value or reference type, there is similarly nothing to generate that would be valid for all possible types. A reference comparison would not be valid for value types and some sort of value comparison would be unexpected for reference types that do not overload.Here is what you can do...I have validated that both of these methods work for a generic comparison of reference and value types:orTo do comparisons with the "==" operator you will need to use one of these methods:If all cases of T derive from a known base class you can let the compiler know using generic type restrictions.The compiler then recognizes how to perform operations on MyBase and will not throw the "Operator \'==\' cannot be applied to operands of type \'T\' and \'T\'" error that you are seeing now.Another option would be to restrict T to any type that implements IComparable.And then use the CompareTo method defined by the IComparable interface.Try this:that should compile, and do what you want.(Edited)Marc Gravell has the best answer, but I wanted to post a simple code snippet I worked up to demonstrate it.  Just run this in a simple C# console app:One more thing: can someone with VS2008 try this as an extension method?  I\'m stuck with 2005 here and I\'m curious to see if that would be allowed.Edit: Here is how to get it working as an extension method:To handle all types of T, including where T is a primitive type, you\'ll need to compile in both methods of comparison:There is going to be a problem here -If you\'re going to allow this to work for any type, default(T) will always be null for reference types, and 0 (or struct full of 0) for value types.This is probably not the behavior you\'re after, though.  If you want this to work in a generic way, you probably need to use reflection to check the type of T, and handle value types different than reference types.Alternatively, you could put an interface constraint on this, and the interface could provide a way to check against the default of the class/struct.I think you probably need to split this logic into two parts and check for null first.In the IsNull method, we\'re relying on the fact that ValueType objects can\'t be null by definition so if value happens to be a class which derives from ValueType, we already know it\'s not null. On the other hand, if it\'s not a value type then we can just compare value cast to an object against null. We could avoid the check against ValueType by going straight to a cast to object, but that would mean that a value type would get boxed which is something we probably want to avoid since it implies that a new object is created on the heap.In the IsNullOrEmpty method, we\'re checking for the special case of a string. For all other types, we\'re comparing the value (which already know is not null) against it\'s default value which for all reference types is null and for value types is usually some form of zero (if they\'re integral).Using these methods, the following code behaves as you might expect:Don\'t know if this works with your requirements or not, but you could constrain T to be a Type that implements an interface such as IComparable and then use the ComparesTo() method from that interface (which IIRC supports/handles nulls) like this:There are probably other interfaces that you could use as well IEquitable, etc.@ilitirit:Operator \'==\' cannot be applied to operands of type \'T\' and \'T\'I can\'t think of a way to do this without the explicit null test followed by invoking the Equals method or object.Equals as suggested above.You can devise a solution using System.Comparison but really that\'s going to end up with way more lines of code and increase complexity substantially.I think you were close.Now this compiles, but will fail if myArgument is null, which is part of what I\'m testing  for. I can add an explicit null check like this:You just need to reverse the object on which the equals is being called for an elegant null-safe approach.