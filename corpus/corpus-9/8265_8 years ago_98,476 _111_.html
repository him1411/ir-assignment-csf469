My web application uses sessions to store information about the user once they\'ve logged in, and to maintain that information as they travel from page to page within the app. In this specific application, I\'m storing the user_id, first_name and last_name of the person. I\'d like to offer a "Keep Me Logged In" option on log in that will put a cookie on the user\'s machine for two weeks, that will restart their session with the same details when they return to the app.What is the best approach for doing this? I don\'t want to store their user_id in the cookie, as it seems like that would make it easy for one user to try and forge the identity of another user.Security Notice: Basing the cookie off an MD5 hash of deterministic data is a bad idea; it\'s better to use a random token derived from a CSPRNG. See ircmaxell\'s answer to this question for a more secure approach.Usually I do something like this:Off course you can use different cookie names etc. also you can change the content of the cookie a bit, just make sure it isn\'t to easily created. You can for example also create a user_salt when the user is created and also put that in the cookie. Also you could use sha1 instead of md5 (or pretty much any algorithm)OK, let me put this bluntly: if you\'re putting user data, or anything derived from user data into a cookie for this purpose, you\'re doing something wrong. There. I said it. Now we can move on to the actual answer.What\'s wrong with hashing user data, you ask? Well, it comes down to exposure surface and security through obscurity. Imagine for a second that you\'re an attacker. You see a cryptographic cookie set for the remember-me on your session. It\'s 32 characters wide. Gee. That may be an MD5...Let\'s also imagine for a second that they know the algorithm that you used. For example:Now, all an attacker needs to do is brute force the "salt" (which isn\'t really a salt, but more on that later), and he can now generate all the fake tokens he wants with any username for his IP address! But brute-forcing a salt is hard, right? Absolutely. But modern day GPUs are exceedingly good at it. And unless you use sufficient randomness in it (make it large enough), it\'s going to fall quickly, and with it the keys to your castle.In short, the only thing protecting you is the salt, which isn\'t really protecting you as much as you think.But Wait!All of that was predicated that the attacker knows the algorithm! If it\'s secret and confusing, then you\'re safe, right? WRONG. That line of thinking has a name: Security Through Obscurity, which should NEVER be relied upon.The Better WayThe better way is to never let a user\'s information leave the server, except for the id. When the user logs in, generate a large (128 to 256 bit) random token. Add that to a database table which maps the token to the userid, and then send it to the client in the cookie.What if the attacker guesses the random token of another user? Well, let\'s do some math here. We\'re generating a 128 bit random token. That means that there are:Now, to show how absurdly large that number is, let\'s imagine every server on the internet (let\'s say 50,000,000 today) trying to brute-force that number at a rate of 1,000,000,000 per second each. In reality your servers would melt under such load, but let\'s play this out.So 50 quadrillion guesses per second. That\'s fast! Right?So 6.8 sextillion seconds... Let\'s try to bring that down to more friendly numbers.Or even better:Yes, that\'s 47917 times the age of the universe... Basically, it\'s not going to be cracked.So to sum up:The better approach that I recommend is to store the cookie with three parts. Then, to validate:Note: Do not use the token or combination of user and token to lookup a record in your database. Always be sure to fetch a record based on the user and use a timing-safe comparison function to compare the fetched token afterwards. More about timing attacks.Now, it\'s very important that the SECRET_KEY be a cryptographic secret (generated by something like /dev/urandom and/or derived from a high-entropy input). Also, GenerateRandomToken() needs to be a strong random source (mt_rand() is not nearly strong enough. Use a library, such as RandomLib or random_compat, or mcrypt_create_iv() with DEV_URANDOM)...The hash_equals() is to prevent timing attacks.\nIf you use a PHP version below PHP 5.6 the function hash_equals() is not supported. In this case you can replace hash_equals() with the timingSafeCompare function:IntroductionYour title \xe2\x80\x9cKeep Me Logged In\xe2\x80\x9d - the best approach make it difficult for me to know where to start because if you are looking at best approach then you would have to consideration the following :CookiesCookies are vulnerable, Between common browser cookie-theft vulnerabilities and cross-site scripting attacks we must accept that cookies are not safe. To help improve security you must note that php setcookies has additional functionality such as bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false ]]]]]] )Definitions Simple Approach A simple solution would be :The above case study summarizes all example given on this page but they disadvantages is that Better SolutionA better solution would be Example Code Class Used Testing in Firefox & Chrome Advantage Disadvantage Quick FixMultiple Cookie ApproachWhen an attacker is about to steal cookes the only focus it on a particular website or domain eg. example.comBut really you can authenticate a user from 2 different domains (example.com & fakeaddsite.com) and make it look like "Advert Cookie" Some people might wonder how can you use 2 different cookies ? Well its possible, imagine example.com = localhost and fakeaddsite.com = 192.168.1.120. If you inspect the cookies it would look like this From the image above 192.168.1.120AdvantageDisadvantage Improvement There are two very interesting articles, I found while searching for a perfect solution for the "remember-me"-problem:I asked one angle of this question here, and the answers will lead you to all the token-based timing-out cookie links you need.Basically, you do not store the userId in the cookie. You store a one-time token (huge string) which the user uses to pick-up their old login session. Then to make it really secure, you ask for a password for heavy operations (like changing the password itself).I would recommend the approach mentioned by Stefan (i.e. follow the guidelines in Improved Persistent Login Cookie Best Practice) and also recommend that you make sure your cookies are HttpOnly cookies so they are not accessible to, potentially malicious, JavaScript.Generate a hash, maybe with a secret only you know, then store it in your DB so it can be associated with the user. Should work quite well.Old thread, but still a valid concern. I noticed some good responses about security, and avoiding use of \'security through obscurity\', but the actual technical methods given were not sufficient in my eyes. Things I must say before I contribute my method:That all being said, there are two great ways to have auto-signin on your system.First, the cheap, easy way that puts it all on someone else. If you make your site support logging in with, say, your google+ account, you probably have a streamlined google+ button that will log the user in if they are already signed into google (I did that here to answer this question, as I am always signed into google). If you want the user automatically signed in if they are already signed in with a trusted and supported authenticator, and checked the box to do so, have your client-side scripts perform the code behind the corresponding \'sign-in with\' button before loading, just be sure to have the server store a unique ID in an auto-signin table that has the username, session ID, and the authenticator used for the user. Since these sign-in methods use AJAX, you are waiting for a response anyway, and that response is either a validated response or a rejection. If you get a validated response, use it as normal, then continue loading the logged in user as normal. Otherwise, the login failed, but don\'t tell the user, just continue as not logged in, they will notice. This is to prevent an attacker who stole cookies (or forged them in an attempt to escalate privileges) from learning that the user auto-signs into the site.This is cheap, and might also be considered dirty by some because it tries to validate your potentially already signed in self with places like Google and Facebook, without even telling you. It should, however, not be used on users who have not asked to auto-signin your site, and this particular method is only for external authentication, like with Google+ or FB.Because an external authenticator was used to tell the server behind the scenes whether or not a user was validated, an attacker cannot obtain anything other than a unique ID, which is useless on its own. I\'ll elaborate:No matter what, even if an attacker uses an ID that does not exist, the attempt should fail on all attempts except when a validated response is received.This method can and should be used in conjunction with your internal authenticator for those who sign into your site using an external authenticator.=========Now, for your very own authenticator system that can auto-signin users, this is how I do it:DB has a few tables:Note that the username is capable of being 255 characters long. I have my server program limit usernames in my system to 32 characters, but external authenticators might have usernames with their @domain.tld be larger than that, so I just support the maximum length of an email address for maximum compatibility.Note that there is no user field in this table, because the username, when logged in, is in the session data, and the program does not allow null data. The session_id and the session_token can be generated using random md5 hashes, sha1/128/256 hashes, datetime stamps with random strings added to them then hashed, or whatever you would like, but the entropy of your output should remain as high as tolerable to mitigate brute-force attacks from even getting off the ground, and all hashes generated by your session class should be checked for matches in the sessions table prior to attempting to add them.MAC addresses by their nature are supposed to be UNIQUE, therefore it makes sense that each entry has a unique value. Hostnames, on the other hand, could be duplicated on separate networks legitimately. How many people use "Home-PC" as one of their computer names? The username is taken from the session data by the server backend, so manipulating it is impossible. As for the token, the same method to generate session tokens for pages should be used to generate tokens in cookies for the user auto-signin. Lastly, the datetime code is added for when the user would need to revalidate their credentials. Either update this datetime on user login keeping it within a few days, or force it to expire regardless of last login keeping it only for a month or so, whichever your design dictates.This prevents someone from systematically spoofing the MAC and hostname for a user they know auto-signs in. NEVER have the user keep a cookie with their password, clear text or otherwise. Have the token be regenerated on each page navigation, just as you would the session token. This massively reduces the likelihood that an attacker could obtain a valid token cookie and use it to login. Some people will try to say that an attacker could steal the cookies from the victim and do a session replay attack to login. If an attacker could steal the cookies (which is possible), they would certainly have compromised the entire device, meaning they could just use the device to login anyway, which defeats the purpose of stealing cookies entirely. As long as your site runs over HTTPS (which it should when dealing with passwords, CC numbers, or other login systems), you have afforded all the protection to the user that you can within a browser.One thing to keep in mind: session data should not expire if you use auto-signin. You can expire the ability to continue the session falsely, but validating into the system should resume the session data if it is persistent data that is expected to continue between sessions. If you want both persistent AND non-persistent session data, use another table for persistent session data with the username as the PK, and have the server retrieve it like it would the normal session data, just use another variable.Once a login has been achieved in this way, the server should still validate the session. This is where you can code expectations for stolen or compromised systems; patterns and other expected results of logins to session data can often lead to conclusions that a system was hijacked or cookies were forged in order to gain access. This is where your ISS Tech can put rules that would trigger an account lockdown or auto-removal of a user from the auto-signin system, keeping attackers out long enough for the user to determine how the attacker succeeded and how to cut them off.As a closing note, be sure that any recovery attempt, password changes, or login failures past the threshold result in auto-signin being disabled until the user validates properly and acknowledges this has occurred.I apologize if anyone was expecting code to be given out in my answer, that\'s not going to happen here. I will say that I use PHP, jQuery, and AJAX to run my sites, and I NEVER use Windows as a server... ever. My solution is like this. It\'s not 100% bulletproof but I think it will save you for the most of the cases.When user logged in successfully create a string with this information:Encrypt $data, set type to HttpOnly and set cookie.When user come back to your site, Make this steps:If user signouts, remove this cookie. Create new cookie if user re-logins.I don\'t understand the concept of storing encrypted stuff in a cookie when it is the encrypted version of it that you need to do your hacking.  If I\'m missing something, please comment.I am thinking about taking this approach to \'Remember Me\'.  If you can see any issues, please comment.Create a table to store "Remember Me" data in - separate to the user table so that I can log in from multiple devices.On successful login (with Remember Me ticked):a) Generate a unique random string to be used as the UserID on this machine: bigUserIDb) Generate a unique random string: bigKeyc) Store a cookie:  bigUserID:bigKeyd) In the "Remember Me" table, add a record with: UserID, IP Address, bigUserID, bigKeyIf trying to access something that requires login:a) Check for the cookie and search for bigUserID & bigKey with a matching IP addressb) If you find it, Log the person in but set a flag in the user table "soft login" so that for any dangerous operations, you can prompt for a full login.On logout, Mark all the "Remember Me" records for that user as expired.The only vulnerabilities that I can see is;I read all the answers and still found it difficult to extract what I was supposed to do. If a picture is worth 1k words I hope this helps others implement a secure persistent storage based on Barry Jaspan\'s Improved Persistent Login Cookie Best PracticeIf you have questions, feedback, or suggestions, I will try to update the diagram to reflect for the newbie trying to implement a secure persistent login.Implementing a "Keep Me Logged In" feature means you need to define exactly what that will mean to the user. In the simplest case, I would use that to mean the session has a much longer timeout: 2 days (say) instead of 2 hours. To do that, you will need your own session storage, probably in a database, so you can set custom expiry times for the session data. Then you need to make sure you set a cookie that will stick around for a few days (or longer), rather than expire when they close the browser.I can hear you asking "why 2 days? why not 2 weeks?". This is because using a session in PHP will automatically push the expiry back. This is because a session\'s expiry in PHP is actually an idle timeout. Now, having said that, I\'d probably implement a harder timeout value that I store in the session itself, and out at 2 weeks or so, and add code to see that and to forcibly invalidate the session. Or at least to log them out. This will mean that the user will be asked to login periodically. Yahoo! does this.Use some kind of "cookie" hash, the username + md5($ip, $username, $password)? That would be my suggestion. And if(md5($_SERVER[\'REMOTE_ADDR\'], $username, $password) = $cookiehash) ? :) 