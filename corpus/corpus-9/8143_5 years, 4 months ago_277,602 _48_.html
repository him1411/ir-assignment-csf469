I have a simple TCP server that listens on a port.I start it with node server.js and then close it with Ctrl + Z on Mac. When I try to run it again with node server.js I get this error message:Am I closing the program the wrong way? How can I prevent this from happening?To end the program, you should be using Ctrl + C.  If you do that, it sends SIGINT, which allows the program to end gracefully, unbinding from any ports it is listening on.See also:  https://superuser.com/a/262948/48624Ctrl+Z suspends it, which means it can still be running.Ctrl+C will actually kill it.you can also kill it manually like this:Find the process ID (second from the left):This may also workOr alternatively you can do all of these in one line:You can replace node inside \'\\snode\\s\' with any other process name. you can type .exit  to quit node js REPLIf you are running Node.js interactively (the REPL):Ctrl + C will take back you to > prompt then type:or just use Ctrl + D.$ sudo killall node in another terminal works on mac, while killall node not working: If you want to stop your server with npm stop or something like this. You can write the code that kill your server process as: Check this link for the detail: \nhttps://gist.github.com/dominhhai/aa7f3314ad27e2c50fd5Though this is a late answer, I found this from NodeJS docs:The \'exit\' event is emitted when the REPL is exited either by receiving the .exit command as input, the user pressing <ctrl>-C twice to signal SIGINT, or by pressing <ctrl>-D to signal \'end\' on the input stream. The listener callback is invoked without any arguments. So to summarize you can exit by:Ctrl+Z suspends it, which means it is still running as a suspended background process. You are likely now at a terminal prompt... Give the command fg to resume the process in the foreground.type Ctrl+C to properly kill it.(NOTE: the following commands may require root, so sudo ... is your friend)or, if you don\'t have pkill, this may work:or perhaps this:sometimes the process will list its own grep, in which case you\'ll need:.h/t @ruffin from the comments on the question itself. I had the same issue and his comment helped me solve it myself.I\'m adding this answer because for many projects with production deployments, we have scripts that stop these processes so we don\'t have to.A clean way to manage your Node Server processes is using the forever package (from NPM). \nnpm install forever -g\n\nforever start -al ./logs/forever.log -ao ./logs/out.log -ae ./logs/err.log server.js\n\ninfo:    Forever processing file: server.js\n\nforever stop server.js\n\ninfo:    Forever stopped process:\n    uid  command                            script                           forever pid   id logfile                           uptime\n[0] sBSj "/usr/bin/nodejs/node" ~/path/to/your/project/server.js 23084   13176    ~/.forever/forever.log 0:0:0:0.247\nThis will cleanly shutdown your Server application.I ran into an issue where I have multiple node servers running, and I want to just kill one of them and redeploy it from a script.Note: This example is in a bash shell on Mac.To do so I make sure to make my node call as specific as possible. For example rather than calling node server.js from the apps directory, I call node app_name_1/app/server.jsThen I can kill it using:kill -9 $(ps aux | grep \'node\\ app_name_1/app/server.js\' | awk \'{print $2}\')This will only kill the node process running app_name_1/app/server.js.If you ran node app_name_2/app/server.js this node process will continue to run.If you decide you want to kill them all you can use killall node as others have mentioned.