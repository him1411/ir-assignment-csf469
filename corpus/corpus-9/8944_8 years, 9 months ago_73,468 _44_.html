Earlier I asked a question about why I see so many examples use the varkeyword and got the answer that while it is only necessary for anonymous types, that it is used nonetheless to make writing code \'quicker\'/easier and \'just because\'.Following this link ("C# 3.0 - Var Isn\'t Objec") I saw that var gets compiled down to the correct type in the IL (you will see it about midway down article).My question is how much more, if any, IL code does using the var keyword take, and would it be even close to having a measurable level on the performance of the code if it was used everywhere?There\'s no extra IL code for the var keyword: the resulting IL should be identical for non-anonymous types.  If the compiler can\'t create that IL because it can\'t figure out what type you intended to use, you\'ll get a compiler error.The only trick is that var will infer an exact type where you may have chosen an Interface or parent type if you were to set the type manually.I need to update this as my understanding has changed. I now believe it may be possible for var to affect performance in the situation where a method returns an interface, but you would have used an exact type. For example, if you have this method:Consider these three lines of code to call the method: All three compile and execute as expected. However, the first two lines are not exactly the same, and the third line will match the second, rather than the first. Because the signature of Foo() is to return an IList<int>, that is how the compiler will build the bar3 variable.From a performance standpoint, mostly you won\'t notice. However, there are situations where the performance of the third line may not be quite as fast as the performance of the first. As you continue to use the bar3 variable, the compiler may not be able to dispatch method calls the same way. Note that it\'s possible (likely even) the jitter will be able to erase this difference, but it\'s not guaranteed. Generally, you should still consider var to be a non-factor in terms of performance. It\'s certainly not at all like using a dynamic variable. But to say it never makes a difference at all may be overstating it.As Joel says, the compiler works out at compile-time what type var should be, effectively it\'s just a trick the compiler performs to save keystrokes, so for examplegets replaced byby the compiler before any IL is generated. The Generated IL will be exactly the same as if you\'d typed string.As nobody has mentioned reflector yet...If you compile the following C# code:Then use reflector on it, you get:So the answer is clearly no runtime performance hit!The C# compiler infers the true type of the var variable at compile time.  There\'s no difference in the generated IL.For the following method: The IL Output is this:So, to be clear, it\'s a lazy coding style. I prefer native types, given the choice; I\'ll take that extra bit of "noise" to ensure I\'m writing and reading exactly what I think I am at code/debug time. * shrug *I don\'t think you properly understood what you read. If it gets compiled to the correct type, then there is no difference. When I do this:The compiler knows it\'s an int, and generate code as if I had written As the post you linked to says, it gets compiled to the same type. It\'s not a runtime check or anything else requiring extra code. The compiler just figures out what the type must be, and uses that.There is no runtime performance cost to using var.  Though, I would suspect there to be a compiling performance cost as the compiler needs to infer the type, though this will most likely be negligable.If the compiler can do automatic type inferencing, then there wont be any issue with performance. Both of these will generate same codehowever, if you are constructing the type dynamically (LINQ ...) then var is your only question and there is other mechanism to compare to in order to say what is the penalty.I always use the word var in web articles or guides writings.The width of the text editor of online article is small.If I write this:You will see that above rendered pre code text is too long and flows out of the box, it gets hidden. The reader needs to scroll to the right to see the complete syntax.That\'s why I always use the keyword var in web article writings.The whole rendered pre code just fit within the screen.In practice, for declaring object, I seldom use var, I rely on intellisense to declare object faster.Example:But, for returning object from a method, I use var to write code faster.Example:"var" is one of those things that people either love or hate (like regions).  Though, unlike regions, var is absolutely necessary when creating anonymous classes.To me, var makes sense when you are newing up an object directly like:That being said, you can easily just do:Dictionary<string, string> dict = new and intellisense will fill in the rest for you here.  If you only want to work with a specific interface, then you can\'t use var unless the method you are calling returns the interface directly.Resharper seems to be on the side of using "var" all over, which may push more people to do it that way.  But I kind of agree that it is harder to read if you are calling a method and it isn\'t obvious what is being returned by the name.var itself doesn\'t slow things down any, but there is one caveat to this that not to many people think about.  If you do var result = SomeMethod(); then the code after that is expecting some sort of result back where you\'d call various methods or properties or whatever.  If SomeMethod() changed its definition to some other type but it still met the contract the other code was expecting, you just created a really nasty bug (if no unit/integration tests, of course).  