How do the Linux kernel developers test their code locally and after they have it committed? Do they use some kind of unit testing, build automation? test plans? The linux kernel has a heavy emphasis on community testing.Typically any developer will test their own code before submitting, and quite often they will be using a development version of the kernel from Linus, or one of the other unstable/development trees for a project relevant to their work. This means they are often testing both their changes and other people\'s changes.There tend not to be much in the way of formal test plans, but extra testing may be asked for before features are merged into upstream trees.As Dean pointed out, there\'s also some automated testing, the linux test project and the kernel autotest (good overview).Developers will often also write automated tests targetted to test their change, but I\'m not sure there\'s a (often used) mechanism to centrally collect these adhoc tests.It depends a lot on which area of the kernel is being changed of course - the testing you\'d do for a new network driver is quite different to the testing you\'d do when replacing the core scheduling algorithm. Naturally, the kernel itself and its parts are tested prior to the release, but these tests cover only the basic functionality. There are some testing systems which perform testing of Linux Kernel:The Linux Test Project (LTP) delivers test suites to the open source community that validate the reliability and stability of Linux. The LTP test suite contains a collection of tools for testing the Linux kernel and related features. https://github.com/linux-test-project/ltpAutotest -- a framework for fully automated testing. It is designed primarily to test the Linux kernel, though it is useful for many other purposes such as qualifying new hardware, virtualization testing, and other general user space program testing under Linux platforms. It\'s an open-source project under the GPL and is used and developed by a number of organizations, including Google, IBM, Red Hat, and many others. http://autotest.github.io/Also there are certification systems developed by some major GNU/Linux distribution companies.  These systems usually check complete GNU/Linux distributions for compatibility with hardware. There are certification systems developed by Novell, Red Hat, Oracle, Canonical, Google.There are also systems for dynamic analysis of Linux kernel:Kmemleak is a memory leak detector included in the Linux kernel. It provides a way of detecting possible kernel memory leaks in a way similar to a tracing garbage collector with the difference that the orphan objects are not freed but only reported via /sys/kernel/debug/kmemleak. Kmemcheck traps every read and write to memory that was allocated dynamically (i.e. with kmalloc()). If a memory address is read that has not previously been written to, a message is printed to the kernel log. Also is a part of Linux KernelFault Injection Framework (included in Linux kernel) allows for infusing errors and exceptions into an application\'s logic to achieve a higher coverage and fault tolerance of the system.How do the Linux kernel developers test their code locally and after they have it committed?Do they use some kind of unit testing, build automation?In classic sense of words, no.E. g. Ingo Molnar is running the following workload:\n1. build new kernel with random set of config options\n2. boot into it\n3. goto 1Every build fail, boot fail, BUG or runtime warning is dealt with. 24/7.\nMultiply by several boxes, and one can uncover quite a lot of problems.test plans?No.There may be misunderstanding that there is central testing facility, there is none.\nEveryone does what he wants.Its not very easy to automate kernel testing.  Most Linux developers do the testing on their own, much like adobriyan mentioned.However, there are a few things that help with debugging the Linux Kernel:Then, developers usually have others review their patches.  Once the patches are reviewed locally and seen not to interfere with anything else, and the patches are tested to work with the latest kernel from Linus without breaking anything, the patches are pushed upstream.Edit: Here\'s a nice video detailing the process a patch goes through before it is integrated into the kernel.In-tree toolsA good way to find test tools in the kernel is to:In v4.0, this leads me to:kselftest under tools/testing/selftests. Run with make kselftest. Must be running built kernel already. See also: Documentation/kselftest.txt , https://kselftest.wiki.kernel.org/ktest under tools/testing/ktest. See also: http://elinux.org/Ktest , http://www.slideshare.net/satorutakeuchi18/kernel-auto-testbyktestStatic analysers section of make help, which contains targets like:Kernel CIhttps://kernelci.org/ is a project that aims to make kernel testing more automated and visible.It appears to do only build and boot tests (TODO how to test automatically that boot worked Source should be at https://github.com/kernelci/).Linaro seems to be the main maintainer of the project, with contributions from many big companies: https://kernelci.org/sponsors/Linaro Lavahttp://www.linaro.org/initiatives/lava/ looks like a CI system with focus on development board bringup and the Linux kernel.Step debuggersNot really unit testing, but may help once your tests start failing:In addition to above/below points, which emphasis more on the functionality testing, hardware certification testing and performance testing the Linux kernel. A lot a testing actually happen through, actually scripts, static code analysis tools, code reviews etc. which is very efficient in catching bugs, which would otherwise break something in the application. Sparse \xe2\x80\x93 An open-source tool designed to find faults in the Linux kernel.Coccinelle is another program does matching and transformation engine which provides the language SmPL (Semantic Patch Language) for specifying desired matches and transformations in C code.checkpatch.pl and other scripts - coding style issues can be found in the file Documentation/CodingStyle in the kernel source tree. The important thing to remember when reading it is not that this style is somehow better than any other style, just that it is consistent. this helps developers easily find and fix coding style issues, the script scripts/checkpatch.pl in the kernel source tree has been developed. This script can point out problems easily, and should always be run by a developer on their changes, instead of having a reviewer waste their time by pointing out problems later on.There also are:MMTests which is collection of benchmarks and scripts to analyze the resultshttps://github.com/gormanm/mmtestsTrinity which is Linux system call fuzz testerhttp://codemonkey.org.uk/projects/trinity/Also the LTP pages at the sourceforge are quite outdated and the project has moved to GitHub\nhttps://github.com/linux-test-project/ltpI would imagine they use virtualization to do quick tests, something like QEMU, VirtualBox or Xen, and some scripts to perform configurations and automated tests.Automated testing is probably done by trying either many random configurations or a few specific ones (if they are working with a specific issue).  Linux has a lot of low-level tools (such as dmesg) to monitor and log debug data from the kernel, so I imagine that is used as well.As far as I know, there is an automatically performance regression check tool(named lkp/0 day) running/funding by the Intel, it will test each valid patch sent to the mailing list and check the scores changed from different microbenchmarks such as hackbench, fio, unixbench, netperf, etc, once there is a performance regression/improvement, a corresponding report will be sent directly to the patch author and Cc related maintainers.LTP and Memtests are generally preferred tools.adobriyan mentioned Ingo\'s loop of random config build testing. That is pretty much now covered by the 0-day test bot (aka kbuild test bot). A nice article about the infrastructure is presented here:Kernel Build/boot testingThe idea behind this set-up is to notify the developers ASAP so that they can rectify the errors soon enough. (before the patches make it into Linus\' tree in some cases as the kbuild infrastructure also tests against maintainer\'s subsystem trees)I had done linux kernel compilation and done some Modifications for android(Marshmallow and Nougat) in which I use linux version 3. I cross-compiled it in linux system, debug the errors manually and then run its boot image file in Android and check if it was going in loop-hole or not. If it runs perfect then it means it is compiled perfectly according to system requirements.\nFor MotoG kernel CompilationNOTE:- Linux Kernel will change according to requirements which depend on System Hardware