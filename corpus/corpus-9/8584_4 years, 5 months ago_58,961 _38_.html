System.Net.Http.HttpClient and System.Net.Http.HttpClientHandler in .NET Framework 4.5 implement IDisposable (via System.Net.Http.HttpMessageInvoker).The using statement documentation says:As a rule, when you use an IDisposable object, you should declare and\n  instantiate it in a using statement.This answer uses this pattern:But the most visible examples from Microsoft don\'t call Dispose() either explicitly or implicitly. For instance:In the announcement\'s comments, someone asked the Microsoft employee:After checking your samples, I saw that you didn\'t perform the dispose\n  action on HttpClient instance. I have used all instances of HttpClient\n  with using statement on my app and I thought that it is the right way\n  since HttpClient  implements the IDisposable interface. Am I on the\n  right path?His answer was:In general that is correct although you have to be careful with\n  "using" and async as they dont\' really mix in .Net 4, In .Net 4.5 you\n  can use "await" inside a "using" statement.Btw, you can reuse the same HttpClient as many times are [as] you like so\n  typically you won\'t create/dispose them all the time.The second paragraph is superflous to this question, which is not concerned about how many times you can use an HttpClient instance, but if it necessary to dispose it after you no longer need it.(Update: in fact that second paragraph is the key to the answer, as provided below by @DPeden.)So my questions are:Is it necessary, given the current implementation (.NET Framework 4.5), to call Dispose() on HttpClient and HttpClientHandler instances? Clarification: by "necessary" I mean if there are any negative consequences for not disposing, such as resource leakage or data corruption risks.If it\'s not necessary, would it be a "good practice" anyway, since they implement IDisposable?If it\'s necessary (or recommended), is this code mentioned above implementing it safely (for .NET Framework 4.5)?If these classes don\'t require calling Dispose(), why were they implemented as IDisposable?If they require, or if it\'s a recommended practice, are the Microsoft examples misleading or unsafe?The general consensus is that you do not (should not) need to dispose of HttpClient.Many people who are intimately involved in the way it works have stated this.See Darrel Miller\'s blog post and a related SO post: HttpClient crawling results in memory leak for reference.I\'d also strongly suggest that you read the HttpClient chapter from Designing Evolvable Web APIs with ASP.NET for context on what is going on under the hood, particularly the "Lifecycle" section quoted here:Although HttpClient does indirectly implement the IDisposable\n  interface, the standard usage of HttpClient is not to dispose of it\n  after every request. The HttpClient object is intended to live for as\n  long as your application needs to make HTTP requests. Having an object\n  exist across multiple requests enables a place for setting\n  DefaultRequestHeaders and prevents you from having to re-specify\n  things like CredentialCache and CookieContainer on every request as\n  was necessary with HttpWebRequest.Or even open up DotPeek.In my understanding, calling Dispose() is necessary only when it\'s locking resources you need later (like a particular connection). It\'s always recommended to free resources you\'re no longer using, even if you don\'t need them again, simply because you shouldn\'t generally be holding onto resources you\'re not using (pun intended).The Microsoft example is not incorrect, necessarily. All resources used will be released when the application exits. And in the case of that example, that happens almost immediately after the HttpClient is done being used. In like cases, explicitly calling Dispose() is somewhat superfluous.But, in general, when a class implements IDisposable, the understanding is that you should Dispose() of its instances as soon as you\'re fully ready and able. I\'d posit this is particularly true in cases like HttpClient wherein it\'s not explicitly documented as to whether resources or connections are being held onto/open. In the case wherein the connection will be reused again [soon], you\'ll want to forgo Dipose()ing of it -- you\'re not "fully ready" in that case.See also:\nIDisposable.Dispose Method and When to call DisposeThe current answers are a bit confusing and misleading, and they are missing some important DNS implications. I\'ll try to summarize where things stand clearly.In my case, I was creating an HttpClient inside a method that actually did the service call.  Something like:\nIn an Azure worker role, after repeatedly calling this method (without disposing the HttpClient), it would eventually fail with SocketException (connection attempt failed).I made the HttpClient an instance variable (disposing it at the class level) and the issue went away.  So I would say, yes, dispose the HttpClient, assuming its safe (you don\'t have outstanding async calls) to do so.In typical usage (responses<2GB) it is not necessary to Dispose the HttpResponseMessages.The return types of the HttpClient methods should be Disposed if their Stream Content is not fully Read. Otherwise there is no way for the CLR to know those Streams can be closed until they are garbage collected.If you set the HttpCompletionOption to ResponseHeadersRead or the response is larger than 2GB, you should clean up. This can be done by calling Dispose on the HttpResponseMessage or by calling Dispose/Close on the Stream obtained from the HttpResonseMessage Content or by reading the content completely.Whether you call Dispose on the HttpClient depends on whether you want to cancel pending requests or not.I think one should use singleton pattern to avoid having to create instances of the HttpClient and closing it all the time. If you are using .Net 4.0 you could use a sample code as below. for more information on singleton pattern check here.Use the code as below.