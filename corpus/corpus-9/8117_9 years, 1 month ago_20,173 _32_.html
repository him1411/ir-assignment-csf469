Is there any difference between:andThe convention that I\'ve seen in most Python code (and the code I myself write) is the former, but I recently came across code which uses the latter.  None is an instance (and the only instance, IIRC) of NoneType, so it shouldn\'t matter, right?  Are there any circumstances in which it might?is always returns True if it compares the same object instanceWhereas == is ultimately determined by the __eq__() methodi.e.You may want to read this object identity and equivalence.The statement \'is\' is used for object identity, it checks if objects refer to the same instance (same address in memory).And the \'==\' statement refers to equality (same value).A word of caution: Is not exactly the same as:The former is a boolean value test and can evaluate to false in different contexts. There are a number of things that represent false in a boolean value tests for example empty containers, boolean values. None also evaluates to false in this situation but other things do too.(ob1 is ob2) equal to (id(ob1) == id(ob2))The reason foo is None is the preferred way is that you might be handling an object that defines its own __eq__, and that defines the object to be equal to None. So, always use foo is None if you need to see if it is infact None.There is no difference because objects which are identical will of course be equal. However, PEP 8 clearly states you should use is:Comparisons to singletons like None should always be done with is or is not, never the equality operators.For None there shouldn\'t be a difference between equality (==) and identity (is). The NoneType probably returns identity for equality. Since None is the only instance you can make of NoneType (I think this is true), the two operations are the same. In the case of other types this is not always the case. For example:This would print "Equal" since lists have a comparison operation that is not the default returning of identity.@Jason:I recommend using something more along the lines ofI don\'t like using "if foo:" unless foo truly represents a boolean value (i.e. 0 or 1). If foo is a string or an object or something else, "if foo:" may work, but it looks like a lazy shortcut to me. If you\'re checking to see if x is None, say "if x is None:".is tests for identity, not equality. For your statement foo is none, Python simply compares the memory address of objects. It means you are asking the question "Do I have two names for the same object?"== on the other hand tests for equality as determined by the __eq__() method. It doesn\'t cares about identity.None is a singleton operator. So None is None is always true.John Machin\'s conclusion that None is a singleton is a conclusion bolstered by this code.Since None is a singleton, x == None and x is None would have the same result.  However, in my aesthetical opinion, x == None is best.Some more details:The is clause actually checks if the two objects are at the same\nmemory location or not. i.e whether they both point to the same\nmemory location and have the same id. As a  consequence of 1, is ensures whether, or not, the two lexically represented objects have identical attributes (attributes-of-attributes...) or notInstantiation of primitive types like bool, int, string(with some exception), NoneType having a same value will always be in the same memory location.E.g.And since NoneType can only have one instance of itself in the python\'s "look-up" table therefore the former and the latter are more of a programming style of the developer who wrote the code(maybe for consistency) rather then having any subtle logical reason to choose one over the other.