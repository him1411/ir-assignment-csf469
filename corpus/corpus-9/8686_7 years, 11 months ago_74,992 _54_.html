I want to watch a folder on my Mac (Snow Leopard) and then execute a script (giving it the filename of what was just moved into a folder (as a parameter... x.sh "filename")).I have a script all written up in bash (x.sh) that will move some files and other stuff on input $1 I just need OSX to give me the file name when new files/folders are moved/created into a dir.Any such command?fswatch is a small program using the Mac OS X FSEvents API to monitor a directory.\nWhen an event about any change to that directory is received, the specified\nshell command is executed by /bin/bashIf you\'re on GNU/Linux,\ninotifywatch (part of the\ninotify-tools package on most distributions) provides similar\nfunctionality.Update: fswatch can now be used across many platforms including BSD, Debian, and Windows.The new way that can watch multiple paths - for versions 1.x and higher:The older way for versions 0.x: As of 9/12/13 it was added back in to homebrew - yay! So, update your formula list (brew update) and then all you need to do is:Which installs it in 2 seconds (literally):\nType these commands in Terminal.appIf you don\'t have a c compiler on your system you may need to install Xcode or Xcode command line tools - both free. However, if that is the case, you should probably just check out homebrew.You can use launchd for that purpose. Launchd can be configured to automatically launch a program when a file path is modified.For example the following launchd config plist will launch the program /usr/bin/logger when the desktop folder of my user account is modified:To activate the config plist save it to the LaunchAgents folder in your Library folder as "logger.plist".From the shell you can then use the command launchctl to activate the logger.plist by running:The desktop folder is now being monitored. Every time it is changed you should see an output in the system.log (use Console.app). \nTo deactivate the logger.plist, run:The configuration file above uses the WatchPaths option. Alternatively you can also use the \nQueueDirectories option. See the launchd man page for more information.You might want to take a look at (and maybe expand) my little tool kqwait. Currently it just sits around and waits for a write event on a single file, but the kqueue architecture allows for hierarchical event stacking...Facebook\'s watchman, available via Homebrew, also looks nice. It supports also filtering:These two lines establish a watch on a source directory and then set\n  up a trigger named "buildme" that will run a tool named "minify-css"\n  whenever a CSS file is changed. The tool will be passed a list of the\n  changed filenames.$ watchman watch ~/src$ watchman -- trigger ~/src buildme \'*.css\' -- minify-cssNotice that the path must be absolute.watchdog is a cross-platform python API for watching files / directories, and it has builtin "tricks" tool that allows you to trigger actions (including shell commands) when events occur (including new added file, removed file and changed file).Apple OSX Folder Actions allow you to automate tasks based on actions taken on a folder.Edit: fsw has been merged into fswatch.  In this answer, any reference to fsw should now read fswatch.I wrote an fswatch replacement in C++ called fsw which features several improvements:It\'s a GNU Build System project which builds on any supported platform (OS X v. >= 10.6) withMultiple paths can be passed as different arguments:It dumps a detailed record with all the event information such as:Its output is easy to parse so that fsw output can be piped to another process.Getting fsw:fsw is hosted on GitHub and can be obtained cloning its repository:Installing fsw:fsw can be installed using the following commands:Further information:I also wrote an introductory blog post where you can find a couple of examples about how fsw works.My fork of fswatch provides the functionality of inotifywait -m with slightly less (no wait, more! I have a lot more troubles on Linux with inotifywait...) parse-friendly output. It is an improvement upon the original fswatch because it sends out the actual path of the changed file over STDOUT rather than requiring you to provide a program that it forks. It\'s been rock solid as the foundation of a series of scary bash scripts I use to automate stuff. (this is off-topic) inotifywait on Linux, on the other hand, requires a lot of kludges on top of it and I still haven\'t figured out a good way to manage it, though I think something based on node.js might be the ticket.This is just to mention entr as an alternative on OSX to run arbitrary commands when files change. I find it simple and useful.Here\'s a one-liner using sschober\'s tool.I have a GIST for this and the usage is pretty simpleTo illustrate, the following command will echo Hello World every time that file1 OR file2 change; and the default interval check is 1 secondIf I want to check every 5 seconds I can use the -t flaghttps://gist.github.com/thiagoh/5d8f53bfb64985b94e5bc8b3844dba55Here\'s a simple single line alternative for users who don\'t have the watch command who want to execute a command every 3 seconds:\nwhile :; do your-command; sleep 3; done\nIt\'s an infinite loop that is basically the same as doing the following:\nwatch -n3 your-command\n