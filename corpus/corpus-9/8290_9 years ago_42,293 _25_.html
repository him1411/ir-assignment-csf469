I am calling, through reflection, a method which may cause an exception. How can I pass the exception to my caller without the wrapper reflection puts around it? I am rethrowing the InnerException, but this destroys the stack trace. Example code:In .NET 4.5 there is now the ExceptionDispatchInfo class.This lets you capture an exception and re-throw it without changing the stack-trace:This works on any exception, not just AggregateException.It was introduced due to the await C# language feature, which unwraps the inner exceptions from AggregateException instances in order to make the asynchronous language features more like the synchronous language features.It is possible to preserve the stack trace before rethrowing without reflection:This wastes a lot of cycles compared to calling InternalPreserveStackTrace via cached delegate, but has the advantage of relying only on public functionality. Here are a couple of common usage patterns for stack-trace preserving functions:I think your best bet would be to just put this in your catch block:And then extract the innerexception later.Call the extension method on your exception before you throw it, it will preserve the original stack trace.Even more reflection...Keep in mind that this may break at any time, as private fields are not part of API. See further discussion on Mono bugzilla.First: don\'t lose the TargetInvocationException - it\'s valuable information when you will want to debug things.\nSecond: Wrap the TIE as InnerException in your own exception type and put an OriginalException property that links to what you need (and keep the entire callstack intact).\nThird: Let the TIE bubble out of your method.Guys, you are cool.. I\'m gonna be a necromancer soon.Anpother sample code which uses exception serialization/deserialization.\nIt does not require the actual exception type to be serializable.\nAlso it uses only public/protected methods.Nobody has explained the difference between ExceptionDispatchInfo.Capture( ex ).Throw() and a plain throw, so here it is.The complete way to rethrow a caught exception is to use ExceptionDispatchInfo.Capture( ex ).Throw() (only available from .Net 4.5).Below there are the cases necessary to test this:1.2.3.4.Case 1 and case 2 will give you a stack trace where the source code line number for the CallingMethod method is the line number of the throw new Exception( "TEST" ) line.However, case 3 will give you a stack trace where the source code line number for the CallingMethod method is the line number of the throw call. This means that if the throw new Exception( "TEST" ) line is surrounded by other operations, you have no idea at which line number the exception was actually thrown.Case 4 is similar with case 2 because the line number of the original exception is preserved, but is not a real rethrow because it changes the type of the original exception.