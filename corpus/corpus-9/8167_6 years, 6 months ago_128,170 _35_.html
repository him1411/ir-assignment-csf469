Can Application.DoEvents() be used in C#?Is this function a way to allow the GUI to catch up with the rest of the app, in much the same way that VB6\'s DoEvents does?Hmya, the enduring mystique of DoEvents().  There\'s been an enormous amount of backlash against it, but nobody ever really explains why it is "bad".  The same kind of wisdom as "don\'t mutate a struct".  Erm, why does the runtime and the language supports mutating a struct if that\'s so bad?  Same reason: you shoot yourself in the foot if you don\'t do it right.  Easily.  And doing it right requires knowing exactly what it does, which in the case of DoEvents() is definitely not easy to grok.Right off the bat: almost any Windows Forms program actually contains a call to DoEvents().  It is cleverly disguised, however with a different name: ShowDialog().  It is DoEvents() that allows a dialog to be modal without it freezing the rest of the windows in the application.Most programmers want to use DoEvents to stop their user interface from freezing when they write their own modal loop.  It certainly does that; it dispatches Windows messages and gets any paint requests delivered.  The problem however is that it isn\'t selective.  It not only dispatches paint messages, it delivers everything else as well.And there\'s a set of notifications that cause trouble.  They come from about 3 feet in front of the monitor.  The user could for example close the main window while the loop that calls DoEvents() is running.  That works, user interface is gone.  But your code didn\'t stop, it is still executing the loop.  That\'s bad.  Very, very bad.There\'s more: The user could click the same menu item or button that causes the same loop to get started.  Now you have two nested loops executing DoEvents(), the previous loop is suspended and the new loop is starting from scratch.  That could work, but boy the odds are slim.  Especially when the nested loop ends and the suspended one resumes, trying to finish a job that was already completed.  If that doesn\'t bomb with an exception then surely the data is scrambled all to hell.Back to ShowDialog().  It executes DoEvents(), but do note that it does something else.  It disables all the windows in the application, other than the dialog.  Now that 3-feet problem is solved, the user cannot do anything to mess up the logic.  Both the close-the-window and start-the-job-again failure modes are solved.  Or to put it another way, there is no way for the user to make your program run code in a different order. It will execute predictably, just like it did when you tested your code. It makes dialogs extremely annoying; who doesn\'t hate having a dialog active and not being able to copy and paste something from another window?  But that\'s the price.Which is what it takes to use DoEvents safely in your code.  Setting the Enabled property of all your forms to false is a quick and efficient way to avoid problems.  Of course, no programmer ever actually likes doing this.  And doesn\'t.  Which is why you shouldn\'t use DoEvents().  You should use threads.  Even though they hand you a complete arsenal of ways to shoot your foot in colorful and inscrutable ways.  But with the advantage that you only shoot your own foot; it won\'t (typically) let the user shoot hers.The next versions of C# and VB.NET will provide a different gun with the new await and async keywords.  Inspired in small part by the trouble caused by DoEvents and threads but in large part by WinRT\'s API design that requires you to keep your UI updated while an asynchronous operation is taking place.  Like reading from a file.It can be, but it\'s a hack.See Is DoEvents Evil?.Direct from the MSDN page that thedev referenced:Calling this method causes the current\n  thread to be suspended while all\n  waiting window messages are processed.\n  If a message causes an event to be\n  triggered, then other areas of your\n  application code may execute. This can\n  cause your application to exhibit\n  unexpected behaviors that are\n  difficult to debug. If you perform\n  operations or computations that take a\n  long time, it is often preferable to\n  perform those operations on a new\n  thread. For more information about\n  asynchronous programming, see\n  Asynchronous Programming Overview.So Microsoft cautions against its use.Also, I consider it a hack because its behavior is unpredictable and side effect prone (this comes from experience trying to use DoEvents instead of spinning up a new thread or using background worker).There is no machismo here - if it worked as a robust solution I would be all over it. However, trying to use DoEvents in .NET has caused me nothing but pain.Yes, there is a static DoEvents method in the Application class in the System.Windows.Forms namespace. System.Windows.Forms.Application.DoEvents() can be used to process the messages waiting in the queue on the UI thread when performing a long-running task in the UI thread. This has the benefit of making the UI seem more responsive and not "locked up" while a long task is running. However, this is almost always NOT the best way to do things.\nAccording to Microsoft calling DoEvents "...causes the current thread to be suspended while all waiting window messages are processed." If an event is triggered there is a potential for unexpected and intermittent bugs that are difficult to track down. If you have an extensive task it is far better to do it in a separate thread. Running long tasks in a separate thread allows them to be processed without interfering with the UI continuing to run smoothly. Look here for more details.Here is an example of how to use DoEvents; note that Microsoft also provides a caution against using it.From my experience I would advise great caution with using DoEvents in .NET. I experienced some very strange results when using DoEvents in a TabControl containing DataGridViews. On the other hand, if all you\'re dealing with is a small form with a progress bar then it might be OK.The bottom line is: if you are going to use DoEvents, then you need to test it thoroughly before deploying your application.Yes.However, if you need to use Application.DoEvents, this is mostly an indication of a bad application design. Perhaps you\'d like to do some work in a separate thread instead?I\'ve seen many commercial applications, using the "DoEvents-Hack". Especially when rendering comes into play, I often see this:They all know about the evil of that method. However, they use the hack, because they don\'t know any other solution. Here are some approaches taken from a blog post by Tom Miller:I saw jheriko\'s comment above and was initially agreeing that I couldn\'t find a way to avoid using DoEvents if you end up spinning your main UI thread waiting for a long running asynchronous piece of code on another thread to complete.  But from Matthias\'s answer a simple Refresh of a small panel on my UI can replace the DoEvents (and avoid a nasty side effect).More detail on my case ...I was doing the following (as suggested here) to ensure that a progress bar type splash screen (How to display a "loading" overlay...) updated during a long running SQL command:The bad: For me calling DoEvents meant that mouse clicks were sometimes firing on forms behind my splash screen, even if I made it TopMost.The good/answer: Replace the DoEvents line with a simple Refresh call to a small panel in the centre of my splash screen, FormSplash.Panel1.Refresh().  The UI updates nicely and the DoEvents weirdness others have warned of was gone.Check out the MSDN Documentation for the Application.DoEvents method.Application.DoEvents can create problems, if something other than graphics processing is put in the message queue. It can be useful for updating progress bars and notifying the user of progress in something like MainForm construction and loading, if that takes a while.In a recent application I\'ve made, I used DoEvents to update some labels on a Loading Screen every time a block of code is executed in the constructor of my MainForm. The UI thread was, in this case, occupied with sending an email on a SMTP server that didn\'t support SendAsync() calls. I could probably have created a different thread with Begin() and End() methods and called a Send() from their, but that method is error-prone and I would prefer the Main Form of my application not throwing exceptions during construction.A new look on how to never need DoEvents again.