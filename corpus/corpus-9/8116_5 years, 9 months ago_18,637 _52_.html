Came across a proposal called "rvalue reference for *this" in clang\'s C++11 status page.I\'ve read quite a bit about rvalue references and understood them, but I don\'t think I know about this. I also couldn\'t find much resources on the web using the terms.There\'s a link to the proposal paper on the page: N2439 (Extending move semantics to *this), but I\'m also not getting much examples from there.What is this feature about? First, "ref-qualifiers for *this" is a just a "marketing statement". The type of *this never changes, see the bottom of this post. It\'s way easier to understand it with this wording though.Next, the following code chooses the function to be called based on the ref-qualifier of the "implicit object parameter" of the function\xe2\x80\xa0:Output:The whole thing is done to allow you to take advantage of the fact when the object the function is called on is an rvalue (unnamed temporary, for example). Take the following code as a further example:This may be a bit contrived, but you should get the idea.Note that you can combine the cv-qualifiers (const and volatile) and ref-qualifiers (& and &&).Note: Many standard quotes and overload resolution explanation after here!\xe2\x80\xa0 To understand how this works, and why @Nicol Bolas\' answer is at least partly wrong, we have to dig in the C++ standard for a bit (the part explaining why @Nicol\'s answer is wrong is at the bottom, if you\'re only interested in that).Which function is going to be called is determined by a process called overload resolution. This process is fairly complicated, so we\'ll only touch the bit that is important to us.First, it\'s important to see how overload resolution for member functions works:\xc2\xa713.3.1 [over.match.funcs]p2 The set of candidate functions can contain both member and non-member functions to be resolved against the same argument list. So that argument and parameter lists are comparable within this heterogeneous set, a member function is considered to have an extra parameter, called the implicit object parameter, which represents the object for which the member function has been called. [...]p3 Similarly, when appropriate, the context can construct an argument list that contains an implied object argument to denote the object to be operated on.Why do we even need to compare member and non-member functions? Operator overloading, that\'s why. Consider this:You\'d certainly want the following to call the free function, don\'t you?That\'s why member and non-member functions are included in the so-called overload-set. To make the resolution less complicated, the bold part of the standard quote exists. Additionally, this is the important bit for us (same clause):p4 For non-static member functions, the type of the implicit object parameter is\xe2\x80\x9clvalue reference to cv X\xe2\x80\x9d for functions declared without a ref-qualifier or with the & ref-qualifier\xe2\x80\x9crvalue reference to cv X\xe2\x80\x9d for functions declared with the && ref-qualifierwhere X is the class of which the function is a member and cv is the cv-qualification on the member function declaration. [...]p5 During overload resolution [...] [t]he implicit object parameter [...] retains its identity since conversions on the corresponding argument shall obey these additional rules:no temporary object can be introduced to hold the argument for the implicit object parameter; andno user-defined conversions can be applied to achieve a type match with it[...](The last bit just means that you can\'t cheat overload resolution based on implicit conversions of the object a member function (or operator) is called on.)Let\'s take the first example at the top of this post. After the aforementioned transformation, the overload-set looks something like this:Then the argument list, containing an implied object argument, is matched against the parameter-list of every function contained in the overload-set. In our case, the argument list will only contain that object argument. Let\'s see how that looks like:If, after all overloads in the set are tested, only one remains, the overload resolution succeeded and the function linked to that transformed overload is called. The same goes for the second call to \'f\':Note however that, had we not provided any ref-qualifier (and as such not overloaded the function), that f1 would match an rvalue (still \xc2\xa713.3.1):p5 [...] For non-static member functions declared without a ref-qualifier, an additional rule applies:Now, onto why @Nicol\'s answer is atleast partly wrong. He says:Note that this declaration changes the type of *this.That is wrong, *this is always an lvalue:\xc2\xa75.3.1 [expr.unary.op] p1The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points.\xc2\xa79.3.2 [class.this] p1In the body of a non-static (9.3) member function, the keyword this is a prvalue expression whose value is the address of the object for which the function is called. The type of this in a member function of a class X is X*. [...]There is an additional use case for the lvalue ref-qualifier form. C++98 has language that allows non-const member functions to be called for class instances that are rvalues. This leads to all kinds of weirdness that is against the very concept of rvalueness and deviates from how built-in types work:Lvalue ref-qualifiers solve these problems:Now the operators work like those of the builtin types, accepting only lvalues.Let\'s say you have two functions on a class, both with the same name and signature. But one of them is declared const:If a class instance is not const, overload resolution will preferentially select the non-const version. If the instance is const, the user can only call the const version. And the this pointer is a const pointer, so the instance cannot be changed.What "r-value reference for this` does is allow you to add another alternative:This allows you to have a function that can only be called if the user calls it through a proper r-value. So if this is in the type Object:This way, you can specialize behavior based on whether the object is being accessed via an r-value or not.Note that you are not allowed to overload between the r-value reference versions and the non-reference versions. That is, if you have a member function name, all of its versions either use the l/r-value qualifiers on this, or none of them do. You can\'t do this:You must do this:Note that this declaration changes the type of *this. This means that the && versions all access members as r-value references. So it becomes possible to easily move from within the object. The example given in the first version of the proposal is (note: the following may not be correct with the final version of C++11; it\'s straight from the initial "r-value from this" proposal):