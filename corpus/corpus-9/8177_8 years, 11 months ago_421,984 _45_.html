How can I check if an application is running from a batch (well cmd) file?I need to not launch another instance if a program is already running. (I can\'t change the app to make it single instance only.)Also the application could be running as any user.Another possibility I came up with, inspired by using grep, is:It doesn\'t need to save an extra file, so I prefer this method.Here\'s how I\'ve worked it out:The above will open Notepad if it is not already running.Edit: Note that this won\'t find applications hidden from the tasklist. This will include any scheduled tasks running as a different user, as these are automatically hidden.I like Chaosmaster\'s solution! But I looked for a solution which does not start another external program (like find.exe or findstr.exe). So I added the idea from Matt Lacey\'s solution, which creates an also avoidable temp file. At the end I could find a fairly simple solution, so I share it...This is working for me nicely...Under Windows you can use Windows Management Instrumentation (WMI) to ensure that no apps with the specified command line is launched, for example:wmic process where (name="nmake.exe")  get commandline | findstr /i /c:"/f load.mak" /c:"/f build.mak" > NUL && (echo THE BUILD HAS BEEN STARTED ALREADY! > %ALREADY_STARTED% & exit /b 1)I use PV.exe from http://www.teamcti.com/pview/prcview.htm installed in Program Files\\PV with a batch file like this:TrueY\'s answer seemed the most elegant solution, however, I had to do some messing around because I didn\'t understand what exactly was going on. Let me clear things up to hopefully save some time for the next person.TrueY\'s modified Answer:Anyway, I hope that helps. I know sometimes reading batch/command-line can be kind of confusing sometimes if you\'re kind of a newbie, like me.The answer provided by Matt Lacey works for Windows XP. However, in Windows Server 2003 the line returns INFO: No tasks are running which match the specified criteria.which is then read as the process is running.I don\'t have a heap of batch scripting experience, so my soulution is to then search for the process name in the search.log file and pump the results into another file and search that for any output.I hope this helps someone else.I like the WMIC and TASKLIST tools but they are not available in home/basic editions of windows.Another way is to use QPROCESS command available on almost every windows machine  (for the ones that have terminal services - I think only win XP without SP2 , so practialy every windows machine):QPROCESS command is not so powerful as TASKLIST and is limited in showing only 12 symbols of process name but should be taken into consideration if TASKLIST is not available.More simple usage where it uses the name if the process as an argument (the .exe suffix is mandatory in this case where you pass the executable name):The difference between two ways of QPROCESS usage is that the QPROCESS * will list all processes while QPROCESS some.exe will filter only the processes for the current user.Using WMI objects through windows script host exe instead of WMIC is also an option.It should on run also on every windows machine (excluding the ones where the WSH is turned off but this is a rare case).Here bat file that lists all processes through WMI classes and can be used instead of QPROCESS in the script above (it is a jscript/bat hybrid and should be saved as .bat):And a modification that will check if a process is running:The two options could be used on machines that have no TASKLIST. The ultimate technique is using MSHTA . This will run on every windows machine from XP and above and does not depend on windows script host settings. the call of MSHTA could reduce a little bit the performance though (again should be saved as bat):I don\'t know how to do so with built in CMD but if you have  grep you can try the following:The suggestion of npocmaka to use QPROCESS instead of TASKLIST is great but, its answer is so big and complex that I feel obligated to post a quite simplified version of it which, I guess, will solve the problem of most non-advanced users:The code above was tested in Windows 7, with a user with administrator rigths.I\'m assuming windows here.  So, you\'ll need to use WMI to get that information.  Check out The Scripting Guy\'s archives for a lot of examples on how to use WMI from a script.I used the script provided by Matt (2008-10-02). The only thing I had trouble with was that it wouldn\'t delete the search.log file. I expect because I had to cd to another location to start my program. I cd\'d back to where the BAT file and search.log are, but it still wouldn\'t delete. So I resolved that by deleting the search.log file first instead of last.You should check the parent process name, see The Code Project article about a .NET based solution**.A non-programmatic way to check:The same can be checked by getting the parent process name.Another solution is:The use of "setlocal" command is recommended to improve the compatibility with other operating systems.The row that check if a process is running is:If the program is closed then will be set the "ERRORLEVEL" variable to 1, otherwise at 0.I usually execute following command in cmd prompt to check if my program.exe is running or not:Building on vtrz\'s answer and Samuel Renkert\'s answer on an other topic, I came up with the following script that only runs %EXEC_CMD% if it isn\'t already running:As was said before, this requires administrative privileges.