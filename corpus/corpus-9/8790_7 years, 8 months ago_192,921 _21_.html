I have a file below:And I want to get:I could write a Ruby script, but it is better if I do not need to.prefix will contain /. It is a path. /opt/workdir/ for example.If prefix contains /, you can use any other character not in prefix, or\nescape the /, so the sed command becomesYou can use Vim in Ex mode:% select all liness replacex save and closeIf your prefix is a bit complicated, just put it in a variable:Then, you pass that variable and let awk deal with it:If you have Perl:Using the shell:While I don\'t think pierr had this concern, I needed a solution that would not delay output from the live "tail" of a file, since I wanted to monitor several alert logs simultaneously, prefixing each line with the name of its respective log.Unfortunately, sed, cut, etc. introduced too much buffering and kept me from seeing the most current lines. Steven Penny\'s suggestion to use the -s option of nl was intriguing, and testing proved that it did not introduce the unwanted buffering that concerned me.There were a couple of problems with using nl, though, related to the desire to strip out the unwanted line numbers (even if you don\'t care about the aesthetics of it, there may be cases where using the extra columns would be undesirable). First, using "cut" to strip out the numbers re-introduces the buffering problem, so it wrecks the solution. Second, using "-w1" doesn\'t help, since this does NOT restrict the line number to a single column - it just gets wider as more digits are needed.It isn\'t pretty if you want to capture this elsewhere, but since that\'s exactly what I didn\'t need to do (everything was being written to log files already, I just wanted to watch several at once in real time), the best way to lose the line numbers and have only my prefix was to start the -s string with a carriage return (CR or ^M or Ctrl-M). So for example:Here\'s a wrapped up example using the sed approach from this answer:Please use the following commandSED will replace the beginning with prefix.sed "s%^%prefix%" file  