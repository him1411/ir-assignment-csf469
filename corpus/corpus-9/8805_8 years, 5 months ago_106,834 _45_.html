I routinely work on several different computers and several different operating systems, which are Mac OS X, Linux, or Solaris. For the project I\'m working on, I pull my code from a remote git repository.I like to be able to work on my projects regardless of which terminal I\'m at. So far, I\'ve found ways to get around the OS changes by changing the makefile every time I switch computers. However, this is tedious and causes a bunch of headaches.How can I modify my makefile so that it detects which OS I\'m using and modifies syntax accordingly?Here is the makefile:There are many good answers here already, but I wanted to share a more complete example that both a) doesn\'t assume uname exists on Windows and b) also detects the processor. The CCFLAGS defined here aren\'t necessarily recommended or ideal; they\'re just what the project to which I was adding OS/CPU auto-detection happened to be using.The uname command (http://developer.apple.com/documentation/Darwin/Reference/ManPages/man1/uname.1.html) with no parameters should tell you the operating system name.  I\'d use that, then make conditionals based on the return value.ExampleIf you do not need sophisticated stuff as done by Git LSF, you can detect the Operating System just using two simple tricks:Or a more safe way, if not Windows and command uname not available:Then you can select the relevant stuff depending on detected_OS:Please see also this detailed answer about importance of uname -s better than uname -o.The use of OS (instead of uname -s) simplifies the identification algorithm. You can still use solely uname -s but you have to deal with if/else blocks to check all MinGW/Cygwin/... variations.Note: The environment variable OS is always set to "Windows_NT" on any Windows platform (see Windows Environment Variables on Wikipedia). An alternative of OS is the environment variable MSVC (it checks the presence of MS Visual Studio, see example using MSVC).Below I provide a complete example using make and gcc to build a shared library: *.so or *.dll depending on the platform. The example is as simplest as possible to be more understandable :-)To install make and gcc on Windows see Cygwin or MinGW.Do not forget: files Makefile are indented using tabulations. To learn more, read Automatic Variables documentation as pointed out by cfi.Fix the copy-paste of Makefile (replace leading spaces by one tabulation).The make command is the same on both platforms. The given output is on Unix-like OSes:The application requires to know where is the shared library. On Windows, a simple solution is to copy the library where the application is:On Unix-like OSes, you can use the LD_LIBRARY_PATH environment variable:Run the command on Windows:Run the command on Unix-like OSes:The git makefile contains numerous examples of how to manage without autoconf/automake, yet still work on a multitude of unixy platforms.I was recently experimenting in order to  answer to this question I was asking myself. Here are my conclusions :Since in Windows, you can\'t be sure that the uname command is available, you can use gcc -dumpmachine. This will display the compiler target.There may be also a problem when using uname if you want to do some cross-compilation.Here\'s a example list of possible output of gcc -dumpmachine :You can check the result in the makefile like this :It worked well for me, but I\'m not sure it\'s a reliable way of getting the system type. At least it\'s reliable about MinGW and that\'s all I need since it does not require to have the uname command or MSYS package in Windows.To sum up, uname gives you the system on which you\'re compiling, gcc -dumpmachine gives you the system for which you are compiling.Hope it helped someone.If your makefile may be running on non-cygwin Windows, uname may not be available.  That\'s awkward, but this is a potential solution.  You have to check for Cygwin first to rule it out, because it has WINDOWS in it\'s PATH too.That\'s the job that GNU\'s automake/autoconf are designed to solve. You might want to investigate them.Alternatively you can set environment variables on your different platforms and make you Makefile conditional against them.I ran into this problem today and I needed it on Solaris so here is a POSIX standard way to do (something very close to) this. Note that Makefiles are extremely sensitive to spacing.  Here\'s an example of a Makefile that runs an extra command on OSX and which works on OSX and Linux.  Overall, though, autoconf/automake is the way to go for anything at all non-trivial.Another way to do this is by using a "configure" script. If you are already using one with your makefile, you can use a combination of uname and sed to get things to work out. First, in your script, do:Then, in order to put this in your Makefile, start out with Makefile.in which should have something likein it.Use the following sed command in your configure script after the UNAME=uname bit.Now your makefile should have UNAME defined as desired. If/elif/else statements are all that\'s left!Here\'s a simple solution that checks if you are in a Windows or posix-like (Linux/Unix/Cygwin/Mac) environment:It takes advantage of the fact that echo exists on both posix-like and Windows environments, and that in Windows the shell does not filter the quotes.