I\'m trying to write huge amounts of data onto my SSD(solid state drive). And by huge amounts I mean 80GB.I browsed the web for solutions, but the best I came up with was this:Compiled with Visual Studio 2010 and full optimizations and run under Windows7 this program maxes out around 20MB/s. What really bothers me is that Windows can copy files from an other SSD to this SSD at somewhere between 150MB/s and 200MB/s. So at least 7 times faster. That\'s why I think I should be able to go faster.Any ideas how I can speed up my writing?Edit: Now it compiles.This did the job:I just timed 8GB in 36sec, which is about 220MB/s and I think that maxes out my SSD. Also worth to note, the code in the question used one core 100%, whereas this code only uses 2-5%.Thanks a lot to everyone.Update: 5 years have passed. Compilers, hardware, libraries and my requirements have changed. That\'s why I made some changes to the code and did some measurements.First up the code:Now the code compiles with Visual Studio 2017 and g++ 7.2.0 (which is now one of my requirements).\nI let the code run with two setups:Which gave the following measurements (after ditching the values for 1MB, because they were obvious outliers):\n\n\nBoth times option1 and option3 max out my SSD. I didn\'t expect this to see, because option2 used to be the fastest code on my machine back then.TL;DR: My measurements indicate to use std::fstream over FILE.Try the following, in order:Smaller buffer size. Writing ~2 MiB at a time might be a good start. On my last laptop, ~512 KiB was the sweet spot, but I haven\'t tested on my SSD yet.Note: I\'ve noticed that very large buffers tend to decrease performance. I\'ve noticed speed losses with using 16-MiB buffers instead of 512-KiB buffers before.Use _open (or _topen if you want to be Windows-correct) to open the file, then use _write. This will probably avoid a lot of buffering, but it\'s not certain to.Using Windows-specific functions like CreateFile and WriteFile. That will avoid any buffering in the standard library.I see no difference between std::stream/FILE/device.\nBetween buffering and non buffering.Also note:I am seeing the code run in 63 secondds.\nThus a transfer rate of: 260M/s (my SSD look slightly faster than yours).I get a no increase by moving to FILE* from std::fstream.So the C++ stream are working as fast as the underlying library will allow.But I think it is unfair comparing the OS to an application that is built on-top of the OS. The application can make no assumptions (it does not know the drives are SSD) and thus uses the file mechanisms of the OS for transfer.While the OS does not need to make any assumptions. It can tell the types of the drives involved and use the optimal technique for transferring the data. In this case a direct memory to memory transfer. Try writing a program that copies 80G from 1 location in memory to another and see how fast that is.I changed my code to use the lower level calls:\nie no buffering.This made no diffference.NOTE: My drive is an SSD drive if you have a normal drive you may see a difference between the two techniques above. But as I expected non buffering and buffering (when writting large chunks greater than buffer size) make no difference.Have you tried the fastest method of copying files in C++The best solution is to implement an async writing with double buffering.Look at the time line:The \'F\' represents time for buffer filling, and \'W\' represents time for writing buffer to disk. So the problem in wasting time between writing buffers to file. However, by implementing writing on a separate thread, you can start filling the next buffer right away like this:F - filling 1st buffer\nf - filling 2nd buffer\nW - writing 1st buffer to file\nw - writing 2nd buffer to file\n_ - wait while operation is completedThis approach with buffer swaps is very useful when filling a buffer requires more complex computation (hence, more time).\nI always implement a CSequentialStreamWriter class that hides asynchronous writing inside, so for the end-user the interface has just Write function(s).And the buffer size must be a multiple of disk cluster size. Otherwise, you\'ll end up with poor performance by writing a single buffer to 2 adjacent disk clusters.Writing the last buffer.\nWhen you call Write function for the last time, you have to make sure that the current buffer is being filled should be written to disk as well. Thus CSequentialStreamWriter should have a separate method, let\'s say Finalize (final buffer flush), which should write to disk the last portion of data.Error handling.\nWhile the code start filling 2nd buffer, and the 1st one is being written on a separate thread, but write fails for some reason, the main thread should be aware of that failure.Let\'s assume the interface of a CSequentialStreamWriter has Write function returns bool or throws an exception, thus having an error on a separate thread, you have to remember that state, so next time you call Write or Finilize on the main thread, the method will return False or will throw an exception. And it does not really matter at which point you stopped filling a buffer, even if you wrote some data ahead after the failure - most likely the file would be corrupted and useless.I\'d suggest trying file mapping. I used mmapin the past, in a UNIX environment, and I was impressed by the high performance I could achieveTry using open()/write()/close() API calls and experiment with the output buffer size. I mean do not pass the whole "many-many-bytes" buffer at once, do a couple of writes (i.e., TotalNumBytes / OutBufferSize).  OutBufferSize can be from 4096 bytes to megabyte.Another try - use WinAPI OpenFile/CreateFile and use this MSDN article to turn off buffering (FILE_FLAG_NO_BUFFERING). And this MSDN article on WriteFile() shows how to get the block size for the drive to know the optimal buffer size.Anyway, std::ofstream is a wrapper and there might be blocking on I/O operations. Keep in mind that traversing the entire N-gigabyte array also takes some time. While you are writing a small buffer, it gets to the cache and works faster.Could you use FILE* instead, and the measure the performance you\'ve gained?\nA couple of options is to use fwrite/write instead of fstream:If you decide to use write, try something similar:I would also advice you to look into memory map. That may be your answer. Once I had to process a 20GB file in other to store it in the database, and the file as not even opening. So the solution as to utilize moemory map. I did that in Python though.Try to use memory-mapped files.If you copy something from disk A to disk B in explorer, Windows employs DMA. That means for most of the copy process, the CPU will basically do nothing other than telling the disk controller where to put, and get data from, eliminating a whole step in the chain, and one that is not at all optimized for moving large amounts of data - and I mean hardware.What you do involves the CPU a lot.\nI want to point you to the "Some calculations to fill a[]" part. Which I think is essential. You generate a[], then you copy from a[] to an output buffer (thats what fstream::write does), then you generate again, etc.What to do? Multithreading! (I hope you have a multi-core processor)fstreams are not slower than C streams, per se, but they use more CPU (especially if buffering is not properly configured). When a CPU saturates, it limits the I/O rate.At least the MSVC 2015 implementation copies 1 char at a time to the output buffer when a stream buffer is not set (see streambuf::xsputn). So make sure to set a stream buffer (>0).I can get a write speed of 1500MB/s (the full speed of my M.2 SSD) with fstream using this code:I tried this code on other platforms (Ubuntu, FreeBSD) and noticed no I/O rate differences, but a CPU usage difference of about 8:1 (fstream used 8 times more CPU). So one can imagine, had I a faster disk, the fstream write would slow down sooner than the stdio version.If you want to write fast to file streams then you could make stream the read buffer larger:Also, when writing lots of data to files it is sometimes faster to logically extend the file size instead of physically, this is because when logically extending a file the file system does not zero the new space out before writing to it. It is also smart to logically extend the file more than you actually need to prevent lots of file extentions. Logical file extention is supported on Windows by calling SetFileValidData or xfsctl with XFS_IOC_RESVSP64 on XFS systems.im compiling my program in  gcc in GNU/Linux and mingw in win 7 and win xp and worked goodyou can use my program and to create a 80 GB file just change the line 33 towhen exit the program the file will be destroyed then check the file when it is running to have the program that you want just change the programfirt one is the windows program and the second is for GNU/Linuxhttp://mustafajf.persiangig.com/Projects/File/WinFile.cpphttp://mustafajf.persiangig.com/Projects/File/File.cpp