right now I have this line, and it worked until I had whitespace in the second field.is there a way to have awk print everything in $2 or greater?  ($3, $4.. until we don\'t have anymore columns?)I suppose I should add that I\'m doing this in a Windows environment with Cygwin.will print all but very first column:will print all but two first columns:There\'s a duplicate question with a simpler answer using cut:-d specifies the delimeter (space), -f specifies the list of columns (all starting with the 2nd)You could use a for-loop to loop through printing fields $2 through $NF (built-in variable that represents the number of fields on the line).Edit:\nSince "print" appends a newline, you\'ll want to buffer the results:Alternatively, use printf:My answer is based on the one of VeeArr, but I noticed it started with a white space before it would print the second column (and the rest). As I only have 1 reputation point, I can\'t comment on it, so here it goes as a new answer:start with "out" as the second column and then add all the other columns (if they exist). This goes well as long as there is a second column.I personally tried all the answers mentioned above, but most of them were a bit complex or just not right. The easiest way to do it from my point of view is:Where   -F" "  defines the delimiter for awk to use. In my case is the whitespace, which is also the default delimiter for awk. This means that -F" " can be ignored.Where  NF  defines the total number of fields/columns. Therefore the loop will begin from the 4th field up to the last field/column.Where   $N  retrieves the value of the Nth field. Therefore   print $i   will print the current field/column based based on the loop count.This was irritating me so much, I sat down and wrote a cut-like field specification parser, tested with GNU Awk 3.1.7. First, create a new Awk library script called pfcut, with e.g.Then, paste in the script below, and save. After that, this is how the usage looks like:To avoid typing all that, I guess the best one can do (see otherwise Automatically load a user function at startup with awk? - Unix & Linux Stack Exchange) is add an alias to ~/.bashrc; e.g. with:... then you can just call:Here is the source of the pfcut script:Printing out columns starting from #2 (the output will have no trailing space in the beginning):Would this work?It leaves some whitespace in front though.this one uses awk to print all except the last fieldMost solutions with awk leave an space. The options here avoid that problem.A simple cut solution (works only with single delimiters):Forcing an awk re-calc sometimes remove the added leading space (OFS) left by removing the first fields (works with some versions of awk):Printing each field formatted with printf will give more control:However, all previous answers change all repeated FS  between fields to OFS. Let\'s build a couple of option that do not do that.A loop with sub to remove fields and delimiters at the front.\nAnd using the value of FS instead of space (which could be changed).\nIs more portable, and doesn\'t trigger a change of FS to OFS:\nNOTE: The ^[FS]* is to accept an input with leading spaces.It is quite possible to build a solution that does not add extra (leading or trailing) whitespace, and preserve existing whitespace(s) using the function gensub from GNU awk, as this:It also may be used to swap a group of fields given a count n:Of course, in such case, the OFS is used to separate both parts of the line, and the trailing white space of the fields is still printed.NOTE: [FS]* is used to allow leading spaces in the input line.This is what I preferred from all the recommendations:Printing from the 6th to last column.orIf you need specific columns printed with arbitrary delimeter:col#3  col#4col#3anythingcol#4So if you have whitespace in a column it will be two columns, but you can connect it with any delimiter or without it. Perl solution:These command-line options are used:-n loop around every line of the input file, do not automatically print every line-l removes newlines before processing, and adds them back in afterwards-a autosplit mode \xe2\x80\x93 split input lines into the @F array.  Defaults to splitting on whitespace-e execute the perl codesplice @F,0,1 cleanly removes column 0 from the @F arrayjoin " ",@F joins the elements of the @F array, using a space in-between each elementPython solution:python -c "import sys;[sys.stdout.write(\' \'.join(line.split()[1:]) + \'\\n\') for line in sys.stdin]" < fileIf you want formatted text, chain your commands with echo and use $0 to print the last field.Example:Prints:This would work if you are using Bash and you could use as many \'x \' as elements you wish to discard and it ignores multiple spaces if they are not escaped.If you don\'t want to reformat the part of the line that you don\'t chop off, the best solution I can think of is written in my answer in:How to print all the columns after a particular number using awk?It  chops what is before the given field number N, and prints all the rest of the line, including field number N and maintaining the original spacing (it does not reformat). It doesn\'t mater if the string of the field appears also somewhere else in the line.Define a function:And use it like this:Output maintains everything, including trailing spacesIn you particular case:If your file/stream does not contain new-line characters in the middle of the lines (you could be using a different Record Separator), you can use:The first case will fail only in files/streams that contain the rare hexadecimal char number 1Perl:Awk examples looks complex here, here is simple Bash shell syntax:Where 1 is your nth column counting from 0.Given this content of file (in.txt):here is the output:I wasn\'t happy with any of the awk solutions presented here because I wanted to extract the first few columns and then print the rest, so I turned to perl instead. The following code extracts the first two columns, and displays the rest as is:The advantage compared to the perl solution from Chris Koknat is that really only the first n elements are split off from the input string; the rest of the string isn\'t split at all and therefor stays completely intact. My example demonstrates this with a mix of spaces and tabs.To change the amount of columns that should be extracted, replace the 3 in the example with n+1.from this answer is not bad but the natural spacing is gone.\nPlease then compare it to this one: Then you\'d see the difference.  Even ls -la | awk \'{$1=$2=""; print}\' which is based on the answer voted best thus far is not preserve the formatting.  Thus I would use the following, and it also allows explicit selective columns in the beginning: Note that every space counts for columns too, so for instance in the below, columns 1 and 3 are empty, 2 is INFO and 4 is: