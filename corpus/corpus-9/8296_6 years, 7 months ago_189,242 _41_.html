For example in this line of code I wrote, print and puts produce different results.puts adds a newline to the end of each argument if there is not one already. print does not add a new line.For example:puts [[1,2,3], [4,5,nil]] Would return:\n\n1\n2\n3\n4\n5Whereas print [[1,2,3], [4,5,nil]]\nwould return:[[1,2,3], [4,5,nil]]Notice how puts does not output the nil value whereas print does.A big difference is if you are displaying arrays.\nEspecially ones with NIL.\nFor example:givesbutgivesNote, no appearing nil item (just a blank line) and each item on a different line.print outputs each argument, followed by $,, to $stdout, followed by $\\. It is equivalent to args.join($,) + $\\puts sets both $, and $\\ to "\\n" and then does the same thing as print. The key difference being that each argument is a new line with puts.You can require \'english\' to access those global variables with user-friendly names.The API docs give some good hints:Writes the given object(s) to ios. The stream must be opened for writing. If the output field separator ($,) is not nil, it will be inserted between each object. If the output record separator ($\\) is not nil, it will be appended to the output. If no arguments are given, prints $_. Objects that aren\xe2\x80\x99t strings will be converted by calling their to_s method. With no argument, prints the contents of the variable $_. Returns nil....Writes the given objects to ios as with IO#print. Writes a record separator (typically a newline) after any that do not already end with a newline sequence. If called with an array argument, writes each element on a new line. If called without arguments, outputs a single record separator.Experimenting a little with the points given above, the differences seem to be:Called with multiple arguments, print separates them by the \'output field separator\' $, (which defaults to nothing) while puts separates them by newlines. puts also puts a newline after the final argument, while print does not.puts automatically unpacks arrays, while print does not:print with no arguments prints $_ (the last thing read by gets), while puts prints a newline:print writes the output record separator $\\ after whatever it prints, while puts ignores this variable:puts call the to_s of each argument and adds a new line to each string, if it does not end with new line.\nprint just output each argument by calling their to_s.for example:\nputs "one two": \none two{new line}puts "one two\\n":\none two{new line} #puts will not add a new line to the result, since the string ends with a new lineprint "one two":\none twoprint "one two\\n":\none two{new line}And there is another way to output: pFor each object, directly writes obj.inspect followed by a newline to the program\xe2\x80\x99s standard output.It is helpful to output debugging message.\np "aa\\n\\t": aa\\n\\tThe print command just takes whatever you give it and prints it to the screen. puts (for "put string") is slightly different: it adds a new (blank) line after the thing you want it to print.But...if you would like to output array within string using "puts", you will get the same result as if you were using "print":But if not withing a quoted string then yes. The only difference is between new line when we use "puts" .If you use \'print\' it will not create a new line automatically.\nWith \'puts\' it does create a new line automatically.