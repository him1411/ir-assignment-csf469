I\'m trying to check if a file exists, but with a wildcard. Here is my example:I have also tried it without the double quotes.The simplest should be to rely on ls return value (it returns non-zero when the files do not exist):I redirected the ls output to make it completely silent.EDIT: Since this answer has got a bit of attention (and very useful critic remarks as comments), here is an optimization that also relies on glob expansion, but avoids the use of ls:This is very similar to @grok12\'s answer, but it avoids the unnecessary iteration through the whole list.If your shell has a nullglob option and it\'s turned on, a wildcard pattern that matches no files will be removed from the command line altogether. This will make ls see no pathname arguments, list the contents of the current directory and succeed, which is wrong. GNU stat, which always fails if given no arguments or an argument naming a nonexistent file, would be more robust. Also, the &> redirection operator is a bashism.Better still is GNU find, which can handle a wildcard search internally and exit as soon as at it finds one matching file, rather than waste time processing a potentially huge list of them expanded by the shell; this also avoids the risk that the shell might overflow its command line buffer.Non-GNU versions of find might not have the -maxdepth option used here to make find search only the /dir/to/search instead of the entire directory tree rooted there.Here is my answer - This will work with multiple files and with white space in file names.UPDATE:Okay, now I definitely have the solution:Maybe this will help someone:You can do the following:This works with sh and derivates: ksh and bash. It doesn\'t create any sub-shell.  $(..)and `...` commands create a sub-shell : they fork a process, and they are inefficient.The question wasn\'t specific to Linux/Bash so I thought I would add the Powershell way - which treats wildcards different - you put it in the quotes like so below:I think this is helpful because the concept of the original question covers "shells" in general not just Bash or Linux, and would apply to Powershell users with the same question too.  The bash code I useThanks!Strictly speaking, if you only want to print "Blah" here is the solution :Here is another way :But I think the most optimal is as follow, because it won\'t try to sort file names :Here\'s a solution for your specific problem that doesn\'t require for loops or external commands like ls, find and the like.As you can see, it\'s just a tad more complicated than what you were hoping for, and relies on the fact that if the shell is not able to expand the glob, it means no files with that glob exist and echo will output the glob as is, which allows us to do a mere string comparison to check whether any of those files exist at all.If we were to generalize the procedure, though, we should take into account the fact that files might contain spaces within their names and/or paths and that the glob char could rightfully expand to nothing (in your example, that would be the case of a file whose name is exactly xorg-x11-fonts).This could be achieved by the following function, in bash.\nGoing back to your example, it could be invoked like this.\nGlob expansion should happen within the function itself for it to work properly, that\'s why I put the argument in quotes and that\'s what the first line in the function body is there for: so that any multiple arguments (which could be the result of a glob expansion outside the function, as well as a spurious parameter) would be coalesced into one. Another approach could be to raise an error if there\'s more than one argument, yet another could be to ignore all but the 1st argument.The second line in the function body sets the files var to an array constituted by all the file names that the glob expanded to, one for each array element. It\'s fine if the file names contain spaces, each array element will contain the names as is, including the spaces. The third line in the function body does two things:It first checks whether there\'s more than one element in the array. If so, it means the glob surely got expanded to something (due to what we did on the 1st line), which in turn implies that at least one file matching the glob exist, which is all we wanted to know.If at step 1. we discovered that we got less than 2 elements in the array, then we check whether we got one and if so we check whether that one exist, the usual way. We need to do this extra check in order to account for function arguments without glob chars, in which case the array contains only one, unexpanded, element.I use this:IMHO it\'s better to use find always when testing for files, globs or directories. The stumbling block in doing so is find\'s exit status: 0 if all paths were traversed successfully, >0 otherwise. The expression you passed to find creates no echo in its exit code.The following example tests if a directory has entries:When A has no files grep fails:When A does not exist grep fails again because find only prints to stderr:Replace -not -empty by any other find expression, but be careful if you -exec a command that prints to stdout. You may want to grep for a more specific expression in such cases.This approach works nicely in shell scripts. The originally question was to look for the glob xorg-x11-fonts*:Note that the else-branched is reached if xorg-x11-fonts* had not matched, or find encountered an error. To distinguish the case use $?.Try thisedit 2014-04-03 (removed dbl-quotes and added test file \'Charlie  22.html\' (2 spaces)TestNote that this only works in the current directory, or where the var fileTarget includes the path you are want to inspect.How about If there is a huge amount of files on a network folder using the wildcard is questionable (speed, or command line arguments overflow).I ended up with:man test will work for dir\\file.regards