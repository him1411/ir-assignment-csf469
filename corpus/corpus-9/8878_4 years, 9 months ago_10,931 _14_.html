The output of the above program compiled using gcc isWith the -Wall or -Waddress option, gcc issues a warning:How is c being evaluated in the above program?It\'s c = i && (&i);, with the second part being redundant, since &i will never evaluate to false.For a user-defined type, where you can actually overload unary operator &, it might be different, but it\'s still a very bad idea.If you turn on warnings, you\'ll get something like:warning: the address of \xe2\x80\x98i\xe2\x80\x99 will always evaluate as \xe2\x80\x98true\xe2\x80\x99There is no &&& operator or token in C.  But the && (logical "and") and & (unary address-of or bitwise "and") operators do exist.By the maximal munch rule, this:is equivalent to this:It sets c to 1 if both i and &i are true, and to 0 if either of them is false.For an int, any non-zero value is true. For a pointer, any non-null value is true (and the address of an object is always non-null). So:It sets c to 1 if i is non-zero, or to 0 if i is equal to zero.Which implies that the &&& is being used here just for deliberate obfuscation. The assignment might as well be any of the following: