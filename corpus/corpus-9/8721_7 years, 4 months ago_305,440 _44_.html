I am trying to use time() to measure various points of my program.What I don\'t understand is why the values in the before and after are the same?  I understand this is not the best way to profile my program, I just want to see how long something take.  I have tried:How do I read a result of **time taken = 0 26339?  Does that mean 26,339 nanoseconds = 26.3 msec?What about **time taken = 4 45025, does that mean 4 seconds and 25 msec?The time() function is only accurate to within a second, but there are CLOCKS_PER_SEC "clocks" within a second.  This is an easy, portable measurement, even though it\'s over-simplified.You can abstract the time measuring mechanism and have each callable\'s run time measured with minimal extra code, just by being called through a timer structure. Plus, at compile time you can parametrize the timing type (milliseconds, nanoseconds etc). Thanks to the review by Loki Astari and the suggestion to use variadic templates.\nThis is why the forwarded function call.DemoAccording to the comment by Howard Hinnant it\'s best not to escape out of the chrono system until we have to. So the above class could give the user the choice to call count manually by providing an extra static method (shown in C++14)and be most useful for clients that "want to post-process a bunch of durations prior to I/O (e.g. average)"The complete code can be found here. My attempt to build a benchmarking tool based on chrono is recorded here.If C++17\'s std::invoke is available, the invocation of the callable in execution could be done like this : to provide for callables that are pointers to member functions. As I can see from your question, it looks like you want to know the elapsed time after execution of some piece of code. I guess you would be comfortable to see the results in second(s). If so, try using difftime() function as shown below. Hope this solves your problem.   Windows only: (The Linux tag was added after I posted this answer)You can use GetTickCount() to get the number of milliseconds that have elapsed since the system was started.the time(NULL) function will return the number of seconds elapsed since 01/01/1970 at 00:00. And because, that function is called at different time in your program, it will always be different\nTime in C++time(NULL) returns the number of seconds elapsed since 01/01/1970 at 00:00 (the Epoch). So the difference between the two values is the number of seconds your processing took. You can get finer results with getttimeofday(), which return the current time in seconds, as time() does and also in microseconds.The values printed by your second program are seconds, and microseconds.Usage is below ::THis is similar to RAII in scopeNOTE this is not mine, but i thought it was relevant hereInternally the function will access the system\'s clock, which is why it returns different values each time you call it. In general with non-functional languages there can be many side effects and hidden state in functions which you can\'t see just by looking at the function\'s name and arguments.The time(NULL) function call will return the number of seconds elapsed since epoc: January 1 1970. Perhaps what you mean to do is take the difference between two timestamps:From what is see, tv_sec stores the seconds elapsed while tv_usec stored the microseconds elapsed separately. And they aren\'t the conversions of each other. Hence, they must be changed to proper unit and added to get the total time elapsed.On linux, clock_gettime() is one of the good choices.\nYou must link real time library(-lrt).They are they same because your doSomething function happens faster than the granularity of the timer. Try:The reason both values are the same is because your long procedure doesn\'t take that long - less than one second. You can try just adding a long loop (for (int i = 0; i < 100000000; i++) ; ) at the end of the function to make sure this is the issue, then we can go from there...In case the above turns out to be true, you will need to find a different system function (I understand you work on linux, so I can\'t help you with the function name) to measure time more accurately. I am sure there is a function simular to GetTickCount() in linux, you just need to find it.I usually use the following:It\'s the same as @nikos-athanasiou proposed except that I avoid using of a non-steady clock and use floating number of seconds as a duration.In answer to OP\'s three specific questions."What I don\'t understand is why the values in the before and after are the same?"The first question and sample code shows that time() has a resolution of 1 second, so the answer has to be that the two functions execute in less than 1 second. But occasionally it will (apparently illogically) inform 1 second if the two timer marks straddle a one second boundary.The next example uses gettimeofday() which fills this structand the second question asks: "How do I read a result of **time taken = 0 26339? Does that mean 26,339 nanoseconds = 26.3 msec?"My second answer is the time taken is 0 seconds and 26339 microseconds, that is 0.026339 seconds, which bears out the first example executing in less than 1 second.The third question asks: "What about **time taken = 4 45025, does that mean 4 seconds and 25 msec?"My third answer is the time taken is 4 seconds and 45025 microseconds, that is 4.045025 seconds, which shows that OP has altered the tasks performed by the two functions which he previously timed.You can use SFML library, which is Simple and Fast Multimedia Library.\nIt includes many useful and well-defined classes like Clock, Socket, Sound, Graphics, etc.\nIt\'s so easy to use and highly recommended.This is an example for this question.