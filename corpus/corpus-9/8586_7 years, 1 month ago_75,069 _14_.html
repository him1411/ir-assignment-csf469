I\'ve successfully implemented onRetainNonConfigurationInstance() for my main Activity to save and restore certain critical components across screen orientation changes. But it seems, my custom views are being re-created from scratch when the orientation changes. This makes sense, although in my case it\'s inconvenient because the custom view in question is an X/Y plot and the plotted points are stored in the custom view. Is there a crafty way to implement something similar to onRetainNonConfigurationInstance() for a custom view, or do I need to just implement methods in the custom view which allow me to get and set its "state"?You do this by implementing View#onSaveInstanceState and View#onRestoreInstanceState and extending the View.BaseSavedState class.The work is split between the View and the View\'s SavedState class. You should do all the work of reading and writing to and from the Parcel in the SavedState class. Then your View class can do the work of extracting the state members and doing the work necessary to get the class back to a valid state.Notes: View#onSavedInstanceState and View#onRestoreInstanceState are called automatically for you if View#getId returns a value >= 0. This happens when you give it an id in xml or call setId manually. Otherwise you have to call View#onSaveInstanceState and write the Parcelable returned to the parcel you get in Activity#onSaveInstanceState to save the state and subsequently read it and pass it to View#onRestoreInstanceState from Activity#onRestoreInstanceState.Another simple example of this is the CompoundButtonI think this is a much simpler version. Bundle is a built-in type which implements ParcelableHere is another variant that uses a mix of the two above methods.\nCombining the speed and correctness of Parcelable with the simplicity of a Bundle:The answers here already are great, but don\'t necessarily work for custom ViewGroups. To get all custom Views to retain their state, you must override onSaveInstanceState() and onRestoreInstanceState(Parcelable state) in each class.\nYou also need to ensure they all have unique ids, whether they\'re inflated from xml or added programmatically.What I came up with was remarkably like Kobor42\'s answer, but the error remained because I was adding the Views to a custom ViewGroup programmatically and not assigning unique ids.The link shared by mato will work, but it means none of the individual Views manage their own state - the entire state is saved in the ViewGroup methods.The problem is that when multiple of these ViewGroups are added to a layout, the ids of their elements from the xml are no longer unique (if its defined in xml). At runtime, you can call the static method View.generateViewId() to get a unique id for a View. This is only available from API 17.Here is my code from the ViewGroup (it is abstract, and mOriginalValue is a type variable):