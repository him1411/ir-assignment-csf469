@user object adds errors to the lang_errors variable in the update_lanugages method.\nwhen I perform a save on the @user object I lose the errors that were initially stored in the lang_errors variable.Though what I am attempting to do would be more of a hack (which does not seem to be working). I would like to understand why the variable values are washed out. I understand pass by reference so I would like to know how the value can be held in that variable without being washed out.In traditional terminology, Ruby is strictly pass-by-value. But that\'s not really what you\'re asking here.Ruby doesn\'t have any concept of a pure, non-reference value, so you certainly can\'t pass one to a method. Variables are always references to objects. In order to get an object that won\'t change out from under you, you need to dup or clone the object you\'re passed, thus giving an object that nobody else has a reference to. (Even this isn\'t bulletproof, though \xe2\x80\x94 both of the standard cloning methods do a shallow copy, so the instance variables of the clone still point to the same objects that the originals did. If the objects referenced by the ivars mutate, that will still show up in the copy, since it\'s referencing the same objects.)The other answerers are all correct, but a friend asked me to explain this to him and what it really boils down to is how Ruby handles variables, so I thought I would share some simple pictures / explanations I wrote for him (apologies for the length and probably some oversimplification):It\'s basically the same as what happens in Q3/Q4; the method gets its own private copy of the variable / label (str2) that gets passed in to it (str).  It can\'t change which object the label str points to, but it can change the contents of the object that they both reference to contain else:Is Ruby pass by reference or by value?Ruby is pass-by-value. Always. No exceptions. No ifs. No buts.Here is a simple program which demonstrates that fact:(Using Python\'s terminology.)To say Ruby uses "pass by value" or "pass by reference" isn\'t really descriptive enough to be helpful. I think as most people know it these days, that terminology ("value" vs "reference") comes from C++.In C++, "pass by value" means the function gets a copy of the variable and any changes to the copy don\'t change the original. That\'s true for objects too. If you pass an object variable by value then the whole object (including all of its members) get copied and any changes to the members don\'t change those members on the original object. (It\'s different if you pass a pointer by value but Ruby doesn\'t have pointers anyway, AFAIK.)Output:In C++, "pass by reference" means the function gets access to the original variable. It can assign a whole new literal integer and the original variable will then have that value too.Output:Ruby uses pass by value (in the C++ sense) if the argument is not an object. But in Ruby everything is an object, so there really is no pass by value in the C++ sense in Ruby.In Ruby, "pass by object reference" (to use Python\'s terminology) is used:Therefore Ruby does not use "pass by reference" in the C++ sense. If it did, then assigning a new object to a variable inside a function would cause the old object to be forgotten after the function returned.Output:* This is why, in Ruby, if you want to modify an object inside a function but forget those changes when the function returns, then you must explicitly make a copy of the object before making your temporary changes to the copy.There are already some great answers, but I want to post the definition of a pair of authorities on the subject, but also hoping someone might explain what said authorities Matz (creator of Ruby) and David Flanagan meant in their excellent O\'Reilly book, The Ruby Programming Language.[from 3.8.1: Object References]When you pass an object to a method in Ruby, it is an object reference that is passed to the  method. It is not the object itself, and it is not a reference to the reference to the  object. Another way to say this is that method arguments are passed by value rather than by reference, but that the values passed are object references.Because object references are passed to methods, methods can use those references to modify the underlying object. These modifications are then visible when the method returns.This all makes sense to me until that last paragraph, and especially that last sentence. This is at best misleading, and at worse confounding. How, in any way, could modifications to that passed-by-value reference change the underlying object?Is Ruby pass by reference or by value?Ruby is pass-by-reference. Always. No exceptions. No ifs. No buts.Here is a simple program which demonstrates that fact:=> 2279146940 Ruby is pass-by-reference 2279146940 because object_id\'s (memory addresses) are always the same ;)=> some people don\'t realize it\'s reference because local assignment can take precedence, but it\'s clearly pass-by-referenceRuby is pass-by-value in a strict sense, BUT the values are references. This could be called "pass-reference-by-value". This article has the best explanation I have read: http://robertheaton.com/2014/07/22/is-ruby-pass-by-reference-or-pass-by-value/Pass-reference-by-value could briefly be explained as follows:A function receives a reference to (and will access) the same object in memory as used by the caller. However, it does not receive the box that the caller is storing this object in; as in pass-value-by-value, the function provides its own box and creates a new variable for itself. The resulting behavior is actually a combination of the classical definitions of pass-by-reference and pass-by-value.Parameters are a copy of the original reference. So, you can change values, but cannot change the original reference.Ruby is interpreted.  Variables are references to data, but not the data itself. This facilitates using the same variable for data of different types.Assignment of lhs = rhs then copies the reference on the rhs, not the data.  This differs in other languages, such as C, where assignment does a data copy to lhs from rhs.  So for the function call, the variable passed, say x, is indeed copied into a local variable in the function, but x is a reference. There will then be two copies of the reference, both referencing the same data.  One will be in the caller, one in the function. Assignment in the function would then copy a new reference to the function\'s version of x. After this the caller\'s version of x remains unchanged.  It is still a reference to the original data.In contrast, using the .replace method on x will cause ruby to do a data copy.  If replace is used before any new assignments then indeed the caller will see the data change in its version also.Similarly, as long as the original reference is in tact for the passed in variable, the instance variables will be the same that the caller sees.  Within the framework of an object, the instance variables always have the most up to date reference values, whether those are provided by the caller or set in the function the class was passed in to.The \'call by value\' or \'call by reference\' is muddled here because of confusion over \'=\' In compiled languages \'=\' is a data copy.  Here in this interpreted language \'=\' is a reference copy.  In the example you have the reference passed in followed by a reference copy though \'=\' that clobbers the original passed in reference, and then people talking about it as though \'=\' were a data copy.  To be consistent with definitions we must keep with \'.replace\' as it is a data copy.  From the perspective of \'.replace\' we see that this is indeed pass by reference.  Furthermore, if we walk through in the debugger, we see references being passed in, as variables are references.  However if we must keep \'=\' as a frame of reference, then indeed we do get to see the passed in data up until an assignment, and then we don\'t get to see it anymore after assignment while the caller\'s data remains unchanged.  At a behavioral level this is pass by value as long as we don\'t consider the passed in value to be composite - as we won\'t be able to keep part of it while changing the other part in a single assignment (as that assignment changes the reference and the original goes out of scope).  There will also be a wart, in that instance variables in objects will be references, as are all variables.  Hence we will be forced to talk about passing \'references by value\' and have to use related locutions.Try this:--identifier a contains object_id 3 for value object 1 and identifier b contains object_id 5 for value object 2.Now do this:--Now, a and b both contain same object_id 5 which refers to value object 2.\nSo, Ruby variable contains object_ids to refer to value objects.Doing following also gives error:--but doing this won\'t give error:--Here identifier a returns value object 11 whose object id is 23 i.e. object_id 23 is at identifier a, Now we see an example by using method.arg in foo is assigned with return value of x.\nIt clearly shows that argument is passed by value 11, and value 11 being itself an object has unique object id 23. Now see this also:--Here, identifier arg first contains object_id 23 to refer 11 and after internal assignment with value object 12, it contains object_id 25. But it does not change value referenced by identifier x used in calling method.Hence, Ruby is pass by value and Ruby variables do not contain values but do contain reference to value object.It should be noted that you do not have to even use the "replace" method to change the value original value. If you assign one of the hash values for a hash, you are changing the original value. 