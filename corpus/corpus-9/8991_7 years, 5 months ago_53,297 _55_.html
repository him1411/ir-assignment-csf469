How can I check if I have any uncommitted changes in my git repository:from a script?git-status seems to always return zero with git version 1.6.4.2.Great timing! I wrote a blog post about exactly this a few days ago, when I figured out how to add git status information to my prompt.Here\'s what I do:For dirty status:For untracked files (Notice the --porcelain flag to git status which gives you nice parse-able output):Although git diff --shortstat is more convenient, you can also use git status --porcelain for getting dirty files:Note: The 2>/dev/null filters out the error messages so you can use these commands on non-git directories. (They\'ll simply return 0 for the file counts.)Edit:Here are the posts:Adding Git Status Information to your Terminal PromptImproved Git-enabled Shell PromptThe key to reliably \xe2\x80\x9cscripting\xe2\x80\x9d Git is to use the \xe2\x80\x98plumbing\xe2\x80\x99 commands.The developers take care when changing the plumbing commands to make sure they provide very stable interfaces (i.e. a given combination of repository state, stdin, command line options, arguments, etc. will produce the same output in all versions of Git where the command/option exists). New output variations in plumbing commands can be introduced via new options, but that can not introduce any problems for programs that have already been written against older versions (they would not be using the new options, since they did not exist (or at least were not used) at the time the script was written).Unfortunately the \xe2\x80\x98everyday\xe2\x80\x99 Git commands are the \xe2\x80\x98porcelain\xe2\x80\x99 commands, so most Git users may not be familiar with with the plumbing commands. The distinction between porcelain and plumbing command is made in the main git manpage (see subsections titled High-level commands (porcelain) and Low-level commands (plumbing).To find out about uncomitted changes, you will likely need git diff-index (compare index (and maybe tracked bits of working tree) against some other treeish (e.g. HEAD)), maybe git diff-files (compare working tree against index), and possibly git ls-files (list files; e.g. list untracked, unignored files).(Note that in the below commands, HEAD -- is used instead of HEAD because otherwise the command fails if there is a file named HEAD.)To check whether a repository has staged changes (not yet committed) use this:To check whether a working tree has changes that could be staged:To check whether the combination of the index and the tracked files in the working tree have changes with respect to HEAD:You also mentioned untracked files. You might mean \xe2\x80\x9cuntracked and unignored\xe2\x80\x9d, or you might mean just plain \xe2\x80\x9cuntracked\xe2\x80\x9d (including ignored files). Either way, git ls-files is the tool for the job:For \xe2\x80\x9cuntracked\xe2\x80\x9d (will include ignored files, if present):For \xe2\x80\x9cuntracked and unignored\xe2\x80\x9d:My first thought is to just check whether these commands have output:There is a small chance that this will translate abnormal exits from git ls-files into \xe2\x80\x9cno untracked files\xe2\x80\x9d reports (both result in non-zero exits of the above command). A bit more robust version might look like this:Another idea is to use --error-unmatch to cause a non-zero exit when there are no untracked files. This also runs the risk of conflating \xe2\x80\x9cno untracked files\xe2\x80\x9d\xc2\xa0(exit 1) with \xe2\x80\x9can error occurred\xe2\x80\x9d (exit non-zero, but probably 128). But checking for 0 vs. 1 vs. non-zero exit codes is probably fairly robust:Any of the above git ls-files examples can take --exclude-standard if you want to consider only untracked and unignored files.Assuming you are on git 1.7.0 or later...After reading all of the answers on this page and some experimenting, I think the method that hits the right combination of correctness and brevity is:While git allows for a lot of nuance between what\'s tracked, ignore, untracked but unignored, and so on, I believe the typical use case is for automating build scripts, where you want to stop everything if your checkout isn\'t clean.In that case, it makes sense to simulate what the programmer would do: type git status and look at the output. But we don\'t want to rely on specific words showing up, so we use the --porcelain mode introduced in 1.7.0; when enabled, a clean directory results in no output.Then we use test -n to see if there was any output or not.This command will return 1 if the working directory is clean and 0 if there are changes to be committed. You can change the -n to a -z if you want the opposite.  This is useful for chaining this to a command in a script. For example:This effectively says "either there are no changes to be made or set off an alarm"; this one-liner might be preferable to an if-statement depending on the script you are writing.An implementation from VonC\'s answer:Had a look through a few of these answers... (and had various issues on *nix and windows, which was a requirement I had)... found the following worked well...To check the exit code in *nixTo check the exit code in window$Sourced from https://github.com/sindresorhus/pure/issues/115\nThanks to @paulirish on that post for sharingWhy not encapsulate \'git status with a script which:That way, you can use that \'enhanced\' status in your script.As 0xfe mentions in his excellent answer, git status --porcelain is instrumental in any script-based solutionGive the output in a stable, easy-to-parse format for scripts.\n  Currently this is identical to --short output, but is guaranteed not to change in the future, making it safe for scripts.One DIY possibility, updated to follow 0xfe\'s suggestionAs noted by Chris Johnsen, this only works on Git 1.7.0 or newer.This is a more shell friendly variation for finding out if any untracked files exist in the repository:This doesn\'t fork a second process, grep, and doesn\'t need a check for if you are in a git repository or not.  Which is handy for shell prompts, etc.There may be a better combination of answers from this thread.. but this works for me...  for your .gitconfig\'s [alias] section ...The simplest automatic test I use to detect dirty state = any changes including untracked files:NOTE:You can also do. It will append the word "-dirty" at the end if it detects a dirty working tree. According to git-describe(1):. Caveat: untracked files are not considered "dirty", because, as the manpage states, it only cares about the working tree.Here is the best, cleanest way. The selected answer didn\'t work for me for some reason, it didn\'t pick up changes staged that were new files that weren\'t committed.