Why doesn\'t Set provide an operation to get an element that equals another element?I can ask whether the Set contains an element equal to bar, so why can\'t I get that element? :(To clarify, the equals method is overridden, but it only checks one of the fields, not all. So two Foo objects that are considered equal can actually have different values, that\'s why I can\'t just use foo.There would be no point of getting the element if it is equal. A Map is better suited for this usecase.If you still want to find the element you have no other option but to use the iterator:To answer the precise question "Why doesn\'t Set provide an operation to get an element that equals another element?", the answer would be: because the designers of the collection framework were not very forward looking. They didn\'t anticipate your very legitimate use case, naively tried to "model the mathematical set abstraction" (from the javadoc) and simply forgot to add the useful get() method.Now to the implied question "how do you get the element then": I think the best solution is to use a Map<E,E> instead of a Set<E>, to map the elements to themselves. In that way, you can efficiently retrieve an element from the "set", because the get() method of the Map will find the element using an efficient hash table or tree algorithm. If you wanted, you could write your own implementation of Set that offers the additional get() method, encapsulating the Map.The following answers are in my opinion bad or wrong:"You don\'t need to get the element, because you already have an equal object": the assertion is wrong, as you already showed in the question. Two objects that are equal still can have different state that is not relevant to the object equality. The goal is to get access to this state of the element contained in the Set, not the state of the object used as a "query"."You have no other option but to use the iterator": that is a linear search over a collection which is totally inefficient for large sets (ironically, internally the Set is organized as hash map or tree that could be queried efficiently). Don\'t do it! I have seen severe performance problems in real-life systems by using that approach. In my opinion what is terrible about the missing get() method is not so much that it is a bit cumbersome to work around it, but that most programmers will use the linear search approach without thinking of the implications.Convert set to list, and then use get method of listIf your set is in fact a NavigableSet<Foo> (such as a TreeSet), and Foo implements Comparable<Foo>, you can use(Thanks to @eliran-malka\xe2\x80\x99s comment for the hint.)If you have an equal object, why do you need the one from the set? If it is "equal" only by a key, an Map would be a better choice.Anyway, the following will do it:With Java 8 this can become a one liner:Default Set in Java is, unfortunately, not designed to provide a "get" operation, as jschreiner accurately explained.The solutions of using an iterator to find the element of interest (suggested by dacwe) or to remove the element and re-add it with its values updated (suggested by KyleM), could work, but can be very inefficient.Overriding the implementation of equals so that non-equal objects are "equal", as stated correctly by David Ogren, can easily cause maintenance problems.And using a Map as an explicit replacement (as suggested by many), imho, makes the code less elegant.If the goal is to get access to the original instance of the element contained in the set (hope I understood correctly your use case), here is another possible solution.I personally had your same need while developing a client-server videogame with Java. In my case, each client had copies of the components stored in the server and the problem was whenever a client needed to modify an object of the server.Passing an object through the internet meant that the client had different instances of that object anyway. In order to match this "copied" instance with the original one, I decided to use Java UUIDs.So I created an abstract class UniqueItem, which automatically gives a random unique id to each instance of its subclasses.This UUID is shared between the client and the server instance, so this way it could be easy to match them by simply using a Map.However directly using a Map in a similar usecase was still inelegant. Someone might argue that using an Map might be more complicated to mantain and handle.For these reasons I implemented a library called MagicSet, that makes the usage of an Map "transparent" to the developer.https://github.com/ricpacca/magicsetLike the original Java HashSet, a MagicHashSet (which is one of the implementations of MagicSet provided in the library) uses a backing HashMap, but instead of having elements as keys and a dummy value as values, it uses the UUID of the element as key and the element itself as value. This does not cause overhead in the memory use compared to a normal HashSet. Moreover, a MagicSet can be used exactly as a Set, but with some more methods providing additional functionalities, like getFromId(), popFromId(), removeFromId(), etc.The only requirement to use it is that any element that you want to store in a MagicSet needs to extend the abstract class UniqueItem.Here is a code example, imagining to retrieve the original instance of a city from a MagicSet, given another instance of that city with the same UUID (or even just its UUID).If you only do one get this will not be very performing because you will loop over all your elements but when performing multiple retrieves on a big set you will notice the difference.You better use the Java HashMap object for that purpose http://download.oracle.com/javase/1,5.0/docs/api/java/util/HashMap.htmlI know, this has been asked and answered long ago, however if anyone is interested, here is my solution - custom set class backed by HashMap:http://pastebin.com/Qv6S91n9You can easily implement all other Set methods.Quick helper method that might address this situation:With Java 8 you can do:But be careful, .get() throws a NoSuchElementException, or you can manipulate a Optional item.If you want nth Element from HashSet, you can go with below solution, \nhere i have added object of ModelClass in HashSet.Because any particular implementation of Set may or may not be random access.You can always get an iterator and step through the Set, using the iterators\' next() method to return the result you want once you find the equal element.  This works regardless of the implementation.  If the implementation is NOT random access (picture a linked-list backed Set), a get(E element) method in the interface would be deceptive, since it would have to iterate the collection to find the element to return, and a get(E element) would seem to imply this would be necessary, that the Set could jump directly to the element to get.contains() may or may not have to do the same thing, of course, depending on the implementation, but the name doesn\'t seem to lend itself to the same sort of misunderstandings.Maybe using an array:ObjectClass[] arrayName = SetOfObjects.toArray( new ObjectClass[setOfObjects.size()] );Been there done that!! If you are using Guava a quick way to convert it to a map is:Yes, use HashMap ... but in a specialised way: the trap I foresee in trying to use a HashMap as a pseudo-Set is the possible confusion between "actual" elements of the Map/Set, and "candidate" elements, i.e. elements used to test whether an equal element is already present.  This is far from foolproof, but nudges you away from the trap:Then do this:But... you now want the candidate to self-destruct in some way unless the programmer actually immediately puts it in the Map/Set... you\'d want contains to "taint" the candidate so that any use of it unless it joins the Map makes it "anathema".  Perhaps you could make SomeClass implement a new Taintable interface.A more satisfactory solution is a GettableSet, as below. However, for this to work you have either to be in charge of the design of SomeClass in order to make all constructors non-visible (or... able and willing to design and use a wrapper class for it):Implementation: Your NoVisibleConstructor classes then look like this:PS one technical issue with such a NoVisibleConstructor class: it may be objected that such a class is inherently final, which may be undesirable. Actually you could always add a dummy parameterless protected constructor:... which would at least let a subclass compile. You\'d then have to think about whether you need to include another getOrCreate() factory method in the subclass.Final step is an abstract base class (NB "element" for a list, "member" for a set) like this for your set members (when possible - again, scope for using a wrapper class where the class is not under your control, or already has a base class, etc.), for maximum implementation-hiding:... usage is fairly obvious (inside your SomeClass\'s static factory method):Why:It seems that Set plays a useful role in providing a means of comparison. It is designed not to store duplicate elements.Because of this intention/design, if one were to get() a reference to the stored object, then mutate it, it is possible that the design intentions of Set could be thwarted and could cause unexpected behavior.From the JavaDocsGreat care must be exercised if mutable objects are used as set elements. The behavior of a set is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is an element in the set.How:Now that Streams have been introduced one can do the followingyou can use Iterator classFollowing can be an approach 