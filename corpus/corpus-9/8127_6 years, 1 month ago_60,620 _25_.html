Why is there no std::make_unique function template in the standard C++11 library? I finda bit verbose. Wouldn\'t the following be much nicer?This hides the new nicely and only mentions the type once.Anyway, here is my attempt at an implementation of make_unique:It took me quite a while to get the std::forward stuff to compile, but I\'m not sure if it\'s correct. Is it? What exactly does std::forward<Args>(args)... mean? What does the compiler make of that?Herb Sutter, chair of the C++ standardization committee, writes on his blog:That C++11 doesn\xe2\x80\x99t include make_unique is partly an oversight, and it will almost certainly be added in the future.He also gives an implementation that is identical with the one given by the OP.Edit: std::make_unique now is part of C++14.Nice, but Stephan T. Lavavej (better known as STL) has a better solution for make_unique, which works correctly for the array version.This can be seen on his Core C++ 6 video.An updated version of STL\'s version of make_unique is now available as N3656. This version got adopted into draft C++14.While nothing stops you from writing your own helper, I believe that the main reason for providing make_shared<T> in the library is that it actually creates a different internal type of shared pointer than shared_ptr<T>(new T), which is differently allocated, and there\'s no way to achieve this without the dedicated helper.Your make_unique wrapper on the other hand is mere syntactic sugar around a new expression, so while it might look pleasing to the eye, it doesn\'t bring anything new to the table. Correction: this isn\'t in fact true: Having a function call to wrap the new expression provides exception safety, for example in the case where you call a function void f(std::unique_ptr<A> &&, std::unique_ptr<B> &&). Having two raw news that are unsequenced with respect to one another means that if one new expression fails with an exception, the other may leak resources. As for why there\'s no make_unique in the standard: It was just forgotten. (This happens occasionally. There\'s also no global std::cbegin in the standard even though there should be one.)Also note that unique_ptr takes a second template parameter which you should somehow allow for; this is different from shared_ptr, which uses type erasure to store custom deleters without making them part of the type.std::make_shared isn\'t just shorthand for std::shared_ptr<Type> ptr(new Type(...));. It does something that you cannot do without it.In order to do its job, std::shared_ptr must allocate a tracking block in addition to holding the storage for the actual pointer. However, because std::make_shared allocates the actual object, it is possible that std::make_shared allocates both the object and the tracking block in the same block of memory.So while std::shared_ptr<Type> ptr = new Type(...); would be two memory allocations (one for the new, one in the std::shared_ptr tracking block), std::make_shared<Type>(...) would allocate one block of memory.That is important for many potential users of std::shared_ptr. The only thing a std::make_unique would do is be slightly more convenient. Nothing more than that.In C++11 ... is used (in template code) for "pack expansion" too.The requirement is that you use it as a suffix of an expression containing an unexpanded pack of parameters, and it will simply apply the expression to each of the elements of the pack.For example, building on your example:The latter being incorrect I think.Also, pack of arguments may not be passed to a function unexpanded. I am unsure about a pack of template parameters.Inspired by the implementation by Stephan T. Lavavej, I thought it might be nice to have a make_unique that supported array extents, it\'s on github and I\'d love to get comments on it.  It allows you to do this: