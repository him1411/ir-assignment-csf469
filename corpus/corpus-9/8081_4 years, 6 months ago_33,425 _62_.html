How dangerous is accessing an array outside of its bounds (in C)? It can sometimes happen that I read from outside the array (I now understand I then access memory used by some other parts of my program or even beyond that) or I am trying to set a value to an index outside of the array. The program sometimes crashes, but sometimes just runs, only giving unexpected results. Now what I would like to know is, how dangerous is this really? If it damages my program, it is not so bad. If on the other hand it breaks something outside my program, because I somehow managed to access some totally unrelated memory, then it is very bad, I imagine.\nI read a lot of \'anything can happen\', \'segmentation might be the least bad problem\', \'your harddisk might turn pink and unicorns might be singing under your window\', which is all nice, but what is really the danger?My questions:I use OSX 10.7, Xcode 4.6This is my first Stackoverflow question. I took time reading as much as I could on the subject, but I probably missed many resources. Let me know if you feel I did not do enough research and/or you see other problems with this question.As far as the ISO C standard (the official definition of the language) is concerned, accessing an array outside its bounds has "undefined behavior". The literal meaning of this is:behavior, upon use of a nonportable or erroneous program construct or\n  of erroneous data, for which this International Standard imposes no\n  requirementsA non-normative note expands on this:Possible undefined behavior ranges from ignoring the situation \n  completely with unpredictable results, to behaving during translation\n  or program execution in a documented manner characteristic of the\n  environment (with or without the issuance of a diagnostic message), to\n  terminating a translation or execution (with the issuance of a\n  diagnostic message).So that\'s the theory. What\'s the reality?In the "best" case, you\'ll access some piece of memory that\'s either owned by your currently running program (which might cause your program to misbehave), or that\'s not owned by your currently running program (which will probably cause your program to crash with something like a segmentation fault). Or you might attempt to write to memory that your program owns, but that\'s marked read-only; this will probably also cause your program to crash.That\'s assuming your program is running under an operating system that attempts to protect concurrently running processes from each other. If your code is running on the "bare metal", say if it\'s part of an OS kernel or an embedded system, then there is no such protection; your misbehaving code is what was supposed to provide that protection. In that case, the possibilities for damage are considerably greater, including, in some cases, physical damage to the hardware (or to things or people nearby).Even in a protected OS environment, the protections aren\'t always 100%. There are operating system bugs that permit unprivileged programs to obtain root (administrative) access, for example. Even with ordinary user privileges, a malfunctioning program can consume excessive resources (CPU, memory, disk), possibly bringing down the entire system. A lot of malware (viruses, etc.) exploits buffer overruns to gain unauthorized access to the system.(One historical example: I\'ve heard that on some old systems with core memory, repeatedly accessing a single memory location in a  tight loop could literally cause that chunk of memory to melt. Other possibilities include destroying a CRT display, and moving the read/write head of a disk drive with the harmonic frequency of the drive cabinet, causing it to walk across a table and fall onto the floor.)And there\'s always Skynet to worry about.The bottom line is this: if you could write a program to do something bad deliberately, it\'s at least theoretically possible that a buggy program could do the same thing accidentally.In practice, it\'s very unlikely that your buggy program running on a MacOS X system is going to do anything more serious than crash. But it\'s not possible to completely prevent buggy code from doing really bad things.In general, Operating Systems of today (the popular ones anyway) run all applications in protected memory regions using a virtual memory manager.  It turns out that it is not terribly EASY (per say) to simply read or write to a location that exists in REAL space outside the region(s) that have been assigned / allocated to your process.Direct answers:1) Reading will almost never directly damage another process, however it can indirectly damage a process if you happen to read a KEY value used to encrypt, decrypt, or validate a program / process.  Reading out of bounds can have somewhat adverse / unexpected affects on your code if you are making decisions based on the data you are reading2) The only way your could really DAMAGE something by writing to a loaction accessible by a memory address is if that memory address that you are writing to is actually a hardware register (a location that actually is not for data storage but for controlling some piece of hardware) not a RAM location.  In all fact, you still wont normally damage something unless you are writing some one time programmable location that is not re-writable (or something of that nature).3) Generally running from within the debugger runs the code in debug mode.  Running in debug mode does TEND to (but not always) stop your code faster when you have done something considered out of practice or downright illegal.4) Never use macros, use data structures that already have array index bounds checking built in, etc....ADDITIONAL\nI should add that the above information is really only for systems using an operating system with memory protection windows.  If writing code for an embedded system or even a system utilizing an operating system (real-time or other) that does not have memory protection windows (or virtual addressed windows) that one should practice a lot more caution in reading and writing to memory.  Also in these cases SAFE and SECURE coding practices should always be employed to avoid security issues.Not checking bounds can lead to to ugly side effects, including security holes. One of the ugly ones is arbitrary code execution. In classical example: if you have an fixed size array, and use strcpy() to put a user-supplied string there, the user can give you a string that overflows the buffer and overwrites other memory locations, including code address where CPU should return when your function finishes.Which means your user can send you a string that will cause your program to essentially call exec("/bin/sh"), which will turn it into shell, executing anything he wants on your system, including harvesting all your data and turning your machine into botnet node.See Smashing The Stack For Fun And Profit for details on how this can be done.You write:I read a lot of \'anything can happen\', \'segmentation might be the\n  least bad problem\', \'your harddisk might turn pink and unicorns might\n  be singing under your window\', which is all nice, but what is really\n  the danger?Lets put it that way: load a gun. Point it outside the window without any particular aim and fire. What is the danger?The issue is that you do not know. If your code overwrites something that crashes your program you are fine because it will stop it into a defined state. However if it does not crash then the issues start to arise. Which resources are under control of your program and what might it do to them? Which resources might get under control of your program and what might it do to them? I know at least one major issue that was caused by such an overflow. The issue was in a seemingly meaningless statistics function that messed up some unrelated conversion table for a production database. The result was some very expensive cleanup afterwards. Actually it would have been much cheaper and easier to handle if this issue would have formatted the hard disks ... with other words: pink unicorns might be your least problem.The idea that your operating system will protect you is optimistic. If possible try to avoid writing out of bounds.Not running your program as root or any other privileged user won\'t harm any of your system, so generally this might be a good idea.By writing data to some random memory location you won\'t directly "damage" any other program running on your computer as each process runs in it\'s own memory space.If you try to access any memory not allocated to your process the operating system will stop your program from executing with a segmentation fault.So directly (without running as root and directly accessing files like /dev/mem) there is no danger that your program will interfere with any other program running on your operating system.Nevertheless - and probably this is what you have heard about in terms of danger - by blindly writing random data to random memory locations by accident you sure can damage anything you are able to damage. For example your program might want to delete a specific file given by a file name stored somewhere in your program. If by accident you just overwrite the location where the file name is stored you might delete a very different file instead.Besides your own program, I don\'t think you will break anything, in the worst case you will try to read or write from a memory address that corresponds to a page that the kernel didn\'t assign to your proceses, generating the proper exception and being killed (I mean, your process).NSArrays in Objective-C are assigned a specific block of memory.  Exceeding the bounds of the array means that you would be accessing memory that is not assigned to the array.  This means:From the aspect of your program you always want to know when your code is exceeding the bounds of an array.  This can lead to unknown values being returned, causing your application to crash or provide invalid data.You may want to try using the memcheck tool in Valgrind when you test your code -- it won\'t catch individual array bounds violations within a stack frame, but it should catch many other sorts of memory problem, including ones that would cause subtle, wider problems outside the scope of a single function.From the manual:Memcheck is a memory error detector. It can detect the following problems that are common in C and C++ programs.ETA: Though, as Kaz\'s answer says, it\'s not a panacea, and doesn\'t always give the most helpful output, especially when you\'re using exciting access patterns.I\'m working with a compiler for a DSP chip which deliberately generates code that accesses one past the end of an array out of C code which does not!This is because the loops are structured so that the end of an iteration prefetches some data for the next iteration. So the datum prefetched at the end of the last iteration is never actually used.Writing C code like that invokes undefined behavior, but that is only a formality from a standards document which concerns itself with maximal portability.More often that not, a program which accesses out of bounds is not cleverly optimized. It is simply buggy. The code fetches some garbage value and, unlike the optimized loops of the aforementioned compiler, the code then uses the value in subsequent computations, thereby corrupting theim.It is worth catching bugs like that, and so it is worth making the behavior undefined for even just that reason alone: so that the run-time can produce a diagnostic message like "array overrun in line 42 of main.c".On systems with virtual memory, an array could happen to be allocated such that the address which follows is in an unmapped area of virtual memory. The access will then bomb the program.As an aside, note that in C we are permitted to create a pointer which is one past the end of an array. And this pointer has to compare greater than any pointer to the interior of an array.\n  This means that a C implementation cannot place an array right at the end of memory, where the one plus address would wrap around and look smaller than other addresses in the array.Nevertheless, access to uninitialized or out of bounds values are sometimes a valid optimization technique, even if not maximally portable. This is for instance why the Valgrind tool does not report accesses to uninitialized data when those accesses happen, but only when the value is later used in some way that could affect the outcome of the program. You get a diagnostic like "conditional branch in xxx:nnn depends on uninitialized value" and it can be sometimes hard to track down where it originates. If all such accesses were trapped immediately, there would be a lot of false positives arising from compiler optimized code as well as correctly hand-optimized code.Speaking of which, I was working with some codec from a vendor which was giving off these errors when ported to Linux and run under Valgrind. But the vendor convinced me that only several bits of the value being used actually came from uninitialized memory, and those bits were carefully avoided by the logic.. Only the good bits of the value were being used and Valgrind doesn\'t have the ability to track down to the individual bit. The uninitialized material came from reading a word past the end of a bit stream of encoded data, but the code knows how many bits are in the stream and will not use more bits than there actually are.  Since the access beyond the end of the bit stream array does not cause any harm on the DSP architecture (there is no virtual memory after the array, no memory-mapped ports, and the address does not wrap) it is a valid optimization technique."Undefined behavior" does not really mean much, because according to ISO C, simply including a header which is not defined in the C standard, or calling a function which is not defined in the program itself or the C standard, are examples of undefined behavior. Undefined behavior doesn\'t mean "not defined by anyone on the planet" just "not defined by the ISO C standard". But of course, sometimes undefined behavior really is absolutely not defined by anyone.If you ever do systems level programming or embedded systems programming, very bad things can happen if you write to random memory locations. Older systems and many micro-controllers use memory mapped IO, so writing to a memory location that maps to a peripheral register can wreak havoc, especially if it is done asynchronously. An example is programming flash memory. Programming mode on the memory chips is enabled by writing a specific sequence of values to specific locations inside the address range of the chip. If another process were to write to any other location in the chip while that was going on, it would cause the programming cycle to fail.In some cases the hardware will wrap addresses around (most significant bits/bytes of address are ignored) so writing to an address beyond the end of the physical address space will actually result in data being written right in the middle of things.And finally, older CPUs like the MC68000 can locked up to the point that only a hardware reset can get them going again. Haven\'t worked on them for a couple of decades but I believe it\'s when it encountered a bus error (non-existent memory) while trying to handle an exception, it would simply halt until the hardware reset was asserted.My biggest recommendation is a blatant plug for a product, but I have no personal interest in it and I am not affiliated with them in any way - but based on a couple of decades of C programming and embedded systems where reliability was critical, Gimpel\'s PC Lint will not only detect those sort of errors, it will make a better C/C++ programmer out of you by constantly harping on you about bad habits. I\'d also recommend reading the MISRA C coding standard, if you can snag a copy from someone.  I haven\'t seen any recent ones but in ye olde days they gave a good explanation of why you should/shouldn\'t do the things they cover.Dunno about you, but about the 2nd or 3rd time I get a coredump or hangup from any application, my opinion of whatever company produced it goes down by half. The 4th or 5th time and whatever the package is becomes shelfware and I drive a wooden stake through the center of the package/disc it came in just to make sure it never comes back to haunt me.