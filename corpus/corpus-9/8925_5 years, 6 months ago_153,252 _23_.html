My code is as below    The step objUDMCountryStandards.Country = txtSearchCountry.Text.Trim() != string.Empty ? txtSearchCountry.Text : null; in get grid data throws exception The calling thread cannot access this object because a different\n  thread owns it.What\'s wrong here?This is a common problem with people getting started. Whenever you update your UI elements from a thread other than the main thread, you need to use:You can also use control.Dispatcher.CheckAccess() to check whether the current thread owns the control. If it does own it, your code looks as normal. Otherwise, use above pattern.Not enough reputation to comment or +1, but I wanted to promote Candide\'s answer.Another good use for Dispatcher.Invoke is for immediately updating the UI in a function that performs other tasks:I use this to update button text to "Processing..." and disable it while making WebClient requests.To add my 2 cents, the exception can occur even if you call your code through System.Windows.Threading.Dispatcher.CurrentDispatcher.Invoke(). The point is that you have to call Invoke() of the Dispatcher of the control that you\'re trying to access, which in some cases may not be the same as System.Windows.Threading.Dispatcher.CurrentDispatcher. So instead you should use YourControl.Dispatcher.Invoke() to be safe. I was banging my head for a couple of hours before I realized this. If anyone tries to work with BitmapSource in WPF and threads and has this same message: just call .Freeze() method first before passing a BitmapSource as a threadparameter.You need to Update in to the UI, So use this happened with me because I tried to access UI component in another thread insted of UI thread like thisto solve this problem, wrap any ui call inside what Candide mentioned above in his answerFor some reason Candide\'s answer didn\'t build. It was helpful, though, as it led me to find this, which worked perfectly:The problem is that you are calling GetGridData from a background thread.  This method accesses several WPF controls which are bound to the main thread.  Any attempt to access them from a background thread will lead to this error.  In order to get back to the correct thread you should use SynchronizationContext.Current.Post.  However in this particular case it seems like the majority of the work you are doing is UI based.  Hence you would be creating a background thread just to go immediately back to the UI thread and do some work.  You need to refactor your code a bit so that it can do the expensive work on the background thread and then post the new data to the UI thread afterwardsAlso, another solution is ensuring your controls are created in UI thread, not by a background worker thread for example.I also found that System.Windows.Threading.Dispatcher.CurrentDispatcher.Invoke() is not always dispatcher of target control, just as dotNet wrote in his answer. I didn\'t had access to control\'s own dispatcher, so I used Application.Current.Dispatcher and it solved the problem.(not enough reputation to add comment)VikramBose suggests using BeginInvoke, but no mention of EndInvoke. Good Practice is that \'every BeginInvoke has a matching EndInvoke\' and certainly there needs to be some safeguard against race conditions (Think: what happens with multiple BeginInvoke of code but none have finished processing yet?)It\'s easy to forget, and I\'ve seen this error (and, yes, it is an error) in both MSDN examples and published books on WinForms