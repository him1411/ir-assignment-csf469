Background:While optimizing some Pascal code with embedded assembly language, I noticed an unnecessary MOV instruction, and removed it.To my surprise, removing the un-necessary instruction caused my program to slow down.I found that adding arbitrary, useless MOV instructions increased performance even further.The effect is erratic, and changes based on execution order: the same junk instructions transposed up or down by a single line produce a slowdown.I understand that the CPU does all kinds of optimizations and streamlining, but, this seems more like black magic.The data:A version of my code conditionally compiles three junk operations in the middle of a loop that runs 2**20==1048576 times. (The surrounding program just calculates SHA-256 hashes).The results on my rather old machine (Intel(R) Core(TM)2 CPU 6400  @ 2.13Â GHz):The programs were run 25 times in a loop, with the run order changing randomly each time.Excerpt:Try it yourself:The code is online at GitHub if you want to try it out yourself.My questions:The most likely cause of the speed improvement is that:Your Core2 doesn\'t keep a separate history record for each conditional jump. Instead it keeps a shared history of all conditional jumps.  One disadvantage of global branch prediction is that the history is diluted by irrelevant information if the different conditional jumps are uncorrelated.This little branch prediction tutorial shows how branch prediction buffers work. The cache buffer is indexed by the lower portion of the address of the branch instruction.  This works well unless two important uncorrelated branches share the same lower bits.  In that case, you end-up with aliasing which causes many mispredicted branches (which stalls the instruction pipeline and slowing your program).If you want to understand how branch mispredictions affect performance, take a look at this excellent answer:  https://stackoverflow.com/a/11227902/1001643Compilers typically don\'t have enough information to know which branches will alias and whether those aliases will be significant.  However, that information can be determined at runtime with tools such as Cachegrind and VTune.You may want to read http://research.google.com/pubs/pub37077.htmlTL;DR: randomly inserting nop instructions in programs can easily increase performance by 5% or more, and no, compilers cannot easily exploit this. It\'s usually a combination of branch predictor and cache behaviour, but it can just as well be e.g. a reservation station stall (even in case there are no dependency chains that are broken or obvious resource over-subscriptions whatsoever).I believe in modern CPUs the assembly instructions, while being the last visible layer to a programmer for providing execution instructions to a CPU, actually are several layers from actual execution by the CPU.Modern CPUs are RISC/CISC hybrids that translate CISC x86 instructions into internal instructions that are more RISC in behavior. Additionally there are out-of-order execution analyzers, branch predictors, Intel\'s "micro-ops fusion" that try to group instructions into larger batches of simultaneous work (kind of like the VLIW/Itanium titanic). There are even cache boundaries that could make the code run faster for god-knows-why if it\'s bigger (maybe the cache controller slots it more intelligently, or keeps it around longer).CISC has always had an assembly-to-microcode translation layer, but the point is that with modern CPUs things are much much much more complicated. With all the extra transistor real estate in modern semiconductor fabrication plants, CPUs can probably apply several optimization approaches in parallel and then select the one at the end that provides the best speedup. The extra instructions may be biasing the CPU to use one optimization path that is better than others. The effect of the extra instructions probably depends on the CPU model / generation / manufacturer, and isn\'t likely to be predictable. Optimizing assembly language this way would require execution against many CPU architecture generations, perhaps using CPU-specific execution paths, and would only be desirable for really really important code sections, although if you\'re doing assembly, you probably already know that.Move operations to memory can prepare the cache and make subsequent move operations faster. A CPU usually have two load units and one store units. A load unit can read from memory into a register (one read per cycle), a store unit stores from register to memory. There are also other units that do operations between registers. All the units work in parallel. So, on each cycle, we may do several operations at once, but no more than two loads, one store, and several register operations. Usually it is up to 4 simple operations with plain registers, up to 3 simple operations with XMM/YMM registers and a 1-2 complex operations with any kind of registers. Your code has lots of operations with registers, so one dummy memory store operation is free (since there are more than 4 register operations anyway), but it prepares memory cache for the subsequent store operation. To find out how memory stores work, please refer to the Intel 64 and IA-32 Architectures Optimization Reference Manual.Although this does not exactly refer to your case, but sometimes using 32-bit mov operations under the 64-bit processor (as in your case) are used to clear the higher bits (32-63) and break the dependency chains.It is well known that under x86-64, using 32-bit operands clears the higher bits of the 64-bit register. Pleas read the relevant section - 3.4.1.1 - of The Intel\xc2\xae 64 and IA-32 Architectures Software Developer\xe2\x80\x99s Manual Volume 1:32-bit operands generate a 32-bit result, zero-extended to a 64-bit result in the destination general-purpose registerSo, the mov instructions, that may seem useless at the first sight, clear the higher bits of the appropriate registers. What it gives to us? It breaks dependency chains and allows the instructions to execute in parallel, in random order, by the Out-of-Order algorithm implemented internally by CPUs since Pentium Pro in 1995.A Quote from the Intel\xc2\xae 64 and IA-32 Architectures Optimization Reference Manual, Section 3.5.1.8:Code sequences that modifies partial register can experience some delay in its dependency chain, but can be avoided by using dependency breaking idioms. In processors based on Intel Core micro-architecture, a number of instructions can help clear execution dependency when software uses these instruction to clear register content to zero. Break dependencies on portions of registers between instructions by operating on 32-bit registers instead of partial registers. For\n  moves, this can be accomplished with 32-bit moves or by using MOVZX.Assembly/Compiler Coding Rule 37. (M impact, MH generality): Break dependencies on portions of registers between instructions by operating on 32-bit registers instead of partial registers. For moves, this can be accomplished with 32-bit moves or by using MOVZX.The MOVZX and MOV with 32-bit operands for x64 are equivalent - they all break dependency chains.That\'s why your code executes faster. If there are no dependencies, the CPU can internally rename the registers, even though at the first sight it may seem that the second instruction modifies a register used by the first instruction, and the two cannot execute in parallel. But due to register renaming they can.Register renaming is a technique used internally by a CPU that eliminates the false data dependencies arising from the reuse of registers by successive instructions that do not have any real data dependencies between them.I think you now see that it is too obvious.