Is this wrong? I would assume that this actually has a static readonly field for each of the possible EnumRouteConstraint<T> that I happen to instance.It\'s fine to have a static field in a generic type, so long as you know that you\'ll really get one field per combination of type arguments. My guess is that R# is just warning you in case you weren\'t aware of that.Here\'s an example of that:As you can see, Generic<string>.Foo is a different field from Generic<object>.Foo - they hold separate values.From the JetBrains wiki:In the vast majority of cases, having a static field in a generic type\n  is a sign of an error. The reason for this is that a static field in a\n  generic type will not be shared among instances of different close\n  constructed types. This means that for a generic class C<T> which\n  has a static field X, the values of C<int>.X and C<string>.X\n  have completely different, independent values.In the rare cases when you do need the \'specialized\' static fields,\n  feel free to suppress the warning.If you need to have a static field shared between instances with\n  different generic arguments, define a non-generic base class to\n  store your static members, then set your generic type to inherit from\n  this type.This is not an error by any means. It is kind of misunderstanding of generics in C#. The easiest way to remember what generics do is the following:\nGenerics are "blueprints" for creating classes, much like classes are "blueprints" for creating objects. (Well, this is a simplification though. You may use method generics as well.)From this point of view MyClassRecipe<T> is not a class -- it is a recipe, a blueprint, of what your class would look like. Once you substitute T with something concrete, say int, string, etc., you get a class. It is perfectly legal to have a static member (field, property, method) declared in your newly created class (as in any other class) and no sign of any error here. \nIt would be somewhat suspicious, at first sight, if you declare static MyStaticProperty<T> Property { get; set; } within your class blueprint, but this is legal too. Only your property would be parameterized, or templated, as well.No wonder in VB statics are called shared. In this case however, you should be aware that such "shared" members are shared among class\' instances, not among different classes produced by substituting <T> with something else.There are several good answers here already, that explain the warning and the reason for it. Several of these state something like having a static field in a generic type generally a mistake.I thought I\'d add an example of how this feature can be useful, i.e. a case where suppressing the R#-warning makes sense. Imagine you have a set of entity-classes that you want to serialize, say to Xml. You can create a serializer for this using new XmlSerializerFactory().CreateSerializer(typeof(SomeClass)), but then you will have to create a separate serializer for each type. Using generics, you can replace that with the following, which you can place in a generic class that entities can derive from:Since your probably don\'t want to generate a new serializer each time you need to serialize an instance of a particular type, you might add this:If this class was NOT generic, then each instance of the class would use the same _typeSpecificSerializer. Since it IS generic however, a set of instances with the same type for T will share a single instance of _typeSpecificSerializer (which will have been created for that specific type), while instances with a different type for T will use different instances of _typeSpecificSerializer.Provided the two classes that extend SerializableEntity<T>: ... let\'s use them:In this case, under the hood, firstInst and secondInst will be instances of the same class (namely SerializableEntity<MyFirstEntity>), and as such, they will share an instance of _typeSpecificSerializer. thirdInst and fourthInst are instances of a different class (SerializableEntity<OtherEntity>), and so will share an instance of _typeSpecificSerializer that is different from the other two. This means you get different serializer-instances for each of your entity types, while still keeping them static within the context of each actual type (i.e., shared among instances that are of a specific type).