I want a custom error page shown for 500, 404 and 403. Here\'s what I have done:Enabled custom errors in the web.config as follows:Registered HandleErrorAttribute as a global action filter in the FilterConfig class as follows:Created a custom error page for each of the above messages. The default one for 500 was already available out of the box.Declared in each custom error page view that the model for the page is System.Web.Mvc.HandleErrorInfoFor 500, it shows the custom error page. For others, it doesn\'t.Is there something I am missing?It does look like this is not all there is to displaying custom errors as I read through the code in the OnException method of the HandleErrorAttribute class and it is handling only 500.What do I have to do to handle other errors?My current setup (on MVC3, but I think it still applies) relies on having an ErrorController, so I use:And the controller contains the following:And the views just the way you implement them. I tend to add a bit of logic though, to show the stack trace and error information if the application is in debug mode. So Error.cshtml looks something like this:I\'ve done pablo solution and I always had the error (MVC4)The view \'Error\' or its master was not found or no view engine supports the searched location.To get rid of this, remove the line in FilterConfig.csI do something that requires less coding than the other solutions posted. First, in my web.config, I have the following:And the controller (/Controllers/ErrorPageController.cs) contains the following:And finally, the view contains the following (stripped down for simplicity, but it can conta:It\'s just as simple as that. It could be easily extended to offer more detailed error info, but ELMAH handles that for me & the statusCode & statusDescription is all that I usually need. I would Recommend to use Global.asax.cs File. There seem to be a number of steps here jumbled together. I\'ll put forward what I did from scratch.Create the ErrorPage controllerAdd views for these two actions (right click -> Add View). These should appear in a folder called ErrorPage.Inside App_Start open up FilterConfig.cs and comment out the error handling filter.Inside web.config add the following <customerErrors> entries, under System.WebTest (of course). Throw an unhandled exception in your code and see it go to the page with id 500, and then use a url to a page that does not exist to see 404.Thanks to everyone above. Upvoted accordingly.Building on the answer posted by maxspan, I\'ve put together a minimal sample project on GitHub showing all the working parts. Basically, we just add an Application_Error method to global.asax.cs to intercept the exception and give us an opportunity to redirect (or more correctly, transfer request) to a custom error page.Error Controller:Error page View:Nothing else is involved, other than disabling/removing filters.Add(new HandleErrorAttribute()) in FilterConfig.csWhile very simple to implement, the one drawback I see in this approach is using querystring to deliver exception information to the target error page.Here is my solution. Use [ExportModelStateToTempData] / [ImportModelStateFromTempData] is uncomfortable in my opinion.~/Views/Home/Error.cshtml:~/Controllers/HomeController.sc:~/Controllers/BaseController.sc:~/Controllers/MyController.sc:I wish you successful projects ;-)You can get errors working correctly without hacking global.cs, messing with HandleErrorAttribute, doing Response.TrySkipIisCustomErrors, hooking up Application_Error, or whatever:In system.web (just the usual, on/off)and in system.webServerNow things should behave as expected, and you can use your ErrorController to display whatever you need.I had everything set up, but still couldn\'t see proper error pages for status code 500 on our staging server, despite the fact everything worked fine on local development servers.I found this blog post from Rick Strahl that helped me.I needed to add Response.TrySkipIisCustomErrors = true; to my custom error handling code.It seems i came late to the party, but you should better check this out too.So in system.web for caching up exceptions within the application such as return HttpNotFound()and in system.webServer for catching up errors that were caught by IIS and did not made their way to the asp.net frameworkIn the last one if you worry about the client response then change the responseMode="Redirect" to responseMode="File" and serve a static html file, since this one will display a friendly page with an 200 response code.In web.config add this under system.webserver tag as below,and add a controller as,and add their respected views, this will work definitely I guess for all.This solution I found it from: Neptune Century