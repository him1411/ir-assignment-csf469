I know the question is not too specific. All I want is someone to tell me how to convert a normal merge sort into an in-place merge sort (or a merge sort with constant extra space overhead). All I can find (on the net) is pages saying "it is too complex" or "out of scope of this text". The only known ways to merge in-place (without any extra space) are too complex to be reduced to practical program.  (taken from here)Even if it is too complex, what is the basic concept of how to make the merge sort in-place?Knuth left this as an exercise (Vol 3, 5.2.5). There do exists in-place merge sort. It must be implemented carefully.First, naive in-place merge such as described here isn\'t the right solution. It downgrades the performance to O(N2).The idea is to sort part of the array while using the rest as working area for merging.For example as the following merge function.It takes the array xs, the two sorted sub arrays are represented as range [i, m) and [j, n) respectively. The working area starts from w. Compare with the standard merge algorithm given in most textbooks, this one exchanges the contents between the sorted sub array and the working area. As the result, the previous working area contains the merged sorted elements, while the previous elements stored in working area are moved to the two sub arrays.However, there are two constrains must be satisfied:With this merging algorithm defined, it\'s easy to imagine a solution, which can sort half of the array; The next question is, how to deal with the rest of the unsort part stored in work area as shown below:One intuitive idea is to recursive sort another half of the working area, thus there are only 1/4 elements haven\'t been sorted yet. The key point at this stage is that we must merge the sorted 1/4 elements B\nwith the sorted 1/2 elements A sooner or later.Is the working area left, which only holds 1/4 elements, big enough to merge\nA and B? Unfortunately, it isn\'t.However, the second constraint mentioned above gives us a hint, that we can exploit it by arranging the working area to overlap with either sub array if we can ensure the merging sequence that the unmerged elements won\'t be overwritten.Actually, instead of sorting the second half of the working area, we can sort the first half, and put the working area between the two sorted arrays like this:This setup effects arrange the work area overlap with the sub array A. This idea\nis proposed in [Jyrki Katajainen, Tomi Pasanen, Jukka Teuhola. ``Practical in-place mergesort\'\'. Nordic Journal of Computing, 1996].So the only thing left is to repeat the above step, which reduce the working area from 1/2,, 1/4, 1/8 ..., When the working area becomes small enough, for example, only two elements left, we can switch to a trivial insertion sort to end this algorithm.Here is the implementation in ANSI C based on this paper.Where wmerge is defined previously.The full source code can be found here and the detailed explanation can be found hereBy the way, this version isn\'t the fastest merge sort because it needs more swap operations. According to my test, it\'s faster than the standard version, which allocates extra spaces in every recursion. But it\'s slower than the optimized version, which doubles the original array in advance, and uses it for further merging.Including its "big result", this paper describes a couple of variants of in-place merge sort (PDF):http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.5514&rep=rep1&type=pdfIn-place sorting with fewer movesJyrki Katajainen, Tomi A. Pasanen It is shown that an array of n\n  elements can be sorted using O(1)\n  extra space, O(n log n / log log n)\n  element moves, and n log 2 n+O(n log\n  log n) comparisons. This is the first\n  in-place sorting algorithm requiring\n  o(n log n) moves in the worst case\n  while guaranteeing O(n log n)\n  comparisons, but due to the constant\n  factors involved the algorithm is\n  predominantly of theoretical interest.I think this is relevant too. I have a printout of it lying around, passed on to me by a colleague, but I haven\'t read it. It seems to cover basic theory, but I\'m not familiar enough with the topic to judge how comprehensively:http://comjnl.oxfordjournals.org/cgi/content/abstract/38/8/681Optimal Stable MergingAntonios SymvonisThis paper shows how to stably merge\n  two sequences A and B  of sizes m and\n  n, m \xe2\x89\xa4 n, respectively, with O(m+n)\n  assignments, O(mlog(n/m+1))\n  comparisons and using only a constant\n  amount of additional space. This\n  result matches all known lower bounds...The critical step is getting the merge itself to be in-place. It\'s not as difficult as those sources make out, but you lose something when you try.Looking at one step of the merge:[...list-sorted...|x...list-A...|y...list-B...]We know that the sorted sequence is less than everything else, that x is less than everything else in A, and that y is less than everything else in B. In the case where x is less than or equal to y, you just move your pointer to the start of A on one. In the case where y is less than x, you\'ve got to shuffle y past the whole of A to sorted. That last step is what makes this expensive (except in degenerate cases).It\'s generally cheaper (especially when the arrays only actually contain single words per element, e.g., a pointer to a string or structure) to trade off some space for time and have a separate temporary array that you sort back and forth between.It really isn\'t easy or efficient, and I suggest you don\'t do it unless you really have to (and you probably don\'t have to unless this is homework since the applications of inplace merging are mostly theoretical). Can\'t you use quicksort instead? Quicksort will be faster anyway with a few simpler optimizations and its extra memory is O(log N).Anyway, if you must do it then you must. Here\'s what I found: one and two. I\'m not familiar with the inplace merge sort, but it seems like the basic idea is to use rotations to facilitate merging two arrays without using extra memory.Note that this is slower even than the classic merge sort that\'s not inplace.Just for reference, here is a nice implementation of a stable in-place merge sort. Complicated, but not too bad.I ended up implementing both a stable in-place merge sort and a stable in-place quicksort in Java. Please note the complexity is O(n (log n)^2)Adds support code and modifications to accelerate the merge when an auxiliary buffer of any size is available (still works without additional memory). Uses forward and backward merging, ring rotation, small sequence merging and sorting, and iterative mergesort.This is my C version:There is a relatively simple implementation of in-place merge sort using Kronrod\'s original technique but with simpler implementation. A pictorial example that illustrates this technique can be found here: http://www.logiccoder.com/TheSortProblem/BestMergeInfo.htm. There are also links to more detailed theoretical analysis by the same author associated with this link. I just tried in place merge algorithm for merge sort in JAVA by using the insertion sort algorithm, using following steps.\n1) Two sorted arrays are available.\n2) Compare the first values of each array; and place the smallest value into the first array.\n3) Place the larger value into the second array by using insertion sort (traverse from left to right).\n4) Then again compare the second value of first array and first value of second array, and do the same. But when swapping happens there is some clue on skip comparing the further items, but just swapping required.I have made some optimization here; to keep lesser comparisons in insertion sort. The only drawback i found with this solutions is it needs larger swapping of array elements in the second array. e.g)First___Array   : 3, 7, 8, 9 Second Array : 1, 2, 4, 5    Then 7, 8, 9 makes the second array to swap(move left by one) all its elements by one each time to place himself in the last.So the assumption here is swapping items is negligible compare to comparing of two items.https://github.com/skanagavelu/algorithams/blob/master/src/sorting/MergeSort.java An example of mergesort in Swift.