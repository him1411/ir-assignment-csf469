I realize session and REST don\'t exactly go hand in hand but is it not possible to access session state using the new Web API? HttpContext.Current.Session is always null.For an MVC project make the following changes (WebForms and Dot Net Core answer down below):This solution has the added bonus that we can fetch the base URL in javascript for making the AJAX calls:and then within our Javascript files/code we can make our webapi calls that can access the session:Do the above but change the WebApiConfig.Register function to take a RouteCollection instead:And then call the following in Application_Start:Add the Microsoft.AspNetCore.Session NuGet package and then make the following code changes:Call the AddDistributedMemoryCache and AddSession methods on the services object within the ConfigureServices function:and in the Configure function add a call to UseSession:Within your controller, add a using statement at the top:and then use the HttpContext.Session object within your code like so:you should now be able to hit:and then going to this URL will pull it out:Plenty more info on accessing session data within dot net core here: https://docs.microsoft.com/en-us/aspnet/core/fundamentals/app-state Read Simon Weaver\'s answer below regarding performance. If you\'re accessing session data inside a WebApi project it can have very serious performance consequence - I have seen ASP.NET enforce a 200ms delay for concurrent requests. This could add up and become disastrous if you have many concurrent requests.Make sure you are locking down resources per user - an authenticated user shouldn\'t be able to retrieve data from your WebApi that they don\'t have access to. Read Microsoft\'s article on Authentication and Authorization in ASP.NET Web API - https://www.asp.net/web-api/overview/security/authentication-and-authorization-in-aspnet-web-apiRead Microsoft\'s article on avoiding Cross-Site Request Forgery hack attacks. (In short, check out the AntiForgery.Validate method) -  https://www.asp.net/web-api/overview/security/preventing-cross-site-request-forgery-csrf-attacks You can access session state using a custom RouteHandler.Found here: http://techhasnoboundary.blogspot.com/2012/03/mvc-4-web-api-access-session.htmlWell you\'re right, REST is stateless. If you use a session the processing will become stateful, subsequent requests will be able to use state (from a session).In order for a session to be rehydrated, you\'ll need to supply a key to associate the state. In a normal asp.net application that key is supplied by using a cookie (cookie-sessions) or url parameter (cookieless sessions).If you need a session forget rest, sessions are irrelevant in REST based designs. If you need a session for validation then use a token or authorise by IP addresses.Performance, performance, performance!There\'s a very good, and often overlooked reason why you shouldn\'t be using Session in WebAPI at all.The way ASP.NET works when Session is in use is to serialize all requests received from a single client. Now I\'m not talking about object serialization - but running them in the order received and waiting for each to complete before running the next.  This is to avoid nasty thread / race conditions if two requests each try to access Session simultaneously.Access to ASP.NET session state\n  is exclusive per session, which means that if two different users make\n  concurrent requests, access to each separate session is granted\n  concurrently. However, if two concurrent requests are made for the\n  same session (by using the same SessionID value), the first request\n  gets exclusive access to the session information. The second request\n  executes only after the first request is finished. (The second session\n  can also get access if the exclusive lock on the information is freed\n  because the first request exceeds the lock time-out.) If the\n  EnableSessionState value in the @ Page directive is set to ReadOnly, a\n  request for the read-only session information does not result in an\n  exclusive lock on the session data. However, read-only requests for\n  session data might still have to wait for a lock set by a read-write\n  request for session data to clear.So what does this mean for Web API? If you have an application running many AJAX requests then only ONE is going to be able to run at a time. If you have a slower request then it will block all others until it is complete. In some applications this could lead to very noticeably sluggish performance.So you should probably use an MVC controller if you absolutely need something from the users session and avoid the unncesessary performance penalty of enabling it for WebApi.You can easily test this out for yourself by just putting Thread.Sleep(5000) in a WebAPI method and enable Session. Run 5 requests to it and they will take a total of 25 seconds to complete. Without Session they\'ll take a total of just over 5 seconds.(This same reasoning applies to SignalR).Mark, if you check the nerddinner MVC example the logic is pretty much the same.You only need to retrieve the cookie and set it in the current session.Global.asax.csYou\'ll have to define your "SampleIdentity" class, which you can borrow from the nerddinner project.Last one is not working now, take this one, it worked for me.in WebApiConfig.cs at App_StartGlobal.asaxfournd here: http://forums.asp.net/t/1773026.aspx/1To fix the issue:in Global.asax.csFollowing on from LachlanB\'s answer, if your ApiController doesn\'t sit within a particular directory (like /api) you can instead test the request using RouteTable.Routes.GetRouteData, for example:I had this same problem in asp.net mvc, I fixed it by putting this method in my base api controller that all my api controllers inherit from:Then in your api call that you want to access the session you just do:I also have this in my Global.asax.cs file like other people have posted, not sure if you still need it using the method above, but here it is just in case:You could also just make a custom filter attribute that you can stick on your api calls that you need session, then you can use session in your api call like you normally would via HttpContext.Current.Session["SomeValue"]:Hope this helps.I followed @LachlanB approach and indeed the session was available when the session cookie was present on the request. The missing part is how the Session cookie is sent to the client the first time? I created a HttpModule which not only enabling the HttpSessionState availability but also sends the cookie to the client when a new session is created.one thing need to mention on @LachlanB \'s answer.If you omit the line   if (IsWebApiRequest())The whole site will have page loading slowness issue if your site is mixed with web form pages.Going back to basics why not keep it simple and store the Session value in a hidden html value to pass to your API?ControllercshtmlJavascript$(document).ready(function () {}