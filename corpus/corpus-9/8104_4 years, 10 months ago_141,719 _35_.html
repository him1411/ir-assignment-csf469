This question already has an answer here:I\'m new to parallel programming. There are two classes available  in .NET: Task and Thread. So, the question is: What is difference between those classes? When is it better to use Thread and when Task?Thread is a lower-level concept: if you\'re directly starting a thread, you know it will be a separate thread, rather than executing on the thread pool etc.Task is more than just an abstraction of "where to run some code" though - it\'s really just "the promise of a result in the future". So as some different examples:Note that the Task<T> abstraction is pivotal to the async support in C# 5.In general, I\'d recommend that you use the higher level abstraction wherever you can: in modern C# code you should rarely need to explicitly start your own thread.SourceThreadThread represents an actual OS-level thread, with its own stack and kernel resources. (technically, a CLR implementation could use fibers instead, but no existing CLR does this) Thread allows the highest degree of control; you can Abort() or Suspend() or Resume() a thread (though this is a very bad idea), you can observe its state, and you can set thread-level properties like the stack size, apartment state, or culture.The problem with Thread is that OS threads are costly. Each thread you have consumes a non-trivial amount of memory for its stack, and adds additional CPU overhead as the processor context-switch between threads. Instead, it is better to have a small pool of threads execute your code as work becomes available.There are times when there is no alternative Thread. If you need to specify the name (for debugging purposes) or the apartment state (to show a UI), you must create your own Thread (note that having multiple UI threads is generally a bad idea). Also, if you want to maintain an object that is owned by a single thread and can only be used by that thread, it is much easier to explicitly create a Thread instance for it so you can easily check whether code trying to use it is running on the correct thread.ThreadPoolThreadPool is a wrapper around a pool of threads maintained by the CLR. ThreadPool gives you no control at all; you can submit work to execute at some point, and you can control the size of the pool, but you can\'t set anything else. You can\'t even tell when the pool will start running the work you submit to it.Using ThreadPool avoids the overhead of creating too many threads. However, if you submit too many long-running tasks to the threadpool, it can get full, and later work that you submit can end up waiting for the earlier long-running items to finish. In addition, the ThreadPool offers no way to find out when a work item has been completed (unlike Thread.Join()), nor a way to get the result. Therefore, ThreadPool is best used for short operations where the caller does not need the result.TaskFinally, the Task class from the Task Parallel Library offers the best of both worlds. Like the ThreadPool, a task does not create its own OS thread. Instead, tasks are executed by a TaskScheduler; the default scheduler simply runs on the ThreadPool.Unlike the ThreadPool, Task also allows you to find out when it finishes, and (via the generic Task) to return a result. You can call ContinueWith() on an existing Task to make it run more code once the task finishes (if it\'s already finished, it will run the callback immediately). If the task is generic, ContinueWith() will pass you the task\'s result, allowing you to run more code that uses it.You can also synchronously wait for a task to finish by calling Wait() (or, for a generic task, by getting the Result property). Like Thread.Join(), this will block the calling thread until the task finishes. Synchronously waiting for a task is usually bad idea; it prevents the calling thread from doing any other work, and can also lead to deadlocks if the task ends up waiting (even asynchronously) for the current thread.Since tasks still run on the ThreadPool, they should not be used for long-running operations, since they can still fill up the thread pool and block new work. Instead, Task provides a LongRunning option, which will tell the TaskScheduler to spin up a new thread rather than running on the ThreadPool.All newer high-level concurrency APIs, including the Parallel.For*() methods, PLINQ, C# 5 await, and modern async methods in the BCL, are all built on Task.ConclusionThe bottom line is that Task is almost always the best option; it provides a much more powerful API and avoids wasting OS threads.The only reasons to explicitly create your own Threads in modern code are setting per-thread options, or maintaining a persistent thread that needs to maintain its own identity.Task is a higher level concept than thread... and that\'s what this phrase means :You can\'t use Abort/ThreadAbortedException, you should support\ncancel event in your "business code" periodically testing IsCancellationRequested flag (also avoid long or timeoutless connections e.g. to db, otherwise you will never get a chance to test this flag). There are no thread\'s Suspend() and Resume() methods functionality. But you get two new tools: continuations, and\nnested/child tasks ; those two samples demonstrate the idea and the                  syntax: Task is integrated with C# async/await features aka \'Promise Model\', e.g there client.RequestAsync will not block UI thread: requestButton.Clicked += async (o, e) => ProcessResponce(await client.RequestAsync(e.ResourceName)); when Clicked call code doesn\'t have any special support for this (all is done by compiler).Creating Thread instance - creates Windows thread, when Task get thread from pool. Therefore tasks actually not guarantee parallel threads execution (async is not same as parallel).That is enough to make a choice. If you need to support Cancel functionality of thread that tends to hang (e.g. timeoutless connection), or if you are creating multithread background calculations and need to manage resources using Suspend/Resume, or if you want to manage parallel execution manually - stay with Thread. Otherwise go to Tasks because of they will give you easy manipulate on groups of them and are integrated into language.The Thread class is used for creating and manipulating a thread in Windows.A Task represents some asynchronous operation and is part of the Task Parallel Library, a set of APIs for running tasks asynchronously and in parallel.In the days of old (i.e. before TPL) it used to be that using the Thread class was one of the standard ways to run code in the background or in parallel (a better alternative was often to use a ThreadPool), however this was cumbersome and had several disadvantages, not least of which was the performance overhead of creating a whole new thread to perform a task in the background.Nowadays using tasks and the TPL is a far better solution 90% of the time as it provides abstractions which allows far more efficient use of system resources.  I imagine there are a few scenarios where you want explicit control over the thread on which you are running your code, however generally speaking if you want to run something asynchronously your first port of call should be the TPL.