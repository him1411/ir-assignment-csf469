When I ran ReSharper on my code, for example:ReSharper gave me the above warning (Invert "if" statement to reduce nesting), and suggested the following correction:I would like to understand why that\'s better. I always thought that using "return" in the middle of a method problematic, somewhat like "goto".A return in the middle of the method is not necessarily bad. It might be better to return immediately if it makes the intent of the code clearer. For example:In this case, if _isDead is true, we can immediately get out of the method. It might be better to structure it this way instead:I\'ve picked this code from the refactoring catalog. This specific refactoring is called: Replace Nested Conditional with Guard Clauses.It is not only aesthetic, but it also reduces the maximum nesting level inside the method. This is generally regarded as a plus because it makes methods easier to understand (and indeed, many static analysis tools provide a measure of this as one of the indicators of code quality).On the other hand, it also makes your method have multiple exit points, something that another group of people believes is a no-no.Personally, I agree with ReSharper and the first group (in a language that has exceptions I find it silly to discuss "multiple exit points"; almost anything can throw, so there are numerous potential exit points in all methods).Regarding performance: both versions should be equivalent (if not at the IL level, then certainly after the jitter is through with the code) in every language. Theoretically this depends on the compiler, but practically any widely used compiler of today is capable of handling much more advanced cases of code optimization than this.This is a bit of a religious argument, but I agree with ReSharper that you should prefer less nesting. I believe that this outweighs the negatives of having multiple return paths from a function.The key reason for having less nesting is to improve code readability and maintainability. Remember that many other developers will need to read your code in the future, and code with less indentation is generally much easier to read.Preconditions are a great example of where it is okay to return early at the start of the function. Why should the readability of the rest of the function be affected by the presence of a precondition check?As for the negatives about returning multiple times from a method - debuggers are pretty powerful now, and it\'s very easy to find out exactly where and when a particular function is returning.Having multiple returns in a function is not going to affect the maintainance programmer\'s job.Poor code readability will.As others have mentioned, there shouldn\'t be a performance hit, but there are other considerations.  Aside from those valid concerns, this also can open you up to gotchas in some circumstances.  Suppose you were dealing with a double instead:Contrast that with the seemingly equivalent inversion: So in certain circumstances what appears to be a a correctly inverted if might not be.The idea of only returning at the end of a function came back from the days before languages had support for exceptions. It enabled programs to rely on being able to put clean-up code at the end of a method, and then being sure it would be called and some other programmer wouldn\'t hide a return in the method that caused the cleanup code to be skipped. Skipped cleanup code could result in a memory or resource leak.However, in a language that supports exceptions, it provides no such guarantees. In a language that supports exceptions, the execution of any statement or expression can cause a control flow that causes the method to end. This means clean-up must be done through using the finally or using keywords.Anyway, I\'m saying I think a lot of people quote the \'only return at the end of a method\' guideline without understanding why it was ever a good thing to do, and that reducing nesting to improve readability is probably a better aim.I\'d like to add that there is name for those inverted if\'s - Guard Clause. I use it whenever I can.I hate reading code where there is if at the beginning, two screens of code and no else. Just invert if and return. That way nobody will waste time scrolling.http://c2.com/cgi/wiki?GuardClauseIt doesn\'t only affect aesthetics, but it also prevents code nesting. It can actually function as a precondition to ensure that your data is valid as well.This is of course subjective, but I think it strongly improves on two points:Multiple return points were a problem in C (and to a lesser extent C++) because they forced you to duplicate clean-up code before each of the return points. With garbage collection, the try | finally construct and using blocks, there\'s really no reason why you should be afraid of them.Ultimately it comes down to what you and your colleagues find easier to read.Performance-wise, there will be no noticeable difference between the two approaches.But coding is about more than performance. Clarity and maintainability are also very important. And, in cases like this where it doesn\'t affect performance, it is the only thing that matters.There are competing schools of thought as to which approach is preferable.One view is the one others have mentioned: the second approach reduces the nesting level, which improves code clarity. This is natural in an imperative style: when you have nothing left to do, you might as well return early.Another view, from the perspective of a more functional style, is that a method should have only one exit point. Everything in a functional language is an expression. So if statements must always have an else clauses. Otherwise the if expression wouldn\'t always have a value. So in the functional style, the first approach is more natural.Guard clauses or pre-conditions (as you can probably see) check to see if a certain condition is met and then breaks the flow of the program. They\'re great for places where you\'re really only interested in one outcome of an if statement. So rather than say:You reverse the condition and break if that reversed condition is fulfilledreturn is nowhere near as dirty as goto. It allows you to pass a value to show the rest of your code that the function couldn\'t run.You\'ll see the best examples of where this can be applied in nested conditions:vs:You\'ll find few people arguing the first is cleaner but of course, it\'s completely subjective. Some programmers like to know what conditions something is operating under by indentation, while I\'d much rather keep method flow linear.I won\'t suggest for one moment that precons will change your life or get you laid but you might find your code just that little bit easier to read.There are several good points made here, but multiple return points can be unreadable as well, if the method is very lengthy. That being said, if you\'re going to use multiple return points just make sure that your method is short, otherwise the readability bonus of multiple return points may be lost.Personally I prefer only 1 exit point.  It\'s easy to accomplish if you keep your methods short and to the point, and it provides a predictable pattern for the next person who works on your code.eg.This is also very useful if you just want to check the values of certain local variables within a function before it exits.  All you need to do is place a breakpoint on the final return and you are guaranteed to hit it (unless an exception is thrown).Performance is in two parts. You have performance when the software is in production, but you also want to have performance while developing and debugging. The last thing a developer wants is to "wait" for something trivial. In the end, compiling this with optimization enabled will result in similar code. So it\'s good to know these little tricks that pay off in both scenarios.The case in the question is clear, ReSharper is correct. Rather than nesting if statements, and creating new scope in code, you\'re setting a clear rule at the start of your method. It increases readability, it will be easier to maintain, and it reduces the amount of rules one has to sift through to find where they want to go.Many good reasons about how the code looks like. But what about results?Let\'s take a look to some C# code and its IL compiled form:This simple snippet can be compiled. You can open the generated .exe file with ildasm and check what is the result. I won\'t post all the assembler thing but I\'ll describe the results.The generated IL code does the following:So it seems that the code will jump to the end. What if we do a normal if with nested code?The results are quite similar in IL instructions. The difference is that before there were to jumps per condition: if false go to next piece of code, if true go to then end. And now the IL code flows better and has 3 jumps (the compiler optimized this a bit):\n  1. First jump: when Length is 0 to a part where the code jumps again (Third jump) to the end.\n  2. Second: in the middle of the second condition to avoid one instruction.\n  3. Third: if the second condition is false, jump to the end.Anyway, the program counter will always jump.That is simply controversial. There is no "agreement among programmers" on the question of early return. It\'s always subjective, as far as I know.It\'s possible to make a performance argument, since it\'s better to have conditions that are written so they are most often true; it can also be argued that it is clearer. It does, on the other hand, create nested tests.I don\'t think you will get a conclusive answer to this question.In theory, inverting if could lead to better performance if it increases branch prediction hit rate.  In practice, I think it it very hard to know exactly how branch prediction will behave, especially after compiling, so I would not do it in my day to day development, except if I am writing assembly code.More on branch prediction here.It\'s a matter of opinion.My normal approach would be to avoid single line ifs, and returns in the middle of a method.You wouldn\'t want lines like it suggests everywhere in your method but there is something to be said for checking a bunch of assumptions at the top of your method, and only doing your actual work if they all pass.In my opinion early return is fine if you are just returning void (or some useless return code you\'re never gonna check) and it might improve readability because you avoid nesting and at the same time you make explicit that your function is done.If you are actually returning a returnValue - nesting is usually a better way to go cause you return your returnValue just in one place (at the end - duh), and it might make your code more maintainable in a whole lot of cases.There are a lot of insightful answers there already, but still, I would to direct to a slightly different situation: Instead of precondition, that should be put on top of a function indeed, think of a step-by-step initialization, where you have to check for each step to succeed and then continue with the next. In this case, you cannot check everything at the top.I found my code really unreadable when writing an ASIO host application with Steinberg\'s ASIOSDK, as I followed the nesting paradigm. It went like eight levels deep, and I cannot see a design flaw there, as mentioned by Andrew Bullock above. Of course, I could have packed some inner code to another function, and then nested the remaining levels there to make it more readable, but this seems rather random to me.By replacing nesting with guard clauses, I even discovered a misconception of mine regarding a portion of cleanup-code that should have occurred much earlier within the function instead of at the end. With nested branches, I would never have seen that, you could even say they led to my misconception.So this might be another situation where inverted ifs can contribute to a clearer code.Avoiding multiple exit points can lead to performance gains. I am not sure about C# but in C++ the Named Return Value Optimization (Copy Elision, ISO C++ \'03 12.8/15) depends on having a single exit point. This optimization avoids copy constructing your return value (in your specific example it doesn\'t matter). This could lead to considerable gains in performance in tight loops, as you are saving a constructor and a destructor each time the function is invoked.But for 99% of the cases saving the additional constructor and destructor calls is not worth the loss of readability nested if blocks introduce (as others have pointed out). I think it depends on what you prefer, as mentioned, theres no general agreement afaik.\nTo reduce annoyment, you may reduce this kind of warning to "Hint"My idea is that the return "in the middle of a function" shouldn\'t be so "subjective".\nThe reason is quite simple, take this code:Maybe the first "return" it\'s not SO intuitive, but that\'s really saving.\nThere are too many "ideas" about clean codes, that simply need more practise to lose their "subjective" bad ideas.There are several advantages to this sort of coding but for me the big win is, if you can return quick you can improve the speed of your application. IE I know that because of Precondition X that I can return quickly with an error. This gets rid of the error cases first and reduces the complexity of your code. In a lot of cases because the cpu pipeline can be now be cleaner it can stop pipeline crashes or switches. Secondly if you are in a loop, breaking or returning out quickly can save you a lots of cpu. Some programmers use loop invariants to do this sort of quick exit but in this you can broke your cpu pipeline and even create memory seek problem and mean the the cpu needs to load from outside cache. But basically I think you should do what you intended, that is end the loop or function not create a complex code path just to implement some abstract notion of correct code. If the only tool you have is a hammer then everything looks like a nail.