StringTokenizer? Convert the String to a char[] and iterate over that? Something else?I use a for loop to iterate the string and use charAt() to get each character to examine it.  Since the String is implemented with an array, the charAt() method is a constant time operation.That\'s what I would do.  It seems the easiest to me.As far as correctness goes, I don\'t believe that exists here.  It is all based on your personal style.Two optionsorThe first is probably faster, then 2nd is probably more readable. Note most of the other techniques described here break down if you\'re dealing with characters outside of the BMP (Unicode Basic Multilingual Plane), i.e. code points that are outside of the u0000-uFFFF range. This will only happen rarely, since the code points outside this are mostly assigned to dead languages. But there are some useful characters outside this, for example some code points used for mathematical notation, and some used to encode proper names in Chinese.In that case your code will be:The Character.charCount(int) method requires Java 5+.Source: http://mindprod.com/jgloss/codepoint.htmlI agree that StringTokenizer is overkill here. Actually I tried out the suggestions above and took the time. My test was fairly simple: create a StringBuilder with about a million characters, convert it to a String, and traverse each of them with charAt() / after converting to a char array / with a CharacterIterator a thousand times (of course making sure to do something on the string so the compiler can\'t optimize away the whole loop :-) ).The result on my 2.6 GHz Powerbook (that\'s a mac :-) ) and JDK 1.5:As the results are significantly different, the most straightforward way also seems to be the fastest one. Interestingly, charAt() of a StringBuilder seems to be slightly slower than the one of String.BTW I suggest not to use CharacterIterator as I consider its abuse of the \'\\uFFFF\' character as "end of iteration" a really awful hack. In big projects there\'s always two guys that use the same kind of hack for two different purposes and the code crashes really mysteriously. Here\'s one of the tests:There are some dedicated classes for this:If you have Guava on your classpath, the following is a pretty readable alternative. Guava even has a fairly sensible custom List implementation for this case, so this shouldn\'t be inefficient.UPDATE: As @Alex noted, with Java 8 there\'s also CharSequence#chars to use. Even the type is IntStream, so it can be mapped to chars like:If you need to iterate through the code points of a String (see this answer) a shorter / more readable way is to use the CharSequence#codePoints method added in Java 8:or using the stream directly instead of a for loop:There is also CharSequence#chars if you want a stream of the characters (although it is an IntStream, since there is no CharStream).I wouldn\'t use StringTokenizer as it is one of classes in the JDK that\'s legacy.The javadoc says:StringTokenizer is a legacy class that\n  is retained for compatibility reasons\n  although its use is discouraged in new\n  code. It is recommended that anyone\n  seeking this functionality use the\n  split  method of String or the\n  java.util.regex package instead.See The Java Tutorials: Strings.Put the length into int len and use for loop.StringTokenizer is totally unsuited to the task of breaking a string into its individual characters.  With String#split() you can do that easily by using a regex that matches nothing, e.g.:But StringTokenizer doesn\'t use regexes, and there\'s no delimiter string you can specify that will match the nothing between characters.  There is one cute little hack you can use to accomplish the same thing: use the string itself as the delimiter string (making every character in it a delimiter) and have it return the delimiters:However, I only mention these options for the purpose of dismissing them.  Both techniques break the original string into one-character strings instead of char primitives, and both involve a great deal of overhead in the form of object creation and string manipulation.  Compare that to calling charAt() in a for loop, which incurs virtually no overhead. Elaborating on this answer and this answer.Above answers point out the problem of many of the solutions here which don\'t iterate by code point value -- they would have trouble with any surrogate chars. The java docs also outline the issue here (see "Unicode Character Representations").  Anyhow, here\'s some code that uses some actual surrogate chars from the supplementary Unicode set, and converts them back to a String.  Note that .toChars() returns an array of chars:  if you\'re dealing with surrogates, you\'ll necessarily have two chars.  This code should work for any Unicode character.This Example Code will Help you out!