I am aware that every object requires heap memory and every primitive/reference on the stack requires stack memory.When I attempt to create an object on the heap and there\'s insufficient memory to do so, the JVM creates an java.lang.OutOfMemoryError on the heap and throws it to me.So implicitly, this means that there is some memory reserved by the JVM on startup.What happens when this reserved memory is used up (it would definitely be used up, read discussion below) and the JVM does not have enough memory on the heap to create an instance of java.lang.OutOfMemoryError?Does it just hang? Or would he throw me a null since there\'s no memory to new an instance of OOM ?==Why couldn\'t the JVM reserve sufficient memory?No matter how much memory is reserved, it is still possible for that memory to be used up if the JVM does not have a way to "reclaim" that memory:Or more concisely:The JVM never really runs out of memory. It does memory computation of the heap stack in advance.The Structure of the JVM, Chapter 3, section 3.5.2 states:For Heap, Section 3.5.3.So, it does a computation in advance before doing allocation of the object.What happens is that the JVM tries to allocate memory for an object in the memory called Permanent Generation region (or PermSpace). If allocation fails (even after the JVM invokes the Garbage Collector to try & allocate free space), it throws an OutOfMemoryError. Even exceptions requires a memory space so the error will be thrown indefinitely.Further reading.? Furthermore, OutOfMemoryError can occur in different JVM structure.Graham Borland seems to be right: at least my JVM apparently re-uses OutOfMemoryErrors.  To test this, I wrote a simple test program:Running it produces this output:BTW, the JVM I\'m running (on Ubuntu 10.04) is this:Edit: I tried to see what would happen if I forced the JVM to run completely out of memory using the following program:As it turns out, it seems to loop forever.  However, curiously, trying to terminate the program with Ctrl+C doesn\'t work, but only gives the following message:Java HotSpot(TM) 64-Bit Server VM warning: Exception java.lang.OutOfMemoryError occurred dispatching signal SIGINT to handler- the VM may need to be forcibly terminatedMost runtime environments will pre-allocate on startup, or otherwise reserve, enough memory to deal with memory starvation situations. I imagine most sane JVM implementations would do this.Last time I was working in Java and using a debugger, the heap inspector showed that the JVM allocated an instance of OutOfMemoryError on startup. In other words, it allocates the object before your program has a chance to start consuming, let alone run out of, memory.From the JVM Spec, Chapter 3.5.2:If Java virtual machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java virtual machine stack for a new thread, the Java virtual machine throws an OutOfMemoryError.Every Java Virtual Machine has to guarantee that it will throw an OutOfMemoryError. That implies, that it has to be capable of creating an instance of OutOfMemoryError (or haveing on created in advance) even if there\'s no heap space left.Although it does not have to guarantee, that there\'s enough memory left to catch it and print a nice stacktrace...AdditionYou added some code to show, that the JVM might run out of heap space if it had to throw more than one OutOfMemoryError. But such an implementation would violate the requirement from above. There is no requirement that the thrown instances of OutOfMemoryError are unique or created on demand. A JVM could prepare exactly one instance of OutOfMemoryError during startup and throw this whenever it runs out of heap space - which is once, in normal environment. In other words: the instance of OutOfMemoryError that we see could be a singleton.Interesting question :-). While the others have given good explanations of the theoretical aspects, I decided to try it out. This is on Oracle JDK 1.6.0_26, Windows 7 64 bit.Test setupI wrote a simple program to exhaust memory (see below).The program just creates a static java.util.List, and keeps stuffing fresh strings into it, until OOM is thrown. It then catches it and continues stuffing in an endless loop (poor JVM...).Test resultAs one can see from the output, the first four times OOME is thrown, it comes with a stack trace. After that, subsequent OOMEs only print java.lang.OutOfMemoryError: Java heap space if printStackTrace() is invoked.So apparently the JVM makes an effort to print a stack trace if it can, but if memory is really tight, it just omits the trace, just like the other answers suggest.Also interesting is the hash code of the OOME. Note that the first few OOME all have different hashes. Once the JVM starts omitting stack traces, the hash is always the same. This suggests that the JVM will use fresh (preallocated?) OOME instances as long as possible, but if push comes to shove, it will just reuse the same instance rather than having nothing to throw.OutputNote: I truncated some stack traces to make the output easier to read ("[...]").The programI am pretty sure, the JVM will make absolutely sure that it has at least enough memory to throw an exception before it runs out of memory.Exceptions indicating an attempt to violate the boundaries of a managed-memory environment are handled by the runtime of said environment, in this case the JVM. The JVM is its own process, which is running your application\'s IL. Should a program attempt to make a call that extends the call stack beyond the limits, or allocate more memory than the JVM can reserve, the runtime itself will inject an exception, which will cause the call stack to be unwound. Regardless of the amount of memory your program currently needs, or how deep its call stack, the JVM will have allocated enough memory within its own process bounds to create said exception and inject it into your code.You seem to be confusing the virtual memory reserved by the JVM in which the JVM runs Java programs with the host OS\'s native memory in which the JVM is run as a native process. The JVM on your machine is running in the memory managed by the OS, not in the memory the JVM has reserved to run Java programs.Further reading:And as a final note, trying to catch a java.lang.Error (and its descendant classes) in order to print a stacktrace may not give you any useful information. You want a heap dump instead.To further clarify @Graham Borland\'s answer, functionally, the JVM does this at startup:Later, the JVM executes one of the following Java bytecodes: \'new\', \'anewarray\', or \'multianewarray\'.  This instruction causes the JVM to perform a number of steps in an out of memory condition:Obviously, these are not literal steps; they\'ll vary from JVM to JVM in implementation, but this is the high-level idea.(*) A significant amount of work happens here before failing.  The JVM will attempt to clear SoftReference objects, attempt allocation directly into the tenured generation when using a generational collector, and possibly other things, like finalization.The answers that say that the JVM will pre-allocate OutOfMemoryErrors are indeed correct.\nIn addition to testing this by provoking an out-of-memory situation we can just check the heap of any JVM (I used a small program that just does a sleep, running it using Oracle\'s Hotspot JVM from Java 8 update 31).Using jmap we see that there seems to be 9 instances of OutOfMemoryError (even though we have plenty of memory):We can then generate a heap dump:and open it using Eclipse Memory Analyzer, where an OQL query shows that the JVM actually seems to pre-allocate OutOfMemoryErrors for all possible messages:The code for the Java 8 Hotspot JVM that actually preallocates these can be found here, and looks like this (with some parts omitted):and this code shows that the JVM will first try to use one of the pre-allocated errors with space for a stack trace, and then fall back to one without a stack trace: