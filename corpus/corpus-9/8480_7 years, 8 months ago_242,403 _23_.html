While running a C program, It says "(core dumped)" but I can\'t see any files under current path.I have set and verified the ulimit:I also tried to find file named "core", but didn\'t get the core dumped file?\nAny help, where is my core file?Read /usr/src/linux/Documentation/sysctl/kernel.txt.[/proc/sys/kernel/]core_pattern is used to specify a core dumpfile pattern name.Instead of writing the core dump to disk, your system is configured to send it to the abrt program instead.  Automated Bug Reporting Tool is possibly not as documented as it should be...In any case, the quick answer is that you should be able to find your core file in /var/cache/abrt, where abrt stores it after being invoked.  Similarly, other systems using Apport may squirrel away cores in /var/crash, and so on.On recent Ubuntu (12.04 in my case), it\'s possible for "Segmentation fault (core dumped)" to be printed, but no core file produced where you might expect one (for instance for a locally compiled program).This can happen if you have a core file size ulimit of 0 (you haven\'t done ulimit -c unlimited) -- this is the default on Ubuntu. Normally that would suppress the "(core dumped)", cluing you into your mistake, but on Ubuntu, corefiles are piped to Apport (Ubuntu\'s crash reporting system) via /proc/sys/kernel/core_pattern, and this seems to cause the misleading message.If Apport discovers that the program in question is not one it should be reporting crashes for (which you can see happening in /var/log/apport.log), it falls back to simulating the default kernel behaviour of putting a core file in the cwd (this is done in the script /usr/share/apport/apport). This includes honouring ulimit, in which case it does nothing. But (I assume) as far as the kernel is concerned, a corefile was generated (and piped to apport), hence the message "Segmentation fault (core dumped)".Ultimately PEBKAC for forgetting to set ulimit, but the misleading message had me thinking I was going mad for a while, wondering what was eating my corefiles.(Also, in general, the core(5) manual page -- man 5 core -- is a good reference for where your core file ends up and reasons it might not be written.)With the launch of systemd, there\'s another scenario aswell. By default systemd will store core dumps in its journal, being accessible with the systemd-coredumpctl command. Defined in the core_pattern-file:This behaviour can be disabled with a simple "hack":As always, the size of core dumps has to be equal or higher than the size of the core that is being dumped, as done by for example ulimit -c unlimited.I could think of two following possibilities:As others have already pointed out, the program might chdir(). Is the user running the program allowed to write into the directory it chdir()\'ed to? If not, it cannot create the core dump.For some weird reason the core dump isn\'t named core.* You can check /proc/sys/kernel/core_pattern for that. Also, the find command you named wouldn\'t find a typical core dump. You should use find / -name "*core.*", as the typical name of the coredump is core.$PIDIf you\'re missing core dumps for binaries on RHEL and when using abrt,\nmake sure that /etc/abrt/abrt-action-save-package-data.confcontains This enables the creation of crash reports (including core dumps) for binaries which are not part of installed packages (e.g. locally built).For fedora25, I could find core file at where ccpp-2017-02-16-16:36:51-2974" is pattern "%s %c %p %u %g %t %P % as per `/proc/sys/kernel/core_pattern\'