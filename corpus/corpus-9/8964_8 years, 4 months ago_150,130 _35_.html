In T-SQL you could have a query like:How would you replicate that in a LINQ to Entities query? Is it even possible?You need to turn it on its head in terms of the way you\'re thinking about it.  Instead of doing "in" to find the current item\'s user rights in a predefined set of applicable user rights, you\'re asking a predefined set of user rights if it contains the current item\'s applicable value.  This is exactly the same way you would find an item in a regular list in .NET.There are two ways of doing this using LINQ, one uses query syntax and the other uses method syntax.  Essentially, they are the same and could be used interchangeably depending on your preference:Query Syntax:Method Syntax:My personal preference in this instance might be method syntax because instead of assigning the variable, I could do the foreach over an anonymous call like this:Syntactically this looks more complex, and you have to understand the concept of lambda expressions or delegates to really figure out what\'s going on, but as you can see, this condenses the code a fair amount.It all comes down to your coding style and preference - all three of my examples do the same thing slightly differently.An alternative way doesn\'t even use LINQ, you can use the same method syntax replacing "where" with "FindAll" and get the same result, which will also work in .NET 2.0:This should suffice your purpose. It compares two collections and checks if one collection has the values matching those in the other collectionIf you\'re using VS2008/.net 3.5, see Alex James\' tip #8:\nhttp://blogs.msdn.com/alexj/archive/2009/03/26/tip-8-writing-where-in-style-queries-using-linq-to-entities.aspxOtherwise just use the array.Contains(someEntity.Member) method.I will go for Inner Join in this context. If I would have used contains, it would iterate 6 times despite if the fact that there are just one match.Suppose I have two list objects.Using Contains, it will search for each List 1 item in List 2 that means iteration will happen 49 times !!!This could be the possible way in which you can directly use LINQ extension methods to check the in clause I also tried to work with an SQL-IN-like thing - querying against an Entity Data Model. My approach is a string builder to compose a big OR-expression. That\'s terribly ugly, but I\'m afraid it\'s the only way to go right now.Now well, that looks like this:Working with GUIDs in this context: As you can see above, there is always the word "GUID" before the GUID ifself in the query string fragments. If you don\'t add this, ObjectQuery<T>.Where throws the following exception:The argument types \'Edm.Guid\' and\n  \'Edm.String\' are incompatible for this\n  operation., near equals expression,\n  line 6, column 14.Found this in MSDN Forums, might be helpful to have in mind.Matthias... looking forward for the next version of .NET and Entity Framework, when everything get\'s better. :)An alternative method to BenAlabaster answerFirst of all, you can rewrite the query like this:Certainly this is more \'wordy\' and a pain to write but it works all the same.So if we had some utility method that made it easy to create these kind of LINQ expressions we\'d be in business.with a utility method in place you can write something like this:This builds an expression that has the same effect as:But which more importantly actually works against .NET 3.5 SP1.Here is the plumbing function that makes this possible:I\'m not going to try to explain this method, other than to say it essentially builds a predicate expression for all the values using the valueSelector (i.e. p => p.User_Rights) and ORs those predicates together to create an expression for the complete predicateSource: http://blogs.msdn.com/b/alexj/archive/2009/03/26/tip-8-writing-where-in-style-queries-using-linq-to-entities.aspxSeriously?  You folks have never used