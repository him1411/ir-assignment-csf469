I frequently hear/read the following advice:Always make a copy of an event before you check it for null and fire it. This will eliminate a potential problem with threading where the event becomes null at the location right between where you check for null and where you fire the event:Updated: I thought from reading about optimizations that this might also require the event member to be volatile, but Jon Skeet states in his answer that the CLR doesn\'t optimize away the copy.But meanwhile, in order for this issue to even occur, another thread must have done something like this:The actual sequence might be this mixture:The point being that OnTheEvent runs after the author has unsubscribed, and yet they just unsubscribed specifically to avoid that happening. Surely what is really needed is a custom event implementation with appropriate synchronisation in the add and remove accessors. And in addition there is the problem of possible deadlocks if a lock is held while an event is fired.So is this Cargo Cult Programming? It seems that way - a lot of people must be taking this step to protect their code from multiple threads, when in reality it seems to me that events require much more care than this before they can be used as part of a multi-threaded design. Consequently, people who are not taking that additional care might as well ignore this advice - it simply isn\'t an issue for single-threaded programs, and in fact, given the absence of volatile in most online example code, the advice may be having no effect at all.(And isn\'t it a lot simpler to just assign the empty delegate { } on the member declaration so that you never need to check for null in the first place?)Updated: In case it wasn\'t clear, I did grasp the intention of the advice - to avoid a null reference exception under all circumstances. My point is that this particular null reference exception can only occur if another thread is delisting from the event, and the only reason for doing that is to ensure that no further calls will be received via that event, which clearly is NOT achieved by this technique. You\'d be concealing a race condition - it would be better to reveal it! That null exception helps to detect an abuse of your component. If you want your component to be protected from abuse, you could follow the example of WPF - store the thread ID in your constructor and then throw an exception if another thread tries to interact directly with your component. Or else implement a truly thread-safe component (not an easy task).So I contend that merely doing this copy/check idiom is cargo cult programming, adding mess and noise to your code. To actually protect against other threads requires a lot more work.Update in response to Eric Lippert\'s blog posts:So there\'s a major thing I\'d missed about event handlers: "event handlers are required to be robust in the face of being called even after the event has been unsubscribed", and obviously therefore we only need to care about the possibility of the event delegate being null. Is that requirement on event handlers documented anywhere?And so: "There are other ways to solve this problem; for example, initializing the handler to have an empty action that is never removed. But doing a null check is the standard pattern."So the one remaining fragment of my question is, why is explicit-null-check the "standard pattern"? The alternative, assigning the empty delegate, requires only = delegate {} to be added to the event declaration, and this eliminates those little piles of stinky ceremony from every place where the event is raised. It would be easy to make sure that the empty delegate is cheap to instantiate. Or am I still missing something?Surely it must be that (as Jon Skeet suggested) this is just .NET 1.x advice that hasn\'t died out, as it should have done in 2005?The JIT isn\'t allowed to perform the optimization you\'re talking about in the first part, because of the condition. I know this was raised as a spectre a while ago, but it\'s not valid. (I checked it with either Joe Duffy or Vance Morrison a while ago; I can\'t remember which.)Without the volatile modifier it\'s possible that the local copy taken will be out of date, but that\'s all. It won\'t cause a NullReferenceException.And yes, there\'s certainly a race condition - but there always will be. Suppose we just change the code to:Now suppose that the invocation list for that delegate has 1000 entries. It\'s perfectly possible that the action at the start of the list will have executed before another thread unsubscribes a handler near the end of the list. However, that handler will still be executed because it\'ll be a new list. (Delegates are immutable.) As far as I can see this is unavoidable.Using an empty delegate certainly avoids the nullity check, but doesn\'t fix the race condition. It also doesn\'t guarantee that you always "see" the latest value of the variable.I see a lot of people going toward the extension method of doing this ...That gives you nicer syntax to raise the event ...And also does away with the local copy since it is captured at method call time.I suspect the reason for this might be that the null-check is more performant.If you always subscribe an empty delegate to your events when they are created, there will be some overheads:(Note that UI controls often have a large number of events, most of which are never subscribed to. Having to create a dummy subscriber to each event and then invoke it would likely be a significant performance hit.)I did some cursory performance testing to see the impact of the subscribe-empty-delegate approach, and here are my results:Note that for the case of zero or one subscribers (common for UI controls, where events are plentiful), the event pre-initialised with an empty delegate is notably slower (over 50 million iterations...)For more information and source code, visit this blog post on .NET Event invocation thread safety that I published just the day before this question was asked (!)(My test set-up may be flawed so feel free to download the source code and inspect it yourself. Any feedback is much appreciated.)I truly enjoyed this read - not!  Even though I need it to work with the C# feature called events!Why not fix this in the compiler?  I know there are MS people who read these posts, so please don\'t flame this!1 - the Null issue) Why not make events be .Empty instead of null in the first place?  How many lines of code would be saved for null check or having to stick a = delegate {} onto the declaration?  Let the compiler handle the Empty case, IE do nothing!  If it all matters to the creator of the event, they can check for .Empty and do whatever they care with it!  Otherwise all the null checks / delegate adds are hacks around the problem!Honestly I\'m tired of having to do this with every event - aka boilerplate code!2 - the race condition issue) I read Eric\'s blog post, I agree that the H (handler) should handle when it dereferences itself, but cannot the event be made immutable/thread safe?  IE, set a lock flag on its creation, so that whenever it is called, it locks all subscribing and un-subscribing to it while its executing?Conclusion,Are not modern day languages supposed to solve problems like these for us?According to Jeffrey Richter in the book CLR via C#, the correct method is:Because it forces a reference copy.\nFor more information, see his Event section in the book.I\'ve been using this design pattern to ensure that event handlers aren\'t executed after they\'re unsubscribed.  It\'s working pretty well so far, although I haven\'t tried any performance profiling.I\'m mostly working with Mono for Android these days, and Android doesn\'t seem to like it when you try to update a View after its Activity has been sent to the background.This practice is not about enforcing a certain order of operations. It\'s actually about avoiding a null reference exception.The reasoning behind people caring about the null reference exception and not the race condition would require some deep psychological research. I think it has something to do with the fact that fixing the null reference problem is much easier. Once that is fixed, they hang a big "Mission Accomplished" banner on their code and unzip their flight suit.Note: fixing the race condition probably involves using a synchronous flag track whether the handler should runSo I\'m a little late to the party here. :)As for the use of null rather than the null object pattern to represent events with no subscribers, consider this scenario.  You need to invoke an event, but constructing the object (EventArgs) is non-trivial, and in the common case your event has no subscribers.  It would be beneficial to you if you could optimize your code to check to see if you had any subscribers at all before you committed processing effort to constructing the arguments and invoking the event.With this in mind, a solution is to say "well, zero subscribers is represented by null."  Then simply perform the null check before performing your expensive operation.  I suppose another way of doing this would have been to have a Count property on the Delegate type, so you\'d only perform the expensive operation if myDelegate.Count > 0.  Using a Count property is a somewhat nice pattern that solves the original problem of allowing optimization, and it also has the nice property of being able to be invoked without causing a NullReferenceException.Keep in mind, though, that since delegates are reference types, they are allowed to be null.  Perhaps there was simply no good way of hiding this fact under the covers and supporting only the null object pattern for events, so the alternative may have been forcing developers to check both for null and for zero subscribers.  That would be even uglier than the current situation.Note: This is pure speculation.  I\'m not involved with the .NET languages or CLR.for single threaded applicaitons, you are correc this is not an issue.However, if you are making a component that exposes events, there is no guarantee that a consumer of your component is not going to go multithreading, in which case you need to prepare for the worst.Using the empty delegate does solve the problem, but also causes a performance hit on every call to the event, and could possibly have GC implications.You are right that the consumer trie dto unsubscribe in order for this to happen, but if they made it past the temp copy, then consider the message already in transit.If you don\'t use the temporary variable, and don\'t use the empty delegate, and someone unsubscribes, you get a null reference exception, which is fatal, so I think the cost is worth it.I\'ve never really considered this to be much of an issue because I generally only protect against this sort of potential threading badness in static methods (etc) on my reusable components, and I don\'t make static events.Am I doing it wrong?Wire all your events at construction and leave them alone.  The design of the Delegate class cannot possibly handle any other usage correctly, as I will explain in the final paragraph of this post.First of all, there\'s no point in trying to intercept an event notification when your event handlers must already make a synchronized decision about whether/how to respond to the notification.Anything that may be notified, should be notified.  If your event handlers are properly handling the notifications (i.e. they have access to an authoritative application state and respond only when appropriate), then it will be fine to notify them at any time and trust they will respond properly.The only time a handler shouldn\'t be notified that an event has occurred, is if the event in fact hasn\'t occurred!  So if you don\'t want a handler to be notified, stop generating the events (i.e. disable the control or whatever is responsible for detecting and bringing the event into existence in the first place).Honestly, I think the Delegate class is unsalvageable.  The merger/transition to a MulticastDelegate was a huge mistake, because it effectively changed the (useful) definition of an event from something that happens at a single instant in time, to something that happens over a timespan.  Such a change requires a synchronization mechanism that can logically collapse it back into a single instant, but the MulticastDelegate lacks any such mechanism.  Synchronization should encompass the entire timespan or instant the event takes place, so that once an application makes the synchronized decision to begin handling an event, it finishes handling it completely (transactionally).  With the black box that is the MulticastDelegate/Delegate hybrid class, this is near impossible, so adhere to using a single-subscriber and/or implement your own kind of MulticastDelegate that has a synchronization handle that can be taken out while the handler chain is being used/modified.  I\'m recommending this, because the alternative would be to implement synchronization/transactional-integrity redundantly in all your handlers, which would be ridiculously/unnecessarily complex.Please take a look here: http://www.danielfortunov.com/software/%24daniel_fortunovs_adventures_in_software_development/2009/04/23/net_event_invocation_thread_safety\nThis is the correct solution and should always be used instead of all other workarounds.\xe2\x80\x9cYou can ensure that the internal invocation list always has at least one member by initializing it with a do-nothing anonymous method. Because no external party can have a reference to the anonymous method, no external party can remove the method, so the delegate will never be null\xe2\x80\x9d\n    \xe2\x80\x94 Programming .NET Components, 2nd Edition, by Juval L\xc3\xb6wyI don\'t believe the question is constrained to the c# "event" type.  Removing that restriction, why not re-invent the wheel a bit and do something along these lines?Raise event thread safely - best practiceThanks for a useful discussion. I was working on this problem recently and made the following class which is a bit slower, but allows to avoid callings to disposed objects.The main point here is that invocation list can be modified even event is raised.And the usage is:TestI tested it in the following manner. I have a thread which creates and destroys objects like this:In a Bar (a listener object) constructor I subscribe to SomeEvent (which is implemented as shown above) and unsubscribe in Dispose:Also I have couple of threads which raise event in a loop.All these actions are performed simultaneously: many listeners are created and destroyed and event is being fired at the same time.If there were a race conditions I should see a message in a console, but it is empty. But if I use clr events as usual I see it full of warning messages. So, I can conclude that it is possible to implement a thread safe events in c#.What do you think?With C# 6 and above, code could be simplified using new .? operator as in TheEvent?.Invoke(this, EventArgs.Empty);https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-conditional-operators 