Given a dictionary, how can I find out if a given key in that dictionary has already been set to a non-None value?I.e., I want to do this:I.e., I want to increment the value if there\'s already one there, or set it to 1 otherwise.You are looking for collections.defaultdict (available for Python 2.5+). Thiswill do what you want.For regular Python dicts, if there is no value for a given key, you will not get None when accessing the dict -- a KeyError will be raised. So if you want to use a regular dict, instead of your code you would useI prefer to do this in one line of code.Dictionaries have a function, get, which takes two parameters - the key you want, and a default value if it doesn\'t exist. I prefer this method to defaultdict as you only want to handle the case where the key doesn\'t exist in this one line of code, not everywhere.You need the key in dict idiom for that.However, you should probably consider using defaultdict (as dF suggested).I personally like using setdefault()To answer the question "how can I find out if a given index in that dict has already been set to a non-None value", I would prefer this:This conforms to the already invoked concept of EAFP (easier to ask forgiveness then permission). It also avoids the duplicate key lookup in the dictionary as it would in key in my_dict and my_dict[key] is not None what is interesting if lookup is expensive.For the actual problem that you have posed, i.e. incrementing an int if it exists, or setting it to a default value otherwise, I also recommend theas in the answer of Andrew Wilkinson.There is a third solution if you are storing modifyable objects in your dictionary. A common example for this is a multimap, where you store a list of elements for your keys. In that case, you can use:If a value for key does not exist in the dictionary, the setdefault method will set it to the second parameter of setdefault. It behaves just like a standard my_dict[key], returning the value for the key (which may be the newly set value).As you can see from the many answers, there are several solutions. One instance of LBYL (look before you leap) has not been mentioned yet, the has_key() method:Agreed with cgoldberg. How I do it is:So either do it as above, or use a default dict as others have suggested. Don\'t use if statements. That\'s not Pythonic.The way you are trying to do it is called LBYL (look before you leap), since you are checking conditions before trying to increment your value.The other approach is called EAFP (easier to ask forgiveness then permission).  In that case, you would just try the operation (increment the value).  If it fails, you catch the exception and set the value to 1.  This is a slightly more Pythonic way to do it (IMO).http://mail.python.org/pipermail/python-list/2003-May/205182.htmlA bit late but this should work.Here\'s one-liner that I came up with recently for solving this problem. It\'s based on the setdefault dictionary method:I was looking for it, didn\'t found it on web then tried my luck with Try/Error and found itThis isn\'t directly answering the question, but to me, it looks like you might want the functionality of collections.Counter.This results in the output