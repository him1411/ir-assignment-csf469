Why? I couldn\'t find an answer on SO, so let me answer my own question.Basically copying and pasting from Bjarne Stroustrup\'s "The C++ Programming Language 4th Edition":List initialization does not allow narrowing (\xc2\xa7iso.8.5.4). That is:Example:The only situation where = is preferred over {} is when using auto keyword to get the type determined by the initializer.Example:Prefer {} initialization over alternatives unless you have a strong reason not to.There are MANY reasons to use brace initialization, but you should be aware that the initializer_list<> constructor is preferred to the other constructors, the exception being the default-constructor. This leads to problems with constructors and templates where the type T constructor can be either an initializer list or a plain old ctor.Assuming you don\'t encounter such classes there is little reason not to use the intializer list.There are already great answers about the advantages of using list initialization, however my personal rule of thumb is NOT to use curly braces whenever possible, but instead make it dependent on the conceptual meaning:In my experience, this ruleset can be applied much more consistently than using curly braces by default, but having to explicitly remember all the exceptions when they can\'t be used or have a different meaning than the "normal" function-call syntax with parenthesis (calls a different overload). It e.g. fits nicely with standard library-types like std::vector:Please see updated answerHere is what Scott Meyers says about these initializations:...I\xe2\x80\x99ll generally ignore the equals-sign-plus-braces syntax, because C++ usually treats it the same as the braces-only version. - Meyers, S. (2015). Chapter 3: Moving to Modern C++. In Effective Modern C++ (p.49). O\'Reilly Media, Inc.UpdateAfter reading @LibertyLocked question and rereading the reference, I think I see what\'s going on here. In his example Meyers is initializing using int\'s, like this:and not classes...