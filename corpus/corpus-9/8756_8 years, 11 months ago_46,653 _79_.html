The following code receives seg fault on line 2:While this works perfectly well:Tested with MSVC and GCC.See the C FAQ, Question 1.32Q: What is the difference between these initializations?\n  char a[] = "string literal";\n  char *p  = "string literal";\n  My program crashes if I try to assign a new value to p[i].A: A string literal (the formal term\n  for a double-quoted string in C\n  source) can be used in two slightly\n  different ways:Some compilers have a switch\n  controlling whether string literals\n  are writable or not (for compiling old\n  code), and some may have options to\n  cause string literals to be formally\n  treated as arrays of const char (for\n  better error catching).Normally, string literals are stored in read-only memory when the program is run. This is to prevent you from accidentally changing a string constant. In your first example, "string" is stored in read-only memory and *str points to the first character. The segfault happens when you try to change the first character to \'z\'.In the second example, the string "string" is copied by the compiler from its read-only home to the str[] array. Then changing the first character is permitted. You can check this by printing the address of each:Also, printing the size of str in the second example will show you that the compiler has allocated 7 bytes for it:Most of these answers are correct, but just to add a little more clarity...The "read only memory" that people are referring to is the text segment in ASM terms. It\'s the same place in memory where the instructions are loaded. This is read-only for obvious reasons like security. When you create a char* initialized to a string, the string data is compiled into the text segment and the program initializes the pointer to point into the text segment. So if you try to change it, kaboom. Segfault.When written as an array, the compiler places the initialized string data in the data segment instead, which is the same place that your global variables and such live. This memory is mutable, since there are no instructions in the data segment. This time when the compiler initializes the character array (which is still just a char*) it\'s pointing into the data segment rather than the text segment, which you can safely alter at run-time.In the first code, "string" is a string constant, and string constants should never be modified because they are often placed into read only memory.  "str" is a pointer being used to modify the constant.In the second code, "string" is an array initializer, sort of short hand for"str" is an array allocated on the stack and can be modified freely.Why do I get a segmentation fault when writing to a string?C99 N1256 draftThere are two completely different uses of array literals:Initialize char[]:This is "more magic", and described at 6.7.8/14 "Initialization":An array of character type may be initialized by a character string literal, optionally\n  enclosed in braces. Successive characters of the character string literal (including the\n  terminating null character if there is room or if the array is of unknown size) initialize the\n  elements of the array.So this is just a shortcut for:Like any other regular array, c can be modified.Everywhere else: it generates an:So when you write:This is similar to:Note the implicit cast from char[] to char *, which is always legal.Then if you modify c[0], you also modify __unnamed, which is UB.This is documented at 6.4.5 "String literals":5 In translation phase 7, a byte or code of value zero is appended to each multibyte\n  character sequence that results from a string literal or literals. The multibyte character\n  sequence is then used to initialize an array of static storage duration and length just\n  sufficient to contain the sequence. For character string literals, the array elements have\n  type char, and are initialized with the individual bytes of the multibyte character\n  sequence [...]6 It is unspecified whether these arrays are distinct provided their elements have the\n  appropriate values. If the program attempts to modify such an array, the behavior is\n  undefined.6.7.8/32 "Initialization" gives a direct example:EXAMPLE 8: The declarationdefines "plain" char array objects s and t whose elements are initialized with character string literals.This declaration is identical toThe contents of the arrays are modifiable. On the other hand, the declarationdefines p with type "pointer to char" and initializes it to point to an object with type "array of char" with length 4 whose elements are initialized with a character string literal. If an attempt is made to use p to modify the contents of the array, the behavior is undefined.GCC 4.8 x86-64 Linux implementationLet\'s see why this implementation segfaults.Program:Compile and decompile:Output contains:So the string is stored in the .rodata section.Then:Contains (simplified):This means that the default linker script dumps both .text and .rodata into a segment that can be executed but not modified (Flags = R E). Attempting to modify such a segment leads to a segfault in Linux.If we do the same for char[]:we obtain:so it gets stored in the stack (relative to %rbp), and we can of course modify it.Because the type of "whatever" in the context of the 1st example is const char * (even if you assign it to a non-const char*), which means you shouldn\'t try and write to it.The compiler has enforced this by putting the string in a read-only part of memory, hence writing to it generates a segfault.To understand this error or problem you should first know difference b/w the pointer and array\n  so here firstly i have explain you differences b/w themIn memory array is stored in continuous memory cells, stored as [h][e][l][l][o][\\0] =>[] is 1 char byte size memory cell ,and this continuous memory cells can be access by name named strarray here.so here string array strarray itself containing all characters of string initialized to it.in this case here "hello"\nso we can easily change its memory content by accessing each character by its index valueand its value changed to \'m\' so strarray value changed to "mello";one point to note here that we can change the content of string array by changing character by character but can not initialized other string directly to it like strarray="new string" is invalidAs we all know  pointer points to memory location in memory ,\nuninitialized pointer points to random memory location so and after initialization points to particular memory locationhere pointer ptr is initialized to string "hello" which is  constant string stored in read only memory (ROM) so "hello" can not be changed as it is stored in ROMand ptr is stored in stack section and pointing to constant string "hello"so ptr[0]=\'m\' is invalid since you can not access read only memoryBut ptr can be initialised to other string value directly since it is just pointer so it can be point to any memory address of variable of its data typeThe above sets str to point to the literal value "string" which is hard-coded in the program\'s binary image, which is probably flagged as read-only in memory.  So str[0]= is attempting to write to the read-only code of the application.  I would guess this is probably compiler dependent though.allocates a pointer to a string literal, which the compiler is putting in a non-modifiable part of your executable;allocates and initializes a local array which is modifiableThe C FAQ that @matli linked to mentions it, but no one else here has yet, so for clarification: if a string literal (double-quoted string in your source) is used anywhere other than to initialize a character array (ie: @Mark\'s second example, which works correctly), that string is stored by the compiler in a special static string table, which is akin to creating a global static variable (read-only, of course) that is essentially anonymous (has no variable "name"). The read-only part is the important part, and is why the @Mark\'s first code example segfaults.The line defines a pointer and points it to a literal string.  The literal string is not writable so when you do:you get a seg fault.  On some platforms, the literal might be in writable memory so you won\'t see a segfault, but it\'s invalid code (resulting in undefined behavior) regardless.The line:allocates an array of characters and copies the literal string into that array, which is fully writable, so the subsequent update is no problem.String literals like "string" are probably allocated in your executable\'s address space as read-only data (give or take your compiler).  When you go to touch it, it freaks out that you\'re in its bathing suit area and lets you know with a seg fault.In your first example, you\'re getting a pointer to that const data.  In your second example, you\'re initializing an array of 7 characters with a copy of the const data.In the first place, str is a pointer that points at "string".  The compiler is allowed to put string literals in places in memory that you cannot write to, but can only read.  (This really should have triggered a warning, since you\'re assigning a const char * to a char *.  Did you have warnings disabled, or did you just ignore them?)In the second place, you\'re creating an array, which is memory that you\'ve got full access to, and initializing it with "string".  You\'re creating a char[7] (six for the letters, one for the terminating \'\\0\'), and you do whatever you like with it.First is one constant string which can\'t be modified. Second is an array with initialized value, so it can be modified. segmentation fault is caused when you tyr to access the memory which is non accessible. char *str is a pointer to a string which is non modifiable(the reason for getting seg fault)..whereas char str[] is an array and can be modifiable..