While I found similar question I didn\'t find an answer to my problemWhen I try to rename the directory from FOO to foo via git mv FOO foo I get  OK. So I try git mv FOO foo2 && git mv foo2 fooBut when I try to commit via git commit . I getWhen I add the directory via git add foo nothing changes and git commit . gives me the same message again. What am I doing wrong? I thought I\'m using a case-sensitive system (OSX) why can\'t I simply rename the directory?You are in a case insensitive environment. Further, adding with out the -A will not take care of the remove side of the mv as Git understands it. Warning! Ensure that no other changes or untracked files are around when you do this or they will get committed as part of this change! git stash -u first, do this and then git stash pop after. Continuing: To get around this, do the following:That\'s the drawn out way of changing the working directory, committing and then collapsing the 2 commits. You can just move the file in the index, but to someone that is new to git, it may not be explicit enough as to what is happening. The shorter version isAs suggested in one of the comments, you can also do an interactive rebase (git rebase -i HEAD~5 if the wrong case was introduced 5 commits ago) to fix the case there and not have the wrong case appear anywhere in the history at all. You have to be careful if you do this as the commit hashes from then on will be different and others will have to rebase or re-merge their work with that recent past of the branch.This is related to correcting the name of a file: Is git not case sensitive?You want to set the option core.ignorecase to false, which will make Git pay attention to case on file systems that don\'t natively support it. To enable in your repo:Then you can rename the file with git mv and it\'ll work as expected.I was able to resolve this, using git 1.7.7 by using a temporary filename:Force it with -f option:(git mv-free variant.)I ran into this problem in Git on Mac OS X 10.9. I solved it as follows:git rm -r --cached /path/to/directoryThat stages the directory for deletion in Git but does not actually remove any physical files (--cached). This also makes the directory, now with the proper case, show up in untracked files.So you can do this:Git will then recognize that you have renamed the files, and when you do git status you should see a number of renamed: lines. Inspect them and ensure they look correct, and if so, you can commit the changes normally.Do not rename single files. This leads to a bug, described in this answer.If you first want to see the outcome first, use -n:After you\'ve made an mv:Now Git should have renamed the folder BOTH in its internal files and in file system.You\'re not using a case-sensitive filesystem in OS X unless you explicitly choose such. HFS+ can be case-sensitive, but the default is case-insensitive.Here\'s a really simple solution around all the gitfoo on this page.Improving Adam Dymitruk\'s answer (silly that SO doesn\'t let me comment his answer), using "git mv" will automatically stage exactly the moved files. No stashing is needed and the risky "git add -A" can be avoided:I had one related issue.One folder named \'Pro\' (created first) and anther \'pro\' (created by mistake). In Mac, it is the same thing, but different according to git.the git config rename the files to the right folder(thanks), and also created ghost files in \'pro\' (No!!). I could not add ghost file changes to the track and I could not checkout other branches unless carry those those files with me, and i also could not reset it somehow.Instead of that, i did To make it extra safe, i did it in a feature branch, and then i merged back to main branchFor the ghost file issue created by , can any guru explain How and Why? \nThanks in advance. 