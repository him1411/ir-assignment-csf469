I want to be able to create a custom service that fetches an http get request in the case ts data object is empty and populate the data object on success. The next time a service call is made the device will not call the http get and instead will present the data object.Any ideas how to do it?Angular\'s $http has a cache built in. According to the docs:cache \xe2\x80\x93 {boolean|Object} \xe2\x80\x93 A boolean value or object created with $cacheFactory to enable or disable caching of the HTTP response. See\n  $http Caching for more\n  information.So you can set cache to true in its options:or, if you prefer the config type of call:You can also use a cache factory:You can implement it yourself using $cacheFactory (especially handly when using $resource):I think there\'s an even easier way now.  This enables basic caching for all $http requests (which $resource inherits):An easier way to do this in the current stable version (1.0.6) requires a lot less code.After setting up your module add a factory:Now you can pass this into your controller:One downside is that the key names are also setup automatically, which could make clearing them tricky. Hopefully they\'ll add in some way to get key names.Check out the library angular-cache if you like $http\'s built-in caching but want more control. You can use it to seamlessly augment $http cache with time-to-live, periodic purges, and the option of persisting the cache to localStorage so that it\'s available across sessions. FWIW, it also provides tools and patterns for making your cache into a more dynamic sort of data-store that you can interact with as POJO\'s, rather than just the default JSON strings. Can\'t comment on the utility of that option as yet. (Then, on top of that, related library angular-data is sort of a replacement for $resource and/or Restangular, and is dependent upon angular-cache.)As AngularJS factories are singletons, you can simply store the result of the http request and retrieve it next time your service is injected into something.set cache to be true.