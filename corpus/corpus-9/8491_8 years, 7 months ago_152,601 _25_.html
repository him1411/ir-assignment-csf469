I\'ve got code that looks like this:I\'d like remove inactive items immediately after update them, inorder to avoid walking the list again.  But if I add the commented-out lines, I get an error when I get to i++: "List iterator not incrementable".  I tried some alternates which didn\'t increment in the for statement, but I couldn\'t get anything to work.What\'s the best way to remove items as you are walking a std::list?You have to increment the iterator first (with i++) and then remove the previous element (e.g., by using the returned value from i++).  You can change the code to a while loop like so:You want to do:That will correctly update the iterator to point to the location after the iterator you removed.You need to do the combination of Kristo\'s answer and MSN\'s:Of course, the most efficient and SuperCoolÂ® STL savy thing would be something like this:Use std::remove_if algorithm.Edit: \nWork with collections should be like:\n1. prepare collection.\n2. process collection.Life will be easier if you won\'t mix this steps.The alternative for loop version to Kristo\'s answer. You lose some efficiency, you go backwards and then forward again when deleting but in exchange for the extra iterator increment you can have the iterator declared in the loop scope and the code looking a bit cleaner. What to choose depends on priorities of the moment.The answer was totally out of time, I know...Here\'s an example using a for loop that iterates the list and increments or revalidates the iterator in the event of an item being removed during traversal of the list.Removal invalidates only the iterators that point to the elements that are removed.So in this case after removing *i , i is invalidated and you cannot do increment on it.What you can do is first save the iterator of element that is to be removed , then increment the iterator and then remove the saved one.You can writeYou can write equivalent code with std::list::remove_if, which is less verbose and more explicit The std::vector::erase std::remove_if idiom should be used when items is a vector instead of a list to keep compexity at O(n) - or in case you write generic code and items might be a container with no effective way to erase single items (like a vector)If you think of the std::list like a queue, then you can dequeue and enqueue all the items that you want to keep, but only dequeue (and not enqueue) the item you want to remove. Here\'s an example where I want to remove 5 from a list containing the numbers 1-10...myList will now only have numbers 1-4 and 6-10.Here is a very generic for loop example that can delete values while iterating.I think you have a bug there, I code this way: