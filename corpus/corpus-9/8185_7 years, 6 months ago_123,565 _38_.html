I\'m writing my first Android application and trying to get my head around communication between services and activities. I have a Service that will run in the background and do some gps and time based logging. I will have an Activity that will be used to start and stop the Service. So first, I need to be able to figure out if the Service is running when the Activity is started. There are some other questions here about that, so I think I can figure that out (but feel free to offer advice).My real problem: if the Activity is running and the Service is started, I need a way for the Service to send messages to the Activity. Simple Strings and integers at this point - status messages mostly. The messages will not happen regularly, so I don\'t think polling the service is a good way to go if there is another way. I only want this communication when the Activity has been started by the user - I don\'t want to start the Activity from the Service. In other words, if you start the Activity and the Service is running, you will see some status messages in the Activity UI when something interesting happens. If you don\'t start the Activity, you will not see these messages (they\'re not that interesting).It seems like I should be able to determine if the Service is running, and if so, add the Activity as a listener. Then remove the Activity as a listener when the Activity pauses or stops. Is that actually possible? The only way I can figure out to do it is to have the Activity implement Parcelable and build an AIDL file so I can pass it through the Service\'s remote interface. That seems like overkill though, and I have no idea how the Activity should implement writeToParcel() / readFromParcel().Is there an easier or better way? Thanks for any help.EDIT: For anyone who\'s interested in this later on, there is sample code from Google for handling this via AIDL in the samples directory: /apis/app/RemoteService.javaThere are three obvious ways to communicate with services:In your case, I\'d go with option 3. Make a static reference to the service it self and populate it in onCreate(): Make a static function MyService getInstance(), which returns the static sInstance. Then in Activity.onCreate() you start the service, asynchronously wait until the service is actually started (you could have your service notify your app it\'s ready by sending an intent to the activity.) and get its instance. When you have the instance, register your service listener object to you service and you are set. NOTE: when editing Views inside the Activity you should modify them in the UI thread, the service will probably run its own Thread, so you need to call Activity.runOnUiThread().The last thing you need to do is to remove the reference to you listener object in Activity.onPause(), otherwise an instance of your activity context will leak, not good.NOTE: This method is only useful when your application/Activity/task is the only process that will access your service. If this is not the case you have to use option 1. or 2.The asker has probably long since moved past this, but in case someone else searches for this...There\'s another way to handle this, which I think might be the simplest.Add a BroadcastReceiver to your Activity.  Register it to receive some custom intent in onResume and unregister it in onPause.  Then send out that intent from your service when you want to send out your status updates or what have you.Make sure you wouldn\'t by unhappy if some other app listened for your Intent (could anyone do anything malicious?), but beyond that, you should be alright.Code sample was requested:In my service, I have:(RefreshTask.REFRESH_DATA_INTENT is just a constant String.)In my listening activity, I define my BroadcastReceiver:  I declare my receiver at the top of the class:  I override onResume to add:  And I override onPause to add:  Now my activity is listening for my service to say "Hey, go update yourself."  I could pass data in the Intent instead of updating database tables and then going back to find the changes within my activity, but since I want the changes to persist anyway, it makes sense to pass the data via db.Use LocalBroadcastManager to regist a receiver to listen for a broadcast sent from localservice inside your app, reference goes here:http://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.htmlUsing a Messenger is another simple way to communicate between a Service and an Activity.In the Activity, create a Handler with a corresponding Messenger. This will handle messages from your Service.The Messenger can be passed to the service by attaching it to a Message:A full example can be found in the API demos: MessengerService and MessengerServiceActivity. Refer to the full example for how MyService works.I am surprised that no one has given reference to Otto event Bus libraryhttp://square.github.io/otto/I have been using this in my android apps and it works seamlessly.The other method that\'s not mentioned in the other comments is to bind to the service from the activity using bindService() and get an instance of the service in the ServiceConnection callback. As described here http://developer.android.com/guide/components/bound-services.htmlAnother way could be using observers with a fake model class through the activity and the service itself, implementing an MVC pattern variation. I don\'t know if it\'s the best way to accomplish this, but it\'s the way that worked for me. If you need some example ask for it and i\'ll post something.To follow up on @MrSnowflake answer with a code example.\nThis is the XABBER now open source Application class. The Application class is centralising and coordinating Listeners and ManagerInterfaces and more. Managers of all sorts are dynamically loaded. Activity\xc2\xb4s started in the Xabber will report in what type of Listener they are. And when a Service start it report in to the Application class as started. Now to send a message to an Activity all you have to do is make your Activity become a listener of what type you need. In the OnStart() OnPause() register/unreg. The Service can ask the Application class for just that listener it need to speak to and if it\'s there then the Activity is ready to receive. Going through the Application class you\'ll see there\'s a loot more going on then this.