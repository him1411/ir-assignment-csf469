I have a stored procedure that returns rows:My actual procedure is a little more complicated, which is why a sproc is necessary.Is it possible to select the output by calling this procedure?Something like:I need to use SELECT TOP X, ROW_NUMBER, and an additional WHERE clause to page my data, and I don\'t really want to pass these values as parameters.You can use a User-defined function or a view instead of a procedure.A procedure can return multiple result sets, each with its own schema. It\'s not suitable for using in a SELECT statement.You should look at this excellent article by Erland Sommarskog:It basically lists all available options for your scenario. You can ... sql ....You either want a Table-Valued function or insert your EXEC into a temporary table:You must read about OPENROWSET and OPENQUERYIt is not necessary use a temporary table. This is my solutionYou can copy output from sp to temporaty table.You need to declare a table type which contains the same number of columns your store procedure is returning. Data types of the columns in the table type and the columns returned by the procedures should be sameThen you need to insert the result of your stored procedure in your table type you just definedIn the end just select from your table typeYou can cheat a little with OPENROWSET :This would still run the entire SP every time, of course.use OPENQUERY and befor Execute set \'SET FMTONLY OFF; SET NOCOUNT ON;\'Try this sample code:It sounds like you might just need to use a view.  A view allows a query to be represented as a table so it, the view, can be queried.Try converting your procedure in to an Inline Function which returns a table as follows:And then you can call it as You also have the option of passing parameters to the function as follows:And call itIf \'DATA ACCESS\' false,after,it works.If your server is called SERVERX for example, this is how I did it...To check this worked, I commented out the EXEC() command line and replaced it with SELECT @CMD to review the command before trying to execute it! That was to make sure all the correct number of single-quotes were in the right place.  :-)I hope that helps someone.For the sake of simplicity and to make it re-runnable, I have used a system StoredProcedure "sp_readerrorlog" to get data: