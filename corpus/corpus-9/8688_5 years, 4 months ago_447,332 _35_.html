I want to create an empty list (or whatever is the best way) that can hold 10 elements.After that I want to assign values in that list, for example this is supposed to display 0 to 9:But when I run this code, it generates an error or in another case it just displays [] (empty). Can someone explain why?You cannot assign to a list like lst[i] = something. You need to use append. lst.append(something).(You could use the assignment notation if you were using a dictionary).Creating an empty list:range(x) creates a list from [0, 1, 2, ... x-1]Using a function to create a list:List comprehension (Using the squares because for range you don\'t need to do all this, you can just return range(0,9) ):Try this instead:The above will create a list of size 10, where each position is initialized to None. After that, you can add elements to it:Admittedly, that\'s not the Pythonic way to do things. Better do this:Or even better, use list comprehensions like this:varunl\'s currently accepted answerWorks well for non-reference types like numbers. Unfortunately if you want to create a list-of-lists you will run into referencing errors. Example in Python 2.7.6:As you can see, each element is pointing to the same list object. To get around this, you can create a method that will initialize each position to a different object reference.There is likely a default, built-in python way of doing this (instead of writing a function), but I\'m not sure what it is. Would be happy to be corrected! Edit: It\'s [ [] for _ in range(10)]Example : You can .append(element) to the list, e.g.: s1.append(i). What you are currently trying to do is access an element (s1[i]) that does not exist.There are two "quick" methods:It appears that [None]*x is faster:But if you are ok with a range (e.g. [0,1,2,3,...,x-1]), then range(x) might be fastest:(This was written based on the original version of the question.)I want to create a empty list (or whatever is the best way) can hold 10 elements.All lists can hold as many elements as you like, subject only to the limit of available memory. The only "size" of a list that matters is the number of elements currently in it.but when I run it, the result is []print display s1 is not valid syntax; based on your description of what you\'re seeing, I assume you meant display(s1) and then print s1. For that to run, you must have previously defined a global s1 to pass into the function.Calling display does not modify the list you pass in, as written. Your code says "s1 is a name for whatever thing was passed in to the function; ok, now the first thing we\'ll do is forget about that thing completely, and let s1 start referring instead to a newly created list. Now we\'ll modify that list". This has no effect on the value you passed in.There is no reason to pass in a value here. (There is no real reason to create a function, either, but that\'s beside the point.) You want to "create" something, so that is the output of your function. No information is required to create the thing you describe, so don\'t pass any information in. To get information out, return it.That would give you something like:The next problem you will note is that your list will actually have only 9 elements, because the end point is skipped by the range function. (As side notes, [] works just as well as list(), the semicolon is unnecessary, s1 is a poor name for the variable, and only one parameter is needed for range if you\'re starting from 0.) So then you end up withHowever, this is still missing the mark; range is not some magical keyword that\'s part of the language the way for and def are, but instead it\'s a function. And guess what that function returns? That\'s right - a list of those integers. So the entire function collapses to and now you see why we don\'t need to write a function ourselves at all; range is already the function we\'re looking for. Although, again, there is no need or reason to "pre-size" the list.