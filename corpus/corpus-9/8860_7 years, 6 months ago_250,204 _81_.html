We are required to use a Makefile to pull everything together for our project but our professor never showed us how to.I only have ONE file, a3driver.cpp.\nThe driver imports a class from a location "/user/cse232/Examples/example32.sequence.cpp".That\'s it, everything else is contained with the .cpp.How would I go about making a simple Makefile that creates an executable called a3a.exe?Copied from a wiki post I wrote for physics grad students.Since this is for unix the executables have no extensions.One thing to note is that root-config is a utility which provides the right compilation and linking flags; and the right libraries for building applications against root. That\'s just a detail related to the original audience for this document.or You Never Forget The First Time You Got MadeA introductory discussion of make, and how to write a simple makefileWhat is Make? And Why Should I Care?The tool called make is a build dependency manager. That is, it takes care of knowing what commands need to be executed in what order to take your software project from a collection of source files, object files, libraries, headers, etc. etc.---some of which may have changed recently---and turning them into a correct up-to-date version of the program.Actually you can use make for other things too, but I\'m not going to talk about that.A Trivial MakefileSuppose that you have a directory containing: tool tool.cc tool.o support.cc support.hh, and  support.o which depend on root and are supposed to be compiled into a program called tool, and suppose that you\'ve been hacking on the source files (which means the existing tool is now out of date) and want to compile the program.To do this yourself you could1) check if either support.cc or support.hh is newer than support.o, and if so run a command like2) check if either support.hh or tool.cc are newer than tool.o, and if so run a command like3) check if tool.o is newer than tool, and if so run a command likePhew! What a hassle! There is a lot to remember and several chances to make mistakes. (BTW-- The particulars of the command lines exhibited here depend on our software environment. These ones work on my computer.)Of course, you could just run all three commands every time. That would work, but doesn\'t scale well to a substantial piece of software (like DOGS which takes more than 15 minutes to compile from the ground up on my MacBook).Instead you could write a file called makefile like this:and just type make at the command line. which will perform the three steps shown above automatically.The un-indented lines here have the form "target: dependencies" and tell make that the associated commands (indented lines) should be run if any of the dependencies are newer than the target. That is the dependency lines describe the logic of what needs to be rebuilt to accommodate changes in various files. If support.cc changes that means that support.o must be rebuilt, but tool.o can be left alone. When support.o changes tool must be rebuilt.The commands associated with each dependency line are set off with a tab (see below) should modify the target (or at least touch it to update the modification time).At this point, our makefile is simply remembering the work that needs doing, but we still had to figure out and type each and every needed command in its entirety. It does not have to be that way: make is a powerful language with variables, text manipulation functions, and a whole slew of built-in rules which can make this much easier for us.Make VariablesThe syntax for accessing a make variable is $(VAR).The syntax for assigning to a make variable is: VAR = A text value of some kind\n(or VAR := A different text value but ignore this for the moment).You can use variables in rules like this improved version of our makefile:which is a little more readable, but still requires a lot of typingMake FunctionsGNU make supports a variety of functions for accessing information from the filesystem or other commands on the system. In this case we are interested in $(shell ...) which expands to the output of the argument(s), and $(subst opat,npat,text) which replaces all instances of opat with npat in text.Taking advantage of this gives us:which is easier to type and much more readable.Notice thatImplicit and Pattern RulesWe would generally expect that all c++ source files should be treated the same way, and make provides three ways to state thisImplicit rules are built in, and a few will be discussed below. Pattern rules are specified in a form likewhich means that object files are generated from c source files by running the command shown, where the "automatic" variable $< expands to the name of the first dependency.Built-in RulesMake has a whole host of built in rules that mean that very often, a project can be compile by a very simple makefile, indeed.The GNU make built in rule for c source files is the one exhibited above. Similarly we create object files from c++ source files with a rule like $(CXX) -c $(CPPFLAGS) $(CFLAGS)Single object files are linked using $(LD) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS), but this won\'t work in our case, because we want to link multiple object files.Variables Used By Built-in RulesThe built in rules use a  set of standard variables that allow you to specify local environment information (like where to find the ROOT include files) without re-writing all the rules. The ones most likely to be interesting to us are:A Basic MakefileBy taking advantage of the built in rules we can simplify our makefile to:We have also added several standard targets that perform special actions (like cleaning up the source directory).Note that when make is invoked without an argument, it uses the first target found in the file (in this case all), but you can also name the target to get which is what makes make clean remove the object files in this case.We still have all the dependencies hard-coded.Some Mysterious ImprovementsNotice thatOther ReadingKnow Bugs and Historical NotesThe input language for make is whitespace sensitive. In particular the action lines following dependencies must start with a tab. But a series of spaces can look the same (and indeed there are editors that will silently convert tabs to spaces or vice versa), which results in a make file that looks right and still doesn\'t work. This was identified as a bug early on but (the story goes) was not fixed because there were already 10 users.I\'ve always thought this was easier to learn with a detailed example, so here\'s how I think of makefiles. For each section you have one line that\'s not indented and it shows the name of the section followed by dependencies. The dependencies can be either other sections (which will be run before the current section) or files (which if updated will cause the current section to be run again next time you run make).Here\'s a quick example (keep in mind that I\'m using 4 spaces where I should be using a tab, Stack Overflow won\'t let me use tabs):When you type make, it will choose the first section (a3driver). a3driver depends on a3driver.o, so it will go to that section. a3driver.o depends on a3driver.cpp, so it will only run if a3driver.cpp has changed since it was last run. Assuming it has (or has never been run), it will compile a3driver.cpp to a .o file, then go back to a3driver and compile the final executable.Since there\'s only one file, it could even be reduced to:The reason I showed the first example is that it shows the power of makefiles. If you need to compile another file, you can just add another section. Here\'s an example with a secondFile.cpp (which loads in a header named secondFile.h):This way if you change something in secondFile.cpp or secondFile.h and recompile, it will only recompile secondFile.cpp (not a3driver.cpp). Or alternately, if you change something in a3driver.cpp, it won\'t recompile secondFile.cpp.Let me know if you have any questions about it.It\'s also traditional to include a section named "all" and a section named "clean". "all" will usually build all of the executables, and "clean" will remove "build artifacts" like .o files and the executables:EDIT: I didn\'t notice you\'re on Windows. I think the only difference is changing the -o a3driver to -o a3driver.exe.Why does everyone like to list out source files?  A simple find command can take care of that easily.Here\'s an example of a dirt simple C++ Makefile.  Just drop it in a directory containing .C files and then type make...Old question, I know, but for posterity. You had two options. Option 1: simplest makefile = NO MAKEFILE.Rename "a3driver.cpp" to "a3a.cpp", then on the command line write:And that\'s it. If you\'re using gnu-make use "make" or "gmake" or whatever.Option 2: a 2-line makefile.Voil\xc3\xa0.Your make file will have one or two dependency rules depending on whether you compile and link with a single command, or with one command for the compile and one for the link.Dependency are a tree of rules that look like this:There must be a blank line after the commands for a target, and there must not be a blank line before the commands. The first target in the makefile is the overall goal, other targets are built only if the first target depends on them.  So your makefile will look something like this.  I used friedmud\'s answer. I looked into this for a while, and it seems to be a good way to get started. This solution also has a well defined method of adding compiler flags. I answered again because I made changes to make it work in my environment, Ubuntu and g++. More working examples are the best teacher, sometimes.makefiles seem to be very complex. I was using one, but it was generating an error related to not linking in g++ libraries. This configuration solved that problem.That is a simple Makefile:In order to have a full featured Makefile, I suggest to also add:A few notes: