What is the difference between START_STICKY and START_NOT_STICKY while implementing services in android? Could anyone point out to some standard examples.. ?Both codes are only relevant when the phone runs out of memory and kills the service before it finishes executing.  START_STICKY tells the OS to recreate the service after it has enough memory and call onStartCommand() again with a null intent. START_NOT_STICKY tells the OS to not bother recreating the service again.  There is also a third code START_REDELIVER_INTENT that tells the OS to recreate the service and redeliver the same intent to onStartCommand().This article by Dianne Hackborn explained the background of this a lot better than the official documentation.Source: http://android-developers.blogspot.com.au/2010/02/service-api-changes-starting-with.html The key part here is a new result code returned by the function,\n  telling the system what it should do with the service if its process\n  is killed while it is running:START_STICKY is basically the same as the previous behavior, where the\n  service is left "started" and will later be restarted by the system.\n  The only difference from previous versions of the platform is that it\n  if it gets restarted because its process is killed, onStartCommand()\n  will be called on the next instance of the service with a null Intent\n  instead of not being called at all. Services that use this mode should\n  always check for this case and deal with it appropriately.START_NOT_STICKY says that, after returning from onStartCreated(), if\n  the process is killed with no remaining start commands to deliver,\n  then the service will be stopped instead of restarted. This makes a\n  lot more sense for services that are intended to only run while\n  executing commands sent to them. For example, a service may be started\n  every 15 minutes from an alarm to poll some network state. If it gets\n  killed while doing that work, it would be best to just let it be\n  stopped and get started the next time the alarm fires.START_REDELIVER_INTENT is like START_NOT_STICKY, except if the\n  service\'s process is killed before it calls stopSelf() for a given\n  intent, that intent will be re-delivered to it until it completes\n  (unless after some number of more tries it still can\'t complete, at\n  which point the system gives up). This is useful for services that are\n  receiving commands of work to do, and want to make sure they do\n  eventually complete the work for each command sent.Difference:START_STICKYthe system will try to re-create your service after it is killedSTART_NOT_STICKYthe system will not try to re-create your service after it is killedStandard example:The documentation for START_STICKY and START_NOT_STICKY is quite straightforward.START_STICKY:If this service\'s process is killed while it is started (after\n  returning from onStartCommand(Intent, int, int)), then leave it in\n  the started state but don\'t retain this delivered intent. Later the\n  system will try to re-create the service. Because it is in the started\n  state, it will guarantee to call onStartCommand(Intent, int, int)\n  after creating the new service instance; if there are not any pending\n  start commands to be delivered to the service, it will be called with\n  a null intent object, so you must take care to check for this.This mode makes sense for things that will be explicitly started and\n  stopped to run for arbitrary periods of time, such as a service\n  performing background music playback.Example: Local Service SampleSTART_NOT_STICKY:If this service\'s process is killed while it is started (after\n  returning from onStartCommand(Intent, int, int)), and there are no\n  new start intents to deliver to it, then take the service out of the\n  started state and don\'t recreate until a future explicit call to\n  Context.startService(Intent). The service will not receive a\n  onStartCommand(Intent, int, int) call with a null Intent because\n  it will not be re-started if there are no pending Intents to deliver.This mode makes sense for things that want to do some work as a result\n  of being started, but can be stopped when under memory pressure and\n  will explicit start themselves again later to do more work. An example\n  of such a service would be one that polls for data from a server: it\n  could schedule an alarm to poll every N minutes by having the alarm\n  start its service. When its onStartCommand(Intent, int, int) is\n  called from the alarm, it schedules a new alarm for N minutes later,\n  and spawns a thread to do its networking. If its process is killed\n  while doing that check, the service will not be restarted until the\n  alarm goes off.Example: ServiceStartArguments.javaThe most common restart int values are defined by the following Service static fields:The onStartCommand, which executes on the main Thread, is the entry point for your\nservice, so in cases where you execute long running operations on your Service, the\nof\xef\xac\x82oad of your operation into a background thread is imperative for keeping your\napplication responsiveness at bearable levels.