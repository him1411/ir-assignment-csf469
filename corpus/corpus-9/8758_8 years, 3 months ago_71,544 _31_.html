Is there any real practical difference between a SortedList<TKey,TValue> and a SortedDictionary<TKey,TValue>?  Are there any circumstances where you would specifically use one and not the other?Yes - their performance characteristics differ significantly. It would probably be better to call them SortedList and SortedTree as that reflects the implementation more closely.Look at the MSDN docs for each of them (SortedList, SortedDictionary) for details of the performance for different operations in different situtations. Here\'s a nice summary (from the SortedDictionary docs):The SortedDictionary<TKey, TValue> generic\n  class is a binary search tree with\n  O(log n) retrieval, where n is the\n  number of elements in the dictionary.\n  In this, it is similar to the\n  SortedList<TKey, TValue> generic\n  class. The two classes have similar\n  object models, and both have O(log n)\n  retrieval. Where the two classes\n  differ is in memory use and speed of\n  insertion and removal:SortedList<TKey, TValue> uses less\n  memory than SortedDictionary<TKey,\n  TValue>.SortedDictionary<TKey, TValue> has\n  faster insertion and removal\n  operations for unsorted data, O(log n)\n  as opposed to O(n) for\n  SortedList<TKey, TValue>.If the list is populated all at once\n  from sorted data, SortedList<TKey,\n  TValue> is faster than\n  SortedDictionary<TKey, TValue>.(SortedList actually maintains a sorted array, rather than using a tree. It still uses binary search to find elements.)Here is a tabular view if it helps...From a performance perspective:From an implementation perspective:To roughly paraphrase, if you require raw performance SortedDictionary could be a better choice. If you require lesser memory overhead and indexed retrieval SortedList fits better. See this question for more on when to use which.You can read more here, here, here, here and here. I cracked open Reflector to have a look at this as there seems to be a bit of confusion about SortedList. It is in fact not a binary search tree, it is a sorted (by key) array of key-value pairs. There is also a TKey[] keys variable which is sorted in sync with the key-value pairs and used to binary search.Here is some source (targeting .NET 4.5) to backup my claims.Private membersSortedList.ctor(IDictionary, IComparer) SortedList.Add(TKey, TValue) : voidSortedList.RemoveAt(int) : voidCheck out the MSDN page for SortedList:From Remarks section:The SortedList<(Of <(TKey, TValue>)>) generic class is a binary search tree with O(log n) retrieval, where n is the number of elements in the dictionary. In this, it is similar to the SortedDictionary<(Of <(TKey, TValue>)>) generic class. The two classes have similar object models, and both have O(log n) retrieval. Where the two classes differ is in memory use and speed of insertion and removal:SortedDictionary<(Of <(TKey, TValue>)>) has faster insertion and removal operations for unsorted data, O(log n) as opposed to O(n) for SortedList<(Of <(TKey, TValue>)>).If the list is populated all at once from sorted data, SortedList<(Of <(TKey, TValue>)>) is faster than SortedDictionary<(Of <(TKey, TValue>)>).This is visual representation of how performances compare to each other.Enough is said already on the topic, however to keep it simple, here\'s my take.Sorted dictionary should be used when-On the other side, Sorted List should be used when-Hope this helps!!Index access (mentioned here) is the practical difference. \nIf you need to access the successor or predecessor, you need SortedList. SortedDictionary cannot do that so you are fairly limited with how you can use the sorting (first / foreach).