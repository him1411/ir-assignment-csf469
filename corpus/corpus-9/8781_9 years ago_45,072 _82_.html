I\'ve been a professional software engineer for about a year now, having graduated with a CS degree. I\'ve known about assertions for a while in C++ and C, but had no idea they existed in C# and .NET at all until recently.Our production code contains no asserts whatsoever and my question is this...Should I begin using Asserts in our production code? And if so, When is its use most appropriate? Would it make more sense to doorIn Debugging Microsoft .NET 2.0 Applications John Robbins has a big section on assertions. His main points are:PS: If you liked Code Complete, I recommend following it up with this book. I bought it to learn about using WinDBG and dump files, but the first half is packed with tips to help avoid bugs in the first place.Put Debug.Assert() everywhere in the code where you want have sanity checks to ensure invariants. When you compile a Release build (i.e., no DEBUG compiler constant), the calls to Debug.Assert() will be removed so they won\'t affect performance.You should still throw exceptions before calling Debug.Assert(). The assert just makes sure that everything is as expected while you\'re still developing.From Code CompleteAn assertion is code that\xe2\x80\x99s used during development\xe2\x80\x94usually a routine\n  or macro\xe2\x80\x94that allows a program to check itself as it runs. When an\n  assertion is true, that means everything is operating as expected.\n  When it\xe2\x80\x99s false, that means it has detected an unexpected error in the\n  code. For example, if the system assumes that a customer-information\n  file will never have more than 50,000 records, the program might\n  contain an assertion that the number of records is lessthan or equal\n  to 50,000. As long as the number of records is less than or equal to\n  50,000, the assertion will be silent. If it encounters more than\n  50,000 records, however, it will loudly \xe2\x80\x9cassert\xe2\x80\x9d that there is an\n  error in the program.  Assertions are especially useful in large, complicated programs and\n  in high reliability programs. They enable programmers to more quickly\n  flush out mismatched interface assumptions, errors that creep in when\n  code is modified, and so on. An assertion usually takes two arguments: a boolean expression that\n  describes the assumption that\xe2\x80\x99s supposed to be true and a message to\n  display if it isn\xe2\x80\x99t. (\xe2\x80\xa6) Normally, you don\xe2\x80\x99t want users to see assertion messages in\n  production code; assertions are primarily for use during development\n  and maintenance. Assertions are normally compiled into the code at\n  development time and compiled out of the code for production. During\n  development, assertions flush out contradictory assumptions,\n  unexpected conditions, bad values passed to routines, and so on.\n  During production, they are compiled out of the code so that the\n  assertions don\xe2\x80\x99t degrade system performance.Use asserts to check developer assumptions and exceptions to check environmental assumptions. FWIW ... I find that my public methods tend to use the if () { throw; } pattern to ensure that the method is being called correctly. My private methods tend to use Debug.Assert(). The idea is that with my private methods, I\'m the one under control, so if I start calling one of my own private methods with parameters that are incorrect, then I\'ve broken my own assumption somewhere--I should have never gotten into that state. In production, these private asserts should ideally be unnecessary work since I am supposed to be keeping my internal state valid and consistent. Contrast with parameters given to public methods, which could be called by anyone at runtime: I still need to enforce parameter constraints there by throwing exceptions.Additionally, my private methods can still throw exceptions if something doesn\'t work at runtime (network error, data access error, bad data retrieved from a third party service, etc.). My asserts are just there to make sure that I haven\'t broken my own internal assumptions about the state of the object.If I were you I would do:Or to avoid repeated condition checkAsserts are used to catch programmer (your) error, not user error.  They should be used only when there is no chance a user could cause the assert to fire.  If you\'re writing an API, for example, asserts should not be used to check that an argument is not null in any method an API user could call.  But it could be used in a private method not exposed as part of your API to assert that YOUR code never passes a null argument when it isn\'t supposed to.I usually favour exceptions over asserts when I\'m not sure.If you want Asserts in your production code (i.e. Release builds), you can use Trace.Assert instead of Debug.Assert.This of course adds overhead to your production executable.Also if your application is running in user-interface mode, the Assertion dialog will be displayed by default, which may be a bit disconcerting for your users.  You can override this behaviour by removing the DefaultTraceListener: look at the documentation for Trace.Listeners in MSDN.In summary,Use Debug.Assert liberally to help catch bugs in Debug builds.If you use Trace.Assert in user-interface mode, you probably want to remove the DefaultTraceListener to avoid disconcerting users.If the condition you\'re testing is something your app can\'t handle, you\'re probably better off throwing an exception, to ensure execution doesn\'t continue.  Be aware that a user can choose to ignore an assertion.Mostly never in my book.\nIn the vast majority of occasions if you want to check if everything is sane then throw if it isn\'t.What I dislike is the fact that it makes a debug build functionally different to a release build. If a debug assert fails but the functionality works in release then how does that make any sense? It\'s even better when the asserter has long left the company and no-one knows that part of the code. Then you have to kill some of your time exploring the issue to see if it is really a problem or not. If it is a problem then why isn\'t the person throwing in the first place? To me this suggests by using Debug.Asserts you\'re deferring the problem to someone else, deal with the problem yourself. If something is supposed to be the case and it isn\'t then throw. I guess there are possibly performance critical scenarios where you want to optimise away your asserts and they\'re useful there, however I am yet to encounter such a scenario.According to the IDesign Standard, you shouldAssert every assumption.  On average, every fifth line is an assertion.As a disclaimer I should mention I have not found it practical to implement this IRL.  But this is their standard.In Short Assertions have enormous benefit:... More DetailDebug.Assert expresses a condition which has been assumed about state by the remainder of the code block within the control of the program. This can include the state of the provided parameters, state of members of a class instance, or that the return from a method call is in its contracted / designed range. \nTypically, asserts should crash the thread / process / program with all necessary info (Stack Trace, Crash Dump, etc), as they indicate the presence of a bug or unconsidered condition which has not been designed for (i.e. do not try and catch or handle assertion failures), with one possible exception of when an assertion itself could cause more damage than the bug (e.g. Air Traffic Controllers wouldn\'t want a YSOD when an aircraft goes submarine, although it is moot whether a debug build should be deployed to production ...)When should you use Asserts?\n - At any point in a system, or library API, or service where the inputs to a function or state of a class are assumed valid (e.g. when there is validation done on user input in the presentation tier of a system, the business and data tier classes typically assume that null checks, range checks, string length checks etc on input have been already done).\n - Common Assert checks include where an invalid assumption would result in a null object dereference, a zero divisor, numerical or date arithmetic overflow, and general out of band / not designed for behaviour (e.g. Modelling a human\'s age as a 32 bit integer given the coarse grainedness of most type systems is likely assuming the age is actually between 0 and 125 or so)..Net Code Contracts\nIn the .Net Stack there Code Contracts which can be used in addition to, or as an alternative to using Debug.Assert. Code Contracts formalize these assumptions and can assist in detecting violations of assumptions at ~compile time (or shortly thereafter, if run as a background check in an IDE). This extends the number of DBC style checks beyond the run time Assert:Use assertions only in cases where you want the check removed for release builds.  Remember, your assertions will not fire if you don\'t compile in debug mode.Given your check-for-null example, if this is in an internal-only API, I might use an assertion.  If it\'s in a public API, I would definitely use the explicit check and throw.All asserts should be code that could be optimised to:Because it\'s checking something that you have already assumed is true. E.g.:In the above, there are three different approaches to null parameters. The first accepts it as allowable (it just does nothing). The second throws an exception for the calling code to handle (or not, resulting in an error message). The third assumes it can\'t possibly happen, and asserts that it is so.In the first case, there\'s no problem.In the second case, there\'s a problem with the calling code - it shouldn\'t have called GetFirstAndConsume with null, so it gets an exception back.In the third case, there\'s a problem with this code, because it should already have been checked that en != null before it was ever called, so that it isn\'t true is a bug. Or in other words, it should be code that could theoretically be optimised to Debug.Assert(true), sicne en != null should always be true!I thought I would add four more cases, where Debug.Assert can be the right choice.1) Something I have not seen mentioned here is the additional conceptual coverage Asserts can provide during automated testing. As a simple example:When some higher-level caller is modified by an author who believes they have expanded the scope of the code to handle additional scenarios, ideally (!) they will write unit tests to cover this new condition. It may then be that the fully integrated code appears to work fine.However, actually a subtle flaw has been introduced, but not detected in test results. The callee has become non-deterministic in this case, and only happens to provide the expected result. Or perhaps it has yielded a rounding error that was unnoticed. Or caused an error that was offset equally elsewhere. Or granted not only the access requested but additional privileges that should not be granted. Etc.At this point, the Debug.Assert() statements contained in the callee coupled with the new case (or edge case) driven in by unit tests can provide invaluable notification during test that the original author\'s assumptions have been invalidated, and the code should not be released without additional review. Asserts with unit tests are the perfect partners.2) Additionally, some tests are simple to write, but high-cost and unnecessary given the initial assumptions. For example:If an object can only be accessed from a certain secured entry point, should an additional query be made to a network rights database from every object method to ensure the caller has permissions? Surely not. Perhaps the ideal solution includes caching or some other expansion of features, but the design does not require it. A Debug.Assert() will immediately show when the object has been attached to an insecure entry point.3) Next, in some cases your product may have no helpful diagnostic interaction for all or part of its operations when deployed in release mode. For example:Suppose it is an embedded real-time device. Throwing exceptions and restarting when it encounters a malformed packet is counter-productive. Instead the device may benefit from best-effort operation, even to the point of rendering noise in its output. It also may not have a human interface, logging device, or even be physically accessible by human at all when deployed in release mode, and awareness of errors is best provided by assessing the same output. In this case, liberal Assertions and thorough pre-release testing are more valuable than exceptions.4) Lastly, some tests are unneccessary only because the callee is perceived as extremely reliable. In most cases, the more reusable code is, the more effort has been put into making it reliable. Therefore it is common to Exception for unexpected parameters from callers, but Assert for unexpected results from callees. For example:If a core String.Find operation states it will return a -1 when the search criteria is not found, you may be able to safely perform one operation rather than three. However, if it actually returned -2, you may have no reasonable course of action. It would be unhelpful to replace the simpler calculation with one that tests separately for a -1 value, and unreasonable in most release environments to litter your code with tests ensuring core libraries are operating as expected. In this case Asserts are ideal.Quote Taken from The Pragmatic Programmer: From Journeyman to MasterLeave Assertions Turned OnThere is a common misunderstanding about assertions, promulgated by\n  the people who write compilers and language environments. It goes\n  something like this:Assertions add some overhead to code. Because they check for things\n  that should never happen, they\'ll get triggered only by a bug in the\n  code. Once the code has been tested and shipped, they are no longer\n  needed, and should be turned off to make the code run faster.\n  Assertions are a debugging facility.There are two patently wrong assumptions here. First, they assume that\n  testing finds all the bugs. In reality, for any complex program you\n  are unlikely to test even a miniscule percentage of the permutations\n  your code will be put through (see Ruthless Testing).Second, the optimists are forgetting that your program runs in a\n  dangerous world. During testing, rats probably won\'t gnaw through a\n  communications cable, someone playing a game won\'t exhaust memory, and\n  log files won\'t fill the hard drive. These things might happen when\n  your program runs in a production environment. Your first line of\n  defense is checking for any possible error, and your second is using\n  assertions to try to detect those you\'ve missed.Turning off assertions when you deliver a program to production is\n  like crossing a high wire without a net because you once made it\n  across in practice. There\'s dramatic value, but it\'s hard to get life\n  insurance.Even if you  do have performance issues, turn off only those\n  assertions that really hit you.You should always use the second approach (throwing exceptions).Also if you\'re in production (and have a release-build), it\'s better to throw an exception (and let the app crash in the worst-case) than working with invalid values and maybe destroy your customer\'s data (which may cost thousand of dollars).You should use Debug.Assert to test for logical errors in your programs. The complier can only inform you of syntax errors. So you should definetely use Assert statements to test for logical errors. Like say testing a program that sells cars that only BMWs that are blue should get a 15% discount. The complier could tell you nothing about if your program is logically correct in performing this but an assert statement could.I\'ve read the answers here and I thought I should add an important distinction. There are two very different ways in which asserts are used. One  is as a temporary developer shortcut for "This shouldn\'t really happen so if it does let me know so I can decide what to do", sort of like a conditional breakpoint, for cases in which your program is able to continue. The other, is a as a way to put assumptions about valid program states in your code.In the first case, the assertions don\'t even need to be in the final code. You should use Debug.Assert during development and you can remove them if/when no longer needed. If you want to leave them or if you forget to remove them no problem, since they won\'t have any consequence in Release compilations.But in the second case, the assertions are part of the code. They, well, assert, that your assumptions are true, and also document them. In that case, you really want to leave them in the code. If the program is in an invalid state it should not be allowed to continue. If you couldn\'t afford the performance hit you wouldn\'t be using C#. On one hand it might be useful to be able to attach a debugger if it happens. On the other, you don\'t want the stack trace popping up on your users and perhaps more important you don\'t want them to be able to ignore it. Besides, if it\'s in a service it will always be ignored. Therefore in production the correct behavior would be to throw an Exception, and use the normal exception handling of your program, which might show the user a nice message and log the details.Trace.Assert has the perfect way to achieve this. It won\'t be removed in production, and can be configured with different listeners using app.config.\nSo for development the default handler is fine, and for production you can create a simple TraceListener like below which throws an exception and activate it in the production config file.And in the production config file:I don\'t know how it is in C# and .NET, but in C will assert() only work if compiled with -DDEBUG - the enduser will never see an assert() if it\'s compiled without. It\'s for developer only. I use it really often, it\'s sometimes easier to track bugs.I would not use them in production code. Throw exceptions, catch and log.Also need to be careful in asp.net, as an assert can show up on the console and freeze the request(s).