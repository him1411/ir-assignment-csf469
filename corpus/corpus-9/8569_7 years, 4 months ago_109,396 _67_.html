What\'s the reason Java doesn\'t allow us to doI could understand .NET didn\'t allow us to do that, as in .NET you have value types that at run-time can have different sizes, but in Java all kinds of T will be object references, thus having the same size (correct me if I\'m wrong).What is the reason?It\'s because Java\'s arrays (unlike generics) contain, at runtime, information about its component type. So you must know the component type when you create the array. Since you don\'t know what T is at runtime, you can\'t create the array.Quote:Arrays of generic types are not\n  allowed because they\'re not sound. The\n  problem is due to the interaction of\n  Java arrays, which are not statically\n  sound but are dynamically checked,\n  with generics, which are statically\n  sound and not dynamically checked.\n  Here is how you could exploit the\n  loophole:We had proposed to resolve this\n  problem using statically safe arrays\n  (aka Variance) bute that was rejected\n  for Tiger.-- gafter (I believe it is Neal Gafter, but am not sure)See it in context here: http://forums.sun.com/thread.jspa?threadID=457033&forumID=316By failing to provide a decent solution, you just end up with something worse IMHO.The common work around is as follows.is replaced with (assuming T extends Object and not another class)I prefer the first example, however more acedemic types seem to prefer the second, or just prefer not to thing about it.  Most of the examples of why you can\'t just use an Object[] equally apply to List or Collection (which are supported), so I see them as very poor arguments.Note: this is one of the reasons the Collections library itself doesn\'t compile without  warnings.  If you this usecase cannot be supported without warnings, something is fundermentally broken with the generics model IMHO.The reason this is impossible is that Java implements its Generics purely on the compiler level, and there is only one class file generated for each class.\nThis is called Type Erasure.At runtime, the compiled class needs to handle all of its uses with the same bytecode. So, new T[capacity] would have absolutely no idea what type needs to be instantiated.The answer was already given but if you already have an Instance of T then you can do this:Hope, I could Help,\nFerdi265Arrays Are CovariantArrays are said to be covariant which basically means that, given the subtyping rules of Java, an array of type T[] may contain elements of type T or any subtype of T. For instanceBut not only that, the subtyping rules of Java also state that an array S[] is a subtype of the array T[] if S is a subtype of T, therefore, something like this is also valid:Because according to the subtyping rules in Java, an array Integer[] is a subtype of an array Number[] because Integer is a subtype of Number.But this subtyping rule can lead to an interesting question: what would happen if we try to do this?This last line would compile just fine, but if we run this code, we would get an ArrayStoreException because we\xe2\x80\x99re trying to put a double into an integer array. The fact that we are accessing the array through a Number reference is irrelevant here, what matters is that the array is an array of integers.This means that we can fool the compiler, but we cannot fool the run-time type system. And this is so because arrays are what we call a reifiable type. This means that at run-time Java knows that this array was actually instantiated as an array of integers which simply happens to be accessed through a reference of type Number[].So, as we can see, one thing is the actual type of the object, an another thing is the type of the reference that we use to access it, right?The Problem with Java GenericsNow, the problem with generic types in Java is that the type information for type parameters is discarded by the compiler after the compilation of code is done; therefore this type information is not available at run time. This process is called type erasure. There are good reasons for implementing generics like this in Java, but that\xe2\x80\x99s a long story, and it has to do with binary compatibility with pre-existing code.The important point here is that since at run-time there is no type information, there is no way to ensure that we are not committing heap pollution.Let\xe2\x80\x99s consider now the following unsafe code:If the Java compiler does not stop us from doing this, the run-time type system cannot stop us either, because there is no way, at run time, to determine that this list was supposed to be a list of integers only. The Java run-time would let us put whatever we want into this list, when it should only contain integers, because when it was created, it was declared as a list of integers. That\xe2\x80\x99s why the compiler rejects line number 4 because it is unsafe and if allowed could break the assumptions of the type system.As such, the designers of Java made sure that we cannot fool the compiler. If we cannot fool the compiler (as we can do with arrays) then we cannot fool the run-time type system either.As such, we say that generic types are non-reifiable, since at run time we cannot determine the true nature of the generic type.I skipped some parts of this answers you can read full article here:\nhttps://dzone.com/articles/covariance-and-contravariance I like the answer indirectly given\nby Gafter.  However, I propose it is wrong.  I changed Gafter\'s code a little.  It compiles and it runs for a while then it bombs where Gafter predicted it wouldThe output isSo it appears to me you can create generic array types in java.  Did I misunderstand the question?The main reason is due to the fact that arrays in Java are covariant.There\'s a good overview here.In my case, I simply wanted an array of stacks, something like this:Since this was not possible, I used the following as a workaround:Ugly, but Java is happy.Note: as mentioned by BrainSlugs83 in the comment to the question, it is totally possible to have arrays of generics in .NETI know I\'m a little late to the party here, but I figured I might be able to help any future googlers since none of these answers fixed my issue.  Ferdi265\'s answer helped immensely though.I\'m trying to create my own Linked list, so the following code is what worked for me:In the toArray() method lies the way to create an array of a generic type for me:From Oracle tutorial:You cannot create arrays of parameterized types. For example, the following code does not compile:The following code illustrates what happens when different types are inserted into an array:If you try the same thing with a generic list, there would be a problem:If arrays of parameterized lists were allowed, the previous code would fail to throw the desired ArrayStoreException.To me, it sounds very weak. I think that anybody with a sufficient understanding of generics, would be perfectly fine, and even expect, that the ArrayStoredException is not thrown in such case.There surely must be a good way around it (maybe using reflection), because it seems to me that that\'s exactly what ArrayList.toArray(T[] a) does. I quote:public <T> T[] toArray(T[] a)Returns an array containing all of the\n  elements in this list in the correct order; the runtime type of the\n  returned array is that of the specified array. If the list fits in the\n  specified array, it is returned therein. Otherwise, a new array is\n  allocated with the runtime type of the specified array and the size of\n  this list.So one way around it would be to use this function i.e. create an ArrayList of the objects you want in the array, then use toArray(T[] a) to create the actual array. It wouldn\'t be speedy, but you didn\'t mention your requirements.So does anyone know how toArray(T[] a) is implemented?It is because generics were added on to java after they made it, so its kinda clunky because the original makers of java thought that when making an array the type would be specified in the making of it. So that does not work with generics so you have to do \nE[] array=(E[]) new Object[15];\nThis compiles but it gives a warning. If we cannot instantiate generic arrays, why does the language have generic array types? What\'s the point of having a type without objects?The only reason I can think of, is varargs - foo(T...). Otherwise they could have completely scrubbed generic array types. (Well, they didn\'t really have to use array for varargs, since varargs didn\'t exist before 1.5. That\'s probably another mistake.)So it is a lie, you can instantiate generic arrays, through varargs!Of course, the problems with generic arrays are still real, e.g.We can use this example to actually demonstrate the danger of generic array.On the other hand, we\'ve been using generic varargs for a decade, and the sky is not falling yet. So we can argue that the problems are being exaggerated; it is not a big deal. If explicit generic array creation is allowed, we\'ll have bugs here and there; but we\'ve been used to the problems of erasure, and we can live with it.And we can point to foo2 to refute the claim that the spec keeps us from the problems that they claim to keep us from. If Sun had more time and resources for 1.5, I believe they could have reached a more satisfying resolution.