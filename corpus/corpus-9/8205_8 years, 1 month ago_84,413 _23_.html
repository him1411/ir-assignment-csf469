Coming from a C and C++ background, I found judicious use of typedef to be incredibly helpful.  Do you know of a way to achieve similar functionality in Java, whether that be a Java mechanism, pattern, or some other effective way you have used?Java has primitive types, objects and arrays and that\'s it. No typedefs.If this is what you mean, you can simply extend the class you would like to typedef, e.g.:There is no typedef in java as of 1.6, what you can do is make a wrapper class for what you want  since you can\'t subclass final classes (Integer, Double, etc)Really, the only use of typedef that carries over to Javaland is aliasing- that is, giving the same class multiple names. That is, you\'ve got a class "A" and you want "B" to refer to the same thing. In C++, you\'d be doing "typedef B A;"Unfortunately, they just don\'t support it. However, if you control all the types involved you CAN pull a nasty hack at the library level- you either extend B from A or have B implement A.As others have mentioned before, \nThere is no typedef mechanism in Java. \nI also do not support "fake classes" in general, but there should not be a general strict rule of thumb here: \nIf your code for example uses over and over and over a "generic based type" for example: You should definitely consider having a subclass for that purpose. \nAnother approach one can consider, is for example to have in your code a deceleration like:And then use in your code NameToNumbers and have a pre compiler task (ANT/Gradle/Maven) to process and generate relevant java code. \nI know that to some of the readers of this answer this might sound strange, but this is how many frameworks implemented "annotations" prior to JDK 5, this is what project lombok is doing and other frameworks.In some cases, a binding annotation may be just what you\'re looking for:https://github.com/google/guice/wiki/BindingAnnotationsOr if you don\'t want to depend on Guice, just a regular annotation might do.Perhaps this could be another possible replace :As noted in other answers, you should avoid the pseudo-typedef antipattern.  However, typedefs are still useful even if that is not the way to achieve them.  You want to distinguish between different abstract types that have the same Java representation.  You don\'t want to mix up strings that are passwords with those that are street addresses, or integers that represent an offset with those with those that represent an absolute value.The Checker Framework enables you to define a typedef in a backward-compatible way.  I works even for primitive classes such as int and final classes such as String.  It has no run-time overhead and does not break equality tests.Section Type aliases and typedefs in the Checker Framework manual describes several ways to create typedefs, depending on your needs.You could use an Enum, although that\'s semantically a bit different than a typedef in that it only allows a restricted set of values. Another possible solution is a named wrapper class, e.g.but that seems way more clunky, especially given that it\'s not clear from the code that the class has no other function than as an alias. Typedef allows items to be implicitly assigned to types they are not. Some people try to get around this with extensions; read here at IBM for an explanation of why this is a bad idea.Edit: While strong type inference is a useful thing, I don\'t think (and hope we won\'t) see typedef rearing it\'s ugly head in managed languages (ever?).Edit 2: In C#, you can use a using statement like this at the top of a source file. It\'s used so you don\'t have to do the second item shown. The only time you see the name change is when a scope introduces a name collision between two types. The renaming is limited to one file, outside of which every variable/parameter type which used it is known by its full name.There is no need for typedef in Java. Everything is an Object except for the primitives. There are no pointers, only references. The scenarios where you normally would use typedefs are instances in which you create objects instead.