Example:You could use a regex.In your example that would be:I must say, though, maybe you could just downcase (or upcase) the value on the way in rather than incurring the extra cost every time you find it. Obviously this wont work for people\'s names and such, but maybe use-cases like tags.UPDATE:The original answer is now obsolete. Mongodb now supports advanced full text searching, with many features.ORIGINAL ANSWER:It should be noted that searching with regex\'s case insensitive /i means that mongodb cannot search by index, so queries against large datasets can take a long time.  Even with small datasets, it\'s not very efficient.  You take a far bigger cpu hit than your query warrants, which could become an issue if you are trying to achieve scale.As an alternative, you can store an uppercase copy and search against that.  For instance, I have a User table that has a username which is mixed case, but the id is an uppercase copy of the username.  This ensures case-sensitive duplication is impossible (having both "Foo" and "foo" will not be allowed), and I can search by id = username.toUpperCase() to get a case-insensitive search for username.If your field is large, such as a message body, duplicating data is probably not a good option.  I believe using an extraneous indexer like Apache Lucene is the best option in that case.Keep in mind that the previous example:will cause every entries containing bar to match the query ( bar1, barxyz, openbar ), it could be very dangerous for a username search on a auth function ...You may need to make it match only the search term by using the appropriate regexp syntax as:See http://www.regular-expressions.info/ for syntax help on regular expressionsIf you need to create the regexp from a variable, this is a much better way to do it: https://stackoverflow.com/a/10728069/309514You can then do something like:This has the benefit be being more programmatic or you can get a performance boost by compiling it ahead of time if you\'re reusing it a lot.Mongo (current version 2.0.0) doesn\'t allow case-insensitive searches against indexed fields - see their documentation.  For non-indexed fields, the regexes listed in the other answers should be fine.As of Mongodb 3.4 you should use a case-insensitive collation index.  This is the fastest way to do a case-insensitive search over datasets of increasingly large size.  I personally emailed one of the founders to please get this working, and he made it happen! (It was an issue on JIRA for like 5 years, and many have requested the feature).  Here\'s how it works:A case-insensitive index is made by specifying a collation with a strength of either 1 or 2.  You can create a case-insensitive index like this:Or you can do it for the whole collection by default when you create the database like so:And use it like this:This will return "New York", "new york", etc.Alternatively, you can make all indexes use a collation by default when you make the collection like this:The benefit to this method is much improved efficiency and speed on larger datasets.For more info: https://jira.mongodb.org/browse/SERVER-90 , https://docs.mongodb.com/manual/reference/collation/The best method is in your language of choice, when creating a model wrapper for your objects, have your save() method iterate through a set of fields that you will be searching on that are also indexed; those set of fields should have lowercase counterparts that are then used for searching.Every time the object is saved again, the lowercase properties are then checked and updated with any changes to the main properties. This will make it so you can search efficiently, but hide the extra work needed to update the lc fields each time.The lower case fields could be a key:value object store or just the field name with a prefixed lc_. I use the second one to simplify querying (deep object querying can be confusing at times). Note: you want to index the lc_ fields, not the main fields they are based off of. TL;DRDo not Use RegExpGo natural And use mongodb\'s inbuilt indexing , search Need to create index on whichever TEXT field you want to search , without indexing query will be extremely slow       One very important thing to keep in mind when using a Regex based query - When you are doing this for a login system, escape every single character you are searching for, and don\'t forget the ^ and $ operators. Lodash has a nice function for this, should you be using it already:Why? Imagine a user entering .* as his username. That would match all usernames, enabling a login by just guessing any user\'s password.Using Mongoose this worked for me:Suppose you want to search "column" in "Table" and you want case insenstive search. The best and efficient way is as below;Above code just adds your search value as RegEx and searches in with insensitve criteria set with "i" as option.All the best.The aggregation framework was introduced in mongodb 2.2 . You can use the string operator "$strcasecmp" to make a case-insensitive comparison between strings. It\'s more recommended and easier than using regex.Here\'s the official document on the aggregation command operator: https://docs.mongodb.com/manual/reference/operator/aggregation/strcasecmp/#exp._S_strcasecmp .I\'ve created a simple Func for the case insensitive regex, which I use in my filter.Then you simply filter on a field as follows.As you can see in mongo docs - since version 3.2 $text index is case-insensitive by default: https://docs.mongodb.com/manual/core/index-text/#text-index-case-insensitivity Create a text index and use $text operator in your query.These have been tested for string searchesUsing a filter works for me in C#.It may even use the index because I believe the methods are called after the return happens but I haven\'t tested this out yet.This also avoids a problem of that mongodb will think p.Title.ToLower() is a property and won\'t map properly.