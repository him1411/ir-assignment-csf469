I am learning C++ and I\'ve just started learning about some of Qt\'s capabilities to code GUI programs. I asked myself the following question:How does C++, which previously had no syntax capable of asking the OS for a window or a way to communicate through networks (with APIs which I don\'t completely understand either, I admit) suddenly get such capabilities through libraries written in C++ themselves? It all seems terribly circular to me. What C++ instructions could you possibly come up with in those libraries?I realize this question might seem trivial to an experienced software developer but I\'ve been researching for hours without finding any direct response. It\'s gotten to the point where I can\'t follow the tutorial about Qt because the existence of libraries is incomprehensible to me.A computer is like an onion, it has many many layers, from the inner core of pure hardware to the outermost application layer. Each layer exposes parts of itself to the next outer layer, so that the outer layer may use some of the inner layers functionality.In the case of e.g. Windows the operating system exposes the so-called WIN32 API for applications running on Windows. The Qt library uses that API to provide applications using Qt to its own API. You use Qt, Qt uses WIN32, WIN32 uses lower levels of the Windows operating system, and so on until it\'s electrical signals in the hardware.You\'re right that in general, libraries cannot make anything possible that isn\'t already possible.But the libraries don\'t have to be written in C++ in order to be usable by a C++ program. Even if they are written in C++, they may internally use other libraries not written in C++. So the fact that C++ didn\'t provide any way to do it doesn\'t prevent it from being added, so long as there is some way to do it outside of C++.At a quite low level, some functions called by C++ (or by C) will be written in assembly, and the assembly contains the required instructions to do whatever isn\'t possible (or isn\'t easy) in C++, for example to call a system function. At that point, that system call can do anything your computer is capable of, simply because there\'s nothing stopping it.C and C++ have 2 properties that allow all this extensibility that the OP is talking about.In the kernel or in a basic non-protected mode platform, peripherals like the serial port or disk drive are mapped into memory map in the same way as RAM is. Memory is a series of switches and flipping the switches of the peripheral gets you serial port or disk drive to do useful things. In a protected mode operating system, when one wants to access the kernel from userspace (say when writing to the file system or to draw a pixel on the screen) one needs to make a system call. C has not instruction to make a system call but C can call assembler code that can trigger the correct system call which allows one\'s C code to talk to the kernel.In order to make programming a particular platform easier, system calls are wrapped in more complex functions what may perform some useful function within one\'s own program. One is free to call the system calls directly (using assembler) but it is probably easier to just make use of one of the wrapper functions that the platform supplies.There is another level of API that are a lot more useful than a system call. Take for example malloc. Not only will this call the system to obtain large blocks of memory but will manage this memory by doing all the book keeping on what is take place.Win32 APIs wrap some graphic functionality with a common platform widget set. Qt takes this a bit further by wrapping the Win32 (or X Windows) API in a cross platform way.Fundamentally though a C compiler turns C code into machine code and since the computer is designed to use machine code, you should expect C to be able to accomplish the lions share or what a computer can do. All that the wrapper libraries do is do the heavy lifting for you so that you don\'t have to.Languages (like C++11) are specifications, on paper, usually written in English. Look inside the latest C++11 draft (or buy the costly final spec from your ISO vendor).You generally use a computer with some language implementation (You could in principle run a C++ program without any computer, e.g. using a bunch of human slaves interpreting it; that would be unethical and inefficient)Your C++ implementation general works above some operating system and communicate with it (using some implementation specific code, often in some system library). Generally that communication is done thru system calls. Look for instance into syscalls(2) for a list of system calls available on the Linux kernel.From the application point of view, a syscall is an elementary machine instruction like SYSENTER on x86-64 with some conventions (ABI)On my Linux desktop, the Qt libraries are above X11 client libraries communicating with the X11 server Xorg thru X Windows protocols.On Linux, use ldd on your executable to see the (long) list of dependencies on libraries. Use pmap on your running process to see which ones are "loaded" at runtime. BTW, on Linux, your application is probably using only free software, you could study its source code (from Qt, to Xlib, libc, ... the kernel) to understand more what is happeningI think the concept you are missing is system calls. Each operating system provides an enormous amount of resources and functionality that you can tap into to do low-level operating system related things. Even when you call a regular library function, it is probably making a system call behind the scenes.System calls are a low-level way of making use of the power of the operating system, but can be complex and cumbersome to use, so are often "wrapped" in APIs so that you don\'t have to deal with them directly. But underneath, just about anything you do that involves O/S related resources will use system calls, including printing, networking and sockets, etc.In the case of windows, Microsoft Windows has its GUI actually written into the kernel, so there are system calls for making windows, painting graphics, etc. In other operating systems, the GUI may not be a part of the kernel, in which case as far as I know there wouldn\'t be any system calls for GUI related things, and you could only work at an even lower level with whatever low-level graphics and input related calls are available.Good question. Every new C or C++ developer has this in mind. I am assuming a standard x86 machine for the rest of this post. If you are using Microsoft C++ compiler, open your notepad and type this (name the file Test.c)And now compile this file (using developer command prompt) cl Test.c /FaTest.asmNow open Test.asm in your notepad. What you see is the translated code - C/C++ is translated to assembler. Do you get the hint ?C/C++ programs are designed to run on the metal. Which means they have access to lower level hardware which makes it easier to exploit the capabilities of the hardware. Say, I am going to write a C library getch() on a x86 machine. Depending on the assembler I would type something this way :I run it over with an assembler and generate a .OBJ - Name it getch.obj.I then write a C program (I dont #include anything)Now name this file - GetChTest.c. Compile this file by passing getch.obj along. (Or compile individually to .obj and LINK GetChTest.Obj and getch.Obj together to produce GetChTest.exe).Run GetChTest.exe and you would find that it waits for the keyboard input.C/C++ programming is not just about language. To be a good C/C++ programmer you need to have a good understanding on the type of machine that it runs. You will need to know how the memory management is handled, how the registers are structured, etc., You may not need all these information for regular programming - but they would help you immensely. Apart from the basic hardware knowledge, it certainly helps if you understand how the compiler works (ie., how it translates) - which could enable you to tweak your code as necessary. It is an interesting package!Both languages support __asm keyword which means you could mix your assembly language code too. Learning C and C++ will make you a better rounded programmer overall.It is not necessary to always link with Assembler. I had mentioned it because I thought that would help you understand better. Mostly, most such library calls make use of system calls / APIs provided by the Operating System (the OS in turn does the hardware interaction stuff).How does C++ ... suddenly get such capabilities through libraries\n  written in C++ themselves ?There\'s nothing magical about using other libraries. Libraries are simple big bags of functions that you can call.Consider yourself writing a function like thisNow if you include that file you can write addExclamation(myVeryOwnString);. Now you might ask, "how did C++ suddenly get the capability to add exclamation points to a string?" The answer is easy: you wrote a function to do that then you called it.So to answer your question about how C++ can get capabilities to draw windows through libraries written in C++, the answer is the same. Someone else wrote function(s) to do that, and then compiled them and gave them to you in the form of a library.The other questions answer how the window drawing actually works, but you sounded confused about how libraries work so I wanted to address the most fundamental part of your question.The key is the possibility of the operating system to expose an API and a detailed description on how this API is to be used. The operating system offers a set of APIs with calling conventions. \nThe calling convention is defining the way a parameter is given into the API and how results are returned and how to execute the actual call.Operating systems and the compilers creating code for them play nicely together, so you usually have not to think about it, just use it. There is no need for a special syntax for creating windows. All that is required is that the OS provides an API to create windows. Such an API consists of simple function calls for which C++ does provide syntax.Furthermore C and C++ are so called systems programming languages and are able to access arbitrary pointers (which might be mapped to some device by the hardware). Additionally, it is also fairly simple to call functions defined in assembly, which allows the full range of operations the processor provides. Therefore it is possible to write an OS itself using C or C++ and a small amount of assembly. It should also be mentioned that Qt is a bad example, as it uses a so-called meta compiler to extend C++\' syntax. This is however not related to it\'s ability to call into the APIs provided by the OS to actually draw or create windows. First, there\'s a little misunderstading, I thinkHow does C++, which previously had no syntax capable of asking the OS for a window or a way to communicate through networksThere is no syntax for doing OS operations. It\'s the question of semantics. suddenly get such capabilities through libraries written in C++ themselves Well, the operating system is writen mostly in C. You can use shared libraries (so, dll) to call the external code. Additionally, the operating system code can register system routines on syscalls* or interrupts which you can call using assembly. That shared libraries often just make that system calls for you, so you are spared using inline assembly. Here\'s the nice tutorial on that: http://www.win.tue.nl/~aeb/linux/lk/lk-4.html\nIt\'s for Linux, but the principles are the same.How the operating system is doing operations on graphic cards, network cards etc? It\'s a very broad thema, but mostly you need to access interrupts, ports or write some data to special memory region. Since that operations are protected, you need to call them through the operating system anyway.In an attempt to provide a slightly different view to other answers, I shall answer like this. (Disclaimer: I am simplifying things slightly, the situation I give is purely hypothetical and is written as a means of demonstrating concepts rather than being 100% true to life).Think of things from the other perspective, imagine you\'ve just written a simple operating system with basic threading, windowing and memory management capabilities. You want to implement a C++ library to let users program in C++ and do things like make windows, draw onto windows etc. The question is, how to do this.Firstly, since C++ compiles to machine code, you need to define a way to use machine code to interface with C++. This is where functions come in, functions accept arguments and give return values, thus they provide a standard way of transferring data between different sections of code. They do this by establishing something known as a calling convention.A calling convention states where and how arguments should be placed in memory so that a function can find them when it gets executed. When a function gets called, the calling function places the arguments in memory and then asks the CPU to jump over to the other function, where it does what it does before jumping back to where it was called from. This means that the code being called can be absolutely anything and it will not change how the function is called. In this case however, the code behind the function would be relevant to the operating system and would operate on the operating system\'s internal state. So, many months later and you\'ve got all your OS functions sorted out. Your user can call functions to create windows and draw onto them, they can make threads and all sorts of wonderful things. Here\'s the problem though, your OS\'s functions are going to be different to Linux\'s functions or Windows\' functions. So you decide you need to give the user a standard interface so they can write portable code. Here is where QT comes in.As you almost certainly know, QT has loads of useful classes and functions for doing the sorts of things that operating systems do, but in a way that appears independent of the underlying operating system. The way this works is that QT provides classes and functions that are uniform in the way they appear to the user, but the code behind the functions is different for each operating system. For example QT\'s QApplication::closeAllWindows() would actually be calling each operating system\'s specialised window closing function depending on the version used. In Windows it would most likely call CloseWindow(hwnd) whereas on an os using the X Window System, it would potentially call XDestroyWindow(display,window).As is evident, an operating system has many layers, all of which have to interact through interfaces of many varieties. There are many aspects I haven\'t even touched on, but to explain them all would take a very long time. If you are further interested in the inner workings of operating systems, I recommend checking out the OS dev wiki.Bear in mind though that the reason many operating systems choose to expose interfaces to C/C++ is that they compile to machine code, they allow assembly instructions to be mixed in with their own code and they provide a great degree of freedom to the programmer. Again, there is a lot going on here. I would like to go on to explain how libraries like .so and .dll files do not have to be written in C/C++ and can be written in assembly or other languages, but I feel that if I add any more I might as well write an entire article, and as much as I\'d love to do that I don\'t have a site to host it on.When you try to draw something on the screen, your code calls some other piece of code which calls some other code (etc.) until finally there is a "system call", which is a special instruction that the CPU can execute. These instructions can be either written in assembly or can be written in C++ if the compiler supports their "intrinsics" (which are functions that the compiler handles "specially" by converting them into special code that the CPU can understand). Their job is to tell the operating system to do something.When a system call happens, a function gets called that calls another function (etc.) until finally the display driver is told to draw something on the screen. At that point, the display driver looks at a particular region in physical memory which is actually not memory, but rather an address range that can be written to as if it were memory. Instead, however, writing to that address range causes the graphics hardware to intercept the memory write, and draw something on the screen.\nWriting to this region of memory is something that could be coded in C++, since on the software side it\'s just a regular memory access. It\'s just that the hardware handles it differently.\nSo that\'s a really basic explanation of how it can work.Your C++ program is using Qt library (also coded in C++). The Qt library will be using Windows CreateWindowEx function (which was coded in C inside kernel32.dll). Or under Linux it may be using Xlib (also coded in C), but it could as well be sending the raw bytes that in X protocol mean "Please create a window for me".Related to your catch-22 question is the historical note that \xe2\x80\x9cthe first C++ compiler was written in C++\xe2\x80\x9d, although actually it was a C compiler with a few C++ notions, enough so it could compile the first version, which could then compile itself.Similarly, the GCC compiler uses GCC extensions: it is first compiled to a version then used to recompile itself. (GCC build instructions)How i see the question this is actually a compiler question. Look at it this way, you write a piece of code in Assembly(you can do it in any language) which translates your newly written language you want to call Z++ into Assembly, for simplicity lets call it a compiler (it is a compiler).Now you give this compiler some basic functions, so that you can write int, string, arrays etc. actually you give it enough abilities so that you can write the compiler itself in Z++. and now you have a compiler for Z++ written in Z++, pretty neat right. Whats even cooler is that now you can add abilities to that compiler using the abilities it already has, thus expanding the Z++ language with new features by using the previous featuresAn example, if you write enough code to draw a pixel in any color, then you can expand it using the Z++ to draw anything you want.The hardware is what allows this to happen. You can think of the graphics memory as a large array (consisting of every pixel on the screen). To draw to the screen you can write to this memory using C++ or any language that allows direct access to that memory. That memory just happens to be accessible by or located on the graphics card.On modern systems accessing the graphics memory directly would require writing a driver because of various restrictions so you use indirect means. Libraries that create a window (really just an image like any other image) and then write that image to the graphics memory which the GPU then displays on screen. Nothing has to be added to the language except the ability to write to specific memory locations, which is what pointers are for.