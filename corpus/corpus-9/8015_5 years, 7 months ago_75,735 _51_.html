I\'m trying to use storyboards in an app I\'m working on. In the app there are Lists and Users and each contains a collection of the other (members of a list, lists owned by a user). So, accordingly, I have ListCell and UserCell classes. The goal is to have those be re-usable throughout the app (ie, in any of my tableview controllers). That\'s where I\'m running into a problem. How do I create a custom tableview cell in the storyboard that can be re-used in any view controller? Here are the specific things I\'ve tried so far.In Controller #1, added a prototype cell, set the class to my UITableViewCell subclass, set the reuse id, added the labels and wired them to the class\'s outlets. In Controller #2, added an empty prototype cell, set it to the same class and reuse id as before. When it runs, the labels never appear when the cells are shown in Controller #2. Works fine in Controller #1.Designed each cell type in a different NIB and wired up to the appropriate cell class. In storyboard, added an empty prototype cell and set its class and reuse id to refer to my cell class. In controllers\' viewDidLoad methods, registered those NIB files for the reuse id. When shown, cells in both controllers were empty like the prototype.Kept prototypes in both controllers empty and set class and reuse id to my cell class. Constructed the cells\' UI entirely in code. Cells work perfectly in all controllers.In the second case I suspect that the prototype is always overriding the NIB and if I killed the prototype cells, registering my NIB for the reuse id would work. But then I wouldn\'t be able to setup segues from the cells to other frames, which is really the whole point of using storyboards.At the end of the day, I want two things: wire up tableview based flows in the storyboard and define cell layouts visually rather than in code. I can\'t see how to get both of those so far.As I understand it, you want to:Unfortunately, there is currently no way to do this. To understand why your previous attempts didn\'t work, you need to understand more about how storyboards and prototype table view cells work. (If you don\'t care about why these other attempts didn\'t work, feel free to leave now. I\'ve got no magical workarounds for you, other than suggesting that you file a bug.)A storyboard is, in essence, not much more than a collection of .xib files. When you load up a table view controller that has some prototype cells out of a storyboard, here\'s what happens:When you request a cell with a given reuse identifier, it checks whether it has a nib registered. If it does, it instantiates an instance of that cell. This is composed of the following steps:You configure your cell however you want.The important thing to note here is there is a distinction between the class of the cell and the visual appearance of the cell. You could create two separate prototype cells of the same class, but with their subviews laid out completely differently. In fact, if you use the default UITableViewCell styles, this is exactly what\'s happening. The "Default" style and the "Subtitle" style, for example, are both represented by the same UITableViewCell class.This is important: The class of the cell does not have a one-to-one correlation with a particular view hierarchy. The view hierarchy is determined entirely by what\'s in the prototype cell that was registered with this particular controller.Note, as well, that the cell\'s reuse identifier was not registered in some global cell dispensary. The reuse identifier is only used within the context of a single UITableView instance.Given this information, let\'s look at what happened in your above attempts.In Controller #1, added a prototype cell, set the class to my\n  UITableViewCell subclass, set the reuse id, added the labels and wired\n  them to the class\'s outlets. In Controller #2, added an empty\n  prototype cell, set it to the same class and reuse id as before. When\n  it runs, the labels never appear when the cells are shown in\n  Controller #2. Works fine in Controller #1.This is expected. While both cells had the same class, the view hierarchy that was passed to the cell in Controller #2 was entirely devoid of subviews. So you got an empty cell, which is exactly what you put in the prototype.Designed each cell type in a different NIB and wired up to the\n  appropriate cell class. In storyboard, added an empty prototype cell\n  and set its class and reuse id to refer to my cell class. In\n  controllers\' viewDidLoad methods, registered those NIB files for the\n  reuse id. When shown, cells in both controllers were empty like the\n  prototype.Again, this is expected. The reuse identifier is not shared between storyboard scenes or nibs, so the fact that all of these distinct cells had the same reuse identifier was meaningless. The cell you get back from the tableview will have an appearance that matches the prototype cell in that scene of the storyboard.This solution was close, though. As you noted, you could just programmatically call -[UITableView registerNib:forCellReuseIdentifier:], passing the UINib containing the cell, and you\'d get back that same cell. (This isn\'t because the prototype was "overriding" the nib; you simply hadn\'t registered the nib with the tableview, so it was still looking at the nib embedded in the storyboard.) Unfortunately, there\'s a flaw with this approach \xe2\x80\x94 there\'s no way to hook up storyboard segues to a cell in a standalone nib.Kept prototypes in both controllers empty and set class and reuse id\n  to my cell class. Constructed the cells\' UI entirely in code. Cells\n  work perfectly in all controllers.Naturally. Hopefully, this is unsurprising.So, that\'s why it didn\'t work. You can design your cells in standalone nibs and use them in multiple storyboard scenes; you just can\'t currently hook up storyboard segues to those cells. Hopefully, though, you\'ve learned something in the process of reading this.In spite of the great answer by BJ Homer I feel like I have a solution. As far as my testing goes, it works.Concept: Create a custom class for the xib cell. There you can wait for a touch event and perform the segue programmatically. Now all we need is a reference to the controller performing the Segue. My solution is to set it in tableView:cellForRowAtIndexPath:.I have a DetailedTaskCell.xib containing a table cell which I\'d like to use in multiple table views:There is a custom class TaskGuessTableCell for that cell:This is where the magic happens.I have multiple Segues but they all have the same name: "FinishedTask". If you need to be flexible here, I suggest to add another property.The ViewController looks like this:There might be more elegant ways to achieve the same but - it works! :)I was looking for this and I found this answer by Richard Venable. It works for me.iOS 5 includes a new method on UITableView: registerNib:forCellReuseIdentifier:To use it, put a UITableViewCell in a nib. It has to be the only root\n  object in the nib.You can register the nib after loading your tableView, then when you\n  call dequeueReusableCellWithIdentifier: with the cell identifier, it\n  will pull it from the nib, just like if you had used a Storyboard\n  prototype cell.BJ Homer has given an excellent explanation of what is going on. From a practical standpoint I\'d add that, given you can\'t have cells as xibs AND connect segues, the best one to choose is having the cell as a xib - transitions are far easier to maintain than cell layouts and properties across multiple places, and your segues are likely to be different from your different controllers anyway. You can define the segue directly from your table view controller to the next controller, and perform it in code. .  A further note is that having your cell as a separate xib file prevents you being able to connect any actions etc. directly to the table view controller (I haven\'t worked this out, anyway - you can\'t define file\'s owner as anything meaningful). I am working around this by defining a protocol that the cell\'s table view controller is expected to conform to and adding the controller as a weak property, similar to a delegate, in cellForRowAtIndexPath. Swift 3BJ Homer gave an excellent explanation, It helps me understand the concept. To make a custom cell reusable in storyboard, which can be used in any TableViewController we have to mix the Storyboard and xib approach. Suppose we have a cell named as CustomCell which is to be used in the TableViewControllerOne and TableViewControllerTwo. I am making it in steps.\n1. File > New > Click File > Select Cocoa Touch Class > click Next > Give Name Of your class(for example CustomCell) > select Subclass as UITableVieCell > Tick the also create XIB file checkbox and press Next.\n2. Customize the cell as you want and set the identifier in attribute inspector for cell, here we ll set as CellIdentifier. This identifier will be used in your ViewController to identify and reuse the Cell.\n3. Now we just have to register this cell in our ViewController viewDidLoad. No need of any initialization method.\n4. Now we can use this custom cell in any tableView.  In TableViewControllerOne I found a way to load the cell for the same VC, not tested for the segues. This could be a workaround for creating the cell in a separate nibLet\'s say that you have one VC and 2 tables and you want to design a cell in storyboard and use it in both tables.(ex: a table and a search field with a UISearchController with a table for results and you want to use the same Cell in both)When the controller asks for the cell do this:And here you have your cell from the storyboard