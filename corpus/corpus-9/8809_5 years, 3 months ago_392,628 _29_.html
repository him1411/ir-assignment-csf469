I need a solution to properly stop the thread in Java.I have IndexProcessorclass which implements the Runnable interface:And I have ServletContextListener class which starts and stops the thread:But when I shutdown tomcat, I get the exception in my IndexProcessor class:I am using JDK 1.6. So the question is:How can I stop the thread and not throw any exceptions? P.S. I do not want to use .stop(); method because it is deprecated.In the IndexProcessor class you need a way of setting a flag which informs the thread that it will need to terminate, similar to the variable run that you have used just in the class scope.When you wish to stop the thread, you set this flag and call join() on the thread and wait for it to finish.Make sure that the flag is thread safe by using a volatile variable or by using getter and setter methods which are synchronised with the variable being used as the flag.Then in SearchEngineContextListener:Using Thread.interrupt() is a perfectly acceptable way of doing this. In fact, it\'s probably preferrable to a flag as suggested above.  The reason being that if you\'re in an interruptable blocking call (like Thread.sleep or using java.nio Channel operations), you\'ll actually be able to break out of those right away.If you use a flag, you have to wait for the blocking operation to finish and then you can check your flag.  In some cases you have to do this anyway, such as using standard InputStream/OutputStream which are not interruptable.In that case, when a thread is interrupted, it will not interrupt the IO, however, you can easily do this routinely in your code (and you should do this at strategic points where you can safely stop and cleanup)Like I said, the main advantage to Thread.interrupt() is that you can immediately break out of interruptable calls, which you can\'t do with the flag approach.Simple answer:\nYou can stop a thread INTERNALLY in one of two common ways:You can also stop threads EXTERNALLY:*: The expectation is that this is supposed to stop a thread.  However, what the thread actually does when this happens is entirely up to what the developer wrote when they created the thread implementation.A common pattern you see with run method implementations is a while(boolean){}, where the boolean is typically something named isRunning, it\'s a member variable of its thread class, it\'s volatile, and typically accessible by other threads by a setter method of sorts, e.g. kill() { isRunnable=false; }. These subroutines are nice because they allow the thread to release any resources it holds before terminating.You should always end threads by checking a flag in the run() loop (if any).Your thread should look like this:Then you can end the thread by calling thread.stopExecuting(). That way the thread is ended clean, but this takes up to 15 seconds (due to your sleep).\nYou can still call thread.interrupt() if it\'s really urgent - but the prefered way should always be checking the flag.To avoid waiting for 15 seconds, you can split up the sleep like this:For synchronizing threads I prefer using CountDownLatch which helps threads to wait until the process being performed complete. In this case, the worker class is set up with a CountDownLatch instance with a given count. A call to await method will block until the current count reaches zero due to invocations of the countDown method or the timeout set is reached. This approach allows interrupting a thread instantly without having to wait for the specified waiting time to elapse:When you want to finish execution of the other thread, execute countDown on the CountDownLatch and join the thread to the main thread:Some supplementary info.\nBoth flag and interrupt are suggested in the Java doc. https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.htmlFor a thread that waits for long periods (e.g., for input), use Thread.interrupt I didn\'t get the interrupt to work in Android, so I used this method, works perfectly: