Preface: I\'m looking for an explanation, not just a solution. I already know the solution.Despite having spent several days studying MSDN articles about the Task-based Asynchronous Pattern (TAP), async and await, I\'m still a bit confused about some of the finer details.I\'m writing a logger for Windows Store Apps, and I want to support both asynchronous and synchronous logging. The asynchronous methods follow the TAP, the synchronous ones should hide all this, and look and work like ordinary methods.This is the core method of asynchronous logging:Now the corresponding synchronous method...Version 1:This looks correct, but it does not work. The whole program freezes forever.Version 2:Hmm.. Maybe the task was not started?This throws InvalidOperationException: Start may not be called on a promise-style task.Version 3:Hmm.. Task.RunSynchronously sounds promising.This throws InvalidOperationException: RunSynchronously may not be called on a task not bound to a delegate, such as the task returned from an asynchronous method.Version 4 (the solution):This works. So, 2 and 3 are the wrong tools. But 1? What\'s wrong with 1 and what\'s the difference to 4? What makes 1 cause a freeze? Is there some problem with the task object? Is there a non-obvious deadlock?Please help me understand.The await inside your asynchronous method is trying to come back to the UI thread.Since the UI thread is busy waiting for the entire task to complete, you have a deadlock.Moving the async call to Task.Run() solves the issue.\nBecause the async call is now running on a thread pool thread, it doesn\'t try to come back to the UI thread, and everything therefore works.Alternatively, you could call StartAsTask().ConfigureAwait(false) before awaiting the inner operation to make it come back to the thread pool rather than the UI thread, avoiding the deadlock entirely.  See http://ermau.com/avoiding-callbacks-to-the-ui-thread-with-async-and-winrt/Calling async code from synchronous code can be quite tricky.I explain the full reasons for this deadlock on my blog. In short, there\'s a "context" that is saved by default at the beginning of each await and used to resume the method.So if this is called in an UI context, when the await completes, the async method tries to re-enter that context to continue executing. Unfortunately, code using Wait (or Result) will block a thread in that context, so the async method cannot complete.The guidelines to avoid this are:If your method is naturally asynchronous, then you (probably) shouldn\'t expose a synchronous wrapper.Here is what I didworking great and not blocking UI threadWith small custom synchronization context, sync function can wait for completion of async function, without creating deadlock. Here is small example for WinForms app. 