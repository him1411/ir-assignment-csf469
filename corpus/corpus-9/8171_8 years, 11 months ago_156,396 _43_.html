Are there any dictionary classes in the .NET base class library which allow duplicate keys to be used?  The only solution I\'ve found is to create, for example, a class like:But this is quite irritating to actually use.  In Java, I believe a MultiMap accomplishes this, but cannot find an analog in .NET.If you\'re using .NET 3.5, use the Lookup class.EDIT: You generally create a Lookup using Enumerable.ToLookup. This does assume that you don\'t need to change it afterwards - but I typically find that\'s good enough.If that doesn\'t work for you, I don\'t think there\'s anything in the framework which will help - and using the dictionary is as good as it gets :(The List class actually works quite well for key/value collections containing duplicates where you would like to iterate over the collection.  Example:Here is one way of doing this with List< KeyValuePair< string, string > >Outputs k1=v1, k1=v2, k1=v3If you are using strings as both the keys and the values, you can use System.Collections.Specialized.NameValueCollection, which will return an array of string values via the GetValues(string key) method.I just came across the PowerCollections library which includes, among other things, a class called MultiDictionary.  This neatly wraps this type of functionality.Very important note regarding use of Lookup:You can create an instance of a Lookup(TKey, TElement) by calling ToLookup on an object that implements IEnumerable(T)There is no public constructor to create a new instance of a Lookup(TKey, TElement). Additionally, Lookup(TKey, TElement) objects are immutable, that is, you cannot add or remove elements or keys from a Lookup(TKey, TElement) object after it has been created.(from MSDN)I\'d think this would be a show stopper for most uses.I think something like List<KeyValuePair<object, object>> would do the Job.If you are using >= .NET 4  then you can use Tuple Class:Have a look at C5\'s HashBag class.In answer to the original question.  Something like Dictionary<string, List<object>> is implemented in a class called MultiMap in The Code Project.You could find more info to the below link : \nhttp://www.codeproject.com/KB/cs/MultiKeyDictionary.aspxThe NameValueCollection supports multiple string values under one key (which is also a string), but it is the only example I am aware of.I tend to create constructs similar to the one in your example when I run into situations where I need that sort of functionality.  When using the List<KeyValuePair<string, object>> option, you could use LINQ to do the search:\nIt\'s easy enough to "roll your own" version of a dictionary that allows "duplicate key" entries. Here is a rough simple implementation. You might want to consider adding support for basically most (if not all) on IDictionary<T>.A quick example on how to use it:Do you mean congruent and not an actual duplicate? Otherwise a hashtable wouldn\'t be able to work.Congruent means that two separate keys can hash to the equivalent value, but the keys aren\'t equal.For example: say your hashtable\'s hash function was just hashval = key mod 3. Both 1 and 4 map to 1, but are different values. This is where your idea of a list comes into play.When you need to lookup 1, that value is hashed to 1, the list is traversed until the Key  = 1 is found.If you allowed for duplicate keys to be inserted, you wouldn\'t be able to differentiate which keys map to which values.I stumbled across this post in search of the same answer, and found none, so I rigged up a bare-bones example solution using a list of dictionaries, overriding the [] operator to add a new dictionary to the list when all others have a given key(set), and return a list of values (get).\nIt\'s ugly and inefficient, it ONLY gets/sets by key, and it always returns a list, but it works:The way I use is just aDictionary<string, List<string>>This way you have a single key holding a list of strings.Example:U can define a method to building a Compound string key\nevery where u want to using dictionary u must using this method to build your key\nfor example:for using:Duplicate keys break the entire contract of the Dictionary. In a dictionary each key is unique and mapped to a single value. If you want to link an object to an arbitrary number of additional objects, the best bet might be something akin to a DataSet (in common parlance a table). Put your keys in one column and your values in the other. This is significantly slower than a dictionary, but that\'s your tradeoff for losing the ability to hash the key objects. Also this is possible:This way, we can have unique keys. Hope this works for you.You can add same keys with different case like:key1\nKey1\nKEY1\nKeY1\nkEy1\nkeY1I know is dummy answer, but worked for me.