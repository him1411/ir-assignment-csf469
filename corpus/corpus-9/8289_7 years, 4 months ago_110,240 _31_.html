When I use Response.Redirect(...) to redirect my form to a new page I get the error:A first chance exception of type \'System.Threading.ThreadAbortException\' occurred in mscorlib.dll\n      An exception of type \'System.Threading.ThreadAbortException\' occurred in mscorlib.dll but was not handled in user codeMy understanding of this is that the error is being caused by the webserver aborting the remainder of the page the response.redirect was called on.I know I can add a second parameter to Response.Redirect that is called endResponse.  If I set endResponse to True I still get the error but if I set it to False then I do not.  I am pretty sure though that that means the webserver is running the rest of the page I redirected away from.  Which would seem to be inefficient to say the least.  Is there a better way to do this?  Something other than Response.Redirect or is there a way to force the old page to stop loading where I will not get a ThreadAbortException?  The correct pattern is to call the Redirect overload with endResponse=false and make a call to tell the IIS pipeline that it should advance directly to the EndRequest stage once you return control:This blog post from Thomas Marquardt provides additional details, including how to handle the special case of redirecting inside an Application_Error handler.There is no simple and elegant solution to the Redirect problem in ASP.Net WebForms. You can choose between the Dirty solution and the Tedious solutionDirty: Response.Redirect(url) sends a redirect to the browser, and then throws a ThreadAbortedException to terminate the current thread. So no code is executed past the Redirect()-call. Downsides: It is bad practice and have performance implications to kill threads like this. Also, ThreadAbortedExceptions will show up in exception logging.Tedious: The recommended way is to call Response.Redirect(url, false) and then Context.ApplicationInstance.CompleteRequest() However, code execution will continue and the rest of the event handlers in the page lifecycle will still be executed. (E.g. if you perform the redirect in Page_Load, not only will the rest of the handler be executed, Page_PreRender and so on will also still be called - the rendered page will just not be sent to the browser. You can avoid the extra processing by e.g. setting a flag on the page, and then let subsequent event handlers check this flag before before doing any processing.(The documentation to CompleteRequest states that it "Causes ASP.NET to bypass all events and filtering in the HTTP pipeline chain of execution". This can easily be misunderstood. It does bypass further HTTP filters and modules, but it doesn\'t bypass further events in the  current page lifecycle.)The deeper problem is that WebForms lacks a level of abstraction. When you are in a event handler, you are already in the process of building a page to output. Redirecting in an event handler is ugly because you are terminating a partially generated page in order to generate a different page. MVC does not have this problem since the control flow is separate from rendering views, so you can do a clean redirect by simply returning a RedirectAction in the controller, without generating a view.I know I\'m late, but I\'ve only ever had this error if my Response.Redirect is in a Try...Catch block.Never put a Response.Redirect into a Try...Catch block. It\'s bad practiceIn response to @Kiquenet\'s comment, here\'s what I would do as an alternative to putting the Response.Redirect into the Try...Catch block.I\'d break up the method/function into two steps.Step one inside the Try...Catch block performs the requested actions and sets a "result" value to indicate success or failure of the actions.Step two outside of the Try...Catch block does the redirect (or doesn\'t) depending on what the "result" value is.This code is far from perfect and probably should not be copied since I haven\'t tested itResponse.Redirect() throws an exception to abort the current request.This KB article describes this behavior (also for the Request.End() and Server.Transfer() methods).For Response.Redirect() there exists an overload:If you pass endResponse=false, then the exception is not thrown (but the runtime will continue processing the current request).If endResponse=true (or if the other overload is used), the exception is thrown and the current request will immediately be terminated.This is just how Response.Redirect(url, true)  works. It throws the ThreadAbortException to abort the thread. Just ignore that exception. (I presume it is some global error handler/logger where you see it?)An interesting related discussion Is Response.End() considered harmful?Here\'s the official line on the problem (I couldn\'t find the latest, but I don\'t think the situation has changed for later versions of .net)What I do is catch this exception, together with another posible exceptions. Hope this help someone.Also I tried other solution, but some of the code executed after redirect.So if need to prevent code execution  after redirect i even tryed to avoid this, just in case doing the Abort on the thread manually, but i rather leave it with the "CompleteRequest" and move on - my code has return commands after redirects anyway. So this can be doneI had that problem too.\nTry using Server.Transfer instead of Response.Redirect\nWorked for me