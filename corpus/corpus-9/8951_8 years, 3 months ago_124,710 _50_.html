How can I retrieve the item that is selected in a WPF-treeview? I want to do this in XAML, because I want to bind it.You might think that it is SelectedItem but apparently that does not exist is readonly and therefore unusable.This is what I want to do:I want to bind the SelectedItem to a property on my Model.But this gives me the error:\'SelectedItem\' property is read-only and cannot be set from markup.Edit:\nOk, this is the way that I solved this:and in the codebehindfile of my xaml:This property exists : TreeView.SelectedItemBut it is readonly, so you cannot assign it through a binding, only retrieve itI realise this has already had an answer accepted, but I put this together to solve the problem.  It uses a similar idea to Delta\'s solution, but without the need to subclass the TreeView:You can then use this in your XAML as:Hopefully it will help someone!Well, I found a solution. It moves the mess, so that MVVM works.First add this class:and add this to your xaml:Answer with attached properties and no external dependencies, should the need ever arise!You can create an attached property that is bindable and has a getter and setter:Add the namespace declaration containing that class to your XAML and bind as follows (local is how I named the namespace declaration):Now you can bind the selected item, and also set it in your view model to change it programmatically, should that requirement ever arise. This is, of course, assuming that you implement INotifyPropertyChanged on that particular property.This can be accomplished in a \'nicer\' way using only binding and the GalaSoft MVVM Light library\'s EventToCommand. In your VM add a command which will be called when the selected item is changed, and initialize the command to perform whatever action is necessary. In this example I used a RelayCommand and will just set the SelectedCluster property.Then add the EventToCommand behavior in your xaml. This is really easy using blend.All to complicated...  Go with Caliburn Micro (http://caliburnmicro.codeplex.com/)View:ViewModel:It answers a little more than the OP is expecting... But I hope it could help some one at least.If you want to execute a ICommand whenever the SelectedItem changed, you can bind a command on an event and the use of a property SelectedItem in the ViewModel isn\'t needed anymore.To do so:1- Add reference to System.Windows.Interactivity2- Bind the command to the event SelectedItemChangedYou might also be able to use TreeViewItem.IsSelected propertyI came across this page looking for the same answer as the original author, and proving there\'s always more than one way to do it, the solution for me was even easier than the answers provided here so far, so I figured I might as well add to the pile.The motivation for the binding is to keep it nice & MVVM. The probable usage of the ViewModel is to have a property w/ a name such as "CurrentThingy", and somewhere else, the DataContext on some other thing is bound to "CurrentThingy".Rather than going through additional steps required (eg: custom behavior, 3rd party control) to support a nice binding from the TreeView to my Model, and then from something else to my Model, my solution was to use simple Element binding the other thing to TreeView.SelectedItem, rather than binding the other thing to my ViewModel, thereby skipping the extra work required.XAML:Of course, this is great for reading the currently selected item, but not setting it, which is all I needed. There is also a way to create XAML bindable SelectedItem property without using Interaction.Behaviors.You can then use this in your XAML as:I suggest an addition to the behavior provided by Steve Greatrex. His behavior doesn\'t reflects changes from the source because it may not be a collection of TreeViewItems. \nSo it is a matter of finding the TreeViewItem in the tree which datacontext is the selectedValue from the source.\nThe TreeView has a protected property called "ItemsHost", which holds the TreeViewItem collection. We can get it through reflection and walk the tree searching for the selected item. This way the behavior works for two-way bindings. Alternatively, it is possible to move the ItemsHost acquisition to the Behavior\'s OnAttached method, saving the overhead of using reflection every time the binding updates. I tried all solutions of this questions. No one solved my problem fully. So I think it\'s better to use such inherited class with redefined property SelectedItem. It will work perfectly if you choose tree element from GUI and if you set this property value in your codeWPF MVVM TreeView SelectedItem... is a better answer, but does not mention a way to get/set the SelectedItem in the ViewModel. My requirement was for PRISM-MVVM based solution where a TreeView was needed and the bound object is of type Collection<> and hence needs HierarchicalDataTemplate. The default BindableSelectedItemBehavior wont be able to identify the child TreeViewItem. To make it to work in this scenario.This enables to iterate through all the elements irrespective of the level.After studying the Internet for a day I found my own solution for selecting an item after create a normal treeview in a normal WPF/C# environmentIt can also be done using the IsSelected property of the TreeView item. Here\'s how I managed it,Then in the ViewModel that contains the data your TreeView is bound to, just subscribe to the event in the TreeViewItem class.And finally, implement this handler in the same ViewModel,And the binding of course,