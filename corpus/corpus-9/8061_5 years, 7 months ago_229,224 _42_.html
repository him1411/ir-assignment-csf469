I just read some recommendations on using instead of I\'m almost always using the last one because I\'m used to it and it feels natural, more readable. I didn\'t even know that there was a separate comparison function.\nTo be more precise, I thought == would call compare().What are the differences? In which contexts should one way be favored to the other?I\'m considering only the cases where I need to know if a string is the same value as another string.This is what the standard has to say about operator==21.4.8.2 operator==Returns: lhs.compare(rhs) == 0.Seems like there isn\'t much of a difference!std::string::compare() returns an int:If you want your first code snippet to be equivalent to the second one, it should actually read:The equality operator only tests for equality (hence its name) and returns a bool.To elaborate on the use cases, compare() can be useful if you\'re interested in how the two strings relate to one another (less or greater) when they happen to be different. PlasmaHH rightfully mentions trees, and it could also be, say, a string insertion algorithm that aims to keep the container sorted, a dichotomic search algorithm for the aforementioned container, and so on.EDIT: As Steve Jessop points out in the comments, compare() is most useful for quick sort and binary search algorithms. Natural sorts and dichotomic searches can be implemented with only std::less.compare has overloads for comparing substrings. If you\'re comparing whole strings you should just use == operator (and whether it calls compare or not is pretty much irrelevant).Internally, string::operator==() is using string::compare(). Please refer to: CPlusPlus - String::Operator==() I wrote a small application to compare the performance, and apparently if you compile and run your code on debug environment the String::compare() is slightly faster than string::operator==(). However if you compile and run your code in Release environment, both are pretty much the same. FYI, I ran 1,000,000 iteration in order to come up with such conclusion.In order to prove why in debug environment the string::compare is faster, I went to the assembly and here is the code:DEBUG BUILDstring::operator==()string::compare()You can see that in string::operator==(), it has to perform extra operations (add esp, 8 and movzx edx,al)  RELEASE BUILDstring::operator==()string::compare()Both assembly code are very similar as the compiler perform optimization.Finally, in my opinion, the performance gain is negligible, hence I would really leave it to the developer to decide on which one is the preferred one as both achieve the same outcome (especially when it is release build).compare() will return false (well, 0) if the strings are equal.So don\'t take exchanging one for the other lightly.Use whichever makes the code more readable.compare() is equivalent to strcmp(). == is simple equality checking. compare() therefore returns an int, == is a boolean.If you just want to check string equality, use the == operator. Determining whether two strings are equal is simpler than finding an ordering (which is what compare() gives,) so it might be better performance-wise in your case to use the equality operator.Longer answer: The API provides a method to check for string equality and a method to check string ordering. You want string equality, so use the equality operator (so that your expectations and those of the library implementors align.) If performance is important then you might like to test both methods and find the fastest.One thing that is not covered here is that it depends if we compare string to c string, c string to string or string to string.A major difference is that for comparing two strings size equality is checked before doing the compare and that makes the == operator faster than a compare.here is the compare as i see it on g++ Debian 7In Visual Studio 2012 debugger, only the following work correctly when checking a string is empty or not:return true.return 1, andreturn:\nno operator "==" matches these operands.return: An unspecified error has occurred.