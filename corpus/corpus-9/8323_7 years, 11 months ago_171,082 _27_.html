Is there such a thing? It is the first time I encountered a practical need for it, but I don\'t see one listed in Stroustrup. I intend to write:But there is no ^^ operator. Can I use the bitwise ^ here and get the right answer (regardless of machine representation of true and false)? I never mix & and &&, or | and ||, so I hesitate to do that with ^ and ^^. I\'d be more comfortable writing my own bool XOR(bool,bool) function instead.The != operator serves this purpose for bool values.For a true logical XOR operation, this will work:Proper manual logical XOR implementation depends on how closely you want to mimic the general behavior of other logical operators (|| and &&) with your XOR. There are two important things about these operators: 1) they guarantee short-circuit evaluation, 2) they introduce a sequence point, 3) they evaluate their operands only once.XOR evaluation, as you understand, cannot be short-circuited since the result always depends on both operands. So 1 is out of question. But what about 2? If you don\'t care about 2, then with normalized (i.e. bool) values operator != does the job of XOR in terms of the result. And the operands can be easily normalized with unary !, if necessary. Thus !A != !B implements the proper XOR in that regard.But if you care about the extra sequence point though, neither != nor bitwise ^ is the proper way to implement XOR. One possible way to do XOR(a, b) correctly might look as followsThis is actually as close as you can get to making a homemade XOR "similar" to || and &&. This will only work, of course, if you implement your XOR as a macro. A function won\'t do, since the sequencing will not apply to function\'s arguments.Someone might say though, that the only reason of having a sequence point at each && and || is to support the short-circuited evaluation, and thus XOR does not need one. This makes sense, actually. Yet, it is worth considering having a XOR with a sequence point in the middle. For example, the following expression has defined behavior and specificed result in C/C++ (with regard to sequencing at least). So, one might reasonably expect the same from user-defined logical XOR, as inwhile a !=-based XOR doesn\'t have this property.There is another way to do XOR:Which obviously can be demonstrated to work via:The XOR operator cannot be short circuited; i.e. you cannot predict the result of an XOR expression just by evaluating its left hand operand. Thus, there\'s no reason to provide a ^^ version.There was some good code posted that solved the problem better than !a != !bNote that I had to add the BOOL_DETAIL_OPEN/CLOSE so it would work on MSVC 2010Use a simple:I use "xor" (it seems it\'s a keyword; in Code::Blocks at least it gets bold) just as you can use "and" instead of && and "or" instead of ||.Yes, it is bitwise. Sorry.Here is how I think you write an XOR comparison in C++:ProofThe proof is that an exhaustive study of inputs and outputs shows that in the two tables, for every input set the result is always the identical in the two tables.Therefore, the original question being how to write:The answer would beOr if you like, writeIt works as defined. The conditionals are to detect if you are using Objective-C, which is asking for BOOL instead of bool (the length is different!)