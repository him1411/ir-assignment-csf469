I was shown this recently, and thought this was a really cool piece of code. Assume 32-bit architecture.Without compiling the program, what does it output, and why? If you think that a certain output will be arbitrary, say so, invent a value, and then pretend that was the value that was output.Edit: So the question has been answered, fastest gun goes to wnoise! However, I encourage people who are just reading this challenge to attempt it yourself, before you check out the answers.Edit 2: Converted the pointers to void*, as per Chris Young. I believe most compilers treat the two the same way, but let\'s be correct.The output is undefined behavior because %p requires that the pointer be cast to void * since other pointer types might not have the same size and representation as void *. Assuming that part of the program is corrected, the output would be an implementation defined representation of the following values, assuming n = the pointer value of the address of the first element of the array:The reason for the first 3 lines should be obvious. The reason for the last line is because &x is of type int(*)[4] and not int *.Alright! We\'ve got some good answers, and some essentially correct explanations. But let\'s elaborate a little on what\'s going on:First line:Basic retrieval of address of pointer. This is the only arbitrary value of the four.Basic pointer arithmetic. Recall that the size of int on a 32-bit system is 4 bytes, so address increases by four. This is now subscript 1 of the integer array.If you were taught that arrays are equivalent to pointers, this will confuse you: the common response is that this is an another arbitrary value, i.e. the pointer to the pointer, residing somewhere on the stack. If you try code that tries to do that, however, your compiler will complain (GCC says "error: label `x\' used but not defined").The correct response is that x was the address to the first integer of the array; &x is now an address to the actual array, which just happens to be the same as the address to the first integer of the array.If x had been defined as x*, and we malloc\'ed the appropriate amount of memory, the behavior would be different. And when passing pointers through functions, the distinction usually disappears. But a pointer to the array is not the same as a pointer to the first element of the array!If you answered 3 wrong, you would definitely get 4 wrong, because extending that line of thought, we\'re now talking about a pointer to a pointer, and then the appropriate pointer arithmetic would be 4 bytes worth.If you realized that 3 was now a pointer to an array, you would also realize that doing pointer arithmetic would be with regards to the size of the array, not the pointer.Thanks everyone who participated!Technically, there are two "correct" answers because even on a 32-bit architecture, int is allowed to be 16-bit.  wow... it\'s been a loooong time since the good ol days ...but... still.x and &x are basically the same thing here are they not, arrays in C are just syntactic sugar over pointer arithmetic, so my guess would be that basically twice the same pair of lines to be the output of the program above...  unless the adress of an adress yields yet another address...ho... the pain.. my brain hurts... need more beerweeeel   will you look at that, they are both addresses but the pointer arithmetic will be affected differently by the & operator...  typing the pointer differentlyx being the address of the first element (typed int)\n&x being the address of the array of int (typed int[4])nice, thanks