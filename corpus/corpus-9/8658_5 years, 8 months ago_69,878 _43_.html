I\'ve read Romain Guy\'s post on the <merge /> tag, but I still don\'t understand how it\'s useful. Is it a sort-of replacement of the <Frame /> tag, or is it used like so:then <include /> the code in another file?<merge/> is useful because it can get rid of unneeded ViewGroups, i.e. layouts that are simply used to wrap other views and serve no purpose themselves.For example, if you were to <include/> a layout from another file without using merge, the two files might look something like this:layout1.xml:layout2.xml:which is functionally equivalent to this single layout:That FrameLayout in layout2.xml may not be useful.  <merge/> helps get rid of it.  Here\'s what it looks like using merge (layout1.xml doesn\'t change):layout2.xml:This is functionally equivalent to this layout:but since you are using <include/> you can reuse the layout elsewhere.  It doesn\'t have to be used to replace only FrameLayouts - you can use it to replace any layout that isn\'t adding something useful to the way your view looks/behaves.The <include> tag lets you to divide your layout into multiple files: it helps dealing with complex or overlong user interface.Let\'s suppose you split your complex layout using two include files as follows:top_level_activity.xml:\nThen you need to write include1.xml and include2.xml.Keep in mind that the xml from the include files is simply dumped in your top_level_activity layout at rendering time (pretty much like the #INCLUDE macro for C).The include files are plain jane layout xml.include1.xml:... and include2.xml:See? Nothing fancy. \nNote that you still have to declare the android namespace with xmlns:android="http://schemas.android.com/apk/res/android.So the rendered version of  top_level_activity.xml is:\nIn your java code, all this is transparent: findViewById(R.id.textView1) in your activity class returns the correct widget ( even if that widget was declared in a xml file different from the activity layout).And the cherry on top: the visual editor handles the thing swimmingly. The top level layout is rendered with the xml included.As an include file is a classic layout xml file, it means that it must have one top element.\nSo in case your file needs to include more than one widget, you would have to use a layout.Let\'s say that include1.xml has now two TextView: a layout has to be declared. Let\'s choose  a LinearLayout.include1.xml:\nThe top_level_activity.xml will be rendered as: \nBut wait the two levels of LinearLayout are redundant!Indeed, the two nested LinearLayout serve no purpose as the two TextView could be included under layout1for exactly the same rendering.So what can we do? The <merge> tag is just a dummy tag that provides a top level element to deal with this kind of redundancy issues.Now include1.xml becomes: \nand now top_level_activity.xml is rendered as: \nYou saved one hierarchy level, avoid one useless view: Romain Guy sleeps better already.Aren\'t you happier now?In simple and precise words, When a layout containing a merge tag is added to another layout, the\n  merge node is removed and its child Views are added directly to the\n  new parent.merge tag is particularly useful in conjunction with the include tag, which is used to insert the contents of one layout into another.Exampleblazeroni already make\'s it pretty clear, I just want to add few points.Another reason to use merge is when using custom viewgroups in ListViews or GridViews. Instead of using the viewHolder pattern in a list adapter, you can use a custom view. The custom view would inflate an xml whose root is a merge tag. \nCode for adapter: here is the custom viewgroup:and here is the XML: