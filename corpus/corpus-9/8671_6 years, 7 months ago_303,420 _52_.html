I\'m looking for a quick and simple method for properly testing if a given TCP port is open on a remote server, from inside a Shell script.I\'ve managed to do it with the telnet command, and it works fine when the port is opened, but it doesn\'t seem to timeout when it\'s not and just hangs there...Here\'s a sample:I either need a better way, or a way to force telnet to timeout if it doesn\'t connect in under 8 seconds for example, and return something I can catch in Shell (return code, or string in stdout).I know of the Perl method, which uses the IO::Socket::INET module and wrote a successful script that tests a port, but would rather like to avoid using Perl if possible.Note: This is what my server is running (where I need to run this from)SunOS 5.10 Generic_139556-08 i86pc i386 i86pcAs pointed by B. Rhodes, nc will do the job. A more compact way to use it:That way nc will only check if the port is open, exiting with 0 on success, 1 on failure.For a quick interactive check (with a 5 seconds timeout):It\'s easy enough to do with the -z and -w TIMEOUT options to nc, but not all systems have nc installed. If you have a recent enough version of bash, this will work:What\'s happening here is that timeout will run the subcommand and kill it if it doesn\'t exit within the specified timeout (1 second in the above example). In this case bash is the subcommand and uses its special /dev/tcp handling to try and open a connection to the server and port specified. If bash can open the connection within the timeout, cat will just close it immediately (since it\'s reading from /dev/null) and exit with a status code of 0 which will propagate through bash and then timeout. If bash gets a connection failure prior to the specified timeout, then bash will exit with an exit code of 1 which timeout will also return. And if bash isn\'t able to establish a connection and the specified timeout expires, then timeout will kill bash and exit with a status of 124.Note that timeout should be present with RHEL 6+, or is alternatively found in GNU coreutils 8.22. On MacOS, install it using brew install coreutils and use it as gtimeout.If parametrizing the host and port, be sure to specify them as ${HOST} and ${PORT} as is above. Do not specify them merely as $HOST and $PORT, i.e. without the braces; it won\'t work in this case.If you must preserve the exit status of bash,Note that a backward incompatible version of nc gets installed on RHEL 7.Note that the command below is unique in that it is identical for both RHEL 6 and 7. It\'s just the installation and output that are different.If the hostname maps to multiple IPs, the above failing command will cycle through many or all of them. For example:If the hostname maps to multiple IPs, the above failing command will cycle through many or all of them. For example:The -v (--verbose) argument and the echo $? command are of course for illustration only.With netcat you can check whether a port is open like this:The return value of nc will be success if the TCP port was opened, and failure (typically the return code 1) if it could not make the TCP connection.In Bash using pseudo-device files for TCP/UDP connections is straight forward. Here is the script:Testing:Here is one-liner (Bash syntax):Note that some servers can be firewall protected from SYN flood attacks, so you may experience a TCP connection timeout (~75secs). To workaround the timeout issue, try:See: How to decrease TCP connect() system call timeout?While an old question, I\'ve just dealt with a variant of it, but none of the solutions here were applicable, so I found another, and am adding it for posterity.  Yes, I know the OP said they were aware of this option and it didn\'t suit them, but for anyone following afterwards it might prove useful.In my case, I want to test for the availability of a local apt-cacher-ng service from a docker build.  That means absolutely nothing can be installed prior to the test.  No nc, nmap, expect, telnet or python.  perl however is present, along with the core libraries, so I used this:If you\'re using ksh or bash they both support IO redirection to/from a socket using the /dev/tcp/IP/PORT construct. In this Korn shell example I am redirecting no-op\'s (:) std-in from a socket:The shell prints an error if the socket is not open:You can therefore use this as the test in an if condition:The no-op is in a subshell so I can throw std-err away if the std-in redirection fails.I often use /dev/tcp for checking the availability of a resource over HTTP:This one-liner opens file descriptor 9 for reading from and writing to the socket, prints the HTTP GET to the socket and uses cat to read from the socket.I needed a more flexible solution for working on multiple git repositories so I wrote the following sh code based on 1 and 2. You can use your server address instead of gitlab.com and your port in replace of 22.I\'m guessing that it\'s too late for an answer, and this might not be a good one, but here you go...What about putting it inside of a while loop with a timer on it of some sort.  I\'m more of a Perl guy than Solaris, but depending on the shell you\'re using, you should be able to do something like:And then just add a flag in the while loop, so that if it times out before completing, you can cite the timeout as reason for failure.I suspect that the telnet has a timeout switch as well, but just off the top of my head, I think the above will work.If you want to use nc but don\'t have a version that support -z, try using --send-only:and with timeout:and without DNS lookup if it\'s an IP:It returns the codes as the -z based on if it can connect or not.In some cases where tools like curl, telnet, nc o nmap are unavailable you still have a chance with wgetWhat about Netcat or Nmap?The answer lied with Expect. We wrote a simple script that sends a telnet on the port we needed, with a timeout of 8 seconds. There\'s plenty of examples to pick from too.We based ours off this post: http://www.unix.com/shell-programming-scripting/146568-expect-telnet-testing-tacacs-cisco.htmlI needed short script which was run in cron and hasn\'t output. I solve my trouble using nmap To run it You should install nmap because it is not default installed package.This uses telnet behind the scenes, and seems to work fine on mac/linux. It doesn\'t use netcat because of the differences between the versions on linux/mac, and this works with a default mac install.the port 22 is open