I\'m using AutoMapper in an ASP.NET MVC application. I was told that I should move the AutoMapper.CreateMap elsewhere as they have a lot of overhead. I\'m not too sure how to design my application to put these calls in just 1 place.I have a web layer, service layer and a data layer. Each a project of its own. I use Ninject to DI everything. I\'ll utilize AutoMapper in both web and service layers. So what are your setup for AutoMapper\'s CreateMap? Where do you put it? How do you call it?Doesn\'t matter, as long as it\'s a static class. It\'s all about convention.Our convention is that each "layer" (web, services, data) has a single file called AutoMapperXConfiguration.cs, with a single method called Configure(), where X is the layer.The Configure() method then calls private methods for each area.Here\'s an example of our web tier config:We create a method for each "aggregate" (User, Post), so things are separated nicely.Then your Global.asax:It\'s kind of like an "interface of words" - can\'t enforce it, but you expect it, so you can code (and refactor) if necessary.EDIT:Just thought I\'d mention that I now use AutoMapper profiles, so the above example becomes:Much cleaner/more robust.You can really put it anywhere as long as your web project references the assembly that it is in.  In your situation I would put it in the service layer as that will be accessible by the web layer and the service layer and later if you decide to do a console app or you are doing a unit test project the mapping configuration will be available from those projects as well.In your Global.asax you will then call the method that sets all of your maps.  See below:File AutoMapperBootStrapper.csGlobal.asax on application startjust call Now some people will argue against this method violates some SOLID principles, which they have valid arguments.  Here they are for the reading.  Configuring Automapper in Bootstrapper violates Open-Closed Principle?Update: The approach posted here is no more valid as SelfProfiler has been removed as of AutoMapper v2.I would take a similar approach as Thoai. But I would use the built-in SelfProfiler<> class to handle the maps, then use the Mapper.SelfConfigure function to initialize.Using this object as the source:And these as the destination:You can create these profiles:To initialize in your application, create this classAdd this line to your global.asax.cs file: AutoMapperConfiguration.Initialize()Now you can place your mapping classes where they make sense to you and not worry about one monolithic mapping class.For those of you who adhere to the following:I did a combo between profiles and leveraging my ioc container:IoC configuration:Configuration example:Usage example:The trade-off is that you have to reference the Mapper by the IMappingEngine interface instead of the static Mapper, but that\'s a convention I can live with.All of above solutions provide a static method to call (from app_start or any where) that it should call other methods to configure parts of mapping-configuration. But, if you have a modular application, that modules may plug in and out of application at any time, these solutions does not work. I suggest using WebActivator library that can register some methods to run on app_pre_start and app_post_start any where:You can install WebActivator via NuGet.In addition to the best answer, a good way is using Autofac  IoC liberary to add some automation. With this you just define your profiles regardless of initiations. and calling this line in Application_Start method:The above code finds all Profile sub classes and initiate them automatically.Putting all the mapping logic in 1 location is not a good practice for me. Because the mapping class will be extremely large and very hard to maintain.I recommend put the mapping stuff together with the ViewModel class in the same cs file. You can easily navigate to the mapping definition you want following this convention. Moreover, while creating the mapping class, you can reference to the ViewModel properties faster since they are in the same file.So your view model class will look like:From new version of AutoMapper using static method Mapper.Map() is deprecated. So you can add MapperConfiguration as static property to MvcApplication (Global.asax.cs) and use it to create instance of Mapper.App_StartGlobal.asax.csBaseController.cshttps://github.com/AutoMapper/AutoMapper/wiki/Migrating-from-static-APIFor vb.net programmers using the new Version (5.x) of AutoMapper.Global.asax.vb:AutoMapperConfiguration:Profiles:Mapping:For those who are (lost) using:Here\'s how I managed integrating AutoMapper in the "new way". Also, \na Huge thanks to this answer(and question)1 - Created a folder in the WebAPI project called "ProfileMappers". In this folder I place all my profiles classes which creates my mappings:2 - In my App_Start, I have a SimpleInjectorApiInitializer which configures my SimpleInjector container:3 - Startup.cs4 - Then, in your controller just inject as usually a IMapper interface: