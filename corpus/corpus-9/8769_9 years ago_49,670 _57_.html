I\'m building a group calendar application that needs to support recurring events, but all the solutions I\'ve come up with to handle these events seem like a hack. I can limit how far ahead one can look, and then generate all the events at once. Or I can store the events as repeating and dynamically display them when one looks ahead on the calendar, but I\'ll have to convert them to a normal event if someone wants to change the details on a particular instance of the event.I\'m sure there\'s a better way to do this, but I haven\'t found it yet. What\'s the best way to model recurring events, where you can change details of or delete particular event instances?(I\'m using Ruby, but please don\'t let that constrain your answer. If there\'s a Ruby-specific library or something, though, that\'s good to know.)I would use a \'link\' concept for all future recurring events. They are dynamically displayed in the calendar and link back to a single reference object. When events have taken place the link is broken and the event becomes a standalone instance. If you attempt to edit a recurring event then prompt to change all future items (i.e. change single linked reference) or change just that instance (in which case convert this to a standalone instance and then make change). The latter cased is slightly problematic as you need to keep track in your recurring list of all future events that were converted to single instance. But, this is entirely do-able.So, in essence, have 2 classes of events - single instances and recurring events.Martin Fowler - Recurring Events for Calendars contains some interesting insights and patterns.Runt gem implements this pattern.There can be many problems with recurring events, let me highlight a few that I know of.Store original appointment + recurrence data, do not store all the instances.Problems:Store everything from 1, but also all the instances, linked back to the original appointment.Problems:Of course, if you\'re not going to do exceptions, then either solution should be fine, and you basically choose from a time/space trade off scenario.You may want to look at iCalendar software implementations or the standard itself (RFC 2445 RFC 5545).\nOnes to come to mind quickly are the Mozilla projects http://www.mozilla.org/projects/calendar/  A quick search reveals http://icalendar.rubyforge.org/ as well.Other options can be considered depending on how you\'re going to store the events.  Are you building your own database schema?  Using something iCalendar-based, etc.?I\'m working with the following:and a gem in progress that extends formtastic with an input type :recurring (form.schedule :as => :recurring), which renders an iCal-like interface and a before_filter to serialize the view into an IceCube object again, ghetto-ly.My idea is to make it incredibility easy to add recurring attributes to a model and connect it easily in the view. All in a couple of lines.So what does this give me? Indexed, Edit-able, Recurring attributes.events stores a single day instance, and is used in the calendar view/helper\nsay task.schedule stores the yaml\'d IceCube object, so you can do calls like : task.schedule.next_suggestion.Recap: I use two models, one flat, for the calendar display, and one attribute\'d for the functionality.I\'m using the database schema as described below to store the recurrence parametershttp://github.com/bakineggs/recurring_events_forThen I use runt to dynamically calculate the dates.https://github.com/mlipper/runtNote that if you allow recurrence rules that don\'t end, you have to think about how to display your now infinite amount of information.Hope that helps!I have developed multiple calendar-based applications, and also authored a set of reusable JavaScript calendar components that support recurrence. I wrote up an overview of how to design for recurrence that might be helpful to someone. While there are a few bits that are specific to the library I wrote, the vast majority of the advice offered is general to any calendar implementation.Some of the key points:It\'s a really complicated topic with many, many valid approaches to implementing it. I will say that I\'ve actually implemented recurrence several times successfully, and I would be wary of taking advice on this subject from anyone who hasn\'t actually done it.I\'d recommend using the power of the date library and the semantics of the range module of ruby.  A recurring event is really a time, a date range (a start & end) and usually a single day of the week.  Using date & range you can answer any question:Produces all days of the event, including the leap year!From these answers, I\'ve sort of sifted out a solution. I really like the idea of the link concept. Recurring events could be a linked list, with the tail knowing its recurrence rule. Changing one event would then be easy, because the links stay in place, and deleting an event is easy as well - you just unlink an event, delete it, and re-link the event before and after it. You still have to query recurring events every time someone looks at a new time period never been looked at before on the calendar, but otherwise this is pretty clean.You could store the events as repeating, and if a particular instance was edited, create a new event with the same event ID. Then when looking up the event, search for all events with the same event ID to get all the information. I\'m not sure if you rolled your own event library, or if you\'re using an existing one so it may not be possible.Check the article below for three good ruby date/time libraries. \nice_cube in particular seems a solid choice for recurrence rules and other stuff that an event calendar would need.\nhttp://www.rubyinside.com/3-new-date-and-time-libraries-for-rubyists-3238.htmlIn javascript:Handling recurring schedules: \nhttp://bunkat.github.io/later/Handling complex events and dependencies between those schedules:\nhttp://bunkat.github.io/schedule/Basically, you create the rules then you ask the lib to compute the next N recurring events (specifying a date range or not). The rules can be parsed / serialised for saving them into your model.If you have a recurring event and would like to modify only one recurrence you can use the except() function to dismiss a particular day and then add a new modified event for this entry.The lib supports very complex patterns, timezones and even croning events.Store the events as repeating and dynamically display them, however allow the recurring event to contain a list of specific events that could override the default information on a specific day.When you query the recurring event it can check for a specific override for that day.If a user makes changes, then you can ask if he wants to update for all instances (default details) or just that day (make a new specific event and add it to the list).If a user asks to delete all recurrences of this event you also have the list of specifics to hand and can remove them easily.The only problematic case would be if the user wants to update this event and all future events.  In which case you\'ll have to split the recurring event into two.  At this point you may want to consider linking recurring events in some way so you can delete them all.For .NET programmers who are prepared to pay some licensing fees, you might find Aspose.Network useful... it includes an iCalendar compatible library for recurring appointments.You store the events in iCalendar format directly, which allows for open-ended repetition, time-zone localisation and so forth.You could store these in a CalDAV server and then when you want to display the events you can use the  option of the  report defined in CalDAV to ask the server to do the expansion of the recurring events across the viewed period.Or you could store them in a database yourself and use some kind of iCalendar parsing library to do the expansion, without needing the PUT/GET/REPORT to talk to a backend CalDAV server. This is probably more work - I\'m sure CalDAV servers hide complexity somewhere.Having the events in iCalendar format will probably make things simpler in the long run as people will always want them to be exported for putting in other software anyway.I have Simply implemented this feature! Logic is as follows, first you need two tables. RuleTable store general or recycle paternal events. ItemTable is stored cycle events. For example, when you create a cyclic event, the start time for 6 November 2015, the end time for the December 6 (or forever), cycle for one week. You insert data into a RuleTable, fields are as follows: Now you want to query November 20 to December 20 data. You can write a function RecurringEventBE (long start, long end), based on the starting and ending time, WeekLy, you can calculate the collection you want, < cycleA11.20, cycleA 11.27, cycleA 12.4 ......>.\nIn addition to November 6, and the rest I called him a virtual event. When the user changes a virtual event\' name after (cycleA11.27 for example), you insert a data into a ItemTable. Fields are as follows: In function RecurringEventBE (long start, long end), you use this data covering virtual event (cycleB11.27)\nsorry about my english, I tried.This is my RecurringEventBE\xef\xbc\x9aWhat if you have a recurring appointment with no end date? As cheap as space is, you don\'t have infinite space, so Solution 2 is a non-starter there... May I suggest that "no end date" can be resolved to an end date at the end of the century. Even for a dayly event the amount of space remains cheap.