How can I clone an ArrayList and also clone its items in Java?For example I have:And I would expect that objects in clonedList are not the same as in dogs list.You will need to iterate on the items, and clone them one by one, putting the clones in your result array as you go.For that to work, obviously, you will have to get your Dog object to implement the Cloneable interface, and the clone() method.I, personally, would add a constructor to Dog:Then just iterate (as shown in Varkhan\'s answer):I find the advantage of this is you don\'t need to screw around with the broken Cloneable stuff in Java.  It also matches the way that you copy Java collections.Another option could be to write your own ICloneable interface and use that.  That way you could write a generic method for cloning.All standard collections have copy constructors. Use them.clone() was designed with several mistakes (see this question), so it\'s best to avoid it.From Effective Java 2nd Edition, Item 11: Override clone judiciouslyGiven all of the problems associated with Cloneable, it\xe2\x80\x99s safe to say \n  that other interfaces should not extend it, and that classes\n  designed for inheritance (Item 17) should not implement it. Because of\n  its many shortcomings, some expert programmers simply choose never to\n  override the clone method and never to invoke it except, perhaps, to\n  copy arrays. If you design a class for inheritance, be aware that if\n  you choose not to provide a well-behaved protected clone method, it\n  will be impossible for subclasses to implement Cloneable.This book also describes the many advantages copy constructors have over Cloneable/clone.Consider another benefit of using copy constructors: Suppose you have a HashSet s, and you want to copy it as a TreeSet. The clone method can\xe2\x80\x99t offer this functionality, but it\xe2\x80\x99s easy with a conversion constructor: new TreeSet(s).Basically there are three ways without iterating manually, 1  Using constructor2 Using addAll(Collection<? extends E> c)3 Using addAll(int index, Collection<? extends E> c) method with int parameterNB : The behavior of these operations will be undefined if the specified collection is modified while the operation is in progress.Java 8 provides a new way to call the copy constructor or clone method on the element dogs elegantly and compactly: Streams, lambdas and collectors.Copy constructor:The expression Dog::new is called a method references. It references a constructor on Dog which takes another dog as argument.Clone method:Or, if you have to get an ArrayList back (in case you want to modify it later):If you don\'t need to keep the original content of the dogs list you can use the replaceAll method and update the list in place instead:All examples assume import static java.util.stream.Collectors.*;.The collector from the last example can be made into a util method. Since this is such a common thing to do I personally like it to be short and pretty. Like this:For this solution to work the clone method of Dog must not declare that it throws CloneNotSupportedException. The reason is that the argument to map is not allowed to throw any checked exceptions.Like this:This should not be a big problem however, since that is the best practice anyway. (Effectice Java for example gives this advice.)Thanks to Gustavo for noting this.If you find it prettier you can instead use the method reference syntax to do exactly the same thing:I think the current green answer is bad , why you might ask?The way serialization is also bad imo, you might have to add Serializable all over the place.So what is the solution:Java Deep-Cloning library\nThe cloning library is a small, open source (apache licence) java library which deep-clones objects. The objects don\'t have to implement the Cloneable interface. Effectivelly, this library can clone ANY java objects. It can be used i.e. in cache implementations if you don\'t want the cached object to be modified or whenever you want to create a deep copy of objects. Check it out at https://github.com/kostaskougios/cloningA nasty way is to do it with reflection. Something like this worked for me.You will need to clone the ArrayList by hand (by iterating over it and copying each element to a new ArrayList), because clone() will not do it for you. Reason for this is that the objects contained in the ArrayList may not implement Clonable themselves.Edit: ... and that is exactly what Varkhan\'s code does.Here\'s yet another approach, presumably a fast approach: http://javatechniques.com/blog/faster-deep-copies-of-java-objects/The other posters are correct: you need to iterate the list and copy into a new list.However...\nIf the objects in the list are immutable - you don\'t need to clone them. If your object has a complex object graph - they will need to be immutable as well. The other benefit of immutability is that they are threadsafe as well.Here is a solution using a generic template type:for you objects override clone() methodand call .clone() for Vector obj or ArraiList obj....Easy way by using commons-lang-2.3.jar that library of java to clone listlink download commons-lang-2.3.jarHow to useI hope this one can helpful.:DThe package import org.apache.commons.lang.SerializationUtils;There is a method SerializationUtils.clone(Object);ExampleI think I found a really easy way to make a deep copy ArrayList.  Assuming you want to copy a String ArrayList arrayA.Let me know if it doesn\'t work for you.I have found a way, you can use json to serialize/unserialize the list. The serialized list holds no reference to the original object when unserialized.Using gson:You can do that using jackson and any other json library too.I have just developed a lib that is able to clone an entity object and a java.util.List object. Just download the jar in https://drive.google.com/open?id=0B69Sui5ah93EUTloSktFUkctN0U and use the static method cloneListObject(List list). This method not only clones the List but also all entity elements.