Why would someone use WHERE 1=1 AND <conditions> in a SQL clause (Either SQL obtained through concatenated strings, either view definition)I\'ve seen somewhere that this would be used to protect against SQL Injection, but it seems very weird.If there is injection WHERE 1 = 1 AND injected OR 1=1 would have the same result as injected OR 1=1.Later edit: What about the usage in a view definition?Thank you for your answers.Still,\nI don\'t understand why would someone use this construction for defining a view, or use it inside a stored procedure.Take this for example:If the list of conditions is not known at compile time and is instead built at run time, you don\'t have to worry about whether you have one or more than one condition. You can generate them all like:and concatenate them all together. With the 1=1 at the start, the initial and has something to associate with.I\'ve never seen this used for any kind of injection protection, as you say it doesn\'t seem like it would help much. I have seen it used as an implementation convenience. The SQL query engine will end up ignoring the 1=1 so it should have no performance impact.Just adding a example code to Greg\'s answer:I\'ve seen it used when the number of conditions can be variable. You can concatenate conditions using an " AND " string. Then, instead of counting the number of conditions you\'re passing in, you place a "WHERE 1=1" at the end of your stock SQL statement and throw on the concatenated conditions.Basically, it saves you having to do a test for conditions and then add a "WHERE" string before them.Seems like a lazy way to always know that your WHERE clause is already defined and allow you to keep adding conditions without having to check if it is the first one.1 = 1 expression is commonly used in generated sql code. This expression can simplify sql generating code reducing number of conditional statements.Actually, I\'ve seen this sort of thing used in BIRT reports.  The query passed to the BIRT runtime is of the form:and the \'?\' is replaced at runtime by an actual parameter value selected from a drop-down box.  The choices in the drop-down are given by:so that you get all possible values plus "*".  If the user selects "*" from the drop down box (meaning all values of a should be selected), the query has to be modified (by Javascript) before being run.Since the "?" is a positional parameter and MUST remain there for other things to work, the Javascript modifies the query to be:That basically removes the effect of the where clause while still leaving the positional parameter in place.I\'ve also seen the AND case used by lazy coders whilst dynamically creating an SQL query.Say you have to dynamically create a query that starts with select * from t and checks:some people would add the first with a WHERE and subsequent ones with an AND thus:Lazy programmers (and that\'s not necessarily a bad trait) wouldn\'t distinguish between the added conditions, they\'d start with select * from t where 1=1 and just add AND clauses after that.where 1=0, This is done to check if the table exists. Don\'t know why 1=1 is used.Indirectly Relevant: when 1=2 is used:CREATE TABLE New_table_name as select * FROM Old_table_name WHERE 1 = 2;this will create a new table with same schema as old table. (Very handy if you want to load some data for compares)While I can see that 1=1 would be useful for generated SQL, a technique I use in PHP is to create an array of clauses and then dothus avoiding the problem of having a leading or trailing AND. Obviously this is only useful if you know that you are going to have at least one clause!Here\'s a closely related example: using a SQL MERGE statement to update the target tabled using all values from the source table where there is no common attribute on which to join on e.g. I found usefull this pattern when I\'m testing or doublechecking things on the database, so I can comment very quickly other conditions:turns into:Why would someone use WHERE 1=1 AND <proper conditions>I\'ve seen homespun frameworks do stuff like this (blush), as this allows lazy parsing practices to be applied to both the WHERE and AND Sql keywords.For example (I\'m using C# as an example here), consider the conditional parsing of the following predicates in a Sql query string builder:The "benefit" of WHERE 1 = 1 means that no special code is needed:This is obviously a bad idea and would recommend using an established data access framework or ORM for parsing optional and conditional predicates in this way.If you came here searching for WHERE 1, note that WHERE 1 and WHERE 1=1 are identical. WHERE 1 is used rarely because some database systems reject it considering WHERE 1 not really being boolean.I first came across this back with ADO and classic asp, the answer i got was: performance.\nif you do a straight Select * from tablenameand pass that in as an sql command/text you will get a noticeable performance increase with the Where 1=1added, it was a visible difference. something to do with table headers being returned as soon as the first condition is met, or some other craziness, anyway, it did speed things up.Using a predicate like 1=1 is a normal hint sometimes used to force the access plan to use or not use an index scan.  The reason why this is used is when you are using a multi-nested joined query with many predicates in the where clause where sometimes even using all of the indexes causes the access plan to read each table - a full table scan.  This is just 1 of many hints used by DBAs to trick a dbms into using a more efficient path.  Just don\'t throw one in; you need a dba to analyze the query since it doesn\'t always work.I do this usually when I am building dynamic SQL for a report which has many dropdown values a user can select. Since the user may or may not select the values from each dropdown, we end up getting a hard time figuring out which condition was the first where clause. So we pad up the query with a where 1=1 in the end and add all where clauses after that.Something likeThen we would build the where clause like this and pass it as a parameter valueAs the where clause selection are unknown to us at runtime, so this helps us a great deal in finding whether to include an \'AND\' or \'WHERE\'.