Is there a platform-agnostic and filesystem-agnostic method to obtain the full path of the directory from where a program is running using C/C++? Not to be confused with the current working directory. (Please don\'t suggest libraries unless they\'re standard ones like clib or STL.)(If there\'s no platform/filesystem-agnostic method, suggestions that work in Windows and Linux for specific filesystems are welcome too.)Here\'s code to get the full path to the executing app:Windows:Linux:If you fetch the current directory when your program first starts, then you effectively have the directory your program was started from. Store the value in a variable and refer to it later in your program. This is distinct from the directory that holds the current executable program file. It isn\'t necessarily the same directory; if someone runs the program from a command prompt, then the program is being run from the command prompt\'s current working directory even though the program file lives elsewhere.getcwd is a POSIX function and supported out of the box by all POSIX compliant platforms. You would not have to do anything special (apart from incliding the right headers unistd.h on Unix and direct.h on windows).Since you are creating a C program it will link with the default c run time library which is linked to by ALL processes in the system (specially crafted exceptions avoided) and it will include this function by default. The CRT is never considered an external library because that provides the basic standard compliant interface to the OS.On windows getcwd function has been deprecated in favour of _getcwd. I think you could use it in this fashion.If you want a standard way without libraries: No. The whole concept of a directory is not included in the standard.If you agree that some (portable) dependency on a near-standard lib is okay: Use Boost\'s filesystem library and ask for the initial_path(). IMHO that\'s as close as you can get, with good karma (Boost is a well-established high quality set of libraries)This is from the cplusplus forumOn windows:On Linux:On HP-UX:Filesystem TS is now a standard ( and supported by gcc 5.3+ and clang 3.9+ ), so you can use current_path() function from it:In gcc (5.3+) to include Filesystem you need to use:and link your code with -lstdc++fs flag.If you want to use Filesystem with Microsoft Visual Studio, then read this.I know it is very late at the day to throw an answer at this one but I found that none of the answers were as useful to me as my own solution. A very simple way to get the path from your CWD to your bin folder is like this:You can now just use this as a base for your relative path. So for example  I have this directory structure:and I want to compile my source code to bin and write a log to test I can just add this line to my code.I have tried this approach on Linux using full path, alias etc. and it works just fine.NOTE:If you are on windows you should use a \'\\\' as the file separator not \'/\'. You will have to escape this too for example:I think this should work but haven\'t tested, so comment would be appreciated if it works or a fix if not. No, there\'s no standard way. I believe that the C/C++ standards don\'t even consider the existence of directories (or other file system organizations).On Windows the GetModuleFileName() will return the full path to the executable file of the current process when the hModule parameter is set to NULL.  I can\'t help with Linux.Also you should clarify whether you want the current directory or the directory that the program image/executable resides.  As it stands your question is a little ambiguous on this point.Maybe concatenate the current working directory with argv[0]? I\'m not sure if that would work in Windows but it works in linux.For example:When run, it outputs:jeremy@jeremy-desktop:~/Desktop$ ./test\n  /home/jeremy/Desktop/./testYou can not use argv[0] for that purpose, usually it does contain full path to the executable, but not nessesarily - process could be created with arbitrary value in the field. Also mind you, the current directory and the directory with the executable are two different things, so getcwd() won\'t help you either.On Windows use GetModuleFileName(), on Linux read /dev/proc/procID/.. files.For Win32 GetCurrentDirectory should do the trick.Just to belatedly pile on here,...there is no standard solution, because the languages are agnostic of underlying file systems, so as others have said, the concept of a directory based file system is outside the scope of the c / c++ languages.on top of that, you want not the current working directory, but the directory the program is running in, which must take into account how the program got to where it is - ie was it spawned as a new process via a fork, etc.  To get the directory a program is running in, as the solutions have demonstrated, requires that you get that information from the process control structures of the operating system in question, which is the only authority on this question.  Thus, by definition, its an OS specific solution.On Windows the simplest way is to use the _get_pgmptr function in stdlib.h to get a pointer to a string which represents the absolute path to the executable, including the executables name.For Windows system at console you can use system(dir) command. And console gives you information about directory and etc. Read about the dir command at cmd. But for Unix-like systems, I don\'t know... If this command is run, read bash command. ls does not display directory...Example:On POSIX platforms, you can use getcwd().On Windows, you may use _getcwd(), as use of getcwd() has been deprecated.For standard libraries, if Boost were standard enough for you, I would have suggested Boost::filesystem, but they seem to have removed path normalization from the proposal. You may have to wait until TR2 becomes readily available for a fully standard solution.For relative paths, here\'s what I did. I am aware of the age of this question, I simply want to contribute a simpler answer that works in the majority of cases:Say you have a path like this:For some reason, Linux-built executables made in eclipse work fine with this. However, windows gets very confused if given a path like this to work with!As stated above there are several ways to get the current path to the executable, but the easiest way I find works a charm in the majority of cases is appending this to the FRONT of your path:Just adding "./" should get you sorted! :) Then you can start loading from whatever directory you wish, so long as it is with the executable itself.EDIT: This won\'t work if you try to launch the executable from code::blocks if that\'s the development environment being used, as for some reason, code::blocks doesn\'t load stuff right... :DEDIT2: Some new things I have found is that if you specify a static path like this one in your code (Assuming Example.data is something you need to load):If you then launch your app from the actual directory (or in Windows, you make a shortcut, and set the working dir to your app dir) then it will work like that.\nKeep this in mind when debugging issues related to missing resource/file paths.  (Especially in IDEs that set the wrong working dir when launching a build exe from the IDE)Boost Filesystem\'s initial_path() behaves like POSIX\'s getcwd(), and neither does what you want by itself, but appending argv[0] to either of them should do it.You may note that the result is not always pretty--you may get things like /foo/bar/../../baz/a.out or /foo/bar//baz/a.out, but I believe that it always results in a valid path which names the executable (note that consecutive slashes in a path are collapsed to one).I previously wrote a solution using envp (the third argument to main() which worked on Linux but didn\'t seem workable on Windows, so I\'m essentially recommending the same solution as someone else did previously, but with the additional explanation of why it is actually correct even if the results are not pretty.As Minok mentioned, there is no such functionality specified ini C standard or C++ standard. This is considered to be purely OS-specific feature and it is specified in POSIX standard, for example.Thorsten79 has given good suggestion, it is Boost.Filesystem library. However, it may be inconvenient in case you don\'t want to have any link-time dependencies in binary form for your program.A good alternative I would recommend is collection of 100% headers-only STLSoft C++ Libraries Matthew Wilson (author of must-read books about C++). There is portable facade PlatformSTL gives access to system-specific API: WinSTL for Windows and UnixSTL on Unix, so it is portable solution. All the system-specific elements are specified with use of traits and policies, so it is extensible framework. There is filesystem library provided, of course.The linux bash command \nwhich progname    will report a path to program.Even if one could issue the which command from within your program and direct the output to a tmp file and the program\nsubsequently reads that tmp file, it will not tell you if that program is the one executing. It only tells you where a program having that name is located.What is required is to obtain your process id number, and to parse out the path to the name In my program I want to know if the program was\nexecuted from the user\'s bin directory or from another in the path\nor from /usr/bin.  /usr/bin would contain the supported version.\nMy feeling is that in Linux there is the one solution that is portable.