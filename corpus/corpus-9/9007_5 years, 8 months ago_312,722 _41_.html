Is it possible to create an empty array without specifying the size?For example, I created:Can we create the above string array without the size?If you are going to use a collection that you don\'t know the size of in advance, there are better options than arrays.Use a List<string> instead - it will allow you to add as many items as you need and if you need to return an array, call ToArray() on the variable.If you must create an empty array you can do this:Try this: In .Net 4.6 the preferred way is to use a new method, Array.Empty:The implementation is succinct, using how static members in generic classes behave in .Net:(code contract related code removed for clarity)See also:You could inititialize it with a size of 0, but you will have to reinitialize it, when you know what the size is, as you cannot append to the array.There is not much point in declaring an array without size. An array is about size. When you declare an array of specific size, you specify the fixed number of slots available in a collection that can hold things, and accordingly memory is allocated. To add something to it, you will need to anyway reinitialize the existing array (even if you\'re resizing the array, see this thread). One of the rare cases where you would want to initialise an empty array would be to pass array as an argument.If you want to define a collection when you do not know what size it could be of possibly, array is not your choice, but something like a List<T> or similar.That said, the only way to declare an array without specifying size is to have an empty array of size 0. hemant and Alex Dn provides two ways. Another simpler alternative is to just:[The elements inside the bracket should be implicitly convertible to type defined, for instance, string[] a = { "a", "b" };]Or yet another:Here is a more declarative way:Now you can call:You can do:Note: OP meant not having to specify a size, not make an array sizelessYou can define array size at runtime.This will allow you to do whatever to dynamically compute the array\'s size. But, once defined the size is immutable.As I know you can\'t make array without size, but you can use and then l.ToArray().Simple and elegant!Combining @nawfal & @Kobi suggestions:Usage example:HTHHere is a real world example. In this it is necessary to initialize the array foundFiles first to zero length.(As emphasized in other answers: This initializes not an element and especially not an element with index zero because that would mean the array had length 1. The array has zero length after this line!).If the part = string[0] is omitted, there is a compiler error!This is because of the catch block without rethrow. The C# compiler recognizes the code path, that the function Directory.GetFiles() can throw an Exception, so that the array could be uninitialized.Before anyone says, not rethrowing the exception would be bad error handling: This is not true. Error handling has to fit the requirements.In this case it is assumed that the program should continue in case of a directory which cannot be read, and not break- the best example is a function traversing through a directory structure. Here the error handling is just logging it. Of course this could be done better, e.g. collecting all directories with failed GetFiles(Dir) calls in a list, but this will lead too far here.It is enough to state that avoiding throw is a valid scenario, and so the array has to be initialized to length zero. It would be enough to do this in the catch block, but this would be bad style.The call to GetFiles(Dir) resizes the array.I had tried:But I could only insert one string into it, and then I got an exceptionOutOfBound error, so I just simply put a size for it, likeOr another way that work for me:Assigning Value for list: