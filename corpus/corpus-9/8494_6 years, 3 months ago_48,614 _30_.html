Imagine you have 2 entities, Player and Team, where players can be on multiple teams.  In my data model, I have a table for each entity, and a join table to maintain the relationships.  Hibernate is fine at handling this, but how might I expose this relationship in a RESTful API?  I can think of a couple ways.  First, I might have each entity contain a list of the other, so a Player object would have a list of Teams it belongs to, and each Team object would have a list of Players that belong to it.  So to add a Player to a Team, you would just POST the player\'s representation to an endpoint, something like POST /player or POST /team with the appropriate object as the payload of the request.  This seems the most "RESTful" to me but feels a little weird.The other way I can think of to do this would be to expose the relationship as a resource in its own right.  So to see a list of all the players on a given team, you might do a GET /playerteam/team/{id} or something like that and get back a list of PlayerTeam entities.  To add a player to a team, POST /playerteam with an appropriately built PlayerTeam entity as the payload.What is the best practice for this?In a RESTful interface, you can return documents that describe the relationships between resources by encoding those relationships as links. Thus, a team can be said to have a document resource (/team/{id}/players) that is a list of links to players (/player/{id}) on the team, and a player can have a document resource (/player/{id}/teams) that is a list of links to teams that the player is a member of. Nice and symmetric. You can the map operations on that list easily enough, even giving a relationship its own IDs (arguably they\'d have two IDs, depending on whether you\'re thinking about the relationship team-first or player-first) if that makes things easier. The only tricky bit is that you\'ve got to remember to delete the relationship from the other end as well if you delete it from one end, but rigorously handling this by using an underlying data model and then having the REST interface be a view of that model is going to make that easier.Relationship IDs probably ought to be based on UUIDs or something equally long and random, irrespective of whatever type of IDs you use for teams and players. That will let you use the same UUID as the ID component for each end of the relationship without worrying about collisions (small integers do not have that advantage). If these membership relationships have any properties other than the bare fact that they relate a player and a team in a bidirectional fashion, they should have their own identity that is independent of both players and teams; a GET on the player\xc2\xbbteam view (/player/{playerID}/teams/{teamID}) could then do an HTTP redirect to the bidirectional view (/memberships/{uuid}).I recommend writing links in any XML documents you return (if you happen to be producing XML of course) using XLink xlink:href attributes.Make a separate set of /memberships/ resources.I would map such relationship with sub-resources, general design/traversal would then be: In Restful-terms it helps a lot in not thinking of SQL and joins but more into collections, sub-collections and traversal.Some examples:As you see I don\'t use POST for placing players to teams but PUT, which handles your n:n relationship of players and teams better.The existing answers don\'t explain the roles of consistency and idempotency - which motivate their recommendations of UUIDs/random numbers for IDs and PUT instead of POST.If we consider the case where we have a simple scenario like "Add a new player to a team", we encounter consistency issues.Because the player doesn\'t exist, we need to:  However, should the client operation fail after the POST to /players, we\'ve created a player that doesn\'t belong to a team:Now we have an orphaned duplicate player in /players/5.To fix this we might write custom recovery code that checks for orphaned players that match some natural key (e.g. Name). This is custom code that needs to be tested, costs more money and time etc etcTo avoid needing custom recovery code, we can implement PUT instead of POST.From the RFC:the intent of PUT is idempotentFor an operation to be idempotent, it needs to exclude external data such as server-generated id sequences. This is why people are recommending both PUT and UUIDs for Ids together.This allows us to rerun both the /players PUT and the /memberships PUT without consequences:Everything is fine and we didn\'t need to do anything more than retry for partial failures.This is more of an addendum to the existing answers but I hope it puts them in context of the bigger picture of just how flexible and reliable ReST can be.I know that there\'s an answer marked as accepted for this question, however, here is how we could solve the previously raised issues:Let\'s say for PUTAs an example, the followings will all result in the same effect without a need for syncing because they are done on a single resource:now if we want to update multiple memberships for one team we could do as follows (with proper validations):I prefer 2