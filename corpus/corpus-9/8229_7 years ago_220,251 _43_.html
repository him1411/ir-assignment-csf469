time() is in seconds - is there one in milliseconds?The short answer is:Use microtime(). This function returns a string separated by a space. The first part is the fractional part of seconds, the second part is the integral part. Pass in true to get as a number:Beware of precision loss if you use microtime(true).There is also gettimeofday() that returns the microseconds part as an integer.As other have stated, you can use microtime() to get millisecond precision on timestamps.From your comments, you seem to want it as a high-precision UNIX Timestamp. Something like DateTime.Now.Ticks in the .NET world.You may use the following function to do so:Short answer:64 bits platforms only!Long answer:If you want an equilvalent function of time() in milliseconds first you have to consider that as time() returns the number of seconds elapsed since the "epoch time" (01/01/1970), the number of milliseconds since the "epoch time" is a big number and doesn\'t fit into a 32 bit integer.The size of an integer in PHP can be 32 or 64 bit depending on platform.From http://php.net/manual/en/language.types.integer.phpThe size of an integer is platform-dependent, although a maximum value of about two billion is the usual value (that\'s 32 bits signed). 64-bit platforms usually have a maximum value of about 9E18, except for Windows, which is always 32 bit. PHP does not support unsigned integers. Integer size can be determined using the constant PHP_INT_SIZE, and maximum value using the constant PHP_INT_MAX since PHP 4.4.0 and PHP 5.0.5. If you have 64 bit integers then you may use the following function:microtime() returns the number of seconds since the "epoch time" with precision up to microseconds with two numbers separated by space, like...The second number is the seconds (integer) preceeded by the decimal part.The function milliseconds take the integer part multiplied by 1000and adds the decimal part multiplied by 1000 and rounded to 0 decimalsNote that both $mt[1] and the result of round are casted to int. This is necessary because they are floats and the operation on them without casting would result in the function returning a float.Finally, that function is slightly more precise thanthat with a ratio of 1:10 (approx.) returns 1 more millisecond than the correct result.\nThis is due to the limited precision of the float type (microtime(true) returns a float).\nAnyway if you still prefer the shorter round(microtime(true)*1000); I would suggest casting to int the result.Even if it\'s beyond the scope of the question it\'s worth mentioning that if your platform supports 64 bits integers then you can also get the current time in microseconds without incurring in overflow.If fact 2^63 (approx. the biggest signed integer) divided by 10^6 * 3600 * 24 * 365 (approx. the microseconds in one year) gives approx. 292471. That\'s the same value returned by echo PHP_INT_MAX / (1000000*3600*24*365);In other words a signed integer have room to store a timespan of over 200000 years measured in microseconds.You may have thenUse microtime(true) in PHP 5, or the following modification in PHP 4:A portable way to write that code would be:NOTE: PHP5 is required for this function due to the improvements with\n  microtime() and the bc math module is also required (as we\xe2\x80\x99re dealing\n  with large numbers, you can check if you have the module in phpinfo).Hope this help you.try this:echo date(\'Y-m-d H:i:s.\') . gettimeofday()[\'usec\'];output:2016-11-19 15:12:34.346351This works even if you are on 32-bit PHP:Note this doesn\'t give you integers, but strings. However this works fine in many cases, for example when building URLs for REST requests.\nIf you need integers, 64-bit PHP is mandatory.Then you can reuse the above code and cast to (int):Or you can use the good ol\' one-liners:Use this:\nBye