I have two use cases. A. I want to synchronise access by two threads to a queue. B. I want to synchronise access by two threads to a queue and use a condition variable because one of the threads will wait on content to be stored into the queue by the other thread.For use case A I see code example using std::lock_guard<>. For use case B I see code example using std::unique_lock<>. What is the difference between the two and which one should I use in which use case?  The difference is that you can lock and unlock a std::unique_lock. std::lock_guard will be locked only once on construction and unlocked on destruction.So for usecase B you definitely need a std::unique_lock for the condition variable. In case  A it depends whether you need to relock the guard.std::unique_lock has other features that allow it to e.g.: be constructed without locking the mutex immediately but to build the RAII wrapper (see here).Lock guards can be used when you simply need a wrapper for a limited scope, e.g.: a member function:To clarify a question by chmike, by default std::lock_guard and std::unique_lock are the same.\nSo in the above case, you could replace std::lock_guard with std::unique_lock. However, std::unique_lock might have a tad more overhead.lock_guard and unique_lock are pretty much the same thing; lock_guard is a restricted version with a limited interface.A lock_guard always holds a lock from its construction to its destruction. A unique_lock can be created without immediately locking, can unlock at any point in its existence, and can transfer ownership of the lock from one instance to another.So you always use lock_guard, unless you need the capabilities of unique_lock. A condition_variable needs a unique_lock.Use lock_guard unless you need to be able to manually unlock the mutex in between without destroying the lock.In particular, condition_variable unlocks its mutex when going to sleep upon calls to wait. That is why a lock_guard is not sufficient here.There are certain common things between lock_guard and unique_lock and certain differences. But in the context of the question asked, the compiler does not allow using a lock_guard in combination with a condition variable, because when a thread calls wait on a condition variable, the mutex gets unlocked automatically and when other thread/threads notify and the current thread is invoked (comes out of wait), the lock is re-acquired. This phenomenon is against the principle of lock_guard. lock_guard can be constructed only once and destructed only once. Hence lock_guard cannot be used in combination with a condition variable, but a unique_lock can be (because unique_lock can be locked and unlocked several times).As has been mentioned by others, std::unique_lock tracks the locked status of the mutex, so you can defer locking until after construction of the lock, and unlock before destruction of the lock.  std::lock_guard does not permit this.There seems no reason why the std::condition_variable wait functions should not take a lock_guard as well as a unique_lock, because whenever a wait ends (for whatever reason) the mutex is automatically reacquired so that would not cause any semantic violation.  However according to the standard, to use a std::lock_guard with a condition variable you have to use a std::condition_variable_any instead of std::condition_variable.Edit: deleted "Using the pthreads interface std::condition_variable and std::condition_variable_any should be identical".  On looking at gcc\'s implementation: