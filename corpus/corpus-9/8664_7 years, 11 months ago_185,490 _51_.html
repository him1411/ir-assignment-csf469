What is the use of IQueryable in the context of LINQ?Is it used for developing extension methods or any other purpose?Marc Gravell\'s answer is very complete, but I thought I\'d add something about this from the user\'s point of view, as well...The main difference, from a user\'s perspective, is that, when you use IQueryable<T> (with a provider that supports things correctly), you can save a lot of resources.For example, if you\'re working against a remote database, with many ORM systems, you have the option of fetching data from a table in two ways, one which returns IEnumerable<T>, and one which returns an IQueryable<T>.  Say, for example, you have a Products table, and you want to get all of the products whose cost is >$25.If you do:What happens here, is the database loads all of the products, and passes them across the wire to your program.  Your program then filters the data.  In essence, the database does a SELECT * FROM Products, and returns EVERY product to you.With the right IQueryable<T> provider, on the other hand, you can do:The code looks the same, but the difference here is that the SQL executed will be SELECT * FROM Products WHERE Cost >= 25.From your POV as a developer, this looks the same.  However, from a performance standpoint, you may only return 2 records across the network instead of 20,000....In essence its job is very similar to IEnumerable<T> - to represent a queryable data source - the difference being that the various LINQ methods (on Queryable) can be more specific, to build the query using Expression trees rather than delegates (which is what Enumerable uses).The expression trees can be inspected by your chosen LINQ provider and turned into an actual query - although that is a black art in itself.This is really down to the ElementType, Expression and Provider - but in reality you rarely need to care about this as a user. Only a LINQ implementer needs to know the gory details.Re comments; I\'m not quite sure what you want by way of example, but consider LINQ-to-SQL; the central object here is a DataContext, which represents our database-wrapper. This typically has a property per table (for example, Customers), and a table implements IQueryable<Customer>. But we don\'t use that much directly; consider:this becomes (by the C# compiler):which is again interpreted (by the C# compiler) as: Importantly, the static methods on Queryable take expression trees, which - rather than regular IL, get compiled to an object model. For example - just looking at the "Where", this gives us something comparable to:Didn\'t the compiler do a lot for us? This object model can be torn apart, inspected for what it means, and put back together again by the TSQL generator - giving something like:(the string might end up as a parameter; I can\'t remember)None of this would be possible if we had just used a delegate. And this is the point of Queryable / IQueryable<T>: it provides the entry-point for using expression trees.All this is very complex, so it is a good job that the compiler makes it nice and easy for us.For more information, look at "C# in Depth" or "LINQ in Action", both of which provide coverage of these topics.Although Reed Copsey and Marc Gravell already described about IQueryable(and also IEnumerable) enough, though i want to add little more here by providing a small example on IQueryable and IEnumerable as many users asked of itExample: I have created two table in databasePrimary key(PersonId) of table Employee is also forgein key(personid) of table PersonNext i added ado.net entity model in my application and create below\n  service class on thatthey contains same linq. It called in program.cs as defined belowThe output is same for both obviouslySo the question is what/where is the difference? It does not seem to\n  have any difference right? Really!!Let\'s have a look on sql queries generated and executed by entity\n  framwork 5 during these periodIQueryable execution partIEnumerable execution partCommon script for both execution partSo you have few questions now, let me guess those and try to answer themWhy different script is generated for same result? Lets find out some points here, all queries has one common part WHERE [Extent1].[PersonId] IN (0,1,2,3)why? Because both function IQueryable<Employee> GetEmployeeAndPersonDetailIQueryable and \nIEnumerable<Employee> GetEmployeeAndPersonDetailIEnumerable of SomeServiceClass contains one common line in linq queries where employeesToCollect.Contains(e.PersonId)Than why \nAND (N\'M\' = [Extent1].[Gender]) part is missing in IEnumerable execution part, while in both function calling we used Where(i => i.Gender == "M") in program.csNow we are in the point where difference came between IQueryable and\n  IEnumerableWhat entity framwork does when an IQueryable method called, it tooks linq statement written inside the method and try to find out if more linq/expression is defind on the resultset, it gather all linq queries defined until the result need to fetch and constructs more appropriate sql query to execute. It provide a lots of benefits like,like here in example sql server returned to application only two rows after IQueryable execution but returned THREE rows for IEnumerable query why?In case of  IEnumerable method, entity framework took linq statement written inside the method and constructs sql query when result need to fetch. it does not include rest linq part to constructs the sql query. Like here no filtering is done in sql server on column gender. But the outputs are same? Because \'IEnumerable filters the result further in application level after retrieving result from sql serverSO, what should someone choose?\nI personally prefer to define function result as IQueryable<T> because there are lots of benefit it has over \'IEnumerable\' like, you could join two or more IQueryable function which generate more specific script to sql server.Here in example you can see an IQueryable Query(IQueryableQuery2) generate more specific script than IEnumerable query(IEnumerableQuery2) which is much more acceptable in my point of view.It allows for further querying further down the line.  If this was beyond a service boundary say, then the user of this IQueryable object would be allowed to do more with it.For instance if you were using lazy loading with nhibernate this might result in graph being loaded when/if needed.