This KB Article says that ASP.NET\'s Response.End() aborts a thread.  Reflector shows that it looks like this: This seems pretty harsh to me.  As the KB article says, any code in the app following Response.End() will not be executed, and that violates the principle of least astonishment. It\'s almost like Application.Exit() in a WinForms app. The thread abort exception caused by Response.End() is not catchable, so surrounding the code in a try...finally won\'t satisfy.  It makes me wonder if I should always avoid Response.End().Can anyone suggest, when should I use Response.End(), when Response.Close() and when HttpContext.Current.ApplicationInstance.CompleteRequest()? ref: Rick Strahl\'s blog entry.Based on the input I\'ve received, my answer is, Yes, Response.End is harmful, but it is useful in some limited cases.Edit - 13 April 2011Further clarity is available here:\n- Useful post on MSDN Blog\n- Useful analysis by Jon ReidIf you had employed an exception logger on your app, it will be watered down with the ThreadAbortExceptions from these benign Response.End() calls.  I think this is Microsoft\'s way of saying "Knock it off!".I would only use Response.End() if there was some exceptional condition and no other action was possible.  Maybe then, logging this exception might actually indicate a warning.Initially I had recommended that you should simply replace all of your calls to \n  [Response.End] with [...] CompleteRequest() calls, but if you want to avoid \n  postback processing and html rendering you\'ll need to add [...] overrides as \n  well.Jon Reid, "Final Analysis"The Server.Transfer, Response.Redirect, Response.End methods all raise \n  exceptions. Each of these methods internally call Response.End. The call to \n  Response.End, in turn, causes a ThreadAbortException exception.HttpApplication.CompleteRequest() sets a variable that causes the thread to \n  skip past most of the events in the HttpApplication event pipeline [--] not the \n  Page event chain but the Application event chain....create a class level variable that flags if the Page should terminate and then \n  check the variable prior to processing your events or rendering your page. [...] \n  I would recommend just overriding the RaisePostBackEvent and Render methodsResponse.End and Response.Close are not used in normal request processing when \nperformance is important. Response.End is a convenient, heavy-handed means of \nterminating request processing with an associated performance penalty. \nResponse.Close is for immediate termination of the HTTP response at the IIS/socket \nlevel and causes issues with things like KeepAlive. The recommended method of ending an ASP.NET request is \nHttpApplication.CompleteRequest. Keep in mind that ASP.NET rendering will have \nto be skipped manually since  HttpApplication.CompleteRequest skips the rest of \nthe IIS/ASP.NET application pipeline, not the ASP.NET Page pipeline (which is \none stage in the app pipeline).Copyright \xc2\xa9 2001-2007, C6 Software, Inc as best I could tell.Causes ASP.NET to bypass all events and filtering in the HTTP pipeline chain of \n  execution and directly execute the EndRequest event.This method is provided only for compatibility with ASP\xe2\x80\x94that is, for \n  compatibility with COM-based Web-programming technology that preceded \n  ASP.NET.preceded ASP.NET. [Emphasis added]This method terminates the connection to the client in an abrupt manner and is \n  not intended for normal HTTP request processing.  [Emphasis added]This question appears near the top of all google searches for information on response.end so for other searches like myself who wish to post CSV/XML/PDF etc in response to an event without rendering the entire ASPX page, this is how I do it. (overriding the render methods is overly complex for such a simple task IMO)On the question of "I still don\'t know the difference between Response.Close and CompleteRequest()" I would say: Do prefer CompleteRequest(), don\'t use Response.Close(). See the following article for a well-done summary of this case. Be aware that even after calling CompleteRequest() some text (e.g. redndered from ASPX code) would be appended to the response output stream. You can prevent it by overriding Render and RaisePostBackEvent methods as described in the following article.BTW: I agree with preventing of using Response.End(), especially when writing data to the http stream to emulate file download. We\'ve used the Response.End() in the past until our log file became full of ThreadAbortExceptions.I disagree with the statement "Response.End is harmful". It\'s definitely not harmful. Response.End does what it says; it ends execution of the page. Using reflector to see how it was implemented should only be viewed as instructive.My 2cent Recommendation\nAVOID using Response.End() as control flow.\nDO use Response.End() if you need to stop request execution and be aware that (typically)* no code will execute past that point.* Response.End() and ThreadAbortExceptions.Response.End() throws a ThreadAbortException as part of it\'s current implementation (as noted by OP). ThreadAbortException is a special exception that can be caught, but \n  it will automatically be raised again at the end of the catch block.To see how to write code that must deal with ThreadAbortExceptions, see @Mehrdad\'s reply to SO How can I detect a threadabortexception in a finally block where he references RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup Method and Constrained Execution RegionsThe Rick Strahl article mentioned is instructive, and make sure to read the comments as well. Note that Strahl\'s issue was specific. He wanted to get the data to the client (an image) and then process hit-tracking database update that didn\'t slow down the serving of the image, which made his the problem of doing something after Response.End had been called.I\'ve never considered using Response.End() to control program flow.However Response.End() can be useful for example when serving files to a user.You have written the file to the response and you don\'t want anything else being added to the response as it may corrupt your file.I\'ve used Response.End() in both .NET and Classic ASP for forcefully ending things before. For instance, I use it when there is a certian amount of login attempts. Or when a secure page is being accesed from an unauthenticated login (rough example):When serving files to a user I\'d use a Flush, the End can cause issues. I\'ve only used Response.End() as a testing/debugging mechanismJudging from what you have posted in terms of research, I would say it would be a bad design if it required Response.End