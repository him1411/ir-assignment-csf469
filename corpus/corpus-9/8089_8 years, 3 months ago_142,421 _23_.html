This question already has an answer here:What is the most exact way of seeing how long something, for example a method call, took in code?The easiest and quickest I would guess is this:But how exact is this? Are there better ways?A better way is to use the Stopwatch class:As others have said, Stopwatch is a good class to use here. You can wrap it in a helpful method:(Note the use of Stopwatch.StartNew(). I prefer this to creating a Stopwatch and then calling Start() in terms of simplicity.) Obviously this incurs the hit of invoking a delegate, but in the vast majority of cases that won\'t be relevant. You\'d then write:You could even make an ITimer interface for this, with implementations of StopwatchTimer, CpuTimer etc where available.As others said, Stopwatch should be the right tool for this. There can be few improvements made to it though, see this thread specifically: Benchmarking small code samples in C#, can this implementation be improved?.I have seen some useful tips by Thomas Maierhofer hereBasically his code looks like: Another approach is to rely on Process.TotalProcessTime to measure how long the CPU has been kept busy running the very code/process, as shown here This can reflect more real scenario since no other process affects the measurement. It does something like:A naked, detailed implementation of the samething can be found here. I wrote a helper class to perform both in an easy to use manner:Just call orThe last part of the Clock is the tricky part. If you want to display the final timing, its up to you to choose what sort of timing you want. I wrote an extension method NormalizedMean which gives you the mean of the read timings discarding the noise. I mean I calculate the the deviation of each timing from the actual mean, and then I discard the values which was farer (only the slower ones) from the mean of deviation (called absolute deviation; note that its not the often heard standard deviation), and finally return the mean of remaining values. This means, for instance, if timed values are { 1, 2, 3, 2, 100 } (in ms or whatever), it discards 100, and returns the mean of { 1, 2, 3, 2 } which is 2. Or if timings are { 240, 220, 200, 220, 220, 270 }, it discards 270, and returns the mean of { 240, 220, 200, 220, 220 } which is 220.Use the Stopwatch classSystem.Diagnostics.Stopwatch is designed for this task.Stopwatch is fine, but loop the work 10^6 times, then divide by 10^6.\nYou\'ll get a lot more precision.I\'m using this: From my blog: C# Time Measurement For Performance Testing (Not in English)Yes there are some function on Windows kernel