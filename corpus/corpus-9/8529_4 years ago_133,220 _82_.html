The first screen of my application is a UITableViewController without a navigation bar, which means that the content flows under the status bar so there\'s a lot of text collisions. I\'ve adjusted both the properties for Under top bars and Adjust scroll view insets which do actually stop it from scrolling under, but at the cost of keeping the top of the table view under. I\'ve attempted to set the UITableView frame to offset by 20 pixels, but it doesn\'t appear to take effect and as I currently need the app to be compatible with iOS 6 I can\'t jump to iOS 7 Storyboards to force autolayout to use the top height guide. Has anyone found a solution that works for both versions?Things I\'ve tried: setting edgesForExtendedLayout, changing the settings within Storyboard for Under top bars and Adjust scroll view, forcing the frame to a new area.A picture is worth a thousand words:\nFor anyone interested in replicating this, simply follow these steps:If you follow the above steps, when you run the app, you will see that nothing, including tweaking Xcode\'s checkboxes to "Extend Edges Under {Top, Bottom, Opaque} Bars" works to stop the first row from appearing under the status bar, nor can you address this programmatically.E.g. In the above scenario, the following will have no effect:This issue can be very frustrating, and I believe it is a bug on Apple\'s end, especially because it shows up in their own pre-wired UITableViewController from the object library.I disagree with everyone who is trying to solve this by using any form of "Magic Numbers" e.g. "use a delta of 20px". This kind of tightly coupled programming is definitely not what Apple wants us to do here.I have discovered two solutions to this problem:Preserving the UITableViewController\'s scene:\nIf you would like to keep the UITableViewController in the storyboard, without manually placing it into another view, you can embed the UITableViewController in a UINavigationController (Editor > Embed In > Navigation Controller) and uncheck "Shows Navigation Bar" in the inspector. This solves the issue with no extra tweaking needed, and it also preserves your UITableViewController\'s scene in the storyboard.Using AutoLayout and embedding the UITableView into another view (I believe this is how Apple wants us to do this):\nCreate an empty UIViewController and drag your UITableView in it. Then, Ctrl-drag from your UITableView towards the status bar. As the mouse gets to the bottom of the status bar, you will see an Autolayout bubble that says "Top Layout Guide". Release the mouse and choose "Vertical Spacing". That will tell the layout system to place it right below the status bar.I have tested both ways on an empty application and they both work. You may need to do some extra tweaking to make them work for your project.If you are doing things programatically and are using a UITableViewController without a UINavigationController your best bet is to do the following in viewDidLoad:Swift 3  Earlier Swift  The UITableViewController will still scroll behind the status bar but won\'t be under it when scrolled to the top.Please note: This worked for me for the following configuration:If the above two requirements aren\'t met your milage may vary.Original PostI created my view programmatically and this ended up working for me:Source (in topLayoutGuide section at bottom of pg.39).Adding to the top answer:after the 2nd method did not initially seem to work I did some additional tinkering and have found the solution.TLDR; the top answer\'s 2nd solution almost works, but for some versions of xCode ctrl+dragging to "Top Layout Guide" and selecting Vertical Spacing does nothing. However, by first adjusting the size of the Table View and then selecting "Top Space to Top Layout Guide" worksDrag a blank ViewController onto the storyboard.\nDrag a UITableView object into the View. (Not UITableViewController). Position it in the very center using the blue layout guides.\n\nCreate your custom subclass of UIViewController, and add the <UITableViewDataSource, UITableViewDelegate> protocols.  Don\'t forget to set your storyboard\'s ViewController to this class in the Identity Inspector.Create an outlet for your TableView in your implementation file, and name it "tableView"\nNow for the part of not clipping into the status bar.Now you can set up your table view like normal, and it won\'t clip the status bar!https://developer.apple.com/library/ios/documentation/userexperience/conceptual/TransitionGuide/SupportingEarlieriOS.html#//apple_ref/doc/uid/TP40013174-CH14-SW1This is how to write it in "Swift"\nAn adjustment to @lipka\'s answer:Select UIViewController on your storyboard an uncheck option Extend Edges Under Top Bars.\nWorked for me.\n: )For Xcode 7, un-ticking the \'translucent\' check mark for the Navigation Bar worked for me.This will fix it for a UITableViewController (without any magic numbers).  The only thing I couldn\'t get it to fix is if you are on a phone call, in which case the top of the tableView is pushed down too much.  If anyone knows how to solve that, please let us know.chappjc\'s answer works great when working with XIBs. I found the cleanest solution when creating TableViewControllers programmatically is by wrapping the UITableViewController instance in another UIViewController and setting constraints accordingly.Here it is:Cheers, BenI think the approach to using UITableViewController might be a little bit different from what you have done before. It has worked for me, but you might not be a fan of it. What I have done is have a view controller with a container view that points to my UItableViewController. This way I am able to use the TopLayoutGuide provided to my in storyboard. Just add the constraint to the container view and you should be taken care of for both iOS7 and iOS6.I ended up using one extra view with desired background, added after TableView and placed under status bar:It\'s not very pretty, but it\'s rather simple solution, if you need work with xib-less views, and both IOS6 and IOS7I don\'t know how Kosher it is, but I found that this scheme moves the ViewController\'s view down and provides the status bar with a solid background:Of course, replace redColor with whatever color you want for the background.You must separately do one of the swizzles to set the color of the characters/symbols in the status bar.  I use View controller-based status bar appearance = NO and Status bar style = Opaque black style in the plist, to do this globally.Seems to work, and I\'d be interested to hear of any bugs or issues with it.The following solution works well enough in code without using magic constants, and accounts for the user changing the size class, e.g. through rotations or side-by-side apps on ipads:I had a UISearchBar at the top of my UITableView and the following worked;Share and enjoy...I have done this for Retina/Non-Retina display asI got it work by setting size to freeformAbrahamchez\'s solution \nhttps://developer.apple.com/library/ios/qa/qa1797/_index.html\nworked for me as follows. I had a single UITableviewcontroller as my initial view. I had tried the offset code and embedding in a navcon but neither solved the statusbar transparency.Add a Viewcontroller and make it the initial view. This should show you critical Top & Bottom Layout Guides.Drag the old Tableview into the View in the new controller.Do all the stuff to retrofit the table into the new controller:Change your old view controller.h file to inherit/subclass from UIViewController instead of UITableViewController.Add UITableViewDataSource and UITableViewDelegate to the viewcontroller\'s .h.Re-connect anything needed in the storyboard, such as a Searchbar.The big thing is to get the constraints set up, as in the Apple Q&A. I didn\'t bother inserting a toolbar. Not certain the exact sequence. But a red icon appeared on the Layout Guides, perhaps when I built. I clicked it and let Xcode install/clean up the constraints. Then I clicked everywhere until I found the Vertical Space constraint and changed its top value from -20 to 0 and it worked perfectly.I am using a UISplitViewController with a navigationcontroller and a tableviewcontroller. This worked for me in the master view after trying many solutions here:It\'s similar to Hot Licks\' solution but applies the subview to the navigationController.Here is a Swift 2.3. (Xcode 8.0) solution. I have created a subclass of UITableView.The content Inset should always be Zero (by default). I am setting it Zero manually. You can also add a check method which makes the check and if it is anything other than what you want it to be just get the correct rect. The change will reflect only when the tableview is drawn (which does not happen often). Don\'t forget to update the TableView in your IB (in the TableViewController or just TableView inside your ViewController).see all solutions:\nmy project is just use xib, so, the solution with storyboard not worked for me.\nself.edgesForExtendedLayout = UIRectEdgeNone; \njust works for controller if navigationbar is visible.\nbut if your view is just have status bar, that will not work.\nso i combine two conditons.help this works.Works for swift 3 - In viewDidLoad();This code:\n1. Gets the height of the status bar\n2. Gives the top of the table view a content inset equal to the height of the status bar.\n3. Gives the scroll indicator the same inset, so it appears below the status bar.If you also need to support iOS 6, you\'ll have to conditionally move it down. That is, in iOS 7 you should just move it down 20 points (either through frame manipulation or using auto-layout), and in iOS 6 you leave it alone. I don\'t believe you can do this in IB, so you\'ll have to do it in code.EDITYou can actually do this in IB, by using the iOS6/iOS7 deltas. Set your position in iOS 7, then for iOS 6 set the delta Y to -20points. See this SO question for more information.Just set frame for your tableview. and put it 44p down from top. in iOS 7 Everything started from top left window. Also status bar is a part of window.