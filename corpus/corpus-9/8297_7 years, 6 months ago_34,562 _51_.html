What are best ways to Debug Clojure code, while using the repl?There\'s also dotrace, which allows you to look at the inputs and outputs of selected functions.produces the output:In Clojure 1.4, dotrace has moved:You need the dependency:And you need to add the ^:dynamic to the function definitionThen Bob is once again your uncle:I have a little debugging macro that I find very useful:You can insert it wherever you want to watch what\'s going on and when:Emacs\'s CIDER got a source debugger that you can step expression by expression inside an Emacs buffer and even inject new values. You can read all about it here. A demo screenshot:My favourite method is a liberal sprinkling of printlns all over the code... Turning them on and off is easy thanks to the #_ reader macro (which makes the reader read in the following form, then pretend it\'s never seen it). Or you could use a macro expanding either to a passed-in body or nil depending on the value of some special variable, say *debug*:With a (def *debug* false) in there, this will expand to nil. With true, it\'ll expand to body wrapped in a do.The accepted answer to this SO question: Idiomatic Clojure for progress reporting? is very helpful when debugging sequence operations.Then there\'s something which is currently incompatible with swank-clojure\'s REPL, but is too good not to mention: debug-repl. You can use it in a standalone REPL, which is easy to get e.g. with Leiningen (lein repl); and if you\'re launching your programme from the command line, then it\'s going to bring its own REPL up right in your terminal. The idea is that you can drop the debug-repl macro in anywhere you like and have it bring up its own REPL when the programme\'s execution reaches that point, with all locals in scope etc. A couple of relevant links: The Clojure debug-repl, Clojure debug-repl tricks, how \'bout a debug-repl (on the Clojure Google group), debug-repl on Clojars.swank-clojure does an adequate job of making SLIME\'s built-in debugger useful when working with Clojure code -- note how the irrelevant bits of the stacktrace are greyed out so it\'s easy to find the actual problem in the code being debugged. One thing to keep in mind is that anonymous functions without "name tags" appear in the stacktrace with basically no useful information attached to them; when a "name tag" is added, it does appear in the stacktrace and all is well again:You can also insert code to drop yourself into a REPL with all the local bindings, using Alex Osborne\'s debug-repl:Then to use it, insert it wherever you want the repl to start:I stick this in my user.clj so it\'s available in all REPL sessions."best ways to Debug Clojure code, while using the repl"Slightly left-field, but \'using the REPL iteself\'.I\'ve been writing hobbyist Clojure for over a year and haven\'t felt a great need for any debugging tools. If you keep your functions small, and run each one with expected inputs at the REPL and observe the results then it should be possible to have a pretty clear picture of how your code is behaving.I find a debugger is most useful for observing STATE in a running application. Clojure makes it easy (and fun!) to write in a functional style with immutable data structures (no changing state). This massively reduces the need for a debugger. Once I know that all the components behave as I expect (paying particular attention to the types of things) then the large scale behaviour is rarely a problem.If you use emacs/slime/swank, then try this at the REPL:It doesn\'t give you a full stack trace like you\'d get under LISP, but it\'s good for poking\naround.This is the fine work of:http://hugoduncan.org/post/2010/swank_clojure_gets_a_break_with_the_local_environment.xhtmlas was mentioned in a comment above.For IntelliJ there\'s an excellent Clojure plugin called Cursive. Among other things, it provides a REPL which you can run in debug mode and step through your Clojure code just like you would for e.g. Java.I would second Peter Westmacott\'s answer though in that in my experience just running pieces of my code in the REPL is most of the time a sufficient form of debugging.Hugo Duncan and collaborators continue to do amazing work with the ritz project. Ritz-nrepl is a nREPL server with debug capabilities. Watch Hugo\'s Debuggers in Clojure talk at Clojure/Conj 2012 to see it in action, in the video some of the slides aren\'t readable so you may want to view the slides from here.As of 2016 you can use Debux, a simple debugging library for Clojure/Script that works in conjunction with your repl as well as your browser\'s console. You can sprinkle dbg (debug)  or clog (console.log) macros in your code and easily observe results of individual functions, etc, printed to your REPL and/or console. From the project\'s Readme:Basic usageThis is a simple example. The macro dbg prints an original form and\n  pretty-prints the evaluated value on the REPL window. Then it returns\n  the value without interfering with the code execution.If you wrap the code with dbg like this,(* 2 (dbg (+ 10 20))) ; => 60 the following will be printed in the\n  REPL window.REPL output: dbg: (+ 10 20) =>   30Nested dbgThe dbg macro can be nested.(dbg (* 2 (dbg (+ 10 20)))) ; => 60 REPL output: dbg: (* 2 (dbg (+ 10 20))) =>   60Use spyscope which implement a custom reader macro so that your debug code is also production code\nhttps://github.com/dgrnbrg/spyscopeHere\'s a nice macro for debugging complicated let forms: ...and an essay explaining its use.Coming from Java and being familiar with Eclipse, I like what Counterclockwise (the Eclipse plugin for Clojure development) has to offer: http://doc.ccw-ide.org/documentation.html#_debug_clojure_codeFunction version of def-let, which turns a let into a series of defs. Some credit goes to hereUsage: Needs to quote the content with a quotation, e.g. 