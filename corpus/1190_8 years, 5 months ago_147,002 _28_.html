I understand lambdas and the Func and Action delegates. But expressions stump me. In what circumstances would you use an Expression<Func<T>> rather than a plain old Func<T>?When you want to treat lambda expressions as expression trees and look inside them instead of executing them. For example, LINQ to SQL gets the expression and converts it to the equivalent SQL statement and submits it to server (rather than executing the lambda).Conceptually, Expression<Func<T>> is completely different from Func<T>. Func<T> denotes a delegate which is pretty much a pointer to a method and Expression<Func<T>> denotes a tree data structure for a lambda expression. This tree structure describes what a lambda expression does rather than doing the actual thing. It basically holds data about the composition of expressions, variables, method calls, ... (for example it holds information such as this lambda is some constant + some parameter). You can use this description to convert it to an actual method (with Expression.Compile) or do other stuff (like the LINQ to SQL example) with it. The act of treating lambdas as anonymous methods and expression trees is purely a compile time thing.will effectively compile to an IL method that gets nothing and returns 10.will be converted to a data structure that describes an expression that gets no parameters and returns the value 10: larger imageWhile they both look the same at compile time, what the compiler generates is totally different.I\'m adding an answer-for-noobs because these answers seemed over my head, until I realized how simple it is. Sometimes it\'s your expectation that it\'s complicated that makes you unable to \'wrap your head around it\'.I didn\'t need to understand the difference until I walked into a really annoying \'bug\' trying to use LINQ-to-SQL generically:This worked great until I started getting OutofMemoryExceptions on larger datasets. Setting breakpoints inside the lambda made me realize that it was iterating through each row in my table one-by-one looking for matches to my lambda condition. This stumped me for a while, because why the heck is it treating my data table as a giant IEnumerable instead of doing LINQ-to-SQL like it\'s supposed to? It was also doing the exact same thing in my LINQ-to-MongoDb counterpart.The fix was simply to turn Func<T, bool> into Expression<Func<T, bool>>, so I googled why it needs an Expression instead of Func, ending up here.An expression simply turns a delegate into a data about itself. So a => a + 1 becomes something like "On the left side there\'s an int a. On the right side you add 1 to it." That\'s it. You can go home now. It\'s obviously more structured than that, but that\'s essentially all an expression tree really is--nothing to wrap your head around.Understanding that, it becomes clear why LINQ-to-SQL needs an Expression, and a Func isn\'t adequate. Func doesn\'t carry with it a way to get into itself, to see the nitty-gritty of how to translate it into a SQL/MongoDb/other query. You can\'t see whether it\'s doing addition or multiplication on subtraction. All you can do is run it. Expression, on the other hand, allows you to look inside the delegate and see everything it\'s wanting to do, empowering you to translate it into whatever you want, like a SQL query. Func didn\'t work because my DbContext was blind to what was actually in the lambda expression to turn it into SQL, so it did the next best thing and iterated that conditional through each row in my table.Edit: expounding on my last sentence at John Peter\'s request:IQueryable extends IEnumerable, so IEnumerable\'s methods like Where() obtain overloads that accept Expression. When you pass an Expression to that, you keep an IQueryable as a result, but when you pass a Func, you\'re falling back on the base IEnumerable and you\'ll get an IEnumerable as a result. In other words, without noticing you\'ve turned your dataset into a list to be iterated as opposed to something to query. It\'s hard to notice a difference until you really look under the hood at the signatures.An extremely important consideration in the choice of Expression vs Func is that IQueryable providers like LINQ to Entities can \'digest\' what you pass in an Expression, but will ignore what you pass in a Func. I have two blog posts on the subject:More on Expression vs Func with Entity Framework and\nFalling in Love with LINQ - Part 7: Expressions and Funcs (the last section)I\'d like to add some notes about the differences between Func<T> and Expression<Func<T>>:There\'s an article which describes the details with code samples: \nLINQ: Func<T> vs. Expression<Func<T>>.Hope it will be helpful.LINQ is the canonical example (for example, talking to a database), but in truth, any time you care more about expressing what to do, rather  than actually doing it. For example, I use this approach in the RPC stack of protobuf-net (to avoid code-generation etc) - so you call a method with:This deconstructs the expression tree to resolve SomeMethod (and the value of each argument), performs the RPC call, updates any ref/out args, and returns the result from the remote call. This is only possible via the expression tree. I cover this more here.Another example is when you are building the expression trees manually for the purpose of compiling to a lambda, as done by the generic operators code.There is a more philosophical explanation about it from Krzysztof Cwalina\'s book(Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries);You would use an expression when you want to treat your function as data and not as code.  You can do this if you want to manipulate the code (as data).  Most of the time if you don\'t see a need for expressions then you probably don\'t need to use one.The primary reason is when you don\'t want to run the code directly, but rather, want to inspect it. This can be for any number of reasons:I don\'t see any answers yet that mention performance.  Passing Func<>s into Where() or Count() is bad.  Real bad.  If you use a Func<> then it calls the IEnumerable LINQ stuff instead of IQueryable, which means that whole tables get pulled in and then filtered.  Expression<Func<>> is significantly faster, especially if you are querying a database that lives another server.