How do I use JUnit to test a class that has internal private methods, fields or nested classes?It seems bad to change the access modifier for a method just to be able to run a test. If you have somewhat of a legacy application, and you\'re not allowed to change the visibility of your methods, the best way to test private methods is to use reflection. Internally we\'re using helpers to get/set private and private static variables as well as invoke private and private static methods. The following patterns will let you do pretty much anything related to the private methods and fields. Of course you can\'t change private static final variables through reflection.And for fields:Notes:\n  1. targetClass.getDeclaredMethod(methodName, argClasses) lets you look into private methods. The same thing applies for\n  getDeclaredField.\n  2. The setAccessible(true) is required to play around with privates.The best way to test a private method is via another public method. If this cannot be done, then one of the following conditions is true:When I have private methods in a class that are sufficiently complicated that I feel the need to test the private methods directly, that is a code smell: my class is too complicated.  My usual approach to addressing such issues is to tease out a new class that contains the interesting bits.  Often, this method and the fields it interacts with, and maybe another method or two can be extracted in to a new class.  The new class exposes these methods as \'public\', so they\'re accessible for unit testing.  The new and old classes are now both simpler than the original class, which is great for me (I need to keep things simple, or I get lost!).Note that I\'m not suggesting that people create classes without using their brain! The point here is to use the forces of unit testing to help you find good new classes.  I have used reflection to do this in the past, and in my opinion it was a big mistake.Strictly speaking, you should not be writing unit tests that directly test private methods. What you should be testing is the public contract that the class has with other objects; you should never directly test an object\'s internals. If another developer wants to make a small internal change to the class, which doesn\'t affect the classes public contract, he/she then has to modify your reflection based test to ensure that it works. If you do this repeatedly throughout a project, unit tests then stop being a useful measurement of code health, and start to become a hindrance to development, and an annoyance to the development team.What I recommend doing instead is using a code coverage tool such as Cobertura, to ensure that the unit tests you write provide decent coverage of the code in private methods. That way, you indirectly test what the private methods are doing, and maintain a higher level of agility.From this article: Testing Private Methods with JUnit and SuiteRunner (Bill Venners), you basically have 4 options:Generally a unit test is intended to exercise the public interface of a class or unit. Therefore, private methods are implementation detail that you would not expect to test explicitly.Just two examples of where I would want to test a private method:I understand the idea of only testing the "contract". But I don\'t see one can advocate actually not testing code - your mileage may vary.So my tradeoff involves complicating the JUnits with reflection, rather than compromising my security & SDK.The private methods are called by a public method, so the inputs to your public methods should also test private methods that are called by those public methods. When a public method fails, then that could be a failure in the private method.To test legacy code with large and quirky classes, it is often very helpful to be able to test the one private (or public) method I\'m writing right now.I use the junitx.util.PrivateAccessor-package. Lots of helpful one-liners for accessing private methods and private fields.Hope that was helpful :)Having tried Cem Catikkas\' solution using reflection, I\'d have to say his was a more elegant solution than I have described here. However, if you\'re looking for an alternative to using reflection, and have access to the source you\'re testing, this will still be an option.There is possible merit in testing private methods of a class, particularly with test-driven development, where you would like to design small tests before you write any code.Creating a test with access to private members and methods can test areas of code which are difficult to target specifically with access only to public methods. If a public method has several steps involved, it can consist of several private methods, which can then be tested individually.Advantages:Disadvantages:However, if continuous testing requires this method, it may be a signal that the private methods should be extracted, which could be tested in the traditional, public way.Here is a convoluted example of how this would work:The inner class would be compiled to ClassToTest$StaticInnerTest.See also: Java Tip 106: Static inner classes for fun and profitIf you\'re trying to test existing code that you\'re reluctant or unable to change, reflection is a good choice.If the class\'s design is still flexible, and you\'ve got a complicated private method that you\'d like to test separately, I suggest you pull it out into a separate class and test that class separately. This doesn\'t have to change the public interface of the original class; it can internally create an instance of the helper class and call the helper method.If you want to test difficult error conditions coming from the helper method, you can go a step further. Extract an interface from the helper class, add a public getter and setter to the original class to inject the helper class (used through its interface), and then inject a mock version of the helper class into the original class to test how the original class responds to exceptions from the helper. This approach is also helpful if you want to test the original class without also testing the helper class.As others have said... don\'t test private methods directly. Here are a few thoughts:Run the code coverage on the unit tests. If you see that methods are not fully tested add to the tests to get the coverage up. Aim for 100% code coverage, but realize that you probably won\'t get it.Private methods are consumed by public ones. Otherwise, they\'re dead code. That\'s why you test the public method, asserting the expected results of the public method and thereby, the private methods it consumes.Testing private methods should be tested by debugging before running your unit tests on public methods.They may also be debugged using test-driven development, debugging your unit tests until all your assertions are met.I personally believe it is better to create classes using TDD; creating the public method stubs, then generating unit tests with all the assertions defined in advance, so the expected outcome of the method is determined before you code it. This way, you don\'t go down the wrong path of making the unit test assertions fit the results. Your class is then robust and meets requirements when all your unit tests pass.Another approach I have used is to change a private method to package private or protected then complement it with the @VisibleForTesting annotation of the Google Guava library.This will tell anybody using this method to take caution and not access it directly even in a package. Also a test class need not be in same package physically, but in the same package under the test folder.For example, if a method to be tested is in src/main/java/mypackage/MyClass.java then your test call should be placed in src/test/java/mypackage/MyClassTest.java. That way, you got access to the test method in your test class.If using Spring, ReflectionTestUtils provides some handy tools that help out here with minimal effort. For example, to set up a mock on a private member without being forced to add an undesirable public setter:Testing private methods breaks the encapsulation of your class because every time you change the internal implementation you break client code (in this case, the tests).So don\'t test private methods.Since you\'re using JUnit, have a look at junit-addons. It has the ability to ignore the Java security model and access private methods and attributes.If you want to test private methods of a legacy application where you can\'t change the code, one option is jMockit, which will allow you to create mocks to an object even when they\'re private to the class.In the Spring Framework you can test private methods using this method:For example:The answer from JUnit.org FAQ page:But if you must...If you are using JDK 1.3 or higher, you can use reflection to subvert\n  the access control mechanism with the aid of the PrivilegedAccessor.\n  For details on how to use it, read this article.If you are using JDK 1.6 or higher and you annotate your tests with\n  @Test, you can use Dp4j to inject reflection in your test methods. For\n  details on how to use it, see this test script.P.S. I\'m the main contributor to Dp4j, ask me if you need help. :)I tend not to test private methods.  There lies madness.  Personally, I believe you should only test your publicly exposed interfaces (and that includes protected and internal methods).  Today, I pushed a library to help testing private methods and fields. It has been designed with Android in mind, but it can really be used for any Java project.If you got some code with private methods or fields or constructors, you can use BoundBox. It does exactly what you are looking for.\nHere below is an example of a test that accesses two private fields of an Android activity to test it:BoundBox makes it easy to test private/protected fields, methods and constructors. You can even access stuff that is hidden by inheritance. Indeed, BoundBox breaks encapsulation. It will give you access to all that through reflection, BUT everything is checked at compile time.It is ideal for testing some legacy code. Use it carefully. ;)https://github.com/stephanenicolas/boundboxHere is my generic function to test private fields:A private method is only to be accessed within the same class. So there is no way to test a \xe2\x80\x9cprivate\xe2\x80\x9d method of a target class from any test class. A way out is that you can perform unit testing manually or can change your method from \xe2\x80\x9cprivate\xe2\x80\x9d to \xe2\x80\x9cprotected\xe2\x80\x9d.And then a protected method can only be accessed within the same package where the class is defined. So, testing a protected method of a target class means we need to define your test class in the same package as the target class.If all the above does not suits your requirement, use the  reflection way to access the private method.  I would suggest you refactoring your code a little bit. When you have to start thinking about using reflection or other kind of stuff, for just testing your code, something is going wrong with your code.You mentioned different types of problems. Let\'s start with private fields. In case of private fields I would have added a new constructor and injected fields into that. Instead of this:I\'d have used this:This won\'t be a problem even with some legacy code. Old code will be using an empty constructor, and if you ask me, refactored code will look cleaner, and you\'ll be able to inject necessary values in test without reflection.Now about private methods. In my personal experience when you have to stub a private method for testing, then that method has nothing to do in that class. A common pattern, in that case, would be to wrap it within an interface, like Callable and then you pass in that interface also in the constructor (with that multiple constructor trick):Mostly all that I wrote looks like it\'s a dependency injection pattern. In my personal experience it\'s really useful while testing, and I think that this kind of code is cleaner and will be easier to maintain. I\'d say the same about nested classes. If a nested class contains heavy logic it would be better if you\'d moved it as a package private class and have injected it into a class needing it.There are also several other design patterns which I have used while refactoring and maintaining legacy code, but it all depends on cases of your code to test. Using reflection mostly is not a problem, but when you have an enterprise application which is heavily tested and tests are run before every deployment everything gets really slow (it\'s just annoying and I don\'t like that kind of stuff).There is also setter injection, but I wouldn\'t recommended using it. I\'d better stick with a constructor and initialize everything when it\'s really necessary, leaving the possibility for injecting necessary dependencies.As many above have suggested, a good way is to test them via your public interfaces.If you do this, it\'s a good idea to use a code coverage tool (like Emma) to see if your private methods are in fact being executed from your tests.First, I\'ll throw this question out: Why do your private members need isolated testing? Are they that complex, providing such complicated behaviors as to require testing apart from the public surface? It\'s unit testing, not \'line-of-code\' testing. Don\'t sweat the small stuff.If they are that big, big enough that these private members are each a \'unit\' large in complexity -- consider refactoring such private members out of this class.If refactoring is inappropriate or infeasible, can you use the strategy pattern to replace access to these private member functions / member classes when under unit test? Under unit test, the strategy would provide added validation, but in release builds it would be simple passthrough.I recently had this problem and wrote a little tool, called Picklock, that avoids the problems of explicitly using the Java reflection API, two examples:Calling methods, e.g. private void method(String s) - by Java reflectionCalling methods, e.g. private void method(String s) - by PicklockSetting fields, e.g. private BigInteger amount; - by Java reflectionSetting fields, e.g. private BigInteger amount; - by PicklockPlease see below for an example;The following import statement should be added:Now you can directly pass the object which has the private method, method name to be called, and additional parameters as below.I\'d use reflection, since I don\'t like the idea of changing the access to a package on the declared method just for the sake of testing. However, I usually just test the public methods which should also ensure the private methods are working correctly.you can\'t use reflection to get private methods from outside the owner class, the private modifier affects reflection alsoThis is not true. You most certainly can, as mentioned in Cem Catikkas\'s answer.