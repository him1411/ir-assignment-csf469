What does Weak Head Normal Form (WHNF) mean? What does Head Normal form (HNF) and Normal Form (NF) mean?Real World Haskell states:The familiar seq function evaluates an expression to what we call head\n  normal form (abbreviated HNF). It stops once it reaches the outermost\n  constructor (the \xe2\x80\x9chead\xe2\x80\x9d). This is distinct from normal form (NF), in\n  which an expression is completely evaluated.You will also hear Haskell programmers refer to weak head normal form\n  (WHNF). For normal data, weak head normal form is the same as head\n  normal form. The difference only arises for functions, and is too\n  abstruse to concern us here.I have read a few resources and definitions (Haskell Wiki and Haskell Mail List and Free Dictionary) but I don\'t get it. Can someone perhaps give an example or provide a layman definition?I am guessing it would be similar to:How do seq and ($!) relate to WHNF and HNF?I am still confused. I know some of the answers say to ignore HNF. From reading the various definitions it seems that there is no difference between regular data in WHNF and HNF. However, it does seem there is a difference when it comes to a function. If there was no difference, why is seq necessary for foldl\'?Another point of confusion is from the Haskell Wiki, which states that seq reduces to WHNF, will do nothing to the following example. Then they say that they have to use seq to force the evaluation. Is that not forcing it to HNF?Common newbie stack overflowing code:People who understand seq and weak head normal form (whnf) can\n  immediately understand what goes wrong here. (acc+x, len+1) is already\n  in whnf, so seq, which reduces a value to whnf, does nothing to this.\n  This code will build up thunks just like the original foldl example,\n  they\'ll just be inside a tuple. The solution is just to force the\n  components of the tuple,  e.g.-Haskell Wiki on StackoverflowI\'ll try to give an explanation in simple terms. As others have pointed out, head normal form does not apply to Haskell, so I will not consider it here.An expression in normal form is fully evaluated, and no sub-expression could be evaluated any further (i.e. it contains no un-evaluated thunks).These expressions are all in normal form:These expressions are not in normal form:An expression in weak head normal form has been evaluated to the outermost data constructor or lambda abstraction (the head). Sub-expressions may or may not have been evaluated. Therefore, every normal form expression is also in weak head normal form, though the opposite does not hold in general.To determine whether an expression is in weak head normal form, we only have to look at the outermost part of the expression. If it\'s a data constructor or a lambda, it\'s in weak head normal form. If it\'s a function application, it\'s not.These expressions are in weak head normal form:As mentioned, all the normal form expressions listed above are also in weak head normal form.These expressions are not in weak head normal form:Evaluating an expression to weak head normal form may require that other expressions be evaluated to WHNF first. For example, to evaluate 1 + (2 + 3) to WHNF, we first have to evaluate 2 + 3. If evaluating a single expression leads to too many of these nested evaluations, the result is a stack overflow.This happens when you build up a large expression that does not produce any data constructors or lambdas until a large part of it has been evaluated. These are often caused by this kind of usage of foldl:Notice how it has to go quite deep before it can get the expression into weak head normal form.You may wonder, why does not Haskell reduce the inner expressions ahead of time? That is because of Haskell\'s laziness. Since it cannot be assumed in general that every subexpression will be needed, expressions are evaluated from the outside in.(GHC has a strictness analyzer that will detect some situations where a subexpression is always needed and it can then evaluate it ahead of time. This is only an optimization, however, and you should not rely on it to save you from overflows).This kind of expression, on the other hand, is completely safe:To avoid building these large expressions when we know all the subexpressions will have to be evaluated, we want to force the inner parts to be evaluated ahead of time.seq is a special function that is used to force expressions to be evaluated. Its semantics are that seq x y means that whenever y is evaluated to weak head normal form, x is also evaluated to weak head normal form.It is among other places used in the definition of foldl\', the strict variant of foldl.Each iteration of foldl\' forces the accumulator to WHNF. It therefore avoids building up a large expression, and it therefore avoids overflowing the stack.But as the example on HaskellWiki mentions, this does not save you in all cases, as the accumulator is only evaluated to WHNF. In the example, the accumulator is a tuple, so it will only force evaluation of the tuple constructor, and not acc or len.To avoid this, we must make it so that evaluating the tuple constructor forces evaluation of acc and len. We do this by using seq.The section on Thunks and Weak Head Normal Form in the Haskell Wikibooks description of laziness provides a very good description of WHNF along with this helpful depiction:Evaluating the value (4, [1, 2]) step by step. The first stage is\n  completely unevaluated; all subsequent forms are in WHNF, and the last\n  one is also in normal form.Haskell programs are expressions and they are run by performing evaluation.To evaluate an expression, replace all function applications by their definitions. The order in which you do this does not matter much, but it\'s still important: start with the outermost application and proceed from left to right; this is called lazy evaluation.Example:Evaluation stops when there are no more function applications left to replace. The result is in normal form (or reduced normal form, RNF). No matter in which order you evaluate an expression, you will always end up with the same normal form (but only if the evaluation terminates).There is a slightly different description for lazy evaluation. Namely, it says that you should evaluate everything to weak head normal form only. There are precisely three cases for an expression to be in WHNF:In other words, the head of the expression (i.e. the outermost function application) cannot be evaluated any further, but the function argument may contain unevaluated expressions.Examples of WHNF:NotesA good explanation with examples is given at http://foldoc.org/Weak+Head+Normal+Form  Head normal form simplifies even the bits of an expression inside of a function abstraction, while "weak" head normal form stops at function abstractions.From the source, if you have:that is in weak head normal form, but not head normal form... because the possible application is stuck inside of a function that can\'t be evaluated yet.Actual head normal form would be difficult to implement efficiently.  It would require poking around inside of functions.  So the advantage of weak head normal form is that you can still implement functions as an opaque type, and hence it\'s more compatible with compiled languages and optimization.The WHNF does not want the body of lambdas to be evaluated, soseq wants its first argument to be in WHNF, soevaluates toinstead of, what would be using HNFBasically, suppose you have some sort of thunk, t.Now, if we want to evaluate t to WHNF or NHF, which are the same except for functions, we would find that we get something liket1 : t2 where t1 and t2 are thunks. In this case, t1 would be your 0 (or rather, a thunk to 0 given no extra unboxing)seq and $! evalute WHNF. Note that