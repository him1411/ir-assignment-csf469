I have an object:I am looking for a native method, similar to Array.prototype.map that would be used as follows:Does JavaScript have such a map function for objects? (I want this for Node.JS, so I don\'t care about cross-browser issues.)There is no native map to the Object object, but how about this:But you could easily iterate over an object using for ... in:UpdateA lot of people are mentioning that the previous methods do not return a new object, but rather operate on the object itself. For that matter I wanted to add another solution that returns a new object and leaves the original object as it is:Array.prototype.reduce reduces an array to a single value by somewhat merging the previous value with the current. The chain is initialized by an empty object {}. On every iteration a new key of myObject is added with its square as value.No native methods, but lodash#mapValues will do the job brilliantlyHow about a one liner with immediate variable assignment in plain JS (ES6 / ES2015) ?Making use of spread operator and computed key name syntax:jsbinAnother version using reduce:jsbinFirst example as a function:jsbinIf you want to map a nested object recursively in a functional style, it can be done like this:jsbinOr more imperatively, like this:jsbinSince ES7 / ES2016 you can use Object.entries instead of Object.keys e.g. like this:In some rare situation you may need to map a class-like object which holds properties of an inherited object on its prototype-chain. In such cases Object.keys() won\'t work, because Object.keys() does not enumerate inherited properties. If you need to map inherited properties, you should use for (key in myObj) {...}.Here is an example of an object which inherits the properties of another object and how Object.keys() doesn\'t work in such scenario.jsbinHowever, please do me a favor and avoid inheritance. :-)It\'s pretty easy to write one:with example code:NB: this version also allows you to (optionally) set the this context for the callback, just like the Array method.EDIT - changed to remove use of Object.prototype, to ensure that it doesn\'t clash with any existing property named map on the object.You could use Object.keys and then forEach over the returned array of keys:Or in a more modular fashion:Note that Object.keys returns an array containing only the object\'s own enumerable properties, thus it behaves like a for..in loop with a hasOwnProperty check.I came here looking to find and answer for mapping an object to an array and got this page as a result. In case you came here looking for the same answer I was, here is how you can map and object to an array. You can use map to return a new array from the object like so:The accepted answer has two drawbacks:Please note that all functions are defined in curried form.This is not the fastest solution, but a declarative and reusable one. Here is the same implementation as a one-line, succinct but less readable:ES2015 specified the iterator and iterable protocols. But objects are still not iterable and thus not mappable. The reason is the mixing of data and program level.For maximum performance.If your object doesn\'t change often but needs to be iterated on often I suggest using a native Map as a cache.Object.entries already works in Chrome, Edge, Firefox and beta Opera so it\'s a future-proof feature.\nIt\'s from ES7 so polyfill it https://github.com/es-shims/Object.entries for IE where it doesn\'t work.This is straight bs, and everyone in the JS community knows it. There should be this functionality:here is the naive implementation:it is super annoying to have to implement this yourself all the time ;)Why not throw another hat in the ring ?Go ahead and be braveBased on @Amberlamps answer, here\'s a utility function\n(as a comment it looked ugly)and the use is:The map function does not exist on the Object.prototype however you can emulate it like soIf you\'re interested in mapping not only values but also keys, I have written Object.map(valueMapper, keyMapper), that behaves this way:Hey wrote a little mapper function that might help.I needed a version that allowed modifying the keys as well (based on @Amberlamps and @yonatanmn answers);factObject=Edit: slight change to pass in the starting object {}.  Allows it to be [] (if the keys are integers)I specifically wanted to use the same function that I was using for arrays for a single object, and wanted to keep it simple. This worked for me:I know this is an old question, but some of these answers are way too long and complex.You can use a simple for-in loop through ordered pairs. The code below works well with your array object. hasOwnProperty() is used because you created three properties (with values) for your object. Minimal version: