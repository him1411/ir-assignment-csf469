I created a container with -d so it\'s not interactive.I see that the container has exited:Now I would like to run occasional commands on the machine and exit. Just to get the response.I tried to start the machine. I tried attaching. I thought I could call run with a container, but that does not seem to be allowed. Using start just seems to run and then exist quickly.I\'d like to get back into interactive mode after exiting.I tried:But I get:But if I start it, it exits anyway. Catch 22. I can\'t win.In October 2014 the Docker team introduced docker exec command: https://docs.docker.com/engine/reference/commandline/exec/So now you can run any command in a running container just knowing its ID (or name):Note that exec command works only on already running container. If the container is currently stopped, you need to first run it with the following command:The most important thing here is the -d option, which stands for detached. It means that the command you initially provided to the container (/bin/bash) will be run in the background and the container will not stop immediately.Your container will exit as the command you gave it will end. Use the following options to keep it live:So your new run command is:If you would like to attach to an already running container:In these examples /bin/bash is used as the command.To expand on katrmr\'s answer, if the container is stopped and can\'t be started due to an error, you\'ll need to commit it to an image. Then you can launch bash in the new image:Some of the answers here are misleading because they concern containers that are running, not stopped.Sven Dowideit explained on the Docker forum that containers are bound to their process (and Docker can\'t change the process of a stopped container, seemingly due at least to its internal structure: https://github.com/docker/docker/issues/1437). So, basically the only option is to commit the container to an image and run it with a different command.See https://forums.docker.com/t/run-command-in-stopped-container/343\n(I believe the "ENTRYPOINT with arguments" approach wouldn\'t work either, since you still wouldn\'t be able to change the arguments to a stopped container.)So I think the answer is simple than many misleading answers above.To start an existing container which is stoppedTo stop a running containerThen to login to the interactive shell of a containerCreating a container and sending commands to it, one by one:This is a combined answer I made up using the CDR LDN answer above and the answer I found here.The following example starts an Arch Linux container from an image, and then installs git on that container using the pacman tool:That is all.I had to use bash -c to run my command:\ndocker exec -it CONTAINER_ID bash -c "mysql_tzinfo_to_sql /usr/share/zoneinfo | mysql mysql"Assuming the image is using the default entrypoint /bin/sh -c, running /bin/bash will exit  immediately in daemon mode (-d). If you want this container to run an interactive shell, use -it instead of -d. If you want to execute arbitrary commands in a container usually executing another process, you might want to try nsenter or nsinit.  Have a look at https://blog.codecentric.de/en/2014/07/enter-docker-container/ for the details.Unfortunately it is impossible to override ENTRYPOINT with arguments with docker run --entrypoint to achieve this goal.Note: you can override the ENTRYPOINT setting using --entrypoint, but\n  this can only set the binary to exec (no sh -c will be used).Simple answer: start and attach at the same time. In this case you are doing exactly what you asked for.make sure to change <CONTAINER_ID/CONTAINER_NAME>