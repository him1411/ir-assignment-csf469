Suppose a user of your website enters a date range.You need to send this date to a server for some processing, but the server expects all dates and times to be in UTC. Now suppose the user is in Alaska or Hawaii or Fiji. Since they are in a timezone quite different from UTC, the date range needs to be converted to something like this:Using the JavaScript Date object, how would you convert the first "localized" date range into something the server will understand?The format you need is created with the .toISOString() method.  For older browsers (ie8 and under), which don\'t natively support this method, the shim can be found here: This will give you the ability to do what you need:For Timezone work, moment.js and moment.js timezone are really invaluable tools...especially for navigating timezones between client and server javascript.Simple and stupid Here\'s my method:The resulting utc object isn\'t really an UTC date, but a local date shifted to match the UTC time (see comments). However, in practice it does the job.Convert to ISO without changing date/timeConvert to ISO with change in date/time(date/time will be changed)Fiddle linkBrowsers may differ, and you should also remember to not trust any info generated by the client, that being said, the below statement works for me (Google Chrome v24 on Mac OS X 10.8.2)var utcDate = new Date(new Date().getTime());edit: "How is this different than just new Date()?" see here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateAdding the 60000 * Date.getTimezoneOffset() as previous answers have stated is incorrect. First, you must think of all Dates/Times as already being UTC with a timezone modifier for display purposes.Again, browsers may differ, however, Date.getTime() returns the number of milliseconds since 1970-01-01 UTC/GMT. If you create a new Date using this number as I do above, it will be UTC/GMT.  However, if you display it by calling .toString() it will appear to be in your local timezone because .toString() uses your local timezone, not the timezone of the Date object it is called on.I have also found that if you call .getTimezoneOffset() on a date, it will return your local timezone, not the timezone of the date object you called it on (I can\'t verify this to be standard however).In my browser, adding 60000 * Date.getTimezoneOffset() creates a DateTime that is not UTC. However when displayed within my browser (ex: .toString() ), it displays a DateTime in my local timezone that would be correct UTC time if timezone info is ignored.Are you trying to convert the date into a string like that?I\'d make a function to do that, and, though it\'s slightly controversial, add it to the Date prototype. If you\'re not comfortable with doing that, then you can put it as a standalone function, passing the date as a parameter.If you needed it in UTC time, just replace all the get* functions with getUTC*, eg: getUTCFullYear, getUTCMonth, getUTCHours... and then just add "+00:00" at the end instead of the user\'s timezone offset.ought to work in most newer browsers. it returns 2012-07-28T00:00:00.000Z on Firefox 6.0My recommendation when working with dates is to parse the date into individual fields from user input. You can use it as a full string, but you are playing with fire.JavaScript can treat two equal dates in different formats differently.https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parseNever do anything like:Once you have your date parsed into its individual fields from user input, create a date object. Once the date object is created convert it to UTC by adding the time zone offset. I can\'t stress how important it is to use the offset from the date object due to DST (that\'s another discussion however to show why).Now you can pass the date to the server in UTC time. Again I would highly recommend against using any date strings. Either pass it to the server broken down to the lowest granularity you need e.g. year, month, day, minute or as a value like milliseconds from the unix epoch.I just discovered that the 1.2.3 version of Steven Levithan\'s date.format.js does just what I want. It allows you to supply a format string for a JavaScript date and will convert from local time to UTC. Here\'s the code I\'m using now:I\'ve found the jQuery Globalization Plugin date parsing to work best.  Other methods had cross-browser issues and stuff like date.js had not been updated in quite a while. You also don\'t need a datePicker on the page.  You can just call something similar to the example given in the docs:This function works beautifully for me.If you are dealing with dates a lot, it\'s worth using moment.js (http://momentjs.com). The method to convert to UTC would be:You can use format to change your date to any format you want:There is offset options in moment as well but there is an additional complementary library for dealing with timezone (http://momentjs.com/timezone/). The time conversion would be as simple as this:Another solution to convert to UTC and keep it as a date object:\n(It works by removing the \' GMT\' part from the end of the formatted string, then putting it back into the Date constructor)I needed to do this to interface with a datetime picker library. But in general it\'s a bad idea to work with dates this way.Users generally want to work with datetimes in their local time, so you either update the server side code to parse datetime strings with offsets correctly, then convert to UTC (best option) or you convert to a UTC string client-side before sending to the server (like in Will Stern\'s answer)Looking at your question its clear that you just want to send the date range to your backend for further post processing.I am assuming you are conforming to the standard data guidelines which expect the data to be in a particular format. For example, I use ODATA which is a RESTfull API which expects date time objects to be in the format:-YYYY-MM-DDT00:00:00.That can be easily achieved via the snippet posted below(Please change the format as per your requirement). var mydate;//assuming this is my date object which I want to expose\nvar UTCDateStr = mydate.getUTCFullYear() + "-" + mydate.getUTCMonth() + "-" + mydate.getUTCDate() + "T00:00:00";If on the other hand, you are in my situation wherein you have received a date from your backend, and the browser converts that to your local date. You on the other hand are interested in the UTC date then you can perform the following:-var mydate;//assuming this is my date object which I want to expose\nvar UTCDate = new Date(mydate);/*create a copy of your date object. Only needed if you for some reason need the original local date*/\nUTCDate.setTime(UTCDate.getTime() + UTCDate.getTimezoneOffset() * 60 * 1000);The code snippet above basically adds/subtracts the time added/subtracted by the browser based on the timezone. For example if I am in EST(GMT-5) and my Service returns a date time object = Wed Aug 17 2016 00:00:00 GMT-0500\nmy browser automatically subtracts the timezone offset(5hrs) to get my local time. So if I try to fetch the time I get Wed Aug 16 2016 19:00:00 GMT-0500. This causes a lot of problems. There are a lot of libraries out there which will definitely make this easier but I wanted to share the pure JS approach. For more info please have a look at: http://praveenlobo.com/blog/how-to-convert-javascript-local-date-to-utc-and-utc-to-local-date/ where in I got my inspiration.Hope this helps!This will give you the proper UTC Date and Time.\nIt\'s because the getTimezoneOffset() will give you the timezone difference in minutes.\nI recommend you that not to use toISOString() because the output will be in the string Hence in future you will not able to manipulate the dateI know this question is old, but was looking at this same issue, and one option would be to send date.valueOf() to the server instead. the valueOf() function of the javascript Date sends the number of milliseconds since midnight January 1, 1970 UTC.valueOf()The constructor returns the integer in ms since the unix-epoch. All these represent the UTC:\n(node.js v8.0)prints:This is what I have done in the past:This method will give you : 2017-08-04T11:15:00.000+04:30 and you can ignore zone variable to simply get 2017-08-04T11:15:00.000.One of the easiest way to get Date in UTC is:new Date(new Date().toISOString().split(\'.\')[0])Even simpler