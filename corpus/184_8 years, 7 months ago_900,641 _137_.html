I need a good explanation (references are a plus) on Python\'s slice notation. To me, this notation needs a bit of picking up. It looks extremely powerful, but I haven\'t quite got my head around it.It\'s pretty simple really:There is also the step value, which can be used with any of the above:The key point to remember is that the :end value represents the first value that is not in the selected slice. So, the difference beween end and start is the number of elements selected (if step is 1, the default).The other feature is that start or end may be a negative number, which means it counts from the end of the array instead of the beginning. So:Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for a[:-2] and a only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.The Python tutorial talks about it (scroll down a bit until you get to the part about slicing).The ASCII art diagram is helpful too for remembering how slices work:One way to remember how slices work is to think of the indices as pointing between characters, with the left edge of the first character numbered 0. Then the right edge of the last character of a string of n characters has index n.Enumerating the possibilities allowed by the grammar:Of course, if (high-low)%stride != 0, then the end point will be a little lower than high-1.Extended slicing (with commas and ellipses) are mostly used only by special data structures (like Numpy); the basic sequences don\'t support them.The answers above don\'t discuss slice assignment:This may also clarify the difference between slicing and indexing.In short, the colons (:) in subscript notation (subscriptable[subscriptarg]) make slice notation - which has the optional arguments, start, stop, step:Python slicing is a computationally fast way to methodically access parts of your data. In my opinion, to be even an intermediate Python programmer, it\'s one aspect of the language that it is necessary to be familiar with.To begin with, let\'s define a few terms:start: the beginning index of the slice, it will include the element at this index unless it is the same as stop, defaults to 0, i.e. the first index. If it\'s negative, it means to start n items from the end.stop: the ending index of the slice, it does not include the element at this index, defaults to length of the sequence being sliced, that is, up to and including the end.step: the amount by which the index increases, defaults to 1. If it\'s negative, you\'re slicing over the iterable in reverse.You can make any of these positive or negative numbers. The meaning of the positive numbers is straightforward, but for negative numbers, just like indexes in Python, you count backwards from the end for the start and stop, and for the step, you simply decrement your index. This example is from the documentation\'s tutorial, but I\'ve modified it slightly to indicate which item in a sequence each index references:To use slice notation with a sequence that supports it, you must include at least one colon in the square brackets that follow the sequence (which actually implement the __getitem__ method of the sequence, according to the Python data model.)Slice notation works like this:And recall that there are defaults for start, stop, and step, so to access the defaults, simply leave out the argument.Slice notation to get the last nine elements from a list (or any other sequence that supports it, like a string) would look like this:When I see this, I read the part in the brackets as "9th from the end, to the end." (Actually, I abbreviate it mentally as "-9, on")The full notation is and to substitute the defaults (actually when step is negative, stop\'s default is -len(my_list) - 1, so None for stop really just means it goes to whichever end step takes it to):The colon, :,  is what tells Python you\'re giving it a slice and not a regular index. That\'s why the idiomatic way of making a shallow copy of lists in Python 2 isAnd clearing them is with:(Python 3 gets a list.copy and list.clear method.)You may find it useful to separate forming the slice from passing it to the list.__getitem__ method (that\'s what the square brackets do). Even if you\'re not new to it, it keeps your code more readable so that others that may have to read your code can more readily understand what you\'re doing.However, you can\'t just assign some integers separated by colons to a variable. You need to use the slice object:The second argument, None, is required, so that the first argument is interpreted as the start argument otherwise it would be the stop argument. You can then pass the slice object to your sequence:Since slices of Python lists create new objects in memory, another important function to be aware of is itertools.islice. Typically you\'ll want to iterate over a slice, not just have it created statically in memory. islice is perfect for this. A caveat, it doesn\'t support negative arguments to start, stop, or step, so if that\'s an issue you may need to calculate indices or reverse the iterable in advance.The fact that list slices make a copy is a feature of lists themselves. If you\'re slicing advanced objects like a Pandas DataFrame, it may return a view on the original, and not a copy. And a couple of things that weren\'t immediately obvious to me when I first saw the slicing syntax:Easy way to reverse sequences!And if you wanted, for some reason, every second item in the reversed sequence:Found this great table at http://wiki.python.org/moin/MovingToPythonFromOtherLanguagesIn Python 2.7Slicing in PythonUnderstanding index assignment is very important.When you say [a:b:c], you are saying depending on the sign of c (forward or backward), start at a and end at b (excluding element at bth index). Use the indexing rule above and remember you will only find elements in this range:But this range continues in both directions infinitely:For example:If your choice of a, b, and c allows overlap with the range above as you traverse using rules for a,b,c above you will either get a list with elements (touched during traversal) or you will get an empty list.One last thing: if a and b are equal, then also you get an empty list:After using it a bit I realise that the simplest description is that it is exactly the same as the arguments in a for loop...any of them are optionalthen the negative indexing just needs you to add the length of the string to the negative indices to understand it.This works for me anyway...I find it easier to remember how it\'s works, then I can figure out any specific start/stop/step combination.It\'s instructive to understand range() first:Begin from start, increment by step, do not reach stop.  Very simple.The thing to remember about negative step is that stop is always the excluded end, whether it\'s higher or lower. If you want same slice in opposite order, it\'s much cleaner to do the reversal separately: e.g. \'abcde\'[1:-2][::-1] slices off one char from left, two from right, then reverses. (See also reversed().)Sequence slicing is same, except it first normalizes negative indexes, and can never go outside the sequence:TODO: The code below had a bug with "never go outside the sequence" when abs(step)>1; I think I patched it to be correct, but it\'s hard to understand.Don\'t worry about the is None details - just remember that omitting start and/or stop always does the right thing to give you the whole sequence.Normalizing negative indexes first allows start and/or stop to be counted from the end independently: \'abcde\'[1:-2] == \'abcde\'[1:3] == \'bc\' despite range(1,-2) == [].\nThe normalization is sometimes thought of as "modulo the length" but note it adds the length just once: e.g. \'abcde\'[-53:42] is just the whole string.I hope this will help you to model the list in Python.Reference: http://wiki.python.org/moin/MovingToPythonFromOtherLanguagesPython slicing notation:The notation extends to (numpy) matrices and multidimensional arrays.  For example, to slice entire columns you can use:Slices hold references, not copies, of the array elements.  If you want to make a separate copy an array, you can use deepcopy().I use the "an index points between elements" method of thinking about it myself, but one way of describing it which sometimes helps others get it is this:X is the index of the first element you want.\nY is the index of the first element you don\'t want.This is just for some extra info...\nConsider the list below Few other tricks for reversing the list:See abc\'s answer aboveYou can also use slice assignment to remove one or more elements from a list:This is how I teach slices to newbies:Understanding difference between indexing and slicing:Wiki Python has this amazing picture which clearly distinguishes indexing and slicing.It is a list with 6 elements in it. To understand slicing better, consider that list as a set of six boxes placed together. Each box has an alphabet in it.Indexing is like dealing with the contents of box. You can check contents of any box. But You can\'t check contents of multiple boxes at once. You can even replace contents of the box. But You can\'t place 2 balls in 1 box or replace 2 balls at a time.Slicing is like dealing with boxes itself. You can pickup first box and place it on another table. To pickup the box all You need to know is the position of beginning  & ending of the box.You can even pickup first 3 boxes or last 2 boxes or all boxes between 1 & 4. So, You can pick any set of boxes if You know beginning & ending. This positions are called start & stop positions.The interesting thing is that You can replace multiple boxes at once. Also You can place multiple boxes where ever You like.Slicing With Step:Till now You have picked boxes continuously. But some times You need to pickup discretely. For example You can pickup every second box. You can even pickup every third box from the end. This value is called step size. This represents the gap between Your successive pickups. The step size should be positive if You are picking boxes from the beginning to end and vice versa.How Python Figures Out Missing Parameters:When slicing if You leave out any parameter, Python tries to figure it out automatically.If You check source code of CPython, You will find a function called PySlice_GetIndicesEx which figures out indices to a slice for any given parameters. Here is the logical equivalent code in Python.This function takes a Python object & optional parameters for slicing and returns start, stop, step & slice length for the requested slice.This is the intelligence that is present behind slices. Since Python has inbuilt function called slice, You can pass some parameters & check how smartly it calculates missing parameters.Note: This post is originally written in my blog http://www.avilpage.com/2015/03/a-slice-of-python-intelligence-behind.htmlAs a general rule, writing code with a lot of hardcoded index values leads to a readability\nand maintenance mess. For example, if you come back to the code a year later, you\xe2\x80\x99ll\nlook at it and wonder what you were thinking when you wrote it. The solution shown\nis simply a way of more clearly stating what your code is actually doing.\nIn general, the built-in slice() creates a slice object that can be used anywhere a slice\nis allowed. For example:If you have a slice instance s, you can get more information about it by looking at its\ns.start, s.stop, and s.step attributes, respectively. For example:To make it simple, remember slice has only one form\xef\xbc\x9aand here is how it works:Another import thing: all start,end, step can be omitted! And if they are omitted, their default value will be used: 0,len(s),1 accordingly.So possible variations are:NOTE: If start>=end(considering only when step>0), python will return a empty slice [].The above part explains the core features on how slice works, it will work on most occasions. However there can be pitfalls you should watch out, and this part explains them.The very first thing confuses python learners is that index can be negative! \nDon\'t panic: negative index means count from backwards.For example:Make things more confusing is that step can be negative too! Negative step means iterate the array backwards: from end to start, with end index included, and start index excluded from result.NOTE: when step is negative, the default value for start to len(s)(while end does not equal to 0, because s[::-1] contains s[0]). For example:Be surprised: slice does not raise IndexError when index is out of range!If the index is out of range, python will try its best set the index to 0 or len(s) according to the situation. For example:Let\'s finish this answer with examples explains everything we have discussed:My brain seems happy to accept that lst[start:end] contains the start-th item. I might even say that it is a \'natural assumption\'.But occasionally a doubt creeps in and my brain asks for reassurance that it does not contain the end-th element.In these moments I rely on this simple theorem:This pretty property tells me that lst[start:end] does not contain the end-th item because it is in lst[end:].Note that this theorem is true for any n at all. For example, you can check thatreturns True.To get a certain piece of an iterable (like a list), here is an example:In this example, a positive number for number 1 is how many components you take off the front. A negative number is the exact opposite, how many you keep from the end. A positive number for number 2 indicates how many components you intend to keep from the beginning, and a negative is how many you intend to take off from the end. This is somewhat counter intuitive, but you are correct in supposing that list slicing is extremely useful.The answers above don\'t discuss multi-dimentional array slicing which is possible using the famous numpy package:Slicing also apply to multi-dimentional arrays.The ":2" before comma operates on the first dimension and the "0:3:2" after the comma operates on the second dimension.You can run this script and experiment with it, below is some samples that I got from the script.When using a negative step, notice that the answer is shifted to the right by 1.In Python, the most basic form for slicing is the following:l[start:end]where l is some collection, start is an inclusive index and end is an exclusive index.When slicing from start, you can omit the zero index, and when slicing to the end, you can omit the final index since it is redundant, so do not be verbose:Negative integers are useful when doing offsets relative to the end of a collection:It is possible to provide indices that are out of bounds when slicing such as:Keep in mind that the result of slicing a collection is a whole new collection. In addition, when using slice notation in assignments, the length of the slice assignment do not need to be the same. The values before and after the assigned slice will be kept, and the collection will shrink or grow to contain the new values:If you omit the start and end index, you will make a copy of the collection:If the start and end indexes are omitted when performing an assignment operation, the entire content of the collection will be replaced with a copy of what is referenced:Besides basic slicing, it is also possible to apply the following notation:where l is a collection, start is an inclusive index, end is an exclusive index, and step is a stride that can be used to take every nth item in l.Using step provides a useful trick to reverse a collection in Python:It is also possible to use negative integers for step as the following example:However, using a negative value for step could become very confusing. Moreover, in order to be Pythonic, you should avoid using start, end, and step in a single slice. In case this is required, consider doing this in two assignments (one to slice, and the other to stride).The below is the example of index of a stringslicing example: [start:end:step] Below is the example usage 