What are the differences in implementing interfaces implicitly and explicitly in C#?When should you use implicit and when should you use explicit?Are there any pros and/or cons to one or the other?Microsoft\'s official guidelines (from first edition Framework Design Guidelines) states that using explicit implementations are not recommended, since it gives the code unexpected behaviour.I think this guideline is very valid in a pre-IoC-time, when you don\'t pass things around as interfaces.Could anyone touch on that aspect as well?Implicit is when you define your interface via a member on your class. Explicit is when you define methods within your class on the interface. I know that sounds confusing but here is what I mean: IList.CopyTo would be implicitly implemented as:and explicitly as:The difference being that implicitly is accessible through your class you created when it is cast as that class as well as when its cast as the interface. Explicit implementation allows it to only be accessible when cast as the interface itself.I use explicit primarily to keep the implementation clean, or when I need two implementations. But regardless I rarely use it.I am sure there are more reasons to use it/not use it that others will post.See the next post in this thread for excellent reasoning behind each. Implicit definition would be to just add the methods / properties, etc. demanded by the interface directly to the class as public methods.Explicit definition forces the methods to be exposed only when you are working with the interface directly, and not the underlying implementation.  This is preferred in most cases.In addition to excellent answers already provided, there are some cases where explicit implementation is REQUIRED for the compiler to be able to figure out what is required. Take a look at IEnumerable<T> as a prime example that will likely come up fairly often.Here\'s an example:Here, IEnumerable<string> implements IEnumerable, hence we need to too. But hang on, both the generic and the normal version both implement functions with the same method signature (C# ignores return type for this). This is completely legal and fine. How does the compiler resolve which to use? It forces you to only have, at most, one implicit definition, then it can resolve whatever it needs to.ie.PS: The little piece of indirection in the explicit definition for IEnumerable works because inside the function the compiler knows that the actual type of the variable is a StringList, and that\'s how it resolves the function call. Nifty little fact for implementing some of the layers of abstraction some of the .NET core interfaces seem to have accumulated.I tend to use explicit interface implementation when I want to discourage "programming to an implementation" (Design Principles from Design Patterns).For example, in an MVP-based web application:Now another class (such as a presenter) is less likely to depend on the StandardNavigator implementation and more likely to depend on the INavigator interface (since the implementation would need to be cast to an interface to make use of the Redirect method).Another reason I might go with an explicit interface implementation would be to keep a class\'s "default" interface cleaner. For example, if I were developing an ASP.NET server control, I might want two interfaces:A simple example follows. It\'s a combo box control that lists customers. In this example, the web page developer isn\'t interested in populating the list; instead, they just want to be able to select a customer by GUID or to obtain the selected customer\'s GUID. A presenter would populate the box on the first page load, and this presenter is encapsulated by the control.The presenter populates the data source, and the web page developer never needs to be aware of its existence.I wouldn\'t recommend always employing explicit interface implementations.  Those are just two examples where they might be helpful.To quote Jeffrey Richter from CLR via C#\n(EIMI means Explicit Interface Method Implementation)It is critically important for you to\n  understand some ramifications that\n  exist when using EIMIs. And because of\n  these ramifications, you should try to\n  avoid EIMIs as much as possible.\n  Fortunately, generic interfaces help\n  you avoid EIMIs quite a bit. But there\n  may still be times when you will need\n  to use them (such as implementing two\n  interface methods with the same name\n  and signature). Here are the big\n  problems with EIMIs:If you use an interface reference ANY virtual chain can be explicitly replaced with EIMI on any derived class and when an object of such type is cast to the interface, your virtual chain is ignored and the explicit implementation is called. That\'s anything but polymorphism.EIMIs can also be used to hide non-strongly typed interface members from basic Framework Interfaces\' implementations such as IEnumerable<T> so your class doesn\'t expose a non strongly typed method directly, but is syntactical correct.In addition to the other reasons already stated, this is the situation in which a class is implementing two different interfaces that have a property/method with the same name and signature.This code compiles and runs OK, but the Title property is shared.Clearly, we\'d want the value of Title returned to depend on whether we were treating Class1 as a Book or a Person. This is when we can use the explicit interface.Notice that the explicit interface definitions are inferred to be Public - and hence you can\'t declare them to be public (or otherwise) explicitly.Note also that you can still have a "shared" version (as shown above), but whilst this is possible, the existence of such a property is questionable. Perhaps it could be used as a default implementation of Title - so that existing code would not have to be modified to cast Class1 to IBook or IPerson.If you do not define the "shared" (implicit) Title, consumers of Class1 must explicitly cast instances of Class1 to IBook or IPerson first - otherwise the code will not compile.I use explicit interface implementation most of the time. Here are the main reasons.Refactoring is saferWhen changing an interface, it\'s better if the compiler can check it. This is harder with implicit implementations.Two common cases come to mind:Adding a function to an interface, where an existing class that implements this interface already happens to have a method with the same signature as the new one. This can lead to unexpected behavior, and has bitten me hard several times. It\'s difficult to "see" when debugging because that function is likely not located with the other interface methods in the file (the self-documenting issue mentioned below).Removing a function from an interface. Implicitly implemented methods will be suddenly dead code, but explicitly implemented methods will get caught by compile error. Even if the dead code is good to keep around, I want to be forced to review it and promote it.It\'s unfortunate that C# doesn\'t have a keyword that forces us to mark a method as an implicit implementation, so the compiler could do the extra checks. Virtual methods don\'t have either of the above problems due to required use of \'override\' and \'new\'.Note: for fixed or rarely-changing interfaces (typically from vendor API\'s), this is not a problem. For my own interfaces, though, I can\'t predict when/how they will change.It\'s self-documentingIf I see \'public bool Execute()\' in a class, it\'s going to take extra work to figure out that it\'s part of an interface. Somebody will probably have to comment it saying so, or put it in a group of other interface implementations, all under a region or grouping comment saying "implementation of ITask". Of course, that only works if the group header isn\'t offscreen..Whereas: \'bool ITask.Execute()\' is clear and unambiguous.Clear separation of interface implementationI think of interfaces as being more \'public\' than public methods because they are crafted to expose just a bit of the surface area of the concrete type. They reduce the type to a capability, a behavior, a set of traits, etc. And in the implementation, I think it\'s useful to keep this separation.As I am looking through a class\'s code, when I come across explicit interface implementations, my brain shifts into "code contract" mode. Often these implementations simply forward to other methods, but sometimes they will do extra state/param checking, conversion of incoming parameters to better match internal requirements, or even translation for versioning purposes (i.e. multiple generations of interfaces all punting down to common implementations).(I realize that publics are also code contracts, but interfaces are much stronger, especially in an interface-driven codebase where direct use of concrete types is usually a sign of internal-only code.)Related: Reason 2 above by Jon.And so onPlus the advantages already mentioned in other answers here:It\'s not all fun and happiness. There are some cases where I stick with implicits:Also, it can be a pain to do the casting when you do in fact have the concrete type and want to call an explicit interface method. I deal with this in one of two ways:If you implement explicitly, you will only be able to reference the interface members through a reference that is of the type of the interface. A reference that is the type of the implementing class will not expose those interface members.If your implementing class is not public, except for the method used to create the class (which could be a factory or IoC container), and except for the interface methods (of course), then I don\'t see any advantage to explicitly implementing interfaces.Otherwise, explicitly implementing interfaces makes sure that references to your concrete implementing class are not used, allowing you to change that implementation at a later time. "Makes sure", I suppose, is the "advantage". A well-factored implementation can accomplish this without explicit implementation.The disadvantage, in my opinion, is that you will find yourself casting types to/from the interface in the implementation code that does have access to non-public members.Like many things, the advantage is the disadvantage (and vice-versa). Explicitly implementing interfaces will ensure that your concrete class implementation code is not exposed. An implicit interface implementation is where you have a method with the same signature of the interface.An explicit interface implementation is where you explicitly declare which interface the method belongs to.MSDN: implicit and explicit interface implementationsEvery class member that implements an interface exports a declaration which is semantically similar to the way VB.NET interface declarations are written, e.g.Although the name of the class member will often match that of the interface member, and the class member will often be public, neither of those things is required. One may also declare:In which case the class and its derivatives would be allowed to access a class member using the name IFoo_Foo, but the outside world would only be able to access that particular member by casting to IFoo. Such an approach is often good in cases where an interface method will have specified behavior on all implementations, but useful behavior on only some [e.g. the specified behavior for a read-only collection\'s IList<T>.Add method is to throw NotSupportedException].  Unfortunately, the only proper way to implement the interface in C# is:Not as nice.One important use of explicit interface implementation is when in need to implement interfaces with mixed visibility.The problem and solution are well explained in the article C# Internal Interface.For example, if you want to protect leakage of objects between application layers, this technique allows you to specify different visibility of members that could cause the leakage.