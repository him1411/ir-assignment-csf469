Scala syntax has a lot of symbols. Since these kinds of names are difficult to find using search engines, a comprehensive list of them would be helpful.What are all of the symbols in Scala, and what does each of them do?In particular, I\'d like to know about ->, ||=, ++=, <=, _._, ::, and :+=.I divide the operators, for the purpose of teaching, into four categories:It is fortunate, then, that most categories are represented in the question:The exact meaning of most of these methods depend on the class that is defining them. For example, <= on Int means "less than or equal to".  The first one, ->, I\'ll give as example below. :: is probably the method defined on List (though it could be the object of the same name), and :+= is probably the method defined on various Buffer classes.So, let\'s see them.There are some symbols in Scala that are special. Two of them are considered proper keywords, while others are just "reserved". They are:These are all part of the language, and, as such, can be found in any text that properly describe the language, such as Scala Specification(PDF) itself.The last one, the underscore, deserve a special description, because it is so widely used, and has so many different meanings. Here\'s a sample:I probably forgot some other meaning, though.So, if you did not find the symbol you are looking for in the list above, then it must be a method, or part of one. But, often, you\'ll see some symbol and the documentation for the class will not have that method. When this happens, either you are looking at a composition of one or more methods with something else, or the method has been imported into scope, or is available through an imported implicit conversion.These can still be found on ScalaDoc: you just have to know where to look for them. Or, failing that, look at the index (presently broken on 2.9.1, but available on nightly).Every Scala code has three automatic imports:The first two only make classes and singleton objects available. The third one contains all implicit conversions and imported methods, since Predef is an object itself.Looking inside Predef quickly show some symbols:Any other symbol will be made available through an implicit conversion. Just look at the methods tagged with implicit that receive, as parameter, an object of type that is receiving the method. For example:In the above case, -> is defined in the class ArrowAssoc through the method any2ArrowAssoc that takes an object of type A, where A is an unbounded type parameter to the same method.So, many symbols are simply methods on a class. For instance, if you doYou\'ll find the method ++ right on the ScalaDoc for List. However, there\'s one convention that you must be aware when searching for methods. Methods ending in colon (:) bind to the right instead of the left. In other words, while the above method call is equivalent to:If I had, instead 1 :: List(2, 3), that would be equivalent to:So you need to look at the type found on the right when looking for methods ending in colon. Consider, for instance:The first method (+:) binds to the right, and is found on List. The second method (:+) is just a normal method, and binds to the left -- again, on List.So, here\'s a few syntactic sugars that may hide a method:The last one is interesting, because any symbolic method can be combined to form an assignment-like method that way.And, of course, there\'s various combinations that can appear in code:One (good, IMO) difference between Scala and other languages is that it lets you name your methods with almost any character.What you enumerate is not "punctuation" but plain and simple methods, and as such their behavior vary from one object to the other (though there are some conventions).For example, check the Scaladoc documentation for List, and you\'ll see some of the methods you mentioned here.Some things to keep in mind:Most of the times the A operator+equal B combination translates to A = A operator B, like in the ||= or ++= examples.Methods that end in : are right associative, this means that A :: B is actually B.::(A).You\'ll find most answers by browsing the Scala documentation. Keeping a reference here would duplicate efforts, and it would fall behind quickly :)You can group those first according to some criteria. In this post I will just explain the underscore character and the right-arrow._._ contains a period. A period in Scala always indicates a method call. So left of the period you have the receiver, and right of it the message (method name). Now _ is a special symbol in Scala. There are several posts about it, for example this blog entry all use cases. Here it is an anonymous function short cut, that is it a shortcut for a function that takes one argument and invokes the method _ on it. Now _ is not a valid method, so most certainly you were seeing _._1 or something similar, that is, invoking method _._1 on the function argument. _1 to _22 are the methods of tuples which extract a particular element of a tuple. Example:Now lets assume a use case for the function application shortcut. Given a map which maps integers to strings:Wooop, there is already another occurrence of a strange punctuation. The hyphen and greater-than characters, which resemble a right-hand arrow, is an operator which produces a Tuple2. So there is no difference in the outcome of writing either (1, "Eins") or 1 -> "Eins", only that the latter is easier to read, especially in a list of tuples like the map example. The -> is no magic, it is, like a few other operators, available because you have all implicit conversions in object scala.Predef in scope. The conversion which takes place here isWhere ArrowAssoc has the -> method which creates the Tuple2. Thus 1 -> "Eins" is actual the call Predef.any2ArrowAssoc(1).->("Eins"). Ok. Now back to the original question with the underscore character:The underscore here shortens the following equivalent code:Note that the map method of a Map passes in the tuple of key and value to the function argument. Since we are only interested in the values (the strings), we extract them with the _2 method on the tuple.As an addition to brilliant answers of Daniel and 0__, I have to say that Scala understands Unicode analogs for some of the symbols, so instead of one may write<= is just like you would "read" it: \'less than or equals\'. So it\'s a mathematical operator, in the list of < (is less than?), > (is greater than?), == (equals?), != (is not equal?), <= (is less than or equal?), and >= (is greater than or equal?).This must not be confused with => which is kind of a double right-hand arrow, used to separate the argument list from the body of a function and to separate the testing condition in pattern matching (a case block) from the body executed when a match occurs. You can see example of this in my previous two answers. First, the function use:which is already abbreviated as the types are omitted. The follow function would beand the pattern matching use:Regarding :: there is another Stackoverflow entry which covers the :: case. In short, it is used to construct Lists by \'consing\' a head element and a tail list. It is both a class which represents a cons\'ed list and which can be used as an extractor, but most commonly it is a method on a list. As Pablo Fernandez points out, since it ends in a colon, it is right associative, meaning the receiver of the method call is to the right, and the argument to the left of the operator. That way you can elegantly express the consing as prepending a new head element to an existing list:This is equivalent toThe use as extractor object is as follows:This looks like an operator here, but it is really just another (more readable) way of writingYou can read more about extractors in this post.I consider a modern IDE to be critical for understanding large scala projects.  Since these operators are also methods, in intellij idea I just control-click or control-b into the definitions.  You can control-click right into a cons operator (::) and end up at the scala javadoc saying "Adds an element at the beginning of this list."  In user-defined operators, this becomes even more critical, since they could be defined in hard-to-find implicits... your IDE knows where the implicit was defined.Scala inherits most of Java\'s arithmetic operators. This includes bitwise-or | (single pipe character), bitwise-and &, bitwise-exclusive-or ^, as well as logical (boolean) or || (two pipe characters) and logical-and &&. Interestingly, you can use the single character operators on boolean, so the java\'ish logical operators are totally redundant:As pointed out in another post, calls ending in an equals sign =, are resolved (if a method with that name does not exist!) by a reassignment:This \'double-check\' makes it possible, to easily exchange a mutable for an immutable collection:Just adding to the other excellent answers. Scala also has /: (foldLeft) and :\\ (foldRight) operators, which are right-associative infix operators. So following three statements are the same:The same goes for foldRight and :\\.