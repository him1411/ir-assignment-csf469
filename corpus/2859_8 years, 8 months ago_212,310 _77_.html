http://en.wikipedia.org/wiki/UpsertInsert Update stored proc on SQL ServerIs there some clever way to do this in SQLite that I have not thought of?Basically I want to update three out of four columns if the record exists, \nIf it does not exists I want to INSERT the record with the default (NUL) value for the fourth column.The ID is a primary key so there will only ever be one record to UPSERT.(I am trying to avoid the overhead of SELECT in order to determin if I need to UPDATE or INSERT obviously)Suggestions?Assuming 3 columns in the table.. ID, NAME, ROLEBAD: This will insert or replace all columns with new values for ID=1:BAD: This will insert or replace 2 of the columns... the NAME column will be set to NULL or the default value:GOOD: This will update 2 of the columns.\nWhen ID=1 exists, the NAME will be unaffected.\nWhen ID=1 does not exist, the name will be default (NULL).This will update 2 of the columns.\nWhen ID=1 exists, the ROLE will be unaffected.\nWhen ID=1 does not exist, the role will be set to \'Benchwarmer\' instead of the default value.INSERT OR REPLACE is NOT equivalent to "UPSERT".Say I have the table Employee with the fields id, name, and role:Boom, you\'ve lost the name of the employee number 1. SQLite has replaced it with a default value.The expected output of an UPSERT would be to change the role and to keep the name.Eric B\xe2\x80\x99s answer is OK if you want to preserve just one or maybe two columns from the existing row. If you want to preserve a lot of columns, it gets too cumbersome fast.Here\xe2\x80\x99s an approach that will scale well to any amount of columns on either side. To illustrate it I will assume the following schema:Note in particular that name is the natural key of the row \xe2\x80\x93 id is used only for foreign keys, so the point is for SQLite to pick the ID value itself when inserting a new row. But when updating an existing row based on its name, I want it to continue to have the old ID value (obviously!).I achieve a true UPSERT with the following construct:The exact form of this query can vary a bit. The key is the use of INSERT SELECT with a left outer join, to join an existing row to the new values.Here, if a row did not previously exist, old.id will be NULL and SQLite will then assign an ID automatically, but if there already was such a row, old.id will have an actual value and this will be reused. Which is exactly what I wanted.In fact this is very flexible. Note how the ts column is completely missing on all sides \xe2\x80\x93 because it has a DEFAULT value, SQLite will just do the right thing in any case, so I don\xe2\x80\x99t have to take care of it myself.You can also include a column on both the new and old sides and then use e.g. COALESCE(new.content, old.content) in the outer SELECT to say \xe2\x80\x9cinsert the new content if there was any, otherwise keep the old content\xe2\x80\x9d \xe2\x80\x93 e.g. if you are using a fixed query and are binding the new values with placeholders.If you are generally doing updates I would .. If you are generally doing inserts I would This way you avoid the select and you are transactionally sound on Sqlite. I realize this is an old thread but I\'ve been working in sqlite3 as of late and came up with this method which better suited my needs of dynamically generating parameterized queries:It\'s still 2 queries with a where clause on the update but seems to do the trick. I also have this vision in my head that sqlite can optimize away the update statement entirely if the call to changes() is greater than zero. Whether or not it actually does that is beyond my knowledge, but a man can dream can\'t he? ;)For bonus points you can append this line which returns you the id of the row whether it be a newly inserted row or an existing row.I know I\'m late to the party but....So it tries to update, if the record is there then changes() == 1 so the insert is not action-ed.alternatively:Another completely different way of doing this is: In my application I set my in memory rowID to be long.MaxValue when I create the row in memory. (MaxValue will never be used as an ID you will won\'t live long enough.... Then if rowID is not that value then it must already be in the database so needs an UPDATE if it is MaxValue then it needs an insert. This is only useful if you can track the rowIDs in your app.Here is a solution that really is an UPSERT (UPDATE or INSERT) instead of an INSERT OR REPLACE (which works differently in many situations).It works like this:\n1. Try to update if a record with the same Id exists.\n2. If the update did not change any rows (NOT EXISTS(SELECT changes() AS change FROM Contact WHERE change <> 0)), then insert the record.So either an existing record was updated or an insert will be performed.The important detail is to use the changes() SQL function to check if the update statement hit any existing records and only perform the insert statement if it did not hit any record.One thing to mention is that the changes() function does not return changes performed by lower-level triggers (see http://sqlite.org/lang_corefunc.html#changes), so be sure to take that into account.Here is the SQL...Test update:Test insert:Expanding on Aristotle\xe2\x80\x99s answer you can SELECT from a dummy \'singleton\' table  (a table of your own creation with a single row). This avoids some duplication.I\'ve also kept the example portable across MySQL and SQLite and used a \'date_added\' column as an example of how you could set a column only the first time.The best approach I know is to do an update, followed by an insert.\nThe "overhead of a select" is necessary, but it is not a terrible burden since you are searching on the primary key, which is fast.You should be able to modify the below statements with your table & field names to do what you want.Mosor,I cannot confirm that Syntax on the SQLite site for TABLE CREATE.\nI have not built a demo to test it, but It doesnt seem to be supported..If it was, I have three columns so it would actually look like:but the first two blobs will not cause a conflict, only the ID would\nSo I asusme Blob1 and Blob2 would not be replaced (as desired)Sambo,\nUPDATEs in SQLite when binding data are a complete transaction, meaning \nEach sent row to be updated requires:  Prepare/Bind/Step/Finalize statements\nunlike the INSERT which allows the use of the reset functionThe life of a statement object goes something like this:UPDATE I am guessing is slow compared to INSERT, but how does it compare to SELECT using the Primary key?Perhaps I should use the select to read the 4th column (Blob3) and then use REPLACE to write a new record blending the original 4th Column with the new data for the first 3 columns?If someone wants to read my solution for SQLite in Cordova, I got this generic js method thanks to @david answer above.So, first pick up the column names with this function:Then build the transactions programmatically. "Values" is an array you should build before and it represents the rows you want to insert or update into the table."remoteid" is the id I used as a reference, since I\'m syncing with my remote server.For the use of the SQLite Cordova plugin, please refer to the official linkI think this may be what you are looking for: ON CONFLICT clause.If you define your table like this:Now, if you do an INSERT with an id that already exists, SQLite automagically does UPDATE instead of INSERT.Hth...This method remixes a few of the other methods from answer in for this question and incorporates the use of CTE (Common Table Expressions). I will introduce the query then explain why I did what I did.I would like to change the last name for employee 300 to DAVIS if there is an employee 300. Otherwise, I will add a new employee.Table Name: employees\nColumns: id, first_name, last_nameThe query is:Basically, I used the CTE to reduce the number of times the select statement has to be used to determine default values. Since this is a CTE, we just select the columns we want from the table and the INSERT statement uses this.Now you can decide what defaults you want to use by replacing the nulls, in the COALESCE function with what the values should be.Having just read this thread and been disappointed that it wasn\'t easy to just to this "UPSERT"ing, I investigated further...You can actually do this directly and easily in SQLITE.Instead of using: INSERT INTOUse: INSERT OR REPLACE INTOThis does exactly what you want it to do!if COUNT(*) = 0else if COUNT(*) > 0