I\'m using reflection to loop through a Type\'s properties and set certain types to their default.  Now, I could do a switch on the type and set the default(Type) explicitly, but I\'d rather do it in one line.  Is there a programmatic equivalent of default?Why not call the method that returns default(T) with reflection ? You can use GetDefault of any type with:You can use PropertyInfo.SetValue(obj, null).  If called on a value type it will give you the default. This behavior is documented in .NET 4.0 and in .NET 4.5. If you\'re using .NET 4.0 or above and you want a programmatic version that isn\'t a codification of rules defined outside of code, you can create an Expression, compile and run it on-the-fly.The following extension method will take a Type and get the value returned from default(T) through the Default method on the Expression class:You should also cache the above value based on the Type, but be aware if you\'re calling this for a large number of Type instances, and don\'t use it constantly, the memory consumed by the cache might outweigh the benefits.Why do you say generics are out of the picture?This is optimized Flem\'s solution:The chosen answer is a good answer, but be careful with the object returned.Extrapolating...The Expressions can help here:I did not test this snippet, but i think it should produce "typed" nulls for reference types..Can\'t find anything simple and elegant just yet, but I have one idea: If you know the type of the property you wish to set, you can write your own default(T). There are two  cases - T is a value type, and T is a reference type. You can see this by checking T.IsValueType. If T is a reference type, then you can simply set it to null. If T is a value type, then it will have a default parameterless constructor that you can call to get a "blank" value.I do the same task like this. Equivalent to Dror\'s answer but as an extension method: