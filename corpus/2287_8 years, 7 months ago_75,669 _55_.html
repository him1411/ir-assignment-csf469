The title says it all.  Sometimes it seems that the Name and x:Name attributes are interchangeable.So, what are the definitive differences between them, and when is it preferable to use one over the other?Are there any performance or memory implications to using them the wrong way?EDIT  Responses so far suggest that using x:Name all the time works fine, but I still want to know what the difference is.  Microsoft put these two attributes into the very first release of WPF, so there must be some sensible explanation.There really is only one name in XAML, the x:Name. A framework, such as WPF, can optionally map one of its properties to XAML\'s x:Name by using the RuntimeNamePropertyAttribute on the class that designates one of the classes properties as mapping to the x:Name attribute of XAML.The reason this was done was to allow for frameworks that already have a concept of "Name" at runtime, such as WPF. In WPF, for example, FrameworkElement introduces a Name property.In general, a class does not need to store the name for x:Name to be useable. All x:Name means to XAML is generate a field to store the value in the code behind class. What the runtime does with that mapping is framework dependent.So, why are there two ways to do the same thing? The simple answer because there are two concepts mapped onto one property. WPF wants the name of an element preserved at runtime (which is usable through Bind, among other things) and XAML needs to know what elements you want to be accessible by fields in the code behind class. WPF ties these two together by marking the Name property as an alias of x:Name.In the future, XAML will have more uses for x:Name, such as allowing you to set properties by referring to other objects by name, but in 3.5 and prior, it is only used to create fields.Whether you should use one or the other is really a style question, not a technical one. I will leave that to others for a recommendation.See also AutomationProperties.Name VS x:Name, AutomationProperties.Name is used by accessibility tools and some testing tools.They are not the same thing.x:Name is a xaml concept, used mainly to reference elements. When you give an element the x:Name xaml attribute, "the specified x:Name becomes the name of a field that is created in the underlying code when xaml is processed, and that field holds a reference to the object." (MSDN) So, it\'s a designer-generated field, which has internal access by default.Name is the existing string property of a FrameworkElement, listed as any other wpf element property in the form of a xaml attribute.As a consequence, this also means x:Name can be used on a wider range of objects. This is a technique to enable anything in xaml to be referenced by a given name.x:Name and Name are referencing different namespaces. x:name is a reference to the x namespace defined by default at the top of the Xaml file.Just saying Name uses the default below namespace. x:Name is saying use the namespace that has the x alias. x is the default and most people leave it but you can change it to whatever you likeso your reference would be foo:nameDefine and Use Namespaces in WPFEDIT:OK lets look at this a different way. Say you drag and drop an button onto your Xaml page. You can reference this 2 ways x:name and name. All xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" and\nxmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" are is references to multiple namespaces. Since xaml holds the Control namespace(not 100% on that) and presentation holds the FrameworkElement AND the Button class has a inheritance pattern of: So as one would expect anything that inherits from FrameworkElement would have access to all its public attributes. so in the case of Button it is getting its Name attribute from FrameworkElement, at the very top of the hierarchy tree.  So you can say x:Name or Name and they will both be accessing the getter/setter from the FrameworkElement. MSDN ReferenceWPF defines a CLR attribute that is consumed by XAML processors in order to map multiple CLR namespaces to a single XML namespace. The XmlnsDefinitionAttribute attribute is placed at the assembly level in the source code that produces the assembly. The WPF assembly source code uses this attribute to map the various common namespaces, such as System.Windows and System.Windows.Controls, to the http://schemas.microsoft.com/winfx/2006/xaml/presentation namespace.So the assembly attributes will look something like:PresentationFramework.dll - XmlnsDefinitionAttribute:They\'re both the same thing, a lot of framework elements expose a name property themselves, but for those that don\'t you can use x:name - I usually just stick with x:name because it works for everything.Controls can expose name themselves as a DP if they want to  (because they need to use that DP internally), or they can choose not to. More details in msdn here and here:Some WPF framework-level applications\n  might be able to avoid any use of the\n  x:Name attribute, because the Name\n  dependency property as specified\n  within the WPF namespace for several\n  of the important base classes such as\n  FrameworkElement/FrameworkContentElement\n  satisfies this same purpose. There are\n  still some common XAML and framework\n  scenarios where code access to an\n  element with no Name property is\n  necessary, most notably in certain\n  animation and storyboard support\n  classes. For instance, you should\n  specify x:Name on timelines and\n  transforms created in XAML, if you\n  intend to reference them from code.If Name is available as a property on\n  the class, Name and x:Name can be used\n  interchangeably as attributes, but an\n  error will result if both are\n  specified on the same element.X:Name can cause memory issues if you have custom controls.  It will keep a memory location for the NameScope entry.  I say never use x:Name unless you have to.The only difference is that if you are using user Controls into a control from Same Assembly then Name will not identify your control and you will get an error " Use x:Name for controls in the same Assembly". \nSo x:Name is the WPF versioning of naming controls in WPF. Name is just used as a Winform Legacy. They wanted to differentiate the naming of controls in WPF and winforms as they use attributes in Xaml to identify controls from other assemblies they used x: for Names of control. Just keep in mind dont put a name for a control just for the sake of keeping it as it resides in memory as a blank and it will give you a warning that Name has been applied for a control buts its never used. Name:x:Name:Using both directives in XAML for one FrameworkElement or FrameworkContentElement will cause an exception: if the XAML is markup compiled, the exception will occur on the markup compile, otherwise it occurs on load.x:Name means: create a field in the code behind to hold a reference to this object.Name means: set the name property of this object.I always use the x:Name variant.\nI have no idea if this affects any performance, I just find it easier for the following reason.\nIf you have your own usercontrols that reside in another assembly just the "Name" property won\'t always suffice. This makes it easier to just stick too the x:Name property.It\'s not a WPF item but a standard XML one and BtBh has correctly answered it, x refers to the default namespace. In XML when you do not prefix an element/attribute with a namespace it assumes you want the default namespace.\nSo typing just Name is nothing more than a short hand for x:Name. More details on XML namespaces can be found at link textOne of the answers is that x:name is to be used inside different program languages such as c# and name is to be used for the framework. Honestly that is what it sounds like to me.When you declare a Button element in XAML you are referring to a class defined in windows run time called Button.Button has many attribute such as background, text, margin, ..... and an attribute called Name.Now when you declare a Button in XAML is like creating an anonymous object that happened to have an attribute called Name.In general you can not refer to an anonymous object, but in WPF framework XAML processor enables you to refer to that object by whatever value you have given to Name attribute.So far so good.Another way to create an object is create a named object instead of anonymous object. In this case XAML namespace has an attribute for an object called Name (and since it is in XAML name space thus have X:) that you may set so you can identify your object and refer to it.Conclusion:Name is an attribute of a specific object, but X:Name is one attribute of that object (there is a class that defines a general object).The specified x:Name becomes the name of a field that is created in the underlying code when XAML is processed, and that field holds a reference to the object. In Silverlight, using the managed API, the process of creating this field is performed by the MSBuild target steps, which also are responsible for joining the partial classes for a XAML file and its code-behind. This behavior is not necessarily XAML-language specified; it is the particular implementation that Silverlight applies to use x:Name in its programming and application models.Read More on MSDN...