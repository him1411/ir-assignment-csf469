Suppose the following:How do I get a value (any value) out of s without doing s.pop()? I want to leave the item in the set until I am sure I can remove it - something I can only be sure of after an asynchronous call to another host.Quick and dirty:But do you know of a better way? Ideally in constant time.Two options that don\'t require copying the whole set:Or...But in general, sets don\'t support indexing or slicing.Least code would be:Obviously this would create a new list which contains each member of the set, so not great if your set is very large.To provide some timing figures behind the different approaches, consider the following code.\nThe get() is my custom addition to Python\'s setobject.c, being just a pop() without removing the element.The output is:This means that the for/break solution is the fastest (sometimes faster than the custom get() solution).Since you want a random element, this will also work:The documentation doesn\'t seem to mention performance of random.sample. From a really quick empirical test with a huge list and a huge set, it seems to be constant time for a list but not for the set. Also, iteration over a set isn\'t random; the order is undefined but predictable:If randomness is important and you need a bunch of elements in constant time (large sets), I\'d use random.sample and convert to a list first:for first_item in muh_set: break remains the optimal approach in Python 3.x. Curse you, Guido.Welcome to yet another set of Python 3.x timings, extrapolated from wr.\'s excellent Python 2.x-specific response. Unlike AChampion\'s equally helpful Python 3.x-specific response, the timings below also time outlier solutions suggested above \xe2\x80\x93 including:Turn on, tune in, time it:Behold! Ordered by fastest to slowest snippets:Unsurprisingly, manual iteration remains at least twice as fast as the next fastest solution. Although the gap has decreased from the Bad Old Python 2.x days (in which manual iteration was at least four times as fast), it disappoints the PEP 20 zealot in me that the most verbose solution is the best. At least converting a set into a list just to extract the first element of the set is as horrible as expected. Thank Guido, may his light continue to guide us.Surprisingly, the RNG-based solution is absolutely horrible. List conversion is bad, but random really takes the awful-sauce cake. So much for the Random Number God.I just wish the amorphous They would PEP up a set.get_first() method for us already. If you\'re reading this, They: "Please. Do something."I use a utility function I wrote.  Its name is somewhat misleading because it kind of implies it might be a random item or something like that.Following @wr. post, I get similar results (for Python3.5)Output:However, when changing the underlying set (e.g. call to remove()) things go badly for the iterable examples (for, iter):Results in:Seemingly the most compact (6 symbols) though very slow way to get a set element (made possible by PEP 3132):With Python 3.5+ you can also use this 7-symbol expression (thanks to PEP 448):Both options are roughly 1000 times slower on my machine than for-loop method.Another option is to use a dictionary with values you don\'t care about.  E.g.,You can treat the keys as a set except that they\'re just an array:A side effect of this choice is that your code will be backwards compatible with older, pre-set versions of Python.  It\'s maybe not the best answer but it\'s another option.Edit: You can even do something like this to hide the fact that you used a dict instead of an array or set: