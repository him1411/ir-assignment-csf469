Is it possible to have static class variables or methods in python? What syntax is required to do this?Variables declared inside the class definition, but not inside a method are class or static variables:As @millerdev points out, this creates a class-level i variable, but this is distinct from any instance-level i variable, so you could haveThis is different from C++ and Java, but not so different from C#, where a static member can\'t be accessed using a reference to an instance.See what the Python tutorial has to say on the subject of classes and class objects.@Steve Johnson has already answered regarding static methods, also documented under "Built-in Functions" in the Python Library Reference.@beidy recommends classmethods over staticmethod, as the method then receives the class type as the first argument, but I\'m still a little fuzzy on the advantages of this approach over staticmethod. If you are too, then it probably doesn\'t matter.@Blair Conrad said static variables declared inside the class definition, but not inside a method are class or "static" variables:There are a few gotcha\'s here. Carrying on from the example above:Notice how the instance variable t.i got out of sync with the "static" class variable when the attribute i was set directly on t. This is because i was re-bound within the t namespace, which is distinct from the Test namespace. If you want to change the value of a "static" variable, you must change it within the scope (or object) where it was originally defined. I put "static" in quotes because Python does not really have static variables in the sense that C++ and Java do.Although it doesn\'t say anything specific about static variables or methods, the Python tutorial has some relevant information on classes and class objects. @Steve Johnson also answered regarding static methods, also documented under "Built-in Functions" in the Python Library Reference.@beid also mentioned classmethod, which is similar to staticmethod. A classmethod\'s first argument is the class object. Example:As the other answers have noted, static and class methods are easily accomplished using the built-in decorators:As usual, the first argument to MyMethod() is bound to the class instance object. In contrast, the first argument to MyClassMethod() is bound to the class object itself (e.g., in this case, Test). For MyStaticMethod(), none of the arguments are bound, and having arguments at all is optional. However, implementing "static variables" (well, mutable static variables, anyway, if that\'s not a contradiction in terms...) is not as straight forward. As millerdev pointed out in his answer, the problem is that Python\'s class attributes are not truly "static variables". Consider: This is because the line x.i = 12 has added a new instance attribute i to x instead of changing the value of the Test class i attribute. Partial expected static variable behavior, i.e., syncing of the attribute between multiple instances (but not with the class itself; see "gotcha" below), can be achieved by turning the class attribute into a property:Now you can do:The static variable will now remain in sync between all class instances. (NOTE: That is, unless a class instance decides to define its own version of _i! But if someone decides to do THAT, they deserve what they get, don\'t they???)Note that technically speaking, i is still not a \'static variable\' at all; it is a property, which is a special type of descriptor. However, the property behavior is now equivalent to a (mutable) static variable synced across all class instances. For immutable static variable behavior, simply omit the property setter:Now attempting to set the instance i attribute will return an AttributeError: Note that the above methods only work with instances of your class - they will not work when using the class itself. So for example: The line assert Test.i == x.i produces an error, because the i attribute of Test and x are two different objects. Many people will find this surprising. However, it should not be. If we go back and inspect our Test class definition (the second version), we take note of this line: Clearly, the member i of Test must be a property object, which is the type of object returned from the property function. If you find the above confusing, you are most likely still thinking about it from the perspective of other languages (e.g. Java or c++). You should go study the property object, about the order in which Python attributes are returned, the descriptor protocol, and the method resolution order (MRO). I present a solution to the above \'gotcha\' below; however I would suggest - strenuously - that you do not try to do something like the following until - at minimum - you thoroughly understand why assert Test.i = x.i causes an error. I present the (Python 3) solution below for informational purposes only. I am not endorsing it as a "good solution". I have my doubts as to whether emulating the static variable behavior of other languages in Python is ever actually necessary. However, regardless as to whether it is actually useful, the below should help further understanding of how Python works. UPDATE: this attempt is really pretty awful; if you insist on doing something like this (hint: please don\'t; Python is a very elegant language and shoe-horning it into behaving like another language is just not necessary), use the code in Ethan Furman\'s answer instead.Emulating static variable behavior of other languages using a metaclassA metaclass is the class of a class. The default metaclass for all classes in Python (i.e., the "new style" classes post Python 2.3 I believe) is type. For example: However, you can define your own metaclass like this: And apply it to your own class like this (Python 3 only):Below is a metaclass I have created which attempts to emulate "static variable" behavior of other languages. It basically works by replacing the default getter, setter, and deleter with versions which check to see if the attribute being requested is a "static variable". A catalog of the "static variables" is stored in the StaticVarMeta.statics attribute. All attribute requests are initially attempted to be resolved using a substitute resolution order. I have dubbed this the "static resolution order", or "SRO". This is done by looking for the requested attribute in the set of "static variables" for a given class (or its parent classes). If the attribute does not appear in the "SRO", the class will fall back on the default attribute get/set/delete behavior (i.e., "MRO"). You can also add class variables to classes on the flyAnd class instances can change class variablesPersonally I would use a classmethod whenever I needed a static method. Mainly because I get the class as an argument.or use a decoratorFor static properties.. Its time you look up some python definition.. variable can always change. There are two types of them mutable and immutable.. Also, there are class attributes and instance attributes.. Nothing really like static attributes in the sense of java & c++Why use static method in pythonic sense, if it has no relation whatever to the class! If I were you, I\'d either use classmethod or define the method independent from the class.Static methods in python are called classmethods. Take a look at the following codeNotice that when we call the method myInstanceMethod, we get an error. This is because it requires that method be called on an instance of this class. The method myStaticMethod is set as a classmethod using the decorator @classmethod.Just for kicks and giggles, we could call myInstanceMethod on the class by passing in an instance of the class, like so:One special thing to note about static properties & instance properties, shown in the example below:This means before assigning the value to instance property, if we try to access the property thru\' instance, the static value is used. Each property declared in python class always has a static slot in memory.You could also enforce a class to be static using metaclass.Then whenever by accident you try to initialize MyClass you\'ll get an StaticClassError.When define some member variable outside any member method, the variable can be either static or non-static depending on how the variable is expressed. For example:The results areIt is possible to have static class variables, but probably not worth the effort.Here\'s a proof-of-concept written in Python 3 -- if any of the exact details are wrong the code can be tweaked to match just about whatever you mean by a static variable:and in use:and some tests:To avoid any potential confusion, I would like to contrast static variables and immutable objects.Some primitive object types like integers, floats, strings, and touples are immutable in Python. This means that the object that is referred to by a given name cannot change if it is of one of the aforementioned object types. The name can be reassigned to a different object, but the object itself may not be changed.Making a variable static takes this a step further by disallowing the variable name to point to any object but that to which it currently points. (Note: this is a general software concept and not specific to Python; please see others\' posts for information about implementing statics in Python).Absolutely Yes,\n  Python by itself don\'t have any static data member explicitly, but We can have by doing so outputexplanationIn regards to this answer, for a constant static variable, you can use a descriptor. Here\'s an example:resulting in ...You can always raise an exception if quietly ignoring setting value (pass above) is not your thing. If you\'re looking for a C++, Java style static class variable:Have a look at this answer and the official docs HOWTO for more information about descriptors. The best way I found is to use another class. You can create an object and then use it on other objects.With the example above, I made a class named staticFlag.This class should present the static var __success (Private Static Var).tryIt class represented the regular class we need to use.Now I made an object for one flag (staticFlag). This flag will be sent as reference to all the regular objects.All these objects are being added to the list tryArr.This Script Results:One very interesting point about Python\'s attribute lookup is that it can be used to create "virtual variables":Normally there aren\'t any assignments to these after they are created.  Note that the lookup uses self because, although label is static in the sense of not being associated with a particular instance, the value still depends on the (class of the) instance.For anyone using a class factory with python3.6 and up use the nonlocal keyword to add it to the scope / context of the class being created like so: