Is it possible to get the mouse position with JavaScript after page loads without any mouse movement event (without moving the mouse)?Real answer: No, it\'s not possible.OK, I have just thought of a way. Overlay your page with a div that covers the whole document. Inside that, create (say) 2,000 x 2,000 <a> elements (so that the :hover pseudo-class will work in IE 6, see), each 1 pixel in size. Create a CSS :hover rule for those <a> elements that changes a property (let\'s say font-family). In your load handler, cycle through each of the 4 million <a> elements, checking currentStyle / getComputedStyle() until you find the one with the hover font. Extrapolate back from this element to get the co-ordinates within the document.N.B. DON\'T DO THIS.What you can do is create variables for the x and y coordinates of your cursor, update them whenever the mouse moves and call a function on an interval to do what you need with the stored position.The downside to this of course is that at least one initial movement of the mouse is required to have it work. As long as the cursor updates its position at least once, we are able to find its position regardless of whether it moves again. The preceding code updates once a second with a message of where your cursor is. I hope this helps.You can also hook mouseenter (this event is fired after page reload, when the mousecursor is inside the page). Extending Corrupted\'s code should do the trick:You can also set x and y to null on mouseleave-event. So you can check if the user is on your page with it\'s cursor.You could try something similar to what Tim Down suggested - but instead of having elements for each pixel on the screen, create just 2-4 elements (boxes), and change their location, width, height dynamically to divide the yet possible locations on screen by 2-4 recursively, thus finding the mouse real location quickly.For example - first elements take right and left half of screen, afterwards the upper and lower half. By now we already know in which quarter of screen the mouse is located, are able to repeat - discover which quarter of this space...I envision that maybe you have a parent page with a timer and after a certain amount of time or a task is completed, you forward the user to a new page. Now you want the cursor position, and because they are waiting, they aren\'t necessarily touching the mouse.  So track the mouse on the parent page using standard events and pass the last value to the new page in a get or a post variable.You can use JHarding\'s code on your parent page so that the latest position is always available in a global variable:This won\'t help users that navigate to this page by means other than your parent page.@Tim Down\'s answer is not performant if you render 2,000 x 2,000 <a> elements:OK, I have just thought of a way. Overlay your page with a div that\n  covers the whole document. Inside that, create (say) 2,000 x 2,000 \n  elements (so that the :hover pseudo-class will work in IE 6, see),\n  each 1 pixel in size. Create a CSS :hover rule for those  elements\n  that changes a property (let\'s say font-family). In your load handler,\n  cycle through each of the 4 million  elements, checking\n  currentStyle / getComputedStyle() until you find the one with the\n  hover font. Extrapolate back from this element to get the co-ordinates\n  within the document.N.B. DON\'T DO THIS.But you don\'t have to render 4 million elements at once, instead use binary search. Just use 4 <a> elements instead:This way you would need to repeat these steps max 11 times, considering your screen is not wider than 2048px.So you will generate max 11 x 4 = 44 <a> elements.If you don\'t need to determine the mouse position exactly to a pixel, but say 10px precision is OK. You would repeat the steps at most 8 times, so you would need to draw max 8 x 4 = 32 <a> elements.Also generating and then destroying the <a> elements is not performat as DOM is generally slow. Instead, you can just reuse the initial 4 <a> elements and just adjust their top, left, width and height as you loop through steps.Now, creating 4 <a> is an overkill as well. Instead, you can reuse the same one <a> element for when testing for getComputedStyle() in each rectangle. So, instead of splitting the search area into 2 x 2 <a> elements just reuse a single <a> element by moving it with top and left style properties.So, all you need is a single <a> element change its width and height max 11 times, and change its top and left max 44 times and you will have the exact mouse position.I implemented a horizontal/vertical search, (first make a div full of vertical line links arranged horizontally, then make a div full of horizontal line links arranged vertically, and simply see which one has the hover state) like Tim Down\'s idea above, and it works pretty fast. Sadly, does not work on Chrome 32 on KDE.jsfiddle.net/5XzeE/4/You do not have to move the mouse to get the cursor\'s location. The location is also reported on events other than mousemove. Here\'s a click-event as an example: