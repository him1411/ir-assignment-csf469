When should you use struct and not class in C#? My conceptual model is that structs are used in times when the item is merely a collection of value types.  A way to logically hold them all together into a cohesive whole.I came across these rules here:Do these rules work? What does a struct mean semantically? The source referenced by the OP has some credibility ...but what about Microsoft - what is the stance on struct usage? I sought some extra learning from Microsoft, and here is what I found:  Consider defining a structure instead of a class if instances of the\n  type are small and commonly short-lived or are commonly embedded in\n  other objects.Do not define a structure unless the type has all of the following characteristics: Okay, #2 and #3 anyway. Our beloved dictionary has 2 internal structs:  *Reference SourceThe \'JonnyCantCode.com\' source got 3 out of 4 - quite forgivable since #4 probably wouldn\'t be an issue. If you find yourself boxing a struct, rethink your architecture.  Let\'s look at why Microsoft would use these structs:Update - In addition, realize that when a struct implements an interface - as Enumerator does - and is cast to that implemented type, the struct becomes a reference type and is moved to the heap. Internal to the Dictionary class, Enumerator is still a value type. However, as soon as a method calls GetEnumerator(), a reference-type IEnumerator is returned.What we don\'t see here is any attempt or proof of requirement to keep structs immutable or maintaining an instance size of only 16 bytes or less:  And ...\n 4. Both structs store TKey and TValue, which we all know are quite capable of being reference types (added bonus info)Hashed keys notwithstanding, dictionaries are fast in part because instancing a struct is quicker than a reference type. Here, I have a Dictionary<int, int> that stores 300,000 random integers with sequentially incremented keys.Capacity: 312874\n  MemSize:  2660827 bytes\n  Completed Resize:  5ms\n  Total time to fill:  889msCapacity:  number of elements available before the internal array must be resized.  MemSize:  determined by serializing the dictionary into a MemoryStream and getting a byte length (accurate enough for our purposes).  Completed Resize:  the time it takes to resize the internal array from 150862 elements to 312874 elements. When you figure that each element is sequentially copied via Array.CopyTo(), that ain\'t too shabby.  Total time to fill: admittedly skewed due to logging and an OnResize event I added to the source; however, still impressive to fill 300k integers while resizing 15 times during the operation. Just out of curiosity, what would the total time to fill be if I already knew the capacity? 13ms So, now, what if Entry were a class? Would these times or metrics really differ that much?  Capacity:  312874\n  MemSize:  2660827 bytes\n  Completed Resize:  26ms\n  Total time to fill:  964msObviously, the big difference is in resizing. Any difference if Dictionary is initialized with the Capacity? Not enough to be concerned with ... 12ms.  What happens is, because Entry is a struct, it does not require initialization like a reference type. This is both the beauty and the bane of the value type. In order to use Entry as a reference type, I had to insert the following code:The reason I had to initialize each array element of Entry as a reference type can be found at MSDN: Structure Design. In short:Do not provide a default constructor for a structure.If a structure defines a default constructor, when arrays of the\n  structure are created, the common language runtime automatically\n  executes the default constructor on each array element.Some compilers, such as the C# compiler, do not allow structures to\n  have default constructors.It is actually quite simple and we will borrow from Asimov\'s Three Laws of Robotics:...what do we take away from this: in short, be responsible with the use of value types. They are quick and efficient, but have the ability to cause many unexpected behaviors if not properly maintained (i.e. unintentional copies).  Whenever you don\'t need polymorphism, want value semantics, and want to avoid heap allocation and the associated garbage collection overhead.  The caveat, however, is that structs (arbitrarily large) are more expensive to pass around than class references (usually one machine word), so classes could end up being faster in practice.I do not agree with the rules given in the original post. Here are my rules:1) You use structs for performance when stored in arrays. (see also When are structs the answer?)2) You need them in code passing structured data to/from C/C++3) Do not use structs unless you need them: Use a struct when you want value semantics as opposed to reference semantics. Not sure why folks are downvoting this but this is a valid point, and was made before the op clarified his question, and it is the most fundamental basic reason for a struct.If you need reference semantics you need a class not a struct. In addition to the "it is a value" answer, one specific scenario for using structs is when you know that you have a set of data that is causing garbage collection issues, and you have lots of objects. For example, a large list/array of Person instances. The natural metaphor here is a class, but if you have large number of long-lived Person instance, they can end up clogging GEN-2 and causing GC stalls. If the scenario warrants it, one potential approach here is to use an array (not list) of Person structs, i.e. Person[]. Now, instead of having millions of objects in GEN-2, you have a single chunk on the LOH (I\'m assuming no strings etc here - i.e. a pure value without any references). This has very little GC impact.Working with this data is awkward, as the data is probably over-sized for a struct, and you don\'t want to copy fat values all the time. However, accessing it directly in an array does not copy the struct - it is in-place (contrast to a list indexer, which does copy). This means lots of work with indexes:Note that keeping the values themselves immutable will help here. For more complex logic, use a method with a by-ref parameter:Again, this is in-place - we have not copied the value.In very specific scenarios, this tactic can be very successful; however, it is a fairly advanced scernario that should be attempted only if you know what you are doing and why. The default here would be a class.From the C# Language specification:1.7 Structs Like classes, structs are data structures that can contain data members and function members, but unlike classes, structs are\n  value types and do not require heap allocation. A variable of a struct\n  type directly stores the data of the struct, whereas a variable of a\n  class type stores a reference to a dynamically allocated object.\n  Struct types do not support user-specified inheritance, and all struct\n  types implicitly inherit from type object.Structs are particularly useful for small data structures that have\n  value semantics. Complex numbers, points in a coordinate system, or\n  key-value pairs in a dictionary are all good examples of structs. The\n  use of structs rather than classes for small data structures can make\n  a large difference in the number of memory allocations an application\n  performs. For example, the following program creates and initializes\n  an array of 100 points. With Point implemented as a class, 101\n  separate objects are instantiated\xe2\x80\x94one for the array and one each for\n  the 100 elements.An alternative is to make Point a struct.Now, only one object is instantiated\xe2\x80\x94the one for the array\xe2\x80\x94and the Point instances are stored in-line in the array.Struct constructors are invoked with the new operator, but that does not imply that memory is being allocated. Instead of dynamically allocating an object and returning a reference to it, a struct constructor simply returns the struct value itself (typically in a temporary location on the stack), and this value is then copied as necessary.With classes, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable. With structs, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other. For example, the output produced by the following code fragment depends on whether Point is a class or a struct.If Point is a class, the output is 20 because a and b reference the same object. If Point is a struct, the output is 10 because the assignment of a to b creates a copy of the value, and this copy is unaffected by the subsequent assignment to a.x.The previous example highlights two of the limitations of structs. First, copying an entire struct is typically less efficient than copying an object reference, so assignment and value parameter passing can be more expensive with structs than with reference types. Second, except for ref and out parameters, it is not possible to create references to structs, which rules out their usage in a number of situations.Structs are good for atomic representation of data, where the said data can be copied multiple times by the code. Cloning an object is in general more expensive than copying a struct, as it involves allocating the memory, running the constructor and deallocating/garbage collection when done with it.Here is a basic rule.If all member fields are value types create a struct.If any one member field is a reference type, create a class. This is because the reference type field will need the  heap allocation anyway.ExmaplesFirst: Interop scenarios or when you need to specify the memory layoutSecond: When the data is almost the same size as a reference pointer anyway.I use structs for packing or unpacking any sort of binary communication format. That includes reading or writing to disk, DirectX vertex lists, network protocols, or dealing with encrypted/compressed data.The three guidelines you list haven\'t been useful for me in this context. When I need to write out four hundred bytes of stuff in a Particular Order, I\'m gonna define a four-hundred-byte struct, and I\'m gonna fill it with whatever unrelated values it\'s supposed to have, and I\'m going to set it up whatever way makes the most sense at the time. (Okay, four hundred bytes would be pretty strange-- but back when I was writing Excel files for a living, I was dealing with structs of up to about forty bytes all over, because that\'s how big some of the BIFF records ARE.)You need to use a "struct" in situations where you want to explicitly specify memory layout using the StructLayoutAttribute - typically for PInvoke.Edit: Comment points out that you can use class or struct with StructLayoutAttribute and that is certainly true. In practice, you would typically use a struct - it is allocated on the stack vs the heap which makes sense if you are just passing an argument to an unmanaged method call.With the exception of the valuetypes that are used directly by the runtime and various others for PInvoke purposes, you should only use valuetypes in 2 scenarios..NET supports value types and reference types (in Java, you can define only reference types). Instances of reference types get allocated in the managed heap and are garbage collected when there are no outstanding references to them. Instances of value types, on the other hand, are allocated in the stack, and hence allocated memory is reclaimed as soon as their scope ends. And of course, value types get passed by value, and reference types by reference. All C# primitive data types, except for System.String, are value types.When to use struct over class,In C#, structs are value types, classes are reference types. You can create value types, in C#, using the enum keyword and the struct keyword. Using a value type instead of a reference type will result in fewer objects on the managed heap, which results in lesser load on the garbage collector (GC), less frequent GC cycles, and consequently better performance. However, value types have their downsides too. Passing around a big struct is definitely costlier than passing a reference, that\'s one obvious problem. The other problem is the overhead associated with boxing/unboxing. In case you\'re wondering what boxing/unboxing mean, follow these links for a good explanation on boxing and unboxing. Apart from performance, there are times when you simply need types to have value semantics, which would be very difficult (or ugly) to implement if reference types are all you have. You should use value types only, When you need copy semantics or need automatic initialization, normally in arrays of these types.Structure types in C# or other .net languages are generally used to hold things that should behave like fixed-sized groups of values.  A useful aspect of structure types is that the fields of a structure-type instance can be modified by modifying the storage location in which it is held, and in no other way.  It\'s possible to code a structure in such a way that the only way to mutate any field is to construct a whole new instance and then use a struct assignment to mutate all the fields of the target by overwriting them with values from the new instance, but unless a struct provides no means of creating an instance where its fields have non-default values, all of its fields will be mutable if and if the struct itself is stored in a mutable location.Note that it\'s possible to design a structure type so that it will essentially behave like a class type, if the structure contains a private class-type field, and redirects its own members to that of the wrapped class object.  For example, a PersonCollection might offer properties SortedByName and SortedById, both of which hold an "immutable" reference to a PersonCollection (set in their constructor) and implement GetEnumerator by calling either creator.GetNameSortedEnumerator or creator.GetIdSortedEnumerator.  Such structs would behave much like a reference to a PersonCollection, except that their GetEnumerator methods would be bound to different methods in the PersonCollection.  One could also have a structure wrap a portion of an array (e.g. one could define an ArrayRange<T> structure which would hold a T[] called Arr, an int Offset, and an int Length, with an indexed property which, for an index idx in the range 0 to Length-1, would access Arr[idx+Offset]).  Unfortunately, if foo is a read-only instance of such a structure, current compiler versions won\'t allow operations like foo[3]+=4; because they have no way to determine whether such operations would attempt to write to fields of foo.It\'s also possible to design a structure to behave a like a value type which holds a variable-sized collection (which will appear to be copied whenever the struct is) but the only way to make that work is to ensure that no object to which the struct holds a reference will ever be exposed to anything which might mutate it.  For example, one could have an array-like struct which holds a private array, and whose indexed "put" method creates a new array whose content is like that of the original except for one changed element.  Unfortunately, it can be somewhat difficult to make such structs perform efficiently.  While there are times that struct semantics can be convenient (e.g. being able to pass an array-like collection to a routine, with the caller and callee both knowing that outside code won\'t modify the collection, may be better than requiring both caller and callee to defensively copy any data they\'re given), the requirement that class references point to objects that will never be mutated is often a pretty severe constraint.Nah - I don\'t entirely agree with the rules. They are good guidelines to consider with performance and standardization, but not in light of the possibilities.As you can see in the responses, there are a log of creative ways to use them. So, these guidelines need to just be that, always for the sake of performance and efficiency.In this case, I use classes to represent real world objects in their larger form, I use structs to represent smaller objects that have more exact uses. The way you said it, "a more cohesive whole." The keyword being cohesive. The classes will be more object oriented elements, while structs can have some of those characteristics, their on a smaller scale. IMO.I use them a lot putting in Treeview and Listview tags where common static attributes can be accessed very quickly. I would struggle to get this info another way. For example, in my database applications, I use a Treeview where I have Tables, SPs, Functions, or any other objects. I create and populate my struct, put it in the tag, pull it out, get the data of the selection and so forth. I wouldn\'t do this with a class!I do try and keep them small, use them in single instance situations, and keep them from changing. It\'s prudent to be aware of memory, allocation, and performance. And testing is so necessary.I think a good first approximation is "never".I think a good second approximation is "never".If you are desperate for perf, consider them, but then always measure.A class is a reference type. When an object of the class is created, the variable to which the object is assigned holds only a reference to that memory. When the object reference is assigned to a new variable, the new variable refers to the original object. Changes made through one variable are reflected in the other variable because they both refer to the same data.\nA struct is a value type. When a struct is created, the variable to which the struct is assigned holds the struct\'s actual data. When the struct is assigned to a new variable, it is copied. The new variable and the original variable therefore contain two separate copies of the same data. Changes made to one copy do not affect the other copy.\nIn general, classes are used to model more complex behavior, or data that is intended to be modified after a class object is created. Structs are best suited for small data structures that contain primarily data that is not intended to be modified after the struct is created.Classes and Structs (C# Programming Guide)My rule is 1, Always use class;2, If there is any performance issue, I try to change some class to struct depending on the rules which @IAbstract mentioned, and then do a test to see if these changes can improve performance.I was just dealing with Windows Communication Foundation [WCF] Named Pipe and I did notice that it does make sense to use Structs in order to ensure that exchange of data is of value type instead of reference type. I rarely use a struct for things. But that\'s just me. It depends whether I need the object to be nullable or not.As stated in other answers, I use classes for real-world objects. I also have the mindset of structs are used for storing small amounts of data.Struct can be used to improve garbage collection performance.  While you usually don\'t have to worry about GC performance, there are scenarios where it can be a killer.  Like large caches in low latency applications.  See this post for an example:http://00sharp.wordpress.com/2013/07/03/a-case-for-the-struct/Structure or value types can be used in following scenarios -You can know more about the value types and values types here on this linkBriefly, use struct if :1- your object properties/fields do not need to be changed. I mean you just want to give them an initial value and then read them.2- properties and fields in your object are value type and they are not so large.If that\'s the case you can take advantage of structs for a better performance and optimized memory allocation as they use only stacks rather than both stacks and heaps (in classes) A struct is a value type.  If you assign a struct to a new variable, the new variable will contain a copy of the original.Excecution of the following results in 5 instances of the struct stored in memory:A class is a reference type.  When you assign a class to a new variable, the variable contains a reference to the original class object.Excecution of the following results in only one instance of the class object in memory.Structs may increase the likelihood of a code mistake.  If a value object is treated like a mutable reference object, a developer may be surprised when changes made are unexpectedly lost.I did a small benchmark with BenchmarkDotNet to get a better understanding of "struct" benefit in numbers. I\'m testing looping through array (or list) of structs (or classes). Creating those arrays or lists is out of the benchmark\'s scope - it is clear that "class" is more heavy will utilize more memory, and will involve GC.So the conclusion is: be careful with LINQ and hidden structs boxing/unboxing and using structs for microoptimizations strictly stay with arrays. Code:Structures are in most ways like classes/objects. Structure can contain functions, members and can be inherited. But structures are in C# used just for data holding. Structures does take less RAM than classes and are easier for garbage collector to collect. But when you use functions in your structure, then compiler actually takes that structure very similarly as class/object, so if you want something with functions, then use class/object.It seems to me that struct have no strong semantic that give the user a strong idea of when to use it.It resemble as a class but lake most of its feature. It is a kind of degraded version of a class.\nThere is a lot of says about when not use it but very few on when to use it.IMO, there is no reason why struct should be implemented in a OO language at the first place. Actually primitive type should not exist in a pure OO language but I digress.It might be a way to optimize stuff. A kind of boxing free things that can be optimize on some call site.My 2 cent, I would say that it violated the KISS of the language principle and avoid it as much has I can.