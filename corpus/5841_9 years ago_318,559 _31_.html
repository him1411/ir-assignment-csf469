How do you return 1 value per row of the max of several columns:TableNameI need to return something like this:Query?Well, you can use the CASE statement:[For Microsoft SQL Server 2008 and above, you may consider Sven\'s simpler answer below.]Here is another nice solution for the Max functionality using T-SQL and SQL ServerIf you\'re using MySQL, you can useThere are 3 more methods where UNPIVOT (1) is the fastest by far, followed by Simulated Unpivot (3) which is much slower than (1) but still faster than (2)Either of the two samples below will work:The second is an add-on to lassevk\'s answer.Scalar Function cause all sorts of performance issues, so its better to wrap the logic into an Inline Table Valued Function if possible.  This is the function I used to replace some User Defined Functions which selected the Min/Max dates from a list of upto ten dates.  When tested on my dataset of 1 Million rows the Scalar Function took over 15 minutes before I killed the query the Inline TVF took 1 minute which is the same amount of time as selecting the resultset into a temporary table.  To use this call the function from either a subquery in the the SELECT or a CROSS APPLY.This is slightly easier to write out and skips evaluation steps as the case statement is evaluated in order.Unfortunately Lasse\'s answer, though seemingly obvious, has a crucial flaw. It cannot handle NULL values. Any single NULL value results in Date1 being returned. Unfortunately any attempt to fix that problem tends to get extremely messy and doesn\'t scale to 4 or more values very nicely.databyss\'s first answer looked (and is) good. However, it wasn\'t clear whether the answer would easily extrapolate to 3 values from a multi-table join instead of the simpler 3 values from a single table. I wanted to avoid turning such a query into a sub-query just to get the max of 3 columns, also I was pretty sure databyss\'s excellent idea could be cleaned up a bit.So without further ado, here\'s my solution (derived from databyss\'s idea).\nIt uses cross-joins selecting constants to simulate the effect of a multi-table join. The important thing to note is that all the necessary aliases carry through correctly (which is not always the case) and this keeps the pattern quite simple and fairly scalable through additional columns.Problem: choose the minimum rate value given to an entity\nRequirements: Agency rates can be nullInspired by this answer from NatIf you are using SQL Server 2005, you can use the UNPIVOT feature.  Here is a complete example:Using CROSS APPLY (for 2005+) ....From SQL Server 2012 we can use IIF.For T-SQL (MSSQL 2008+)Please try using UNPIVOT:You could create a function where you pass the dates and then add the function to the select statement like below.\nselect Number, dbo.fxMost_Recent_Date(Date1,Date2,Date3), Cost(\n    @Date1 smalldatetime, \n    @Date2 smalldatetime,\n    @Date3 smalldatetime\n)\nRETURNS smalldatetime\nAS\nBEGIN\n    DECLARE @Result smalldatetimeENDBased on the ScottPletcher\'s  solution from http://www.experts-exchange.com/Microsoft/Development/MS-SQL-Server/Q_24204894.html \nI\xe2\x80\x99ve created a set of functions (e.g. GetMaxOfDates3 , GetMaxOfDates13 )to find max of up to 13 Date values using UNION ALL.\nSee T-SQL function to Get Maximum of values from the same row\nHowever I haven\'t considered UNPIVOT solution at the time of writing these functions I do not know if it is on SQL, etc... on M$ACCESS help there is a function called MAXA(Value1;Value2;...) that is supposed to do such.Hope can help someone.P.D.: Values can be columns or calculated ones, etc.here is a good solution: