Is there a concise way to iterate over a stream whilst having access to the index in the stream?The best I\'ve come across so far (challenge 2 here) iswhich seems rather disappointing compared to the LINQ example given thereIs there a more concise way?Further it seems the zip has either moved or been removed...The cleanest way is to start from a stream of indices:The resulting list contains "Erik" only.One alternative which looks more familiar when you are used to for loops would be to maintain an ad hoc counter using a mutable object, for example an AtomicInteger:Note that using the latter method on a parallel stream could break as the items would not necesarily be processed "in order".The Java 8 streams API lacks the features of getting the index of a stream element as well as the ability to zip streams together. This is unfortunate, as it makes certain applications (like the LINQ challenges) more difficult than they would be otherwise.There are often workarounds, however. Usually this can be done by "driving" the stream with an integer range, and taking advantage of the fact that the original elements are often in an array or in a collection accessible by index. For example, the Challenge 2 problem can be solved this way:As I mentioned above, this takes advantage of the fact that the data source (the names array) is directly indexable. If it weren\'t, this technique wouldn\'t work.I\'ll admit that this doesn\'t satisfy the intent of Challenge 2. Nonetheless it does solve the problem reasonably effectively.EDITMy previous code example used flatMap to fuse the filter and map operations, but this was cumbersome and provided no advantage. I\'ve updated the example per the comment from Holger.I\'ve used the following solution in my project. I think it is better than using mutable objects or integer ranges.In addition to protonpack, jOO\xce\xbb\'s Seq provides this functionality (and by extension libraries that build on it like cyclops-react, I am the author of this library).Seq also supports just Seq.of(names) and will build a JDK Stream under the covers.The simple-react equivalent would similarly look like The simple-react version is more tailored for asynchronous / concurrent processing.Just for completeness here\'s the solution involving my StreamEx library:Here we create an EntryStream<Integer, String> which extends Stream<Entry<Integer, String>> and adds some specific operations like filterKeyValue or values. Also toList() shortcut is used.Since guava 21, you can useExample (from official doc):With a List you can tryOutput:There isn\'t a way to iterate over a Stream whilst having access to the index because a Stream is unlike any Collection. A Stream is merely a pipeline for carrying data from one place to another, as stated in the documentation:No storage. A stream is not a data structure that stores elements; instead, they carry values from a source (which could be a data structure, a generator, an IO channel, etc) through a pipeline of computational operations.Of course, as you appear to be hinting at in your question, you could always convert your Stream<V> to a Collection<V>, such as a List<V>, in which you will have access to the indexes.With https://github.com/poetix/protonpack\nu can do that zip:If you don\'t mind using a third-party library, Eclipse Collections has zipWithIndex and forEachWithIndex available for use across many types.  Here\'s a set of solutions to this challenge for both JDK types and Eclipse Collections types using zipWithIndex.Here\'s a solution using forEachWithIndex instead.If you change the lambdas to anonymous inner classes above, then all of these code examples will work in Java 5 - 7 as well.Note: I am a committer for Eclipse CollectionsHere is code by AbacusUtilDisclosure\xef\xbc\x9a I\'m the developer of AbacusUtil.You can create a static inner class to encapsulate the indexer as I needed to do in example below:This question (Stream Way to get index of first element matching boolean)  has marked the current question as a duplicate, so I can not answer it there; I am answering it here.Here is a generic solution to get the matching index that does not require an external library.If you have a list.And call it like this:And if using a collection, try this one.If you happen to use Vavr(formerly known as Javaslang), you can leverage the dedicated method:If we print out the content, we will see something interesting:This is because Streams are lazy and we have no clue about next items in the stream.I found the solutions here when the Stream is created of list or array (and you know the size). But what if Stream is with unknown size? In this case try this variant:Usage:One possible way is to index each element on the flow:Using an anonymous class along a stream is not well-used while being very useful.