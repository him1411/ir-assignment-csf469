I want a to be rounded to 13.95.The round function does not work the way I expected.You are running into the old problem with floating point numbers that all numbers cannot be represented. The command line is just showing you the full floating point form from memory. In floating point your rounded version is the same number. Since computers are binary they store floating point numbers as an integer and then divide it by a power of two so 13.95 will be represented in a similar fashion to 125650429603636838/(2**53). Double precision numbers have 53 bits (16 digits) of precision and regular floats have 24 bits (8 digits) of precision. The floating point in python uses double precision to store the values.for exampleIf you are after only two decimal places as in currency then you have a couple of better choices use integers and store values in cents not dollars and then divide by 100 to convert to dollars.  Or use a fixed point number like decimalThere are new format specifications, here:http://docs.python.org/library/string.html#format-specification-mini-languageYou can do the same as:Note that the above returns a string. in order to get as float, simply wrap with float(...)Note that wrapping with float() doesn\'t change anything:Most numbers cannot be exactly represented in floats. If you want to round the number because that\'s what your mathematical formula or algorithm requires, then you want to use round. If you just want to restrict the display to a certain precision, then don\'t even use round and just format it as that string. (If you want to display it with some alternate rounding method, and there are tons, then you need to mix the two approaches.)And lastly, though perhaps most importantly, if you want exact math then you don\'t want floats at all. The usual example is dealing with money and to store \'cents\' as an integer.I feel that the simplest approach is to use the format() function.For example:This produces a float number as a string rounded to two decimal points.Try codes below:the built-in round() works just fine in Python 3.\nExample:Check out the documentation.With python < 3 (e.g. 2.6 or 2.7), there are two ways to do so.But note that for python versions above 3 (e.g. 3.2 or 3.3), option two is preferedFor more info on option two, I suggest this link on string formatting from the python docs.And for more info on option one, this link will suffice and has info on the various flags.Refrence: Convert floating point number to certain precision, then copy to StringWhat you can do is modify the output format:The rounding problem at input / output has been solved by Python 2.7.0 definitively.See the Release notes Python 2.7 - Other Language Changes the fourth paragraph:Conversions between floating-point numbers and strings are now correctly rounded on most platforms. These conversions occur in many different places: str() on floats and complex numbers; the float and complex constructors; numeric formatting; serializing and de-serializing floats and complex numbers using the marshal, pickle and json modules; parsing of float and imaginary literals in Python code; and Decimal-to-float conversion.Related to this, the repr() of a floating-point number x now returns a result based on the shortest decimal string that\xe2\x80\x99s guaranteed to round back to x under correct rounding (with round-half-to-even rounding mode). Previously it gave a string based on rounding x to 17 decimal digits.The related issueEDIT - more info:: The formatting of float before Python 2.7 was similar to the current numpy.float64. Both types use the same 64 bit IEEE 754 double precision with 52 bit mantisa. A big difference is that np.float64.__repr__ is formated frequently with an excessive decimal number so that no bit can be lost, but no valid IEEE 754 number exists between 13.949999999999999 and 3.950000000000001, the result is not nice and the conversion repr(float(number_as_string)) is not reversible. On the other side: float.__repr__ is formatted so that every digit is important, the sequence is without gaps and the conversion is reversible. Simply: If you perhaps have a numpy.float64 number, convert it to normal float in order to be formatted for humans not for numeric processors, otherwise nothing more is necessary with Python 2.7+.The python tutorial has an appendix called: Floating Point Arithmetic: Issues and Limitations. Read it. It explains what is happening and why python is doing its best. It has even an example that matches yours. Let me quote a bit:you may be tempted to use the round()\n  function to chop it back to the single\n  digit you expect. But that makes no\n  difference:The problem is that the binary\n  floating-point value stored for \xe2\x80\x9c0.1\xe2\x80\x9d\n  was already the best possible binary\n  approximation to 1/10, so trying to\n  round it again can\xe2\x80\x99t make it better:\n  it was already as good as it gets.Another consequence is that since 0.1\n  is not exactly 1/10, summing ten\n  values of 0.1 may not yield exactly\n  1.0, either:One alternative and solution to your problems would be using the decimal module.It\'s doing exactly what you told it to do, and working correctly.  Read more about floating point confusion and maybe try Decimal objects instead.for fix the floating point in type dynamic languages such as Python and Javascript I use this techniqueyou can also use Decimal as follwoing:To round a number to a resolution, the best way is the following one, which can work with any resolution (0.01 for 2 decimals or even other steps)Useinstead of Because the latter may raise error when trying to output multiple variables14.535562514.54The method I use is that of string slicing. It\'s relatively quick and simple.First, convert the float to a string, the choose the length you would like it to be.In the single line above, we\'ve converted the value to a string, then kept the string only to its first four digits or characters (inclusive).Hope that helps!