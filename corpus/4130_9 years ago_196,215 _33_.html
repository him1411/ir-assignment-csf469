I have some template code that I would prefer to have stored in a CPP file instead of inline in the header.  I know this can be done as long as you know which template types will be used.  For example:.h file.cpp fileNote the last two lines - the foo::do template function is only used with ints and std::strings, so those definitions mean the app will link.My question is - is this a nasty hack or will this work with other compilers/linkers? I am only using this code with VS2008 at the moment but will be wanting to port to other environments.The problem you describe can be solved by defining the template in the header, or via the approach you describe above.I recommend reading the following points from the C++ FAQ Lite: They go into a lot of detail about these (and other) template issues.For others on this page wondering what the correct syntax is (as did I) for explicit template specialisation (or at least in VS2008), its the following...In your .h file...And in your .cpp fileThis code is well-formed. You only have to pay attention that the definition of the template is visible at the point of instantiation. To quote the standard, \xc2\xa7 14.7.2.4:The definition of a non-exported function template, a non-exported member function template, or a non-exported member function or static data member of a class template shall be present in every translation unit in which it is explicitly instantiated.This should work fine everywhere templates are supported. Explicit template instantiation is part of the C++ standard.This is definitely not a nasty hack, but be aware of the fact that you will have to do it (the explicit template specialization) for every class/type you want to use with the given template. In case of MANY types requesting template instantiation there can be A LOT of lines in your .cpp file. To remedy this problem you can have a TemplateClassInst.cpp in every project you use so that you have greater control what types will be instantiated. Obviously this solution will not be perfect (aka silver bullet) as you might end up breaking the ODR :).There is, in the latest standard, a keyword (export) that would help alleviate this issue, but it isn\'t implemented in any compiler that I\'m aware of, other than Comeau.See the FAQ-lite about this.Your example is correct but not very portable. There is also a slightly cleaner syntax that can be used (as pointed out by @namespace-sid).Suppose the templated class is part of some library that is to be shared. Should other versions of the templated class be compiled? Is the library maintainer supposed to anticipate all possible templated uses of the class?An alternate approach is a slight variation on what you have: add a third file that is the template implementation/instantiation file.foo.h filefoo.cpp filefoo-impl.cpp fileThe one caveat is that you need to tell the compiler to compile foo-impl.cpp instead of foo.cpp as compiling the latter does nothing.Of course, you can have multiple implementations in the third file or have multiple implementation files for each type you\'d like to use.This enables much more flexibility when sharing the templated class for other uses.This setup also reduces compile times for reused classes because you\'re not recompiling the same header file in each translation unit.Yes, that\'s the standard way to do specializiation explicit instantiation.  As you stated, you cannot instantiate this template with other types.Edit: corrected based on comment.There is nothing wrong with the example you have given. But i must say i believe it\'s not efficient to store function definitions in a cpp file. I only understand the need to separate the function\'s declaration and definition.When used together with explicit class instantiation, the Boost Concept Check Library (BCCL) can help you generate template function code in cpp files.Time for an update! Create an inline (.inl, or probably any other) file and simply copy all your definitions in it. Be sure to add the template above each function (template <typename T, ...>). Now instead of including the header file in the inline file you do the opposite. Include the inline file after the declaration of your class (#include "file.inl").I don\'t really know why no one has mentioned this. I see no immediate drawbacks.