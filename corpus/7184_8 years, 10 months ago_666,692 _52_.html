I\'m working in C, and I have to concatenate a few things.Right now I have this:Now if you have experience in C I\'m sure you realize that this gives you a segmentation fault when you try to run it. So how do I work around that?In C, "strings" are just plain char arrays. Therefore, you can\'t directly concatenate them with other "strings". You can use the strcat function, which appends the string pointed to by src to the end of the string pointed to by dest:Here is an example from cplusplus.com:For the first parameter, you need to provide the destination buffer itself.  The destination buffer must be a char array buffer.  E.g.: char buffer[1024];Make sure that the first parameter has enough space to store what you\'re trying to copy into it.  If available to you, it is safer to use functions like: strcpy_s and strcat_s where you explicitly have to specify the size of the destination buffer. Note: A string literal cannot be used as a buffer, since it is a constant. Thus, you always have to allocate a char array for the buffer.The return value of strcat can simply be ignored, it merely returns the same pointer as was passed in as the first argument. It is there for convenience, and allows you to chain the calls into one line of code:So your problem could be solved as follows:Avoid using strcat in C code. The cleanest and, most importantly, the safest way is to use snprintf:Some commenters raised an issue that the number of arguments may not match the format string and the code will still compile, but most compilers already issue a warning if this is the case.Also malloc and realloc are useful if you don\'t know ahead of time how many strings are being concatenated.Folks, use strncpy(), strncat(), or snprintf().\nExceeding your buffer space will trash whatever else follows in memory!\n(And remember to allow space for the trailing null \'\\0\' character!)Strings can also be concatenated at compile time. Do not forget to initialize the output buffer. The first argument to strcat must be a null terminated string with enough extra space allocated for the resulting string:The first argument of strcat() needs to be able to hold enough space for the concatenated string. So allocate a buffer with enough space to receive the result.strcat() will concatenate the second argument with the first argument, and store the result in the first argument, the returned char* is simply this first argument, and only for your convenience.You do not get a newly allocated string with the first and second argument concatenated, which I\'d guess you expected based on your code.As people pointed out string handling improved much. So you may want to learn how to use the C++ string library instead of C-style strings. However here is a solution in pure CI am not sure whether it is correct/safe but right now I could not find a better way to do this in ANSI C.Best way to do it without having a limited buffer size is by using asprintf()It is undefined behaviour to attempt to modify string literals, which is what something like:will attempt to do. It will try to tack on the name string to the end of the string literal "Hello, ", which is not well defined.Try something this. It achieves what you appear to be trying to do:This creates a buffer area that is allowed to be modified and then copies both the string literal and other text to it. Just be careful with buffer overflows. If you control the input data (or check it before-hand), it\'s fine to use fixed length buffers like I have.Otherwise, you should use mitigation strategies such as allocating enough memory from the heap to ensure you can handle it. In other words, something like:You can write your own function that does the same thing as strcat() but that doesn\'t change anything:If both strings together are more than 1000 characters long, it will cut the string at 1000 characters. You can change the value of MAX_STRING_LENGTH to suit your needs.Assuming you have a char[fixed_size] rather than a char*, you can use a single, creative macro to do it all at once with a <<cout<<like ordering ("rather %s the disjointed %s\\n", "than", "printf style format").  If you are working with embedded systems, this method will also allow you to leave out malloc and the large *printf family of functions like snprintf() (This keeps dietlibc from complaining about *printf too)You are trying to copy a string into an address that is statically allocated. You need to cat into a buffer.Specifically:...snip...destination...snip...http://www.cplusplus.com/reference/clibrary/cstring/strcat.htmlThere\'s an example here as well.If you have experience in C you will notice that strings are only char arrays where the last character is a null character.Now that is quite inconvenient as you have to find the last character in order to append something. strcat will do that for you.So strcat searches through the first argument for a null character. Then it will replace this with the second argument\'s content (until that ends in a null).Now let\'s go through your code:Here you are adding something to the pointer to the text "TEXT" (the type of "TEXT" is const char*. A pointer.).That will usually not work. Also modifying the "TEXT" array will not work as it is usually placed in a constant segment.That might work better, except that you are again trying to modify static texts. strcat is not allocating new memory for the result.I would propose to do something like this instead:Read the documentation of sprintf to check for it\'s options.And now an important point:Ensure that the buffer has enough space to hold the text AND the null character. There are a couple of functions that can help you, e.g., strncat and special versions of printf that allocate the buffer for you.\nNot ensuring the buffer size will lead to memory corruption and remotely exploitable bugs.This was my solution but you need to specify how many strings you\'re going to concatenateTry something similar to this: