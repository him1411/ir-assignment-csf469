This question already has an answer here:Okay, this might just be a silly question, though I\'m sure there are plenty of other people asking the same question from time to time. Me, I just want to make 100% sure about it either way. With jQuery we all know the wonderful However, let\'s say I want to run a function that is written in standard JavaScript with no library backing it, and that I want to launch a function as soon as the page is ready to handle it. What\'s the proper way to approach this?I know I can do:...or I can use the body tag:...or I can even try at the bottom of the page after everything but the end body or html tag like:What is a cross-browser(old/new)-compliant method of issuing one or more functions in a manner like jQuery\'s $.ready()?The simplest thing to do in the absence of a framework that does all the cross-browser compatibility for you is to just put a call to your code at the end of the body.  This is faster to execute than an onload handler because this waits only for the DOM to be ready, not for all images to load.  And, this works in every browser.If you really don\'t want to do it this way and you need cross browser compatibility and you don\'t want to wait for window.onload, then you probably should go look at how a framework like jQuery implements it\'s $(document).ready() method.  It\'s fairly involved depending upon the capabilities of the browser.To give you a little idea what jQuery does (which will work wherever the script tag is placed).If supported, it tries the standard:with a fallback to:or for older versions of IE, it uses:with a fallback to:And, there are some work-arounds in the IE code path that I don\'t quite follow, but it looks like it has something to do with frames.Here is a full substitute for jQuery\'s .ready() written in plain javascript:The latest version of the code is shared publicly on GitHub at https://github.com/jfriend00/docReadyUsage:This has been tested in:Working implementation and test bed: http://jsfiddle.net/jfriend00/YfD3C/Here\'s a summary of how it works:Handlers registered with docReady() are guaranteed to be fired in the order they were registered.If you call docReady(fn) after the document is already ready, the callback will be scheduled to execute as soon as the current thread of execution completes using setTimeout(fn, 1).  This allows the calling code to always assume they are async callbacks that will be called later, even if later is as soon as the current thread of JS finishes and it preserves calling order.I would like to mention some of the possible ways here together with a pure javascript trick which works across all browsers:The trick here, as explained by the original author, is that we are checking the document.readyState property. If it contains the string in (as in uninitialized and loading, the first two DOM ready states out of 5) we set a timeout and check again. Otherwise, we execute the passed function.And here\'s the jsFiddle for the trick which works across all browsers. Thanks to Tutorialzine for including this in their book.Tested in IE9, and latest Firefox and Chrome and also supported in IE8.Example: http://jsfiddle.net/electricvisions/Jacck/UPDATE - reusable versionI have just developed the following. It\'s a rather simplistic equivalent to jQuery or Dom ready without backwards compatibility. It probably needs further refinement. Tested in latest versions of Chrome, Firefox and IE (10/11) and should work in older browsers as commented on. I\'ll update if I find any issues.Usage:It\'s written to handle async loading of JS but you might want to sync load this script first unless you\'re minifying. I\'ve found it useful in development.Modern browsers also support async loading of scripts which further enhances the experience. Support for async means multiple scripts can be downloaded simultaneously all while still rendering the page. Just watch out when depending on other scripts loaded asynchronously or use a minifier or something like browserify to handle dependencies. If you are doing VANILLA plain Javascript without jQuery, then you must use (IE9+)Above is the equivalent of Jquery .ready:Which ALSO could be written SHORTHAND like this, which jQuery will run after the ready even occurs. NOT TO BE CONFUSED with BELOW (which is not meant to be DOM ready)DO NOT use an IFFI like this that is self executing :\n     example:This IFFI will NOT wait for your DOM to load.    ( I\'m even talking about latest version of Chrome browser!The good folks at HubSpot have a resource where you can find pure Javascript methodologies for achieving a lot of jQuery goodness - including readyhttp://youmightnotneedjquery.com/#readyexample inline usage:Your method (placing script before the closing body tag)is a reliable way to support old and new browsers.Use likeSupport: IE9+I\'m not quite sure what your asking but maybe this can help,or: document.ondomcontentready=function(){} should do the trick, but it doesn\'t have full browser compatibility.Seems like you should just use jQuery minOK throwing my $0.02 in (this is basically a clarified, non-eval-using version of Ram-swaroop\'s "works in all browsers" method):This does wait an extra 10ms to run, however, so here\'s a more complicated way that shouldn\'t:See also How to check if DOM is ready without a framework?