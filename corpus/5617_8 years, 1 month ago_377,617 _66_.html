Is there a neater way for getting the length of an int as this?Your String-based solution is perfectly OK, there is nothing "un-neat" about it. You have to realize that mathematically, numbers don\'t have a length, nor do they have digits. Length and digits are both properties of a physical representation of a number in a specific base, i.e. a String.A logarithm-based solution does (some of) the same things the String-based one does internally, and probably does so (insignificantly) faster because it only produces the length and ignores the digits. But I wouldn\'t actually consider it clearer in intent - and that\'s the most important factor.The logarithm is your friend:NB: only valid for n > 0.The fastest approach: divide and conquer.Assuming your range is 0 to MAX_INT, then you have 1 to 10 digits. You can approach this interval using divide and conquer, with up to 4 comparisons per each input. First, you divide [1..10] into [1..5] and [6..10] with one comparison, and then each length 5 interval you divide using one comparison into one length 3 and one length 2 interval. The length 2 interval requires one more comparison (total 3 comparisons), the length 3 interval can be divided into length 1 interval (solution) and a length 2 interval. So, you need 3 or 4 comparisons.No divisions, no floating point operations, no expensive logarithms, only integer comparisons.Code (long but fast):Benchmark (after JVM warm-up) - see code below to see how the benchmark was run:Full code:Again, benchmark:Edit:\nAfter I wrote the benchmark, I took a sneak peak into Integer.toString from Java 6, and I found that it uses:I benchmarked it against my divide-and-conquer solution:Mine is about 4x faster. Two comments on your benchmark: Java is a complex environment, what with just-in-time compiling and garbage collection and so forth, so to get a fair comparison, whenever I run a benchmark, I always: (a) enclose the two tests in a loop that runs them in sequence 5 or 10 times. Quite often the runtime on the second pass through the loop is quite different from the first. And (b) After each "approach", I do a System.gc() to try to trigger a garbage collection. Otherwise, the first approach might generate a bunch of objects, but not quite enough to force a garbage collection, then the second approach creates a few objects, the heap is exhausted, and garbage collection runs. Then the second approach is "charged" for picking up the garbage left by the first approach. Very unfair!That said, neither of the above made a significant difference in this example.With or without those modifications, I got very different results than you did. When I ran this, yes, the toString approach gave run times of 6400 to 6600 millis, while the log approach topok 20,000 to 20,400 millis. Instead of being slightly faster, the log approach was 3 times slower for me.Note that the two approaches involve very different costs, so this isn\'t totally shocking: The toString approach will create a lot of temporary objects that have to be cleaned up, while the log approach takes more intense computation. So maybe the difference is that on a machine with less memory, toString requires more garbage collection rounds, while on a machine with a slower processor, the extra computation of log would be more painful.I also tried a third approach. I wrote this little function:That ran in 1600 to 1900 millis -- less than 1/3 of the toString approach, and 1/10 the log approach on my machine.If you had a broad range of numbers, you could speed it up further by starting out dividing by 1,000 or 1,000,000 to reduce the number of times through the loop. I haven\'t played with that.Since the number of digits in base 10 of an integer is just 1 + truncate(log10(number)), you can do:Edited because my last edit fixed the code example, but not the description.Using Javause import java.lang.Math.*; in the beginningUsing Cuse inclue math.h in the beginningCan I try? ;)based on Dirk\'s solutionMarian\'s solution adapted for long type numbers (up to 9,223,372,036,854,775,807), in case someone want\'s to Copy&Paste it.\nIn the program I wrote this for numbers up to 10000 were much more probable, so I made a specific branch for them. Anyway it won\'t make a significative difference.How about plain old Mathematics? Divide by 10 until you reach 0.Curious, I tried to benchmark it ... the results are :Now I am left to wonder if my benchmark actually means something but I do get consistent results (variations within a ms) over multiple runs of the benchmark itself ... :) It looks like it\'s useless to try and optimize this... edit: following ptomli\'s comment, I replaced \'number\' by \'i\' in the code above and got the following results over 5 runs of the bench : Marian\'s Solution, now with Ternary:Because we can.Can\'t leave a comment yet, so I\'ll post as a separate answer. The logarithm-based solution doesn\'t calculate the correct number of digits for very big long integers, for example:Logarithm-based solution calculates incorrect number of digits in large integersWhat about this recursive method?simple solution:A really simple solution:Or instead the length you can check if the number is larger or smaller then the desired number.}I haven\'t seen a multiplication-based solution yet. Logarithm, divison, and string-based solutions will become rather unwieldy against millions of test cases, so here\'s one for ints:In base 10, this works because n is essentially being compared to 9, 99, 999... as min is 9, 90, 900... and n is being subtracted by 9, 90, 900... Unfortunately, this is not portable to long just by replacing every instance of int due to overflow. On the other hand, it just so happens it will work for bases 2 and 10 (but badly fails for most of the other bases). You\'ll need a lookup table for the overflow points (or a division test... ew)With design (based on problem).  This is an alternate of divide-and-conquer.  We\'ll first define an enum (considering it\'s only for an unsigned int).Now we\'ll define a class that goes through the values of the enum and compare and return the appropriate length.The run time of this solution is the same as the divide-and-conquer approach.Enter the number and create an Arraylist, and the while loop will record all the digits into the Arraylist.  Then we can take out the size of array, which will be the length of the integer value you entered.Easy recursive waynot testedWe can achieve this using a recursive loopHere\'s a really simple method I made that works for any number: The way it works is with the number counter variable is that 10 = 1 digit space. For example .1 = 1 tenth => 1 digit space. Therefore if you have int number = 103342; you\'ll get 6, because that\'s the equivalent of .000001 spaces back. Also, does anyone have a better variable name for numberCounter? I can\'t think of anything better. Edit: Just thought of a better explanation. Essentially what this while loop is doing is making it so you divide your number by 10, until it\'s less than one. Essentially, when you divide something by 10 you\'re moving it back one number space, so you simply divide it by 10 until you reach <1 for the amount of digits in your number. Here\'s another version that can count the amount of numbers in a decimal: One wants to do this mostly because he/she wants to "present" it, which mostly mean it finally needs to be "toString-ed" (or transformed in another way) explicitly or implicitly anyway; before it can be presented (printed for example). If that is the case then just try to make the necessary "toString" explicit and count the bits.I did it this way and got the length of numberYou could could the digits using successive division by ten:Try converting the int to a string and then get the length of the string. That should get the length of the int.