Is this defined by the language? Is there a defined maximum? Is it different in different browsers?+/- 9007199254740991ECMA Section 8.5 - NumbersNote that all the positive and negative integers whose magnitude is no greater than 253 are representable in the Number type (indeed, the integer 0 has two representations, +0 and \xe2\x88\x920). They are 64-bit floating point values, the largest exact integral value is 253-1, or 9007199254740991. In ES6, this is defined as Number.MAX_SAFE_INTEGER.Note that the bitwise operators and shift operators operate on 32-bit ints, so in that case, the max safe integer is 231-1, or 2147483647.  From the reference:It is 253 == 9 007 199 254 740 992. This is because Numbers are stored as floating-point in a 52-bit mantissa.The min value is -253.This makes some fun things happeningAnd can also be dangerous :)Further reading: http://blog.vjeux.com/2010/javascript/javascript-max_int-number-limits.htmlIn javascript, there is a number called Infinityexamples:This may be sufficient for some questions regarding this topic.Jimmy\'s answer correctly represents the continuous JavaScript integer spectrum as -9007199254740992 to 9007199254740992 inclusive (sorry 9007199254740993, you might think you are 9007199254740993, but you are wrong!).  However, there is no answer that finds/proves this programatically (other than the one CoolAJ86 alluded to in his answer that would finish in 28.56 years ;), so here\'s a slightly more efficient way to do that (to be precise, it\'s more efficient by about 28.559999999968312 years :), along with a test fiddle:I thought I\'d be clever and find the value at which x + 1 === x with a more pragmatic approach.My machine can only count 10 million per second or so... so I\'ll post back with the definitive answer in 28.56 years.If you can\'t wait that long, I\'m willing to bet thatFinding x + 1 === x:ECMAScript 6:The short answer is \xe2\x80\x9cit depends.\xe2\x80\x9dIf you\xe2\x80\x99re using bitwise operators anywhere (or if you\xe2\x80\x99re referring to the length of an Array), the ranges are:Unsigned: 0\xe2\x80\xa6(-1>>>0)Signed: (-(-1>>>1)-1)\xe2\x80\xa6(-1>>>1)(It so happens that the bitwise operators and the maximum length of an array are restricted to 32-bit integers.)If you\xe2\x80\x99re not using bitwise operators or working with array lengths:Signed: (-Math.pow(2,53))\xe2\x80\xa6(+Math.pow(2,53))These limitations are imposed by the internal representation of the \xe2\x80\x9cNumber\xe2\x80\x9d type, which generally corresponds to IEEE 754 double-precision floating-point representation. (Note that unlike typical signed integers, the magnitude of the negative limit is the same as the magnitude of the positive limit, due to characteristics of the internal representation, which actually includes a negative 0!)Other may have already given the generic answer, but I thought it would be a good idea to give a fast way of determining it :Which gives me 9007199254740992 within less than a millisecond in Chrome 30.It will test powers of 2 to find which one, when \'added\' 1, equals himself.anything you want to use for bitwise operations must be between 0x80000000 (-2147483648 or -2^31) and 0x7fffffff (2147483647 or 2^31 - 1).the console will tell you that 0x80000000 equals +2147483648, but 0x80000000 & 0x80000000 equals -2147483648I did a simple test with a formula X-(X+1)=-1 and the largest value of X I can get to work on Safari, Opera and Firefox (tested on OSX) is 9e15. Here is the code I used for testing:maxInt = -1 >>> 1in Firefox 3.6 it\'s 2^31 - 1.I write it like this:Same for int32In the Google Chrome built-in javascript, you can go to approximately 2^1024 before the number is called infinity.Scato wrotes:anything you want to use for bitwise operations must be between\n  0x80000000 (-2147483648 or -2^31) and 0x7fffffff (2147483647 or 2^31 -\n  1).the console will tell you that 0x80000000 equals +2147483648, but\n  0x80000000 & 0x80000000 equals -2147483648Hex-Decimals are unsigned positive values, so 0x80000000 = 2147483648 - thats mathematically correct. If you want to make it a signed value you have to right shift: 0x80000000 >> 0 = -2147483648. You can write 1 << 31 instead, too.Number.MAX_VALUE represents the maximum numeric value representable in JavaScript.Since no one seems to have said so, in the v8 engine there is a difference in behavior for 31 bits number and number above that.If you have 32 bits you can use the first bit to tell the javascript engine what type that data is and have the remaining bits contain the actual data. That\'s what V8 does as a small optimisation for 31 bis numbers (or used to do, my sources are quite dated). You have the last 31 bits being the number value and then the first bit telling the engine if it\'s a number or an object reference.However if you use number above 31 bits then the data won\'t fit in, the number will be boxed in 64 bits double and the optimisation won\'t be there.The Bottom line, in the video below, is: prefer numeric values that can be represented as 31bits signed\n  integers.Firefox 3 doesnt seem to have a problem with huge numbers. 1e+200 * 1e+100 will calculate fine to 1e+300.Safari seem to have no problem with it aswell.\n(For the record, this is on a Mac if anyone else decides to test this)Unless I lost my brain at this time of day, this is way bigger than a 64-bit integer.UPDATE: Node.js and google Chrome seem to both be using 1024 bit floating point values so:Number.MAX_VALUE = 1.7976931348623157e+308