I\'m adding https support to an embedded linux device. I have tried to generate a self-signed certificate with these steps:This works, but I get some errors with, for example, google chrome:This is probably not the site you are looking for!\n  The site\'s security certificate is not trusted!Am I missing something? Is this the correct way to build a self-signed certificate?You can do that in one command:You can also add -nodes if you don\'t want to protect your private key with a passphrase, otherwise it will prompt you for "at least a 4 character" password.  The days parameter (365) you can replace with any number to affect expiration date.  It will then prompt you for things like "Country Name" but you can just hit enter and accept defaults.Self-signed certs are not validated with any third party unless you import them to the browsers previously. If you need more security, you should use a certificate signed by a CA.Here are the options described in @diegows\'s answer, described in more detail, from the documentation:PKCS#10 certificate request and certificate generating utility.this option outputs a self signed certificate instead of a certificate request.\n  This is typically used to generate a test certificate or a self signed root CA.this option creates a new certificate request and a new private key. The argument\n  takes one of several forms. rsa:nbits, where nbits is the number of bits,\n  generates an RSA key nbits in size.this gives the filename to write the newly created private key to.This specifies the output filename to write to or standard output by default.when the -x509 option is being used this specifies the number of days to certify\n  the certificate for. The default is 30 days.if this option is specified then if a private key is created it will not be encrypted.The documentation is actually more detailed than the above, I just summarized it here.Am I missing something? Is this the correct way to build a self-signed certificate?Its easy to create a self signed certificate. You just use the openssl req command. It can be tricky to create one that can be consumed by the largest selection of clients, like browsers and command line tools.Its difficult because the browsers have their own set of requirements, and they are more restrictive than the IETF. The requirements used by browsers are documented at the CA/Browser Forums (see references below). The restrictions arise in two key areas: (1) trust anchors, and (2) DNS names.Modern browsers (like the warez we\'re using in 2014/2015) want a certificate that chains back to a trust anchor, and they want DNS names to be presented in particular ways in the certificate. And Browsers are actively moving against self signed server certificatesSome browsers don\'t exactly make it easy to import a self signed server certificate. In fact, you can\'t with some browsers, like Android\'s browser. So the complete solution is to become your own authority.In the absence of becoming your own authority, you have to get the DNS names right to give the certificate the greatest chance of success. But I would encourage you to become your own authority. Its easy to become your own authority and it will side step all the trust issues (who better to trust than yourself?).This is probably not the site you are looking for!\n  The site\'s security certificate is not trusted!This is because browsers use a predefined list of trust anchors to validate server certificates. A self signed certificate does not chain back to a trusted anchor.The best way to avoid this is:Step 1 - Create your own authority just means to create a self signed certificate with CA: true and proper key usage. That means the Subject and Issuer are the same entity, CA is set to true in Basic Constraints (it should also be marked as critical), key usage is keyCertSign and crlSign (if you are using CRLs), and the Subject Key Identifier (SKI) is the same as the Authority Key Identifier (AKI).To become your own certificate authority, see How do you sign Certificate Signing Request with your Certification Authority? on Stack Overflow. Then, import your CA into the Trust Store used by the browser.Steps 2 - 4 are roughly what you do now for a public facing server when you enlist the services of a CA like Startcom or CAcert. Steps 1 and 5 allows you to avoid the third party authority, and act as your own authority (who better to trust than yourself?).The next best way to avoid the browser warning is to trust the server\'s certificate. But some browsers, like Android\'s default browser, do not let you do it. So it will never work on the platform.The issue of browsers (and other similar user agents) not trusting self signed certificates is going to be a big problem in the Internet of Things (IoT). For example, what is going to happen when you connect to your thermostat or refrigerator to program it? The answer is, nothing good as far as the user experience is concerned.The W3C\'s WebAppSec Working Group is starting to look at the issue.  See, for example, Proposal: Marking HTTP As Non-Secure.How to create a self-signed certificate with openssl?The commands below and the configuration file create a self signed certificate (it also shows you how to create a signing request). They differ from other answers in one respect: the DNS names used for the self signed certificate are in the Subject Alternate Name (SAN), and not the Common Name (CN).The DNS names are placed in the SAN through the configuration file with the line subjectAltName = @alternate_names (there\'s no way to do it through the command line). Then there\'s an alternate_names section in the configuration file (you should tune this to suit your taste):Its important to put DNS name in the SAN and not the CN because both the IETF and the CA/Browser Forums specify the practice. They also specify that DNS names in the CN are deprecated (but not prohibited). If you put a DNS name in the CN, then it must be included in the SAN under the CA/B policies. So you can\'t avoid using the Subject Alternate Name.If you don\'t do put DNS names in the SAN, then the certificate will fail to validate under a browser and other user agents which follow the CA/Browser Forum guidelines.Related: browsers follow the CA/Browser Forum policies; and not the IETF policies. That\'s one of the reasons a certificate created with OpenSSL (which generally follows the IETF) sometimes does not validate under a Browser (browsers follow the CA/B). They are different standards, they have different issuing policies and different validation requirements.Create a self signed certificate (notice the addition of -x509 option):Create a signing request (notice the lack of -x509 option):Print a self signed certificate:Print a signing request:Configuration file (passed via -config option)You may need to do the following for Chrome. Otherwise Chrome may complain a Common Name is invalid (ERR_CERT_COMMON_NAME_INVALID). I\'m not sure what the relationship is between an IP address in the SAN and a CN in this instance.There are other rules concerning the handling of DNS names in X.509/PKIX certificates. Refer to these documents for the rules:RFC 6797 and RFC 7469 are listed because they are more restrictive than the other RFCs and CA/B documents. RFC\'s 6797 and 7469 do not allow an IP address, either. I can\'t comment, so will put this as a separate answer.  I found a few issues with the accepted one-liner answer:Here is a simplified version that removes the passphrase, ups the security to suppress warnings and includes a suggestion in comments to pass in -subj to remove the full question list:Replace \'localhost\' with whatever domain you require.  You will need to run the first two commands one by one as openssl will prompt for a passphrase.To combine the two into a .pem file:I would recommend to add -sha256 parameter, to use SHA-2 hash algorithm, because major browsers are considering to show "SHA-1 certificates" as not secure.The same command line from the accepted answer - @diegows with added -sha256openssl req -x509 -sha256 -newkey rsa:2048 -keyout key.pem -out cert.pem -days XXXMore info in Google Security blog.The following command creates a relatively strong (as of 2017) certificate for the domain example.com that is valid for 3650 days (~10 years). It saves the private key and certificate into the files example.key and example.crt.Since it is a self-signed certificate that has to be accepted by users manually, it doesn\'t make sense to use a short expiration or weak crypto.In the future, you might want to use more than 4096 bits for the RSA key and a hash algorithm stronger than sha256, but as of 2017 these are sane values. They are sufficiently strong while being supported by all modern browsers.Side note: Theoretically you could leave out the -nodes parameter (which means "no DES encryption"), in which case example.key would be encrypted with a password. However, this is almost never useful for a server installation, because it means that you either have to store the password on the server as well, or that you have to enter it manually on each reboot.Modern browsers now throw a security error for otherwise well-formed self-signed certificates if they are missing a SAN (Subject Alternate Name). OpenSSL does not provide a command-line way to specify this, so many developers\' tutorials and bookmarks are suddenly outdated.The quickest way to get running again is a short, stand-alone conf file:Create an OpenSSL config file (example: req.cnf)Create the certificate referencing this config fileExample config from https://support.citrix.com/article/CTX135602You have the general procedure correct. The syntax for the command is below.However, the warnings are displayed because the browser was not able to verify the identify by validating the certificate with a known Certificate Authority (CA). As this is a self signed cert there is no CA and you can safely ignore the warning and proceed. Should you want to get a real cert that will be recognizable by anyone on the public internet then the procedure is below.I have more details about this in a post at https://bigthinkingapplied.com/secure-the-connection-installing-certificates-on-3-common-web-servers/I am using /etc/mysql for cert storage because /etc/apparmor.d/usr.sbin.mysqld contains /etc/mysql/*.pem r./etc/mysql/my.cnfOn my setup, ubuntu server logged to: /var/log/mysql/error.logSSL error: Unable to get certificate from \'...\'Mysql might be denied read access to your cert file if it is not in apparmors config. As mentioned in the previous steps^, Save all our certs as .pem files in the /etc/mysql/ directory which is approved by default by apparmor (or modify your apparmor/SELinux to allow access to wherever you stored them.)SSL error: Unable to get private keyYour mysql server version may not support the default rsa:2048 format.Covert generated rsa:2048 to plain rsa with:Check if local server supports ssl:Verifying a connection to the db is ssl encrypted:When logged in to the MySQL instance, you can issue the query: If your connection is not encrypted, the result will be blank: Otherwise, it would show a non-zero length string for the cypher in use: Require ssl for specific user\'s connection (\'require ssl\'):Tells the server to permit only SSL-encrypted connections for the account.To connect, the client must specify the --ssl-ca option to authenticate the server certificate, and may additionally specify the --ssl-key and --ssl-cert options. If neither --ssl-ca option nor --ssl-capath option is specified, the client does not authenticate the server certificate.Alternate link: Lengthy tutorial here http://www.madirish.net/214This is the script I use on local boxes to set the SAN (subjectAltName) in self-signed certificates. This script takes the domain name (example.com) and generates the SAN for *.example.com and example.com in the same certificate. The sections below are commented. Name the script (e.g. generate-ssl.sh) and give it executable permissions. The files will be written to the same directory as the script.Chrome 58 an onward requires SAN to be set in self-signed certificates.This script also writes an info file so you can inspect the new certificate and verify the SAN is set properly.If you are using Apache, then you can reference the above cert in your config file like so:Remember to restart your Apache (or Nginx, or IIS) server for the new cert to take effect.One liner FTW. I like to keep it simple.  Why not use one command that contains ALL the arguments needed? This is how I like it - This creates an x509 certificate and it\'s PEM key:That single command contains all the answers you would normally provide for the certificate details.  This way you can set the params and run the command, get your output - then go for coffee.>> more here <<2017 One liner:This also works in Chrome 57, as it provides the SAN, without having another config file.\nTaken from an answer here. \nThis creates a single .pem file that contains both the private key and cert. You can move them to separate .pem files if needed.