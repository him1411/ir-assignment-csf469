How do I check whether a file exists, without using the try statement?If the reason you\'re checking is so you can do something like if file_exists: open_it(), it\'s safer to use a try around the attempt to open it. Checking and then opening risks the file being deleted or moved or something between when you check and when you try to open it.If you\'re not planning to open the file immediately, you can use os.path.isfileReturn True if path is an existing regular file. This follows symbolic links, so both islink() and isfile() can be true for the same path.if you need to be sure it\'s a file.Starting with Python 3.4, the pathlib module offers an object-oriented approach (backported to pathlib2 in Python 2.7):To check a directory, do:To check whether a Path object exists independently of whether is it a file or directory, use exists():You can also use resolve() in a try block:You have the os.path.exists function:This returns True for both files and directories but you can instead use os.path.isfile to test if it\'s a file specifically. It follows symlinks.Unlike isfile(), exists() will return True for directories.\nSo depending on if you want only plain files or also directories, you\'ll use isfile() or exists(). Here is a simple REPL output.Use os.path.isfile() with os.access():This is the simplest way to check if a file exists. Just because the file existed when you checked doesn\'t guarantee that it will be there when you need to open it.Prefer the try statement. It\'s considered better style and avoids race conditions.Don\'t take my word for it. There\'s plenty of support for this theory. Here\'s a couple:Python 3.4 has an object-oriented path module: pathlib.  Using this new module, you can check whether a file exists like this:You can (and usually should) still use a try/except block when opening files:The pathlib module has lots of cool stuff in it: convenient globbing, checking file\'s owner, easier path joining, etc.  It\'s worth checking out.  If you\'re on an older Python (version 2.6 or later), you can still install pathlib with pip:Then import it as follows:Importing os makes it easier to navigate and perform standard actions with your operating system. For reference also see How to check whether a file exists using Python?If you need high-level operations, use shutil.In Python 3.4 and on, use the new Path object in pathlib.So let\'s get a file that we know is a file:By default, NamedTemporaryFile deletes the file when closed (and will automatically close when no more references exist to it).If you dig into the implementation, though, you\'ll see that is_file uses try:suppressPython 3.4 gives us the suppress context manager (previously the ignore context manager), which does semantically exactly the same thing in fewer lines, while also (at least superficially) meeting the original ask to avoid a try statement:Usage:For earlier Pythons, you could roll your own suppress, but without a try will be much more verbose than with. I do believe this actually is the only answer that doesn\'t use try at any level that can be applied to prior to Python 3.4 because it uses a context manager instead:Easier with a try:isfilefrom the docs:os.path.isfile(path)Return True if path is an existing regular file. This follows symbolic\n  links, so both islink() and isfile() can be true for the same path.But if you examine the source of this function, you\'ll see it actually does use a try statement:All it\'s doing is using the given path to see if it can get stats on it,  catching OSError and then checking if it\'s a file if it didn\'t raise the exception.If you intend to do something with the file, I would suggest directly attempting it with a try-except to avoid a race condition:os.accessAvailable for Unix and Windows is os.access, but to use you must pass flags, and it does not differentiate between files and directories. This is more used to test if the real invoking user has access in an elevated privilege environment:It also suffers from the same race condition problems as isfile. From the docs:Note:\n  Using access() to check if a user is authorized to e.g. open a file\n  before actually doing so using open() creates a security hole, because\n  the user might exploit the short time interval between checking and\n  opening the file to manipulate it. It\xe2\x80\x99s preferable to use EAFP\n  techniques. For example:is better written as:Testing for files and folders with os.path.isfile(), os.path.isdir() and os.path.exists()Assuming that the "path" is a valid path, this table shows what is returned by each function for files and folders:You can also test if a file is a certain type of file using os.path.splitext() to get the extension (if you don\'t already know it)It doesn\'t seem like there\'s a meaningful functional difference between try/except and isfile(), so you should use which one makes sense.If you want to read a file, if it exists, doBut if you just wanted to rename a file if it exists, and therefore don\'t need to open it, doIf you want to write to a file, if it doesn\'t exist, doIf you need file locking, that\'s a different matter.In 2016 the best way is still using os.path.isfile:Or in Python 3 you can use pathlib:You could try this (safer):The ouput would be:([Errno 2] No such file or directory:\n  \'whatever.txt\')Then, depending on the result, your program can just keep running from there or you can code to stop it if you want.Although I always recommend using try and except statements, here are a few possibilities for you (my personal favourite is using os.access):Try opening the file:Opening the file will always verify the existence of the file. You can make a function just like so:If it\'s False, it will stop execution with an unhanded IOError\nor OSError in later versions of Python. To catch the exception,\nyou have to use a try except clause. Of course, you can always\nuse a try except` statement like so (thanks to hsandt\nfor making me think):Use os.path.exists(path):This will check the existence of what you specify. However, it checks for files and directories so beware about how you use it.Use os.access(path, mode):This will check whether you have access to the file. It will check for permissions. Based on the os.py documentation, typing in os.F_OK, it will check the existence of the path. However, using this will create a security hole, as someone can attack your file using the time between checking the permissions and opening the file. You should instead go directly to opening the file instead of checking its permissions. (EAFP vs LBYP). If you\'re not going to open the file afterwards, and only checking its existence, then you can use this.Anyway, here:I should also mention that there are two ways that you will not be able to verify the existence of a file. Either the issue will be permission denied or no such file or directory. If you catch an IOError, set the IOError as e (like my first option), and then type in print(e.args) so that you can hopefully determine your issue. I hope it helps! :)Additionally, os.access():Being R_OK, W_OK, and X_OK the flags to test for permissions (doc).In Python 3.4 the language provides a new module to manage files:Just to add to the confusion, it seems that the try: open() approach suggested previously doesn\'t work in Python, as file access isn\'t exclusive, not even when writing to files, c.f. What is the best way to open a file for exclusive access in Python?.Raising exceptions is considered to be an acceptable, and Pythonic,\n  approach for flow control in your program. Consider handling missing\n  files with IOErrors. In this situation, an IOError exception will be\n  raised if the file exists but the user does not have read permissions.SRC: http://www.pfinn.net/python-check-if-file-exists.htmlHere\'s a 1 line Python command for the Linux command line environment. I find this VERY HANDY since I\'m not such a hot Bash guy.I hope this is helpful.Adding one more slight variation which isn\'t exactly reflected in the other answers.This will handle the case of the file_path being None or empty string.Adding a variant based on suggestion from Shahbaz\nAdding a variant based on suggestion from Peter Wood\nYou can write Brian\'s suggestion without the try:.suppress is part of Python 3.4. In older releases you can quickly write your own suppress:2017 / 09 / 20:Although I think that every possible way has been listed in (at least one of) the existing answers (e.g. Python 3.4 specific stuff was added), I\'ll try to group everything together.Note: every piece of Python standard library code that I\'m going to post, belongs to version 3.5.3 (doc quotes are version 3 specific).Problem statement:Possible solutions:[Python]: os.path.exists (also check other function family members like os.path.isfile, os.path.isdir, os.path.lexists for slightly different behaviors)Return True if path refers to an existing path or an open file descriptor. Returns False for broken symbolic links. On some platforms, this function may return False if permission is not granted to execute os.stat() on the requested file, even if the path physically exists.All good, but if following the import tree:os.path - posixpath.py (ntpath.py)genericpath.py, line ~#20+it\'s just a try/except block around [Python]: os.stat. So, your code is try/except free, but lower in the framestack there\'s (at least) one such block. This also applies to other funcs (including os.path.isfile).1.1. [Python]: pathlib.Path.is_fileUnder the hood, it does exactly the same thing (pathlib.py, line ~#1330):[Python]: os.access whose behavior is close to os.path.exists (actually it\'s wider, mainly because of the 2nd argument)...test if the invoking user has the specified access to path. mode should be F_OK to test the existence of path...Personally, I prefer this one because under the hood, it calls native APIs (via ${PYTHON_SRC_DIR}/Modules/posixmodule.c):Note: calling native APIs is also possible via [Python]: ctypes \xe2\x80\x94 A foreign function library for Python, but in most cases it\'s more complicated.(Win specific): Since msvcr*(vcruntime*) exports a [MSDN]: _access, _waccess function family as well, here\'s an example:Notes:The Lnx(Ubtu(16 x64)) counterpart as well:Use [Python]: With Statement Context Managers. Either:Create one:And its usage - I\'ll replicate the isfile behavior (note that this is just for demonstrating purposes, do not attempt to write such code for production):Use [Python]: contextlib.suppress(*exceptions) - which was specifically designed for selectively suppressing exceptionsBut, they seem to be wrappers over try/except/else/finally blocks, as [Python]: The with statement states:This allows common try...except...finally usage patterns to be encapsulated for convenient reuse.Use filesystem traversal functions (and search the results for matching item(s))Since these iterate over folders, they are inefficient for our problem, so I\'m not going to insist on them. Not to mention that in some cases, filename processing might be required.Install some 3rd Party module with filesystem capabilitiesMost likely, will rely on one of the ways above (maybe with slight customizations).One example would be (again, Win specific) [SourceForge]: Python for Windows Extensions (pywin32), which is a Python wrapper over WINAPIs.But, since this is more like a workaround (gainarie), I\'m stopping here. You can use the "OS" library of Python:I\'m the author of a package that\'s been around for about 10 years, and it has a function that addresses this question directly. Basically, if you are on a non-Windows system, it uses Popen to access find.  However, if you are on Windows, it replicates find with an efficient filesystem walker.The code itself does not use a try block\xe2\x80\xa6 except in determining the operating system and thus steering you to the "Unix"-style find or the hand-buillt find. Timing tests showed that the try was faster in determining the OS, so I did use one there (but nowhere else).And the doc\xe2\x80\xa6The implementation, if you care to look, is here:\nhttps://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190This is helpful when checking for several files. Or you want to do a set intersection/ subtraction with an existing list.How do I check whether a file exists, without using the try statement?In 2016, this is still arguably the easiest way to check if both a file exists and if it is a file:isfile is actually just a helper method that internally uses os.stat and stat.S_ISREG(mode) underneath. This os.stat is a lower-level method that will provide you with detailed information about files, directories, sockets, buffers, and more. More about os.stat hereNote: However, this approach will not lock the file in any way and therefore your code can become vulnerable to "time of check to time of use" (TOCTTOU) bugs.So raising exceptions is considered to be an acceptable, and Pythonic, approach for flow control in your program. And one should consider handling missing files with IOErrors, rather than if statements (just an advice).To check if a file exists, You can use the following open method to check if a file exists + readable: