Is there a way to get the count of rows in all tables in a MySQL database without running a SELECT count() on each table?Note from the docs though: For InnoDB tables, the row count is only a rough estimate used in SQL optimization. You\'ll need to use COUNT(*) for exact counts (which is more expensive).You can probably put something together with Tables table.  I\'ve never done it, but it looks like it has a column for TABLE_ROWS and one for TABLE NAME.  To get rows per table, you can use a query like this:  Like @Venkatramanan and others I found INFORMATION_SCHEMA.TABLES unreliable (using InnoDB, MySQL 5.1.44), giving different row counts each time I run it even on quiesced tables. Here\'s a relatively hacky (but flexible/adaptable) way of generating a big SQL statement you can paste into a new query, without installing Ruby gems and stuff.It produces output like this:Copy and paste except for the last UNION to get nice output like,I just run:This will give you the row count for EVERY table plus a bunch of other info.\nI used to use the selected answer above, but this is much easier.I\'m not sure if this works with all versions, but I\'m using 5.5 with InnoDB engine.This stored procedure lists tables, counts records, and produces a total number of records at the end.To run it after adding this procedure:-The Procedure:That\'s all you need.If you use the database information_schema, you can use this mysql code (the where part makes the query not show tables that have a null value for rows):You can try this. It is working fine for me.The following query produces a(nother) query that will get the value of count(*) for every table, from every schema, listed in information_schema.tables.  The entire result of the query shown here - all rows taken together - comprise a valid SQL statement ending in a semicolon - no dangling \'union\'. The dangling union is avoided by use of a union in the query below.If you want the exact numbers, use the following ruby script. You need Ruby and RubyGems.Install following Gems:File: count_table_records.rbGo back to the command-line:Output:This is how I count TABLES and ALL RECORDS using PHP:Poster wanted row counts without counting, but didn\'t specify which table engine. With InnoDB, I only know one way, which is to count.This is how I pick my potatoes:I am making no assertions about this other than that this is a really ugly but effective way to get how many rows exist in each table in the database regardless of table engine and without having to have permission to install stored procedures, and without needing to install ruby or php. Yes, its rusty. Yes it counts. count(*) is accurate.This is what I do to get the actual count (no using the schema) It\'s slower but more accurate.It\'s a two step process atGet list of tables for your db. You can get it using Create and assign the list of tables to the array variable in this bash script (separated by a single space just like in the code below)Run it:One more option: for non InnoDB it uses data from information_schema.TABLES (as it\'s faster), for InnoDB - select count(*) to get the accurate count. Also it ignores views.If your database has a lot of big InnoDB tables counting all rows can take more time.There\'s a bit of a hack/workaround to this estimate problem.Auto_Increment - for some reason this returns a much more accurate row count for your database if you have auto increment set up on tables.Found this when exploring why show table info did not match up with the actual data.You could then easily use PHP or whatever to return the max of the 2 data columns to give the "best estimate" for row count.i.e. Auto Increment will always be +1 * (table count) rows off, but even with 4,000 tables and 3 million rows, that\'s 99.9% accurate. Much better than the estimated rows.The beauty of this is that the row counts returned in performance_schema are erased for you, as well, because greatest does not work on nulls. This may be an issue if you have no tables with auto increment, though.If you know the number of tables and their names, and assuming they each have primary keys, you can use a cross join in combination with COUNT(distinct [column]) to get the rows that come from each table:Here is an SQL Fiddle example.