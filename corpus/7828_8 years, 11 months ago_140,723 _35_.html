I want to do something like this :Notice the nullable type as the generic parameter. Since the GetValueOrNull function could return null my first attempt was this: But the error I\'m getting now is:The type \'int?\' must be a reference type in order to use it as parameter \'T\' in the generic type or methodRight! Nullable<int> is a struct! So I tried changing the class constraint to a struct constraint (and as a side effect can\'t return null any more):Now the assignment:Gives the following error:The type \'int?\' must be a non-nullable value type in order to use it as parameter \'T\' in the generic type or methodIs specifying a nullable type as a generic parameter at all possible?Change the return type to Nullable, and call the method with the non nullable parameterJust use it like this:Just do two things to your original code. Remove the where constraint, and change the last return from return null to return default(T). This way you can return whatever type you want.By the way, you can avoid the use of "is" by changing your if statement to if (columnValue != DBNull.Value).Just had to do something incredible similar to this. My code:Disclaimer: This answer works, but is intended for educational purposes only. :) James Jones\' solution is probably the best here and certainly the one I\'d go with.C# 4.0\'s dynamic keyword makes this even easier, if less safe:Now you don\'t need the explicit type hinting on the RHS:In fact, you don\'t even need it at all!value will now be an int, or a string, or whatever type was returned from the DB.The only problem is that this does not prevent you from using non-nullable types on the LHS, in which case you\'ll get a rather nasty runtime exception like:As with all code that uses dynamic: caveat coder.I think you want to handle Reference types and struct types.\nI use it to convert XML Element strings to a more typed type.\nYou can remove the nullAlternative with reflection.\nThe formatprovider is to handle the culture dependent \'.\' or \',\' separator in e.g. decimals or ints and doubles.\nThis may work:You can use it like this:This may be a dead thread, but I tend to use the following:I know this is old, but here is another solution:Now, you don\'t care if T was value or reference type. Only if the function returns true, you have a reasonable value from the database.\nUsage:This approach is very similar to int.TryParse("123", out myInt);I just encountered the same problem myself.... = reader["myYear"] as int?; works and is clean.It works with any type without an issue. If the result is DBNull, it returns null as the conversion fails.Multiple generic constraints can\'t be combined in an OR fashion (less restrictive), only in an AND fashion (more restrictive). Meaning that one method can\'t handle both scenarios. The generic constraints also cannot be used to make a unique signature for the method, so you\'d have to use 2 separate method names.However, you can use the generic constraints to make sure that the methods are used correctly.In my case, I specifically wanted null to be returned, and never the default value of any possible value types. GetValueOrDefault = bad. GetValueOrNull = good.I used the words "Null" and "Nullable" to distinguish between reference types and value types. And here is an example of a couple extension methods I wrote that compliments the FirstOrDefault method in System.Linq.Enumerable class.