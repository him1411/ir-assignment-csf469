I encountered a situation where a non-void method is missing a return statement and the code still compiles.\nI know that the statements after the while loop are unreachable(dead code) and would never be executed. But why doesn\'t the compiler even warn about returning something? Or why would a language allow us to have a non-void method having an infinite loop and not returning anything?If I add a break statement(even a conditional one) in the while loop, the compiler complains of the infamous errors: \'Method does not return a value\'(Eclipse) and \'Not all code paths return a value\'(Visual Studio)This is true of both Java and C#Why would a language allow us to have a non-void method having an infinite loop and not returning anything?The rule for non-void methods is every code path that returns must return a value, and that rule is satisfied in your program: zero out of zero code paths that return do return a value.  The rule is not "every non-void method must have a code path that returns". This enables you to write stub-methods like:That\'s a non-void method. It has to be a non-void method in order to satisfy the interface. But it seems silly to make this implementation illegal because it does not return anything. That your method has an unreachable end point because of a goto (remember, a while(true) is just a more pleasant way to write goto) instead of a throw (which is another form of goto) is not relevant.Why doesn\'t the compiler even warn about returning something? Because the compiler has no good evidence that the code is wrong. Someone wrote while(true) and it seems likely that the person who did that knew what they were doing. Where can I read more about reachability analysis in C#?See my articles on the subject, here:ATBG: de facto and de jure reachabilityAnd you might also consider reading the C# specification.The Java compiler is smart enough to find the unreachable code ( the code after while loop)and since its unreachable, there is no point in adding a return statement there (after while ends)same goes with conditional ifsince the boolean condition someBoolean can only evaluate to either true or false, there is no need to provide a return explicitly after if-else, because that code is unreachable, and Java does not complain about it.The compiler knows that the while loop will never stop executing, hence the method will never finish, hence a return statement is not necessary.Given your loop is executing on a constant - the compiler knows that it\'s an infinite loop - meaning the method could never return, anyway.If you use a variable - the compiler will enforce the rule:This won\'t compile:The Java specification defines a concept called Unreachable statements. You are not allowed to have an unreachable statement in your code (it\'s a compile time error). You are not even allowed to have a return statement after the while(true); statement in Java. A while(true); statement makes the following statements unreachable by definition, therefore you don\'t need a return statement.Note that while Halting problem is undecidable in generic case, the definition of Unreachable Statement is more strict than just halting. It\'s deciding very specific cases where a program definitely does not halt. The compiler is theoretically not able to detect all infinite loops and unreachable statements but it has to detect specific cases defined in the specification (for example, the while(true) case)The compiler is smart enough to find out that your while loop is infinite.So the compiler cannot think for you. It cannot guess why you wrote that code. Same stands for the return values of methods. Java won\'t complain if you don\'t do anything with method\'s return values.So, to answer your question:The compiler analyzes your code and after finding out that no execution path leads to falling off the end of the function it finishes with OK.There may be legitimate reasons for an infinite loop. For example a lot of apps use an infinite main loop. Another example is a web server which may indefinitely wait for requests.There is no situation in which the function can reach its end without returning an appropriate value. Therefore, there is nothing for the compiler to complain about.In type theory, there is something called the bottom type which is a subclass of every other type (!) and is used to indicate non-termination among other things.  (Exceptions can count as a type of non-termination--you don\'t terminate via the normal path.)So from a theoretical perspective, these statements that are non-terminating can be considered to return something of Bottom type, which is a subtype of int, so you do (kind of) get your return value after all from a type perspective.  And it\'s perfectly okay that it doesn\'t make any sense that one type can be a subclass of everything else including int because you never actually return one.In any case, via explicit type theory or not, compilers (compiler writers) recognize that asking for a return value after a non-terminating statement is silly: there is no possible case in which you could need that value.  (It can be nice to have your compiler warn you when it knows something won\'t terminate but it looks like you want it to return something.  But that\'s better left for style-checkers a la lint, since maybe you need the type signature that way for some other reason (e.g. subclassing) but you really want non-termination.)Visual studio has the smart engine to detect if you have typed a return type then it should have a return statement with in the function/method.As in PHP Your return type is true if you have not returned anything. compiler get 1 if nothing has returned.As of this Compiler know that while statement itself has a infinte nature so not to consider it. and php compiler will automatically get true if you write a condition in expression of while.But not in the case of VS it will return you a error in the stack .Your while loop will run forever and hence won\'t come outside while; it will continue to execute. Hence, the outside part of while{} is unreachable and there is not point in writing return or not. The compiler is intelligent enough to figure out what part is reachable and what part isn\'t.Example: The above code won\'t compile, because there can be a case that the value of variable x is modified inside the body of while loop. So this makes the outside part of while loop reachable! And hence compiler will throw an error \'no return statement found\'. The compiler is not intelligent enough (or rather lazy ;) ) to figure out that whether the value of x will be modified or not. Hope this clears everything."Why doesn\'t the compiler even warn about returning something? Or why would a language allow us to have a non-void method having an infinite loop and not returning anything?".This code is valid in all other languages too (probably except Haskell!). Because the first assumption is we are "intentionally" writing some code.And there are situations that this code can be totally valid like if you are going to use it as a thread; or if it was returning a Task<int>, you could do some error checking based on the returned int value - which should not be returned.I may be wrong but some debuggers allow modification of variables. Here while x is not modified by code and it will be optimized out by JIT one might modify x to false and method should return something (if such thing is allowed by C# debugger). The specifics of the Java case for this (which are probably very similar to the C# case) are to do with how the Java compiler determines if a method is able to return.Specifically, the rules are that a method with a return type must not be able to complete normally and must instead always complete abruptly (abruptly here indicating via a return statement or an exception) per JLS 8.4.7.If a method is declared to have a return type, then a compile-time\n  error occurs if the body of the method can complete normally.\n  In other words, a method with a return type must return only by using\n  a return statement that provides a value return; it is not allowed to\n  "drop off the end of its body".The compiler looks to see whether normal termination is possible based on the rules defined in JLS 14.21 Unreachable Statements as it also defines the rules for normal completion.Notably, the rules for unreachable statements make a special case just for loops that have a defined true constant expression:A while statement can complete normally iff at least one of the\n  following is true:The while statement is reachable and the condition expression is not a\n  constant expression (\xc2\xa715.28) with value true.There is a reachable break statement that exits the while statement.So if the while statement can complete normally, then a return statement below it is necessary since the code is deemed reachable, and any while loop without a reachable break statement or constant true expression is considered able to complete normally.These rules mean that your while statement with a constant true expression and  without a break is never considered to complete normally, and so any code below it is never considered to be reachable.  The end of the method is below the loop, and since everything below the loop is unreachable, so is the end of the method, and thus the method cannot possibly complete normally (which is what the complier looks for).if statements, on the other hand, do not have the special exemption regarding constant expressions that are afforded to loops.Compare:With:The reason for the distinction is quite interesting, and is due to the desire to allow for conditional compilation flags that do not cause compiler errors (from the JLS):One might expect the if statement to be handled in the following\n  manner:An if-then statement can complete normally iff at least one of the\n  following is true:The if-then statement is reachable and the condition expression is not\n  a constant expression whose value is true.The then-statement can complete normally.The then-statement is reachable iff the if-then statement is reachable\n  and the condition expression is not a constant expression whose value\n  is false.An if-then-else statement can complete normally iff the then-statement\n  can complete normally or the else-statement can complete normally.The then-statement is reachable iff the if-then-else statement is\n  reachable and the condition expression is not a constant expression\n  whose value is false.The else-statement is reachable iff the if-then-else statement is\n  reachable and the condition expression is not a constant expression\n  whose value is true.This approach would be consistent with the treatment of other control\n  structures. However, in order to allow the if statement to be used\n  conveniently for "conditional compilation" purposes, the actual rules\n  differ.As an example, the following statement results in a compile-time\n  error:while (false) { x=3; } because the statement x=3; is not reachable;\n  but the superficially similar case:if (false) { x=3; } does not result in a compile-time error. An\n  optimizing compiler may realize that the statement x=3; will never be\n  executed and may choose to omit the code for that statement from the\n  generated class file, but the statement x=3; is not regarded as\n  "unreachable" in the technical sense specified here.The rationale for this differing treatment is to allow programmers to\n  define "flag variables" such as:static final boolean DEBUG = false; and then write code such as:if (DEBUG) { x=3; } The idea is that it should be possible to change\n  the value of DEBUG from false to true or from true to false and then\n  compile the code correctly with no other changes to the program text.Why does the conditional break statement result in a compiler error? As quoted in the loop reachability rules, a while loop can also complete normally if it contains a reachable break statement.  Since the rules for the reachability of an if statement\'s then clause do not take the condition of the if into consideration at all, such a conditional if statement\'s then clause is always considered reachable.If the break is reachable, then the code after the loop is once again also considered reachable.  Since there is no reachable code that results in abrupt termination after the loop, the method is then considered able to complete normally, and so the compiler flags it as an error.