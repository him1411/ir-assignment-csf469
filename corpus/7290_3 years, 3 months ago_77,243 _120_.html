I have recently been working to add Swift to an existing project, to get to try it out in a real-world fashion.Upon adding a Swift source file to the project, I have no problems about getting the "Bridging Header", that is, Objective-C to Swift.But the -Swift.h header file that is supposed to expose Swift classes either marked @objc or subclasses of ObjC classes, is nowhere to be found :-(I don\'t see any specific instructions on how to accomplish the usage of my new subclass, written in Swift, in my main app code (which is still Obj-C).The app that I am lead developer of has a fairly large codebase (70.000 lines), so transitioning it in one go is out of the question.Now it works.Finally works. Thanks to everyone for the help :-)I had a similar problem and found that you can only add #import \xe2\x80\x9cProductModuleName-Swift.h\xe2\x80\x9d to obj-c .m files, not .h files for the umbrella header to be foundI found that I had to fix all build errors before it would generate the file. The problem for me was that it was a chicken/egg problem, in that I didn\'t see any build errors until I\'d actually commented out the #import statement://#import "ProductModuleName-Swift.h"\nwhich revealed a bunch of other errors in my Swift code. Once I fixed these new errors and got the source building successfully, I uncommented out the #import and bingo! The header was created and importing correctly :)If your project module name has spaces in it, you must replace the spaces with an underscore.For instance, if your project name is "My Project", you would use:#import "My_Project-Swift.h"If you\'re like me you\'ve probably got the header name wrong.  After bashing my head for a while I looked for the file in DerivedData and sure enough it\'s there.  On my setup (using the standard derived data folder, I believe):Will find it.  If nothing in that folder matches then Xcode is not generating it.I\'m using Xcode Version 6.2 (6C86e)* The only important thing is: *to use the defined "Product Module Name" in the target, followed by -Swift.hNo matter if "Defines Module" param is set to Yes or No or if "Product Module Name" Project is not set.Reminder: Swift classes must deriving from NSObject or been tagged with @objc attribute in order to be exposed to ObjectiveC / Foundation || Cocoa ...I wanted to add one more reason you might find an issue with this - I was creating a framework that mixed Swift and Objective-C code.  I was not able to import the Swift classes outside the framework - I checked for the -Swift.h file and it was being generated but was empty.The problem turned out to be very, very simple - I had not declared any of my Swift classes public!  As soon as I added the public keyword to the classes, I was able to use them from classes inside and outside the framework.Also of note, inside the framework (inside .m files only as another answer mentions) I had to import the -Swift.h file as:I had the same problem. Seems like you have to adjust the settings (Defines Module and Product Module Name) before you add your first Swift file. If you do it afterwards the "*-Swift.h" file will not be generated for this project even if you add further Swift files or delete the Swift file and create a new one.The file name is always preceded by your Target name. It is referred as Product name but practically it is the target name. \nSo if you want it to build for a new target be ready to expect that_target-Swift.h file. One way to handle this is Add these lines in the PCH fileAdvantage of using PCH file is that you don\'t have to include the headers everywhere.This should work just fine. Here is another variation of the moduleName-Swift.h not being generated.I decided to include IOS Charts in my project but did not want to mingle the sources in the same directory, so I placed the Charts Project folder next to my code\'s project folder. I dragged the Charts project into my Project\'s Navigator Bar and included the framework in the my project target\'s Embedded Binaries list in the General project settings and set the Embedded Content Contains Swift Code switch to yes in my project\'s Build Settings tab in the Build Options section.My project\'s moduleName-Swift.h file would never generate no matter what other switches or settings suggested here. Finally, using Lou Z\'s method of seeking out the -Swift.h files, I saw that a Charts-Swift.h file was being generated deep in my project\'s xcode Build directory in Charts.framework/Headers/The solution to using Daniel Gindi\'s ios-charts Swift package without including the code in my project\'s source directory was to add:To the modules charting my project\'s data.If XCode is actually generating your -Swift.h header (deep inside DerivedData) but it doesn\'t refer to your Swift classes, make sure you also have a bridging header defined. The way I read the docs implied I only needed that for calling Objective-C from Swift, but it seems to be necessary for calling Swift from Objective-C too. See my answer: https://stackoverflow.com/a/27972946/337392EDIT: It is because of public vs. internal access modifiers, as I eventually found explained in the Apple docs:-By default, the generated header contains interfaces for Swift\n  declarations marked with the public modifier. It also contains those\n  marked with the internal modifier if your app target has an\n  Objective-C bridging header.Allow me to share my experiences trying to use Swift in an old objc project. I did not have to set Defines module to YES.In my case I needed to manually make sure there was an objc Bridging Header. Only the generated interface header name was present in my build settings.This lead to a MyApp-Swift.h file to being generated, but without any traces of my Swift classes.The Apple documentation says that you will be prompted to create a bridging header when adding your first swift file. Well, I wasn\'t. I manually added a MyApp-Bridging-header.h file and pointed to it in the "Objective-C Bridging Header" field. That made my MyApp-Swift.h file become populated with my Swift classes.Docs: Importing Swift into Objective-CSeconding what a lot of people have here, but adding a pertinent screen shot. Swift and Obj-C code can certainly live together. It\'s not an all or none game. To access Swift files in your Objective-C, all you need to do is add this call to your Obj-C file (in the .m / implementation file):(Where {product_module_name} represents the product module name of your project). Rather than try to guess your product module name or figure out corner cases with spaces and special characters, just go to the build settings tab in the project and type in "product module name" - the inspector will reveal yours to you. Mine was something I did not expect it to be. Check out this screen shot if you\'re confused.And to get Obj-c code working in Swift, you just need to add a bridging header file and import the relevant Obj-C headers there.The most important thing is that This file is invisible!!! At least it is in Xcode6 beta5. There will be no such file named "YourModule-Swift.h" in your workspace. Just make sure you have module name and defines module set to yes, and use it in your Objective-C class.This answer addresses the use-case where you may already have some Objective-C code that calls Swift classes and then you start receiving this error.How To Fix IssueThe following steps ultimately resolved all of the issues for me. I read above someone mentioning the "chicken and the egg" and it is exactly that concept which led me to this procedure. This explicit process shows that one has to remove any Objective-C code referencing Swift classes until after the header is generated.Nota Bene: The answers about changing spaces to underscores and the Defines Module to YES as given above still applies when performing this process, as do the rules specified in the Apple Documentation.Bridging Header PathIn one error, the file ProductModuleName-Bridging-Header.h was not being found during the build process. This fact generated an error< unknown>:0: error: bridging header\n  \'/Users/Shared/Working/abc/abc-Bridging-Header.h\' does not existCloser inspection of the error indicated that the file would never exist at the location described because it was actually located at (a wrong path) \'/Users/Shared/Working/abc/abc/abc-Bridging-Header.h\'. a quick search of the target/projects build settings to make the correction manually and the abc-Swift.h file was again auto generated.You have to import a header in Objective-C classes, which is:It is automatically generated, on the reference it says "Any Swift files in your target will be visible in Objective-C .m files containing this import statement."An actual file in the project is not created ([ProductModuleName]-Swift.h). Cmd + Click on the import either generates it on-the-fly (and in-memory) so you can see how the linkage is done, or opens a file somewhere in some Xcode cache dir, but it\'s not in the project dir.You need to set Defines Module project prop (in target\'s Build Settings) to Yes and if your module name has spaces or dashes - use _ in all imports of the [ProductModuleName]-Swift.h file.You can import it in all .h and .m files where you use swift types or you can import it in the .pch.So if my Module (project) is named "Test Project", I would import it like this, in the .pch file of my project (just there):Just a heads up for anyone who used "." in there project name.  Xcode will replace the "." with an underscore "_" for the Swift version of the bridging header file.  Oddly enough the Bridging-Header.h that is generated does not replace the periods with underscores.  For example a project with the name My.Project would have the following Bridging Header file names.  Bridging-Header.h (Autogenerated)My.Project-Bridging-Header.hSwift.hMy_Project.hI hope this helps anyone who used a period and was stuck like I was. This file can be found at the following location.Macintosh HD/Users/user/Library/Developer/Xcode/DerivedData/My.Project-fntdulwpbhbbzdbyrkhanemcrfil/Build/Intermediates/My.Project.build/Debug-iphonesimulator/My.Project.build/DerivedSourcesTake care,JonProject must have a Module Name not including spaces.\nDefines Module must be set to Yes in Build Settings, under Packaging.\ncommented out the #import statement:If still you are having error in importing "ProductModuleName-Swift.h" then//#import "ProductModuleName-Swift.h"which revealed a bunch of other errors in my Swift code.Once I fixed these new errors and got the source building successfully, I uncommented out the #import and bingo! The header was created and importing correctly :)Ok, here are all the things you really need!1.Remove all the swift files you have added, and compile the code, without any errors.2.Go to the "Projects" build settings, and set the product module name.\nProject must have a Product Module Name that does not include spaces.3.Defines Module must be set to Yes in Build Settings, under Packaging, in your project, and not target!4.Now create a swift file or a view controller, in file-> newFile->It will ask to create a bridging-header, allow it to make one.\nIf you have declined it once, you will have to manually add a -Bridging-Header.h5.Add @objc in the controller, to tell the compiler that there is some swift file, which needs to be exposed to ObjectiveC6.Build the project and import #import "-Swift.h" in any of the objectiveC controller, and it will work! You can Command-click on it to see the actual file!Hope this helps!I found a trick that always works on me. Do this work (delete and create the "ProductModuleName-Swift.h" from appDelegate.h file and clean your code) everytime you receive this error to silent it.I Found this solution Now you can instead of ProductModuleName-Swift.hThis\'s a workaround solution, for the next version of Xcode I think this problem will be solved.\nGood luckI was having a hard time determining my module name/objective-c\'s import of swift\'s headers. I did read a lot of articles here too.But the definitive answer for your project name with all its included special characters (be it \'.\' or a numeric or a space) - you can find the text that will work for you in the "Product Module Name" under the target\'s Build Settings.For example my target name started with a numeric - "1mg" and the field mentioned above showed "_mg" as my module name.so I used #import "_mg-Swift.h" and it worked.In my case I had to set the deployment target to at least \xe2\x80\x9cOS X 10.9\xe2\x80\x9d and the -Swift.h header was automatically generated. Keep in mind that you can get a lot of deprecation warnings when you change the deployment target version, especially when you have an older and very large Objective C code base. In our case we also had a lot of work to do in XIB files & view classes.If you were able to build a project before, with no issues related to \xe2\x80\x9cProductModuleName-Swift.h\xe2\x80\x9d not found error, and now you are getting that nasty errors again, the reason might sit in your recent changes.For me this was by (accidental) incorrect .swift file encoding. Reverting changes and bringing the back manually, does the job.This may be an obvious point (maybe too obvious), but you must have at least one swift file in the project for the header to generate. If you are writing boilerplate or config code with the intention of writing swift later the import won\'t work.I had to delete WatchOS2 swift code from my Objective C project. And only after that XCode offered to generate -Swift.hI had similar problem but my project was compiling before and suddenly got error after few files code change. It took me while to figure out why I am getting \'File not found\' error for myproject-swift.h file. The code changes I had done had some errors. Xcode did not point put those error instead all time showing the \'File not found error\'. Then got copy of previous version code and I compared with new code and merged file one by one. After each file merge complied the project to find the error. So bottom line is if you have error in your code Xcode may just display \'file not found error\' for myproject-swift.h file. Most likely you have compilation error in your project. Clean those error and it will work.If you\'re using something like Cocoapods (and working out of the workspace rather than the project) try opening the project and building it before opening the workspace and building. YMMV.