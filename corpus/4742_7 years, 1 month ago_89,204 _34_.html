I have a Wicket page class that sets the page title depending on the result of an abstract method.NetBeans warns me with the message "Overridable method call in constructor", but what should be wrong with it? The only alternative I can imagine is to pass the results of otherwise abstract methods to the super constructor in subclasses. But that could be hard to read with many parameters.Simply put, this is wrong because it unnecessarily opens up possibilities to MANY bugs. When the @Override is invoked, the state of the object may be inconsistent and/or incomplete.A quote from Effective Java 2nd Edition, Item 17: Design and document for inheritance, or else prohibit it:There are a few more restrictions that a class must obey to allow inheritance. Constructors must not invoke overridable methods, directly or indirectly. If you violate this rule, program failure will result. The superclass constructor runs before the subclass constructor, so the overriding method in the subclass will be invoked before the subclass constructor has run. If the overriding method depends on any initialization performed by the subclass constructor, the method will not behave as expected.Here\'s an example to illustrate:Here, when Base constructor calls overrideMe, Child has not finished initializing the final int x, and the method gets the wrong value. This will almost certainly lead to bugs and errors.Constructors with many parameters can lead to poor readability, and better alternatives exist.Here\'s a quote from Effective Java 2nd Edition, Item 2: Consider a builder pattern when faced with many constructor parameters:Traditionally, programmers have used the telescoping constructor pattern, in which you provide a constructor with only the required parameters, another with a single optional parameters, a third with two optional parameters, and so on...The telescoping constructor pattern is essentially something like this:And now you can do any of the following:You can\'t, however, currently set only the name and isAdjustable, and leaving levels at default. You can provide more constructor overloads, but obviously the number would explode as the number of parameters grow, and you may even have multiple boolean and int arguments, which would really make a mess out of things.As you can see, this isn\'t a pleasant pattern to write, and even less pleasant to use (What does "true" mean here? What\'s 13?).Bloch recommends using a builder pattern, which would allow you to write something like this instead:Note that now the parameters are named, and you can set them in any order you want, and you can skip the ones that you want to keep at default values. This is certainly much better than telescoping constructors, especially when there\'s a huge number of parameters that belong to many of the same types.Here\'s an example which helps to understand this: If you run this code, you get the following output: You see? foo() makes use of C before C\'s constructor has been run. If foo() requires C to have a defined state (i.e. the constructor has finished), then it will encounter an undefined state in C and things might break. And since you can\'t know in A what the overwritten foo() expects, you get a warning.Invoking an overridable method in the constructor allows subclasses to subvert the code, so you can\'t guarantee that it works anymore. That\'s why you get a warning.In your example, what happens if a subclass overrides getTitle() and returns null ?To "fix" this, you can use a factory method instead of a constructor, it\'s a common pattern of objects instanciation.If you call methods in your constructor that subclasses override, it means you are less likely to be referencing variables that don\xe2\x80\x99t exist yet if you divide your initialization logically between the constructor and the method.Have a look on this sample link http://www.javapractices.com/topic/TopicAction.do?Id=215Here is an example that reveals the logical problems that can occur when calling an overridable method in the super constructor.The result would actually be:minWeeklySalary: 0maxWeeklySalary: 0This is because the constructor of class B first calls the constructor of class A, where the overridable method inside B gets executed. But inside the method we are using the instance variable factor which has not yet been initialized (because the constructor of A has not yet finished), thus factor is 0 and not 1 and definitely not 2 (the thing that the programmer might think it will be). Imagine how hard would be to track an error if the calculation logic was ten times more twisted. I hope that would help someone.In the specific case of Wicket: This is the very reason why I asked the Wicket \ndevs to add support for an explicit two phase component initialization process in the framework\'s lifecycle of constructing a component i.e. There was quite an active debate about whether it was necessary or not (it fully  is necessary IMHO) as this link demonstrates http://apache-wicket.1842946.n4.nabble.com/VOTE-WICKET-3218-Component-onInitialize-is-broken-for-Pages-td3341090i20.html)The good news is that the excellent devs at Wicket did end up introducing two phase initialization (to make the most aweseome Java UI framework even more awesome!) so with Wicket you can do all your post construction initialization in the onInitialize method that is called by the framework automatically if you override it - at this point in the lifecycle of your component its constructor has completed its work so virtual methods work as expected.I guess for Wicket it\'s better to call add method in the onInitialize() (see components lifecycle) :