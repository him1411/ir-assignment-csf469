I want to read the onClick event value properties. But when i click on it, I see something like this on the console: My code is working correctly. When i run i can see {column} but cant get it in the onClick event.My Code:How can I pass a value to the onClick event in React js?Use an arrow function:This will create a new function that calls handleSort with the right params.Extract it into a sub-component.\nThe problem with using an arrow function in the render call is it will create a new function every time, which ends up causing unneeded re-renders.If you create a sub-component, you can pass handler and use props as the arguments, which will then re-render only when the props change (because the handler reference now never changes):Sub-componentMain componentOld Easy Way (ES5)Use .bind to pass the parameter you want:Nowadays, with ES6, I feel we could use an updated answer. Basically, (for any that don\'t know) since onClick is expecting a function passed to it, bind works because it creates a copy of a function. Instead we can pass an arrow function expression that simply invokes the function we want, and preserves this. You should never need to bind the render method in React, but if for some reason you\'re losing this in one of your component methods:[[h/t to @E.Sundin for linking this in a comment]The top answer (anonymous functions or binding) will work, but it\'s not the most performant, as it creates a copy of the event handler for every instance generated by the map() function.This is an explanation of the optimal way to do it from the ESLint-plugin-react:Lists of ItemsA common use case of bind in render is when rendering a list, to have\n  a separate callback per list item:Rather than doing it this way, pull the repeated section into its own\n  component:This will speed up rendering, as it avoids the need to create new\n  functions (through bind calls) on every render.There are nice answers here, and i agree with @Austin Greco (the second option with separate components) but i\'m surprised no one has mentioned currying.\nWhat you can do is create a function that accept a parameter (your parameter) and returns another function that accepts another parameter (the click event in this case). then you are free to do with it what ever you want.ES5: ES6: And you will use it this way:Here is a full example of such usage:This is my approach, not sure how bad it is, please commentIn the clickable element and thenOne more option not involving .bind or ES6 is to use a child component with a handler to call the parent handler with the necessary props. Here\'s an example (and a link to working example is below):The basic idea is for the parent component to pass the onClick function to a child component. The child component calls the onClick function and can access any props passed to it (and the event), allowing you to use any event value or other props within the parent\'s onClick function. Here\'s a CodePen demo showing this method in action. I have added code for onclick event value pass to the method in two ways . 1 . using bind method 2. using arrow(=>) method .     see the methods handlesort1 and handlesortI have below 3 suggestion to this on JSX onClick Events - Actually, we don\'t need to use .bind() or Arrow function in our code. You can simple use  in your code.You can also move onClick event from th(or ul) to tr(or li) to improve the performance. Basically you will have n number of "Event Listeners" for your n li element.// And you can access item.id in onItemClick method as shown below: I agree with the approach mention above for creating separate React Component for ListItem and List. This make code looks good however if you have 1000 of li then 1000 Event Listeners will be created. Please make sure you should not have much event listener.this example might be little different from yours. but i can assure you that this is the best solution you can have for this problem. \ni have searched for days for a solution which has no performance issue. and finally came up with this one.I wrote a wrapper component that can be reused for this purpose that builds on the accepted answers here. If all you need to do is pass a string however, then just add a data-attribute and read it from e.target.dataset (like some others have suggested).  By default my wrapper will bind to any prop that is a function and starts with \'on\' and automatically pass the data prop back to the caller after all the other event arguments.  Although I haven\'t tested it for performance, it will give you the opportunity to avoid creating the class yourself, and it can be used like this:const DataButton = withData(\'button\')const DataInput = withData(\'input\');or for Components and functionsconst DataInput = withData(SomeComponent);or if you preferconst DataButton = withData(<button/>)declare that Outside your container (near your imports)Here is usage in a container:  Here is the wrapper code \'withData.js:I think, .bind(this, arg1, arg2, ...) in React\'s map - is bad code, because it is slow! 10-50 of .bind(this) in single render method - very slow code.\nI fix it like this:\nRender method\n<tbody onClick={this.handleClickRow}>\nmap of <tr data-id={listItem.id}>\nHandler\nvar id = $(ev.target).closest(\'tr\').data().idFull code below:I would recommend curry over bind in this case. Like, 