Does anyone know how to do convert from a string to a boolean in Python? I found this link. But it doesn\'t look like a proper way to do it.  I.e. using a built in functionality, etc.The reason I asked this is because I learned int("string"), from here. I tried bool("string") but always got True.Really, you just compare the string to whatever you expect to accept as representing true, so you can do this:Or to checks against a whole bunch of values:Be cautious when using the following:Empty strings evaluate to False, but everything else evaluates to True. So this should not be used for any kind of parsing purposes.Then call it like so:> True> False> False> True> FalseHandling true and false explicitly:You could also make your function explicitly check against a True list of words and a False list of words.  Then if it is in neither list, you could throw an exception. Just use:http://docs.python.org/2/distutils/apiref.html?highlight=distutils.util#distutils.util.strtoboolTrue values are y, yes, t, true, on and 1; false values are n, no, f, false, off and 0. Raises ValueError if val is anything else.Starting with Python 2.6, there is now ast.literal_eval:Which seems to work, as long as you\'re sure your strings are going to be either "True" or "False":I wouldn\'t normally recommend this, but it is completely built-in and could be the right thing depending on your requirements.The JSON parser is also useful for in general converting strings to reasonable python types.You can simply use the built-in function eval():and the output:Here\'s is my version. It checks against both positive and negative values lists, raising an exception for unknown values. And it does not receive a string, but any type should do.Sample runs:This version keeps the semantics of constructors like int(value) and provides an easy way to define acceptable string values.you could always do something like the bit in parens would evaluate to False. This is just another way to do it without having to do an actual function call.I don\'t agree with any solution here, as they are too permissive. This is not normally what you want when parsing a string.So here the solution I\'m using:And the results:Just to be clear because it looks as if my answer offended somebody somehow:The point is that you don\'t want to test for only one value and assume the other. I don\'t think you always want to map Absolutely everything to the non parsed value. That produces error prone code.So, if you know what you want code it in.A dict (really, a defaultdict) gives you a pretty easy way to do this trick:It\'s really easy to tailor this method to the exact conversion behavior you want -- you can fill it with allowed Truthy and Falsy values and let it raise an exception (or return None) when a value isn\'t found, or default to True, or default to False, or whatever you want.You probably already have a solution but for others who are looking for a method to convert a value to a boolean value using "standard" false values including None, [], {}, and "" in addition to false, no , and 0.This is the version I wrote. Combines several of the other solutions into one.If it gets a string it expects specific values, otherwise raises an Exception. If it doesn\'t get a string, just lets the bool constructor figure it out. Tested these cases:I like to use the ternary operator for this, since it\'s a bit more succinct for something that feels like it shouldn\'t be more than 1 line.A cool, simple trick (based on what @Alan Marchiori posted), but using yaml:If this is too wide, it can be refined by testing the type result. If the yaml-returned type is a str, then it can\'t be cast to any other type (that I can think of anyway), so you could handle that separately, or just let it be true.I won\'t make any guesses at speed, but since I am working with yaml data under Qt gui anyway, this has a nice symmetry.The usual rule for casting to a bool is that a few special literals (False, 0, 0.0, (), [], {}) are false and then everything else is true, so I recommend the following:I realize this is an old post, but some of the solutions require quite a bit of code, here\'s what I ended up using:here\'s a hairy, built in way to get many of the same answers.  Note that although python considers "" to be false and all other strings to be true, TCL has a very different idea about things.  A good thing about this is that it is fairly forgiving about the values you can use.  It\'s lazy about turning strings into values, and it\'s hygenic about what it accepts and rejects(notice that if the above statement were given at a tcl prompt, it would erase the users hard disk).  the bad thing is that it requires that Tkinter be available, which is usually, but not universally true, and more significantly, requires that a Tk instance be created, which is comparatively heavy.  What is considered true or false depends on the behavior of the Tcl_GetBoolean, which considers 0, false, no and off to be false and 1, true, yes and on to be true, case insensitive.  Any other string, including the empty string, cause an exception.idea: check if you want the string to be evaluated to False; otherwise bool() returns True for any non-empty string.Here\'s something I threw together to evaluate the truthiness of a string:more-or-less same results as using eval but safer.I just had to do this... so maybe late to the party - but someone may find it usefulIf you know that your input will be either "True" or "False" then why not use: