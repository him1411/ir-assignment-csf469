Right, so I have an enumerable and wish to get distinct values from it.Using System.Linq, there\'s of course an extension method called Distinct. In the simple case, it can be used with no parameters, like:Well and good, but if I have an enumerable of objects for which I need to specify equality, the only available overload is:The equality comparer argument must be an instance of IEqualityComparer<T>. I can do this, of course, but it\'s somewhat verbose and, well, cludgy.What I would have expected is an overload that would take a lambda, say a Func<T, T, bool>:Anyone know if some such extension exists, or some equivalent workaround? Or am I missing something?Alternatively, is there a way of specifying an IEqualityComparer inline (embarass me)?UpdateI found a reply by Anders Hejlsberg to a post in an MSDN forum on this subject. He says:The problem you\'re going to run into is that when two objects compare\n  equal they must have the same GetHashCode return value (or else the\n  hash table used internally by Distinct will not function correctly).\n  We use IEqualityComparer because it packages compatible\n  implementations of Equals and GetHashCode into a single interface.I suppose that makes sense..It looks to me like you want DistinctBy from MoreLINQ. You can then write:Here\'s a cut-down version of DistinctBy (no nullity checking and no option to specify your own key comparer):No there is no such extension method overload for this.  I\'ve found this frustrating myself in the past and as such I usually write a helper class to deal with this problem.  The goal is to convert a Func<T,T,bool> to IEqualityComparer<T,T>.  ExampleThis allows you to write the followingThis will do what you want but I don\'t know about performance:At least it\'s not verbose.To Wrap things up . I think most of the people which came here like me want the simplest solution possible without using any libraries and with best possible performance.(The accepted group by method for me i think is an overkill in terms of performance. )Here is a simple extension method using the IEqualityComparer interface which works also for null values.Usage:Extension Method CodeShorthand solution Here\'s a simple extension method that does what I need...It\'s a shame they didn\'t bake a distinct method like this into the framework, but hey ho.Something I have used which worked well for me.All solutions I\'ve seen here rely on selecting an already comparable field. If one needs to compare in a different way, though, this solution here seems to work generally, for something like:You can use InlineComparerUsage sample:Source:\nhttps://stackoverflow.com/a/5969691/206730\nUsing IEqualityComparer for Union\nCan I specify my explicit type comparator inline? I\'m assuming you have an IEnumerable, and in your example delegate, you would like c1 and c2 to be referring to two elements in this list?I believe you could achieve this with a self join\nvar distinctResults = from c1 in myList\n                      join c2 in myList on If Distinct() doesn\'t produce unique results, try this one:The Microsoft System.Interactive package has a version of Distinct that takes a key selector lambda. This is effectively the same as Jon Skeet\'s solution, but it may be helpful for people to know, and to check out the rest of the library. A tricky way to do this is use Aggregate() extension, using a dictionary as accumulator with the key-property values as keys:And a GroupBy-style solution is using ToLookup():Here\'s how you can do it:This method allows you to use it by specifying one parameter like .MyDistinct(d => d.Name), but it also allows you to specify a having condition as a second parameter like so:N.B. This would also allow you to specify other functions like for example .LastOrDefault(...) as well.If you want to expose just the condition, you can have it even simpler by implementing it as:In this case, the query would just look like:N.B. Here, the expression is simpler, but note .MyDistinct2 uses .FirstOrDefault(...) implicitly.Note: The examples above are using the following demo classIEnumerable lambda extension:Usage:Take another way: The sequence return distinct elements compare them by property \'_myCaustomerProperty\' .