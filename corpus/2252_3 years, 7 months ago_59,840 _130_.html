I\'m relatively familiar with data.table, not so much with dplyr.  I\'ve read through some dplyr vignettes and examples that have popped up on SO, and so far my conclusions are that:In my mind 2. doesn\'t bear much weight because I am fairly familiar with it data.table, though I understand that for users new to both it will be a big factor.  I would like to avoid an argument about which is more intuitive, as that is irrelevant for my specific question asked from the perspective of someone already familiar with data.table.  I also would like to avoid a discussion about how "more intuitive" leads to faster analysis (certainly true, but again, not what I\'m most interested about here).What I want to know is:One recent SO question got me thinking about this a bit more, because up until that point I didn\'t think dplyr would offer much beyond what I can already do in data.table.  Here is the dplyr solution (data at end of Q):Which was much better than my hack attempt at a data.table solution.  That said, good data.table solutions are also pretty good (thanks Jean-Robert, Arun, and note here I favored single statement over the strictly most optimal solution):The syntax for the latter may seem very esoteric, but it actually is pretty straightforward if you\'re used to data.table (i.e. doesn\'t use some of the more esoteric tricks).Ideally what I\'d like to see is some good examples were the dplyr or data.table way is substantially more concise or performs substantially better.This is for the first example I showed in the question section.We need to cover at least these aspects to provide a comprehensive answer/comparison (in no particular order of importance): Speed, Memory usage, Syntax and Features.My intent is to cover each one of these as clearly as possible from data.table perspective.Note: unless explicitly mentioned otherwise, by referring to dplyr, we refer to dplyr\'s data.frame interface whose internals are in C++ using Rcpp.The data.table syntax is consistent in its form - DT[i, j, by]. To keep i, j and by together is by design. By keeping related operations together, it allows to easily optimise operations for speed and more importantly memory usage, and also provide some powerful features, all while mainitaining the consistency in syntax.Quite a few benchmarks (though mostly on grouping operations) have been added to the question already showing data.table gets faster than dplyr as the number of groups and/or rows to group by increase, including benchmarks by Matt on grouping from 10 million to 2 billion rows (100GB in RAM) on 100 - 10 million groups and varying grouping columns, which also compares pandas.On benchmarks, it would be great to cover these remaining aspects as well:Grouping operations involving a subset of rows - i.e., DT[x > val, sum(y), by=z] type operations.Benchmark other operations such as update and joins.Also benchmark memory footprint for each operation in addition to runtime.Operations involving filter() or slice() in dplyr can be memory inefficient (on both data.frames and data.tables). See this post. Note that Hadley\'s comment talks about speed (that dplyr is plentiful fast for him), whereas the major concern here is memory.data.table interface at the moment allows one to modify/update columns by reference (note that we don\'t need to re-assign the result back to a variable).But dplyr will never update by reference. The dplyr equivalent would be (note that the result needs to be re-assigned):A concern for this is referential transparency. Updating a data.table object by reference, especially within a function may not be always desirable. But this is an incredibly useful feature: see this and this posts for interesting cases. And we want to keep it.Therefore we are working towards exporting shallow() function in data.table that will provide the user with both possibilities. For example, if it is desirable to not modify the input data.table within a function, one can then do:By not using shallow(), the old functionality is retained:By creating a shallow copy using shallow(), we understand that you don\'t want to modify the original object. We take care of everything internally to ensure that while also ensuring to copy columns you modify only when it is absolutely necessary. When implemented, this should settle the referential transparency issue altogether while providing the user with both possibilties.Also, once shallow() is exported dplyr\'s data.table interface should avoid almost all copies. So those who prefer dplyr\'s syntax can use it with data.tables.  But it will still lack many features that data.table provides, including (sub)-assignment by reference.Aggregate while joining:Suppose you have two data.tables as follows:And you would like to get sum(z) * mul for each row in DT2 while joining by columns x,y. We can either:1) aggregate DT1 to get sum(z), 2) perform a join and 3) multiply (or)2) do it all in one go (using by=.EACHI feature):What is the advantage?We don\'t have to allocate memory for the intermediate result.We don\'t have to group/hash twice (one for aggregation and other for joining).And more importantly, the operation what we wanted to perform is clear by looking at j in (2).Check this post for a detailed explanation of by=.EACHI. No intermediate results are materialised, and the join+aggregate is performed all in one go. Have a look at this, this and this posts for real usage scenarios.In dplyr you would have to join and aggregate or aggregate first and then join, neither of which are as efficient, in terms of memory (which in turn translates to speed).Update and joins:Consider the data.table code shown below:adds/updates DT1\'s column col with mul from DT2 on those rows where DT2\'s key column matches DT1. I don\'t think there is an exact equivalent of this operation in dplyr, i.e., without avoiding a *_join operation, which would have to copy the entire DT1 just to add a new column to it, which is unnecessary.Check this post for a real usage scenario. To summarise, it is important to realise that every bit of optimisation matters. As Grace Hopper would say, Mind your nanoseconds!Let\'s now look at syntax. Hadley commented here:Data tables are extremely fast but I think their concision makes it harder to learn and code that uses it is harder to read after you have written it ...I find this remark pointless because it is very subjective. What we can perhaps try is to contrast consistency in syntax. We will compare data.table and dplyr syntax side-by-side. We will work with the dummy data shown below:Basic aggregation/update operations. data.table syntax is compact and dplyr\'s quite verbose. Things are more or less equivalent in case (a). In case (b), we had to use filter() in dplyr while summarising. But while updating, we had to move the logic inside mutate(). In data.table however, we express both operations with the same logic - operate on rows where x > 2, but in first case, get sum(y), whereas in the second case update those rows for y with its cumulative sum.This is what we mean when we say the DT[i, j, by] form is consistent.Similarly in case (c), when we have if-else condition, we are able to express the logic "as-is" in both data.table and dplyr. However, if we would like to return just those rows where the if condition satisfies and skip otherwise, we cannot use summarise() directly (AFAICT). We have to filter() first and then summarise because summarise() always expects a single value. While it returns the same result, using filter() here makes the actual operation less obvious.It might very well be possible to use filter() in the first case as well (does not seem obvious to me), but my point is that we should not have to.Aggregation / update on multiple columnsIn case (a), the codes are more or less equivalent. data.table uses familiar base function lapply(), whereas dplyr introduces *_each() along with a bunch of functions to funs(). data.table\'s := requires column names to be provided, whereas dplyr generates it automatically.In case (b), dplyr\'s syntax is relatively straightforward. Improving aggregations/updates on multiple functions is on data.table\'s list.In case (c) though, dplyr would return n() as many times as many columns, instead of just once. In data.table, all we need to do is to return a list in j. Each element of the list will become a column in the result. So, we can use, once again, the familiar base function c() to concatenate .N to a list which returns a list.Note: Once again, in data.table, all we need to do is return a list in j. Each element of the list will become a column in result. You can use c(), as.list(), lapply(), list() etc... base functions to accomplish this, without having to learn any new functions.You will need to learn just the special variables - .N and .SD at least. The equivalent in dplyr are n() and .Joinsdplyr provides separate functions for each type of join where as data.table allows joins using the same syntax DT[i, j, by] (and with reason). It also provides an equivalent merge.data.table() function as an alternative.Some might find a separate function for each joins much nicer (left, right, inner, anti, semi etc..), whereas as others might like data.table\'s DT[i, j, by], or merge() which is similar to base R. However dplyr joins do just that. Nothing more. Nothing less. data.tables can select columns while joining (2), and in dplyr you will need to select() first on both data.frames before to join as shown above. Otherwise you would materialiase the join with unnecessary columns only to remove them later and that is inefficient.data.tables can aggregate while joining (3) and also update while joining (4), using by=.EACHI feature. Why materialse the entire join result to add/update just a few columns?data.table is capable of rolling joins (5) - roll forward, LOCF, roll backward, NOCB, nearest.data.table also has mult= argument which selects first, last or all matches (6).data.table has allow.cartesian=TRUE argument to protect from accidental invalid joins.Once again, the syntax is consistent with DT[i, j, by] with additional arguments allowing for controlling the output further.do()...dplyr\'s summarise is specially designed for functions that return a single value. If your function returns multiple/unequal values, you will have to resort to do(). You have to know beforehand about all your functions return value. .SD\'s equivalent is .In data.table, you can throw pretty much anything in j - the only thing to remember is for it to return a list so that each element of the list gets converted to a column.In dplyr, cannot do that. Have to resort to do() depending on how sure you are as to whether your function would always return a single value. And it is quite slow. Once again, data.table\'s syntax is consistent with DT[i, j, by]. We can just keep throwing expressions in j without having to worry about these things.Have a look at this SO question and this one. I wonder if it would be possible to express the answer as straightforward using dplyr\'s syntax...To summarise, I have particularly highlighted several instances where dplyr\'s syntax is either inefficient, limited or fails to make operations straightforward. This is particularly because data.table gets quite a bit of backlash about "harder to read/learn" syntax (like the one pasted/linked above). Most posts that cover dplyr talk about most straightforward operations. And that is great. But it is important to realise its syntax and feature limitations as well, and I am yet to see a post on it.data.table has its quirks as well (some of which I have pointed out that we are attempting to fix). We are also attempting to improve data.table\'s joins as I have highlighted here. But one should also consider the number of features that dplyr lacks in comparison to data.table.I have pointed out most of the features here and also in this post. In addition:fread - fast file reader has been available for a long time now.fwrite - NEW in the current devel, v1.9.7, a parallelised fast file writer is now available. See this post for a detailed explanation on the implementation and #1664 for keeping track of further developments.Automatic indexing - another handy feature to optimise base R syntax as is, internally.Ad-hoc grouping: dplyr automatically sorts the results by grouping variables during summarise(), which may not be always desirable.Numerous advantages in data.table joins (for speed / memory efficiency and syntax) mentioned above.Non-equi joins: is a NEW feature available from v1.9.7+. It allows joins using other operators <=, <, >, >= along with all other advantages of data.table joins.Overlapping range joins was implemented in data.table recently. Check this post for an overview with benchmarks. setorder() function in data.table that allows really fast reordering of data.tables by reference.dplyr provides interface to databases using the same syntax, which data.table does not at the moment.data.table provides faster equivalents of set operations from v1.9.7+ (written by Jan Gorecki) - fsetdiff(), fintersect(), funion() and fsetequal() with additional all argument (as in SQL).data.table loads cleanly with no masking warnings and has a mechanism described here for [.data.frame compatibility when passed to any R package. dplyr changes base functions filter, lag and [ which can cause problems; e.g. here and here.Finally:On databases - there is no reason why data.table cannot provide similar interface, but this is not a priority now. It might get bumped up if users would very much like that feature.. not sure.On parallelism - Everything is difficult, until someone goes ahead and does it. Of course it will take effort (being thread safe). Here\'s my attempt at a comprehensive answer from the dplyr perspective,\nfollowing the broad outline of Arun\'s answer (but somewhat rearranged\nbased on differing priorities).There is some subjectivity to syntax, but I stand by my statement that\nthe concision of data.table makes it harder to learn and harder to read.\nThis is partly because dplyr is solving a much easier problem!One really important thing that dplyr does for you is that it\nconstrains your options. I claim that most single table problems can\nbe solved with just five key verbs filter, select, mutate, arrange and\nsummarise, along with "by group" adverb. That constraint is big help\nwhen you\'re learning data manipulation, because it helps order your\nthinking about the problem. In dplyr, each of these verbs is mapped to a\nsingle function. Each function does one job, and is easy to understand\nin isolation.You create complexity by piping these simple operations together with\n%>%. Here\'s an example from one of the posts Arun linked\nto:Even if you\'ve never seen dplyr before (or even R!), you can still get\nthe gist of what\'s happening because the functions are all English\nverbs. The disadvantage of English verbs is that they require more typing than\n[, but I think that can be largely mitigated by better autocomplete.Here\'s the equivalent data.table code:It\'s harder to follow this code unless you\'re already familiar with\ndata.table. (I also couldn\'t figure out how to indent the repeated [\nin a way that looks good to my eye). Personally, when I look at code I\nwrote 6 months ago, it\'s like looking at a code written by a stranger,\nso I\'ve come to prefer straightforward, if verbose, code.Two other minor factors that I think slightly decrease readibility:Since almost every data table operation uses [ you need additional\ncontext to figure out what\'s happening. For example, is x[y]\njoining two data tables or extracting columns from a data frame?\nThis is only a small issue, because in well-written code the\nvariable names should suggest what\'s happening.I like that group_by() is a separate operation in dplyr. It\nfundamentally changes the computation so I think should be obvious\nwhen skimming the code, and it\'s easier to spot group_by() than\nthe by argument to [.data.table.I also like that the the pipe\nisn\'t just limited to just one package. You can start by tidying your\ndata with\ntidyr, and\nfinish up with a plot in ggvis. And you\'re\nnot limited to the packages that I write - anyone can write a function\nthat forms a seamless part of a data manipulation pipe. In fact, I\nrather prefer the previous data.table code rewritten with %>%:And the idea of piping with %>% is not limited to just data frames and\nis easily generalised to other contexts: interactive web\ngraphics, web\nscraping,\ngists, run-time\ncontracts, ...)I\'ve lumped these together, because, to me, they\'re not that important.\nMost R users work with well under 1 million rows of data, and dplyr is\nsufficiently fast enough for that size of data that you\'re not aware of\nprocessing time. We optimise dplyr for expressiveness on medium data;\nfeel free to use data.table for raw speed on bigger data.The flexibilty of dplyr also means that you can easily tweak performance\ncharacteristcs using the same syntax. If the performance of dplyr with\nthe data frame backend is not good enough for you, you can use the\ndata.table backend (albeit a somewhat restricted set of functionality).\nIf the data you\'re working with doesn\'t fit in memory, then you can use\na database backend.All that said, dplyr performance will get better in the long-term. We\'ll\ndefinitely implement some of the great ideas of data.table like radix\nordering and using the same index for joins & filters. We\'re also\nworking on parallelisation so we can take advantage of multiple cores.A few things that we\'re planning to work on in 2015:the fastread package, to make it easy to get files off disk and in\nto memory, analgous to fread().More flexible joins, including support for non-equi-joins.More flexible grouping like bootstrap samples, rollups and moreI\'m also investing time into improving R\'s database\nconnectors, the ability to talk to\nweb apis, and making it easier to\nscrape html pages.Your point #3dplyr abstracts (or will) potential DB interactionsis a direct answer to your own question but isn\'t elevated to a high enough level. dplyr is truly an extendable front-end to multiple data storage mechanisms where as data.table is an extension to a single one.Look at dplyr as a back-end agnostic interface, with all of the targets using the same grammer, where you can extend the targets and handlers at will. data.table is, from the dplyr perspective, one of those targets.You will never (I hope) see a day that data.table attempts to translate your queries to create SQL statements that operate with on-disk or networked data stores.Based on the design of working in-memory, data.table could have a much more difficult time extending itself into parallel processing of queries than dplyr.Are there analytical tasks that are a lot easier to code with one or the other package for people familiar with the packages (i.e. some combination of keystrokes required vs. required level of esotericism, where less of each is a good thing).This may seem like a punt but the real answer is no. People familiar with tools seem to use the either the one most familiar to them or the one that is actually the right one for the job at hand. With that being said, sometimes you want to present a particular readability, sometimes a level of performance, and when you have need for a high enough level of both you may just need another tool to go along with what you already have to make clearer abstractions.Are there analytical tasks that are performed substantially (i.e. more than 2x) more efficiently in one package vs. another.Again, no.  data.table excels at being efficient in everything it does where dplyr gets the burden of being limited in some respects to the underlying data store and registered handlers.This means when you run into a performance issue with data.table you can be pretty sure it is in your query function and if it is actually a bottleneck with data.table then you\'ve won yourself the joy of filing a report. This is also true when dplyr is using data.table as the back-end; you may see some overhead from dplyr but odds are it is your query.When dplyr has performance issues with back-ends you can get around them by registering a function for hybrid evaluation or (in the case of databases) manipulating the generated query prior to execution.Also see the accepted answer to when is plyr better than data.table?