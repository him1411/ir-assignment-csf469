what is difference between CrudRepository and JpaRepository interfaces in Spring Data JPA, when see the examples in the web. I see them there used kind of interchangeably. What is the difference between them? Why would you want to use one over the other?JpaRepository extends PagingAndSortingRepository which in turn extends CrudRepository. Their main functions are:Because of the inheritance mentioned above,  JpaRepository will have all the functions of CrudRepository and PagingAndSortingRepository. So if you don\'t need the repository to have the functions provided by JpaRepository and PagingAndSortingRepository , use CrudRepository. Ken\'s answer is basically right but I\'d like to chime in on the "why would you want to use one over the other?" part of your question.The base interface you choose for your repository has two main purposes. First, you allow the Spring Data repository infrastructure to find your interface and trigger the proxy creation so that you inject instances of the interface into clients. The second purpose is to pull in as much functionality as needed into the interface without having to declare extra methods.The Spring Data core library ships with two base interfaces that expose a dedicated set of functionalities:The individual store modules (e.g. for JPA or MongoDB) expose store-specific extensions of these base interfaces to allow access to store-specific functionality like flushing or dedicated batching that take some store specifics into account. An example for this is deleteInBatch(\xe2\x80\xa6) of JpaRepository which is different from delete(\xe2\x80\xa6) as it uses a query to delete the given entities which is more performant but comes with the side effect of not triggering the JPA-defined cascades (as the spec defines it).We generally recommend not to use these base interfaces as they expose the underlying persistence technology to the clients and thus tighten the coupling between them and the repository. Plus, you get a bit away from the original definition of a repository which is basically "a collection of entities". So if you can, stay with PagingAndSortingRepository.The downside of directly depending on one of the provided base interfaces is two-fold. Both of them might be considered as theoretical but I think they\'re important to be aware of:The solution to both of these downsides is to craft your own base repository interface or even a set of them. In a lot of applications we\'ve seen something like this:The first repository interface is some general purpose base interface that actually only fixes point 1 but also ties the ID type to be Long for consistency. The second interface usually has all the find\xe2\x80\xa6(\xe2\x80\xa6) methods copied from CrudRepository and PagingAndSortingRepository but does not expose the manipulating ones. Read more on that approach in the reference documentation.The repository abstraction allows you to pickt the base repository totally driven by you architectural and functional needs. Use the ones provided out of the box if they suit, craft your own repository base interfaces if necessary. Stay away from the store specific repository interfaces unless unavoidable.