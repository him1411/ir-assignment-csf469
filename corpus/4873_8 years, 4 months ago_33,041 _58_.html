I am doing some research into common errors and poor assumptions made by junior (and perhaps senior) software engineers.What was your longest-held assumption that was eventually corrected?  For example, I misunderstood that the size of an integer is not a standard and instead depends on the language and target.  A bit embarrassing to state, but there it is.Be frank; what firm belief did you have, and roughly how long did you maintain the assumption?  It can be about an algorithm, a language, a programming concept, testing, or anything else about programming, programming languages, or computer science.For a long time I assumed that everyone else had this super-mastery of all programming concepts (design patterns, the latest new language, computational complexity, lambda expressions, you name it).Reading blogs, Stack Overflow and programming books always seemed to make me feel that I was behind the curve on the things that all programmers must just know intuitively. I\'ve realized over time that I\'m effectively comparing my knowledge to the collective knowledge of many people, not a single individual and that is a pretty high bar for anyone. Most programmers in the real world have a cache of knowledge that is required to do their jobs and have more than a few areas that they are either weak or completely ignorant of.That people knew what they wanted.For the longest time I thought I would talk with people, they would describe a problem or workflow and I would put it into code and automate it. Turns out every time that happens, what they thought they wanted wasn\'t actually what they wanted.Edit: I agree with most of the comments. This is not a technical answer and may not be what the questioner was looking for. It doesn\'t apply only to programming. I\'m sure it\'s not my longest-held assumption either, but it was the most striking thing I\'ve learned in the 10 short years I\'ve been doing this. I\'m sure it was pure naivete on my part but the way my brain is/was wired and the teaching and experiences I had prior to entering the business world led me to believe that I would be doing what I answered; that I would be able to use code and computers to fix people\'s problems.I guess this answer is similar to Robin\'s about non-programmers understanding/caring about what I\'m talking about. It\'s about learning the business as an agile, iterative, interactive process. It\'s about learning the difference between being a programming-code-monkey and being a software developer. It\'s about realizing that there is a differnce between the two and that to be really good in the field, it\'s not just syntax and typing speed.Edit: This answer is now community-wiki to appease people upset at this answer giving me rep.That I know where the performance problem is without profilingThat I should have only one exit point from a function/method.That nonprogrammers understand what I\'m talking about.That bugfree software was possible.That private member variables were private to the instance and not the class.I thought that static typing was sitting very still at your keyboard.That you can fully understand a problem before you start developing.Smart People are Always Smarter than Me.I can really beat myself up when I make mistakes and often get told off for self-deprecating. I used to look up in awe at a lot of developers and often assumed that since they knew more than me on X, they knew more than me.As I have continued to gain experience and meet more people, I have started to realise that oftentimes, while they know more than me in a particular subject, they are not necessarily smarter than me/you.Moral of the story: Never underestimate what you can bring to the table.For the longest time I thought that Bad Programming was something that happened on the fringe.. that Doing Things Correctly was the norm.  I\'m not so naive these days.I thought I should move towards abstracting as much as possible. I got hit in the head major with this, because of too much intertwined little bits of functionality.Now I try keep things as simple and decoupled as possible. Refactoring to make something abstract is much easier than predicting how I need to abstract something.Thus I moved from developing the framework that rules them all, to snippets of functionality that get the job done. Never looked back, except when I think about the time I naively thought I would be the one developing the next big thing.That women find computer programmers sexy...That the quality of software will lead to greater sales.  Sometimes it does but not always.That all languages are (mostly) created equal. For a good long while I figured that the language of choice didn\'t really make much of a difference in the difficulty of the development process and the potential for project success. This is definitely not true. Choosing the right language for the job is as important/critical as any other single project decision that is made. That a large comment/code ratio is a good thing.It took me a while to realize that code should be self documenting. Sure, a comment here and there is helpful if the code can\'t be made clearer or if there\'s an important reason why something is being done. But, in general, it\'s better to spend that comment time renaming variables.  It\'s cleaner, clearer and the comments don\'t get "out of sync" with the code.That programming is impossible.Not kidding, I always thought that programming was some impossible thing to learn, and I always stayed away from it. And when I got near code, I could never understand it.Then one day I just sat down and read some basic beginner tutorials, and worked my way from there. And today I work as a programmer and I love every minute of it.To add, I don\'t think programming is easy, it\'s a challenge and I love learning more and there is nothing more fun than to solve some programming problem."On Error Resume Next" was some kind of error handlingThat programming software requires a strong foundation in higher math.For years before I started coding I was always told that to be a good programmer you had to be good at advanced algebra, geometry, calculus, trig, etc.Ten years later and I have only once had to do anything that an eighth grader couldn\'t.That optimizing == rewriting in assembly language.When I first really understood assembly (coming from BASIC) it seemed that the only way to make code run faster was to rewrite it in assembly.  Took quite a few years to realize that compilers can be very good at optimization and especially with CPUs with branch prediction etc they can probably do a better job than a human can do in a reasonable amount of time.  Also that spending time on optimizing the algorithm is likely to give you a better win than spending time converting from a high to a low level language.  Also that premature optimization is the root of all evil...I would say that storing the year element of a date as 2 digits was an assumption that afflicted an entire generation of developers. The money that was blown on Y2K was pretty horrific.That anything other than insertion/bubble sort was quite simply dark magic.That XML would be a truly interoperable and human readable data format.That C++ was somehow intrinsically better than all other languages.This I received from a friend a couple of years ahead of me in college. I kept it with me for an embarrassingly long time (I\'m blushing right now). It was only after working with it for 2 years or so before I could see the cracks for what they were.No one - and nothing - is perfect, there is always room for improvement.I believed that creating programs would be exactly like what was taught in class...you sit down with a group of people, go over a problem, come up with a solution, etc. etc.  Instead, the real world is "Here is my problem, I need it solved, go" and ten minutes later you get another, leaving you no real time to plan out your solution efficiently. I thought mainstream design patterns were awesome, when they were introduced in a CS class. I had programmed about 8 years as hobby before that, and I really didn\'t have solid understanding of how to create good abstractions.Design patterns felt like magic; you could do really neat stuff. Later I discovered functional programming (via Mozart/Oz, OCaml, later Scala, Haskell, and Clojure), and then I understood that many of the patterns were just boilerplate, or additional complexity, because the language wasn\'t expressive enough.Of course there are almost always some kind of patterns, but they are in a higher level in expressive languages. Now I\'ve been doing some professional coding in Java, and I really feel the pain when I have to use a convention such as visitor or command pattern, instead of  pattern matching and higher order functions.For the first few years I was programming I didn\'t catch on that 1 Kbyte is technically 1024 bytes, not 1000. I was always a little perplexed by the fact that the sizes of my data files seemed slightly off from what I expected them to be.That condition checks like:are performed in an unspecified order...That my programming would be faster and better if I performed it alone.