What is the correct (most efficient) way to define the main() function in C and C++ \xe2\x80\x94 int main() or void main() \xe2\x80\x94 and why? \nIf int main() then return 1 or return 0?There are numerous duplicates of this question, including:Related:The return value for main should indicate how the program exited. Normal exit is generally represented by a 0 return value from main. Abnormal termination is usually signalled by a non-zero return but there is no standard for how non-zero codes are interpreted. Also as noted by others, void main() is explicitly prohibited by the C++ standard and shouldn\'t be used. The valid C++ main signatures are:andwhich is equivalent toIt\'s also worth noting that in C++, int main() can be left without a return value at which point it defaults to returning 0. This is also true with a C99 program. Whether return 0 should be omitted or not is open to debate. The range of valid C program main signatures is much greater.  Also, efficiency is not an issue with the main function. It can only be entered and left once (marking program start and termination) according to the C++ standard. For C, the case is different and re-entering main() is allowed, but should probably be avoided. The accepted answer appears to be targetted for C++, so I thought I\'d add an answer that pertains to C, and this differs in a few ways.ISO/IEC 9899:1989 (C90):main() should be declared as either:Or equivalent. For example, int main(int argc, char *argv[]) is equivalent to the second one. Further, the int return type can be omitted as it is a default.If an implementation permits it, main() can be declared in other ways, but this makes the program implementation defined, and no longer strictly conforming.The standard defines 3 values for returning that are strictly conforming (that is, does not rely on implementation defined behaviour): 0 and EXIT_SUCCESS for a successful termination, and EXIT_FAILURE for an unsuccessful termination. Any other values are non-standard and implementation defined. main() must have an explicit return statement at the end to avoid undefined behaviour.Finally, there is nothing wrong from a standards point of view with calling main() from a program.ISO/IEC 9899:1999 (C99):For C99, everything is the same as above except:For a hosted environment (that\'s the normal one), the C11 standard (ISO/IEC 9899:2011) says:The function called at program startup is named main. The implementation declares no\n  prototype for this function. It shall be defined with a return type of int and with no\n  parameters:or with two parameters (referred to here as argc and argv, though any names may be\n  used, as they are local to the function in which they are declared):or equivalent;10) or in some other implementation-defined manner.If they are declared, the parameters to the main function shall obey the following\n  constraints:10) Thus, int can be replaced by a typedef name defined as int, or the type of argv can be written as\n  char **argv, and so on.The value returned from main() is transmitted to the \'environment\' in an implementation-defined way.1 If the return type of the main function is a type compatible with int, a return from the\n  initial call to the main function is equivalent to calling the exit function with the value\n  returned by the main function as its argument;11) reaching the } that terminates the\n  main function returns a value of 0. If the return type is not compatible with int, the\n  termination status returned to the host environment is unspecified.11) In accordance with 6.2.4, the lifetimes of objects with automatic storage duration declared in main\n  will have ended in the former case, even where they would not have in the latter.Note that 0 is mandated as \'success\'. You can use EXIT_FAILURE and EXIT_SUCCESS from <stdlib.h> if you prefer, but 0 is well established, and so is 1. See also Exit codes greater than 255 \xe2\x80\x94 possible?.In C89 (and hence in Microsoft C), there is no statement about what happens if the main() function returns but does not specify a return value; it therefore leads to undefined behaviour.\xc2\xb65 Finally, control is returned to the host environment. If the value of status is zero or EXIT_SUCCESS, an implementation-defined form of the status successful termination is returned. If the value of status is EXIT_FAILURE, an implementation-defined form of the status unsuccessful termination is returned. Otherwise the status returned is implementation-defined.The C++11 standard (ISO/IEC 14882:2011) says:\xc2\xb61 A program shall contain a global function called main, which is the designated start of the program. [...]\xc2\xb62 An implementation shall not predefine the main function. This function shall not be overloaded. It shall\n  have a return type of type int, but otherwise its type is implementation defined.\n  All implementations\n  shall allow both of the following definitions of main:andIn the latter form argc shall be the number of arguments passed to the program from the environment\n  in which the program is run. If argc is nonzero these arguments shall be supplied in argv[0]\n  through argv[argc-1] as pointers to the initial characters of null-terminated multibyte strings (NTMBSs) (17.5.2.1.4.2) and argv[0] shall be the pointer to the initial character of a NTMBS that represents the\n  name used to invoke the program or "". The value of argc shall be non-negative. The value of argv[argc]\n  shall be 0. [ Note: It is recommended that any further (optional) parameters be added after argv. \xe2\x80\x94end\n  note ]\xc2\xb63 The function main shall not be used within a program. The linkage (3.5) of main is implementation-defined. [...]\xc2\xb65 A return statement in main has the effect of leaving the main function (destroying any objects with automatic\n  storage duration) and calling std::exit with the return value as the argument. If control reaches the end\n  of main without encountering a return statement, the effect is that of executingThe C++ standard explicitly says "It [the main function] shall have a return type of type int, but otherwise its type is implementation defined", and requires the same two signatures as the C standard to be supported as options. So a \'void main()\' is directly not allowed by the C++ standard, though there\'s nothing it can do to stop a non-standard implementation allowing alternatives.  Note that C++ forbids the user from calling main (but the C standard does not).There\'s a paragraph of \xc2\xa718.5 Start and termination in the C++11 standard that is identical to the paragraph from \xc2\xa77.22.4.4 The exit function in the C11 standard (quoted above), apart from a footnote (which simply documents that EXIT_SUCCESS and EXIT_FAILURE are defined in <cstdlib>).Classically, Unix systems support a third variant:The third argument is a null-terminated list of pointers to strings, each of which is an environment variable which has a name, an equals sign, and a value (possibly empty).  If you do not use this, you can still get at the environment via \'extern char **environ;\'.  For a long time, that did not have a header that declared it, but the POSIX 2008 standard now requires it to be declared in <unistd.h>.This is recognized by the C standard as a common extension, documented in Annex J:\xc2\xb61 In a hosted environment, the main function receives a third argument, char *envp[],\n  that points to a null-terminated array of pointers to char, each of which points to a string\n  that provides information about the environment for this execution of the program (5.1.2.2.1).The Microsoft VS 2010 compiler is interesting. The web site says:The declaration syntax for main isor, optionally,Alternatively, the main and wmain functions can be declared as returning void (no return value). If you declare main or wmain as returning void, you cannot return an exit code to the parent process or operating system by using a return statement. To return an exit code when main or wmain is declared as void, you must use the exit function.It is not clear to me what happens (what exit code is returned to the parent or OS) when a program with void main() does exit \xe2\x80\x94 and the MS web site is silent too.Interestingly, MS does not prescribe the two-argument version of main() that the C and C++ standards require. It only prescribes a three argument form where the third argument is char **envp, a pointer to a list of environment variables.The Microsoft page also lists some other alternatives \xe2\x80\x94 wmain() which takes wide character strings, and some more.The Microsoft Visual Studio 2005 version of this page does not list void main() as an alternative.  The versions from Microsoft Visual Studio 2008 onwards do.As noted early on, the requirements above apply to hosted environments. If you are working with a freestanding environment (which is the alternative to a hosted environment), then the standard has much less to say. For a freestanding environment, the function called at program startup need not be called main and there are no constraints on its return type.  The standard says:Two execution environments are defined: freestanding and hosted. In both cases,\n  program startup occurs when a designated C function is called by the execution\n  environment. All objects with static storage duration shall be initialized (set to their initial values) before program startup. The manner and timing of such initialization are otherwise unspecified. Program termination returns control to the execution environment.In a freestanding environment (in which C program execution may take place without any benefit of an operating system), the name and type of the function called at program startup are implementation-defined. Any library facilities available to a freestanding program, other than the minimal set required by clause 4, are implementation-defined.The effect of program termination in a freestanding environment is implementation-defined.The cross-reference to clause 4 Conformance refers to this:\xc2\xb65 A strictly conforming program shall use only those features of the language and library specified in this International Standard.3) It shall not produce output dependent on any unspecified, undefined, or implementation-defined behavior, and shall not exceed any minimum implementation limit.\xc2\xb66 The two forms of conforming implementation are hosted and freestanding. A conforming hosted implementation shall accept any strictly conforming program. A conforming freestanding implementation shall accept any strictly conforming program in which the use of the features specified in the library clause (clause 7) is confined to the contents of the standard headers <float.h>, <iso646.h>, <limits.h>, <stdalign.h>,\n  <stdarg.h>, <stdbool.h>, <stddef.h>, <stdint.h>, and\n  <stdnoreturn.h>. A conforming implementation may have extensions (including\n  additional library functions), provided they do not alter the behavior of any strictly conforming program.4)\xc2\xb67 A conforming program is one that is acceptable to a conforming implementation.5)3) A strictly conforming program can use conditional features (see 6.10.8.3) provided the use is guarded by an appropriate conditional inclusion preprocessing directive using the related macro. For example:4) This implies that a conforming implementation reserves no identifiers other than those explicitly reserved in this International Standard.5) Strictly conforming programs are intended to be maximally portable among conforming implementations. Conforming programs may depend upon non-portable features of a conforming implementation.It is noticeable that the only header required of a freestanding environment that actually defines any functions is <stdarg.h> (and even those may be \xe2\x80\x94 and often are \xe2\x80\x94 just macros).Just as the C standard recognizes both hosted and freestanding environment, so too does the C++ standard. (Quotes from ISO/IEC 14882:2011.)\xc2\xb67 Two kinds of implementations are defined: a hosted implementation and a freestanding implementation. For a hosted implementation, this International Standard defines the set of available libraries. A freestanding\n  implementation is one in which execution may take place without the benefit of an operating system, and has an implementation-defined set of libraries that includes certain language-support libraries (17.6.1.3).\xc2\xb68 A conforming implementation may have extensions (including additional library functions), provided they do not alter the behavior of any well-formed program. Implementations are required to diagnose programs that\n  use such extensions that are ill-formed according to this International Standard. Having done so, however, they can compile and execute such programs.\xc2\xb69 Each implementation shall include documentation that identifies all conditionally-supported constructs that it does not support and defines all locale-specific characteristics.33) This documentation also defines implementation-defined behavior; see 1.9.Two kinds of implementations are defined: hosted and freestanding (1.4). For a hosted implementation, this International Standard describes the set of available headers.A freestanding implementation has an implementation-defined set of headers. This set shall include at least the headers shown in Table 16.The supplied version of the header <cstdlib> shall declare at least the functions abort, atexit, at_quick_exit, exit, and quick_exit (18.5). The other headers listed in this table shall meet the same requirements as for a hosted implementation.Table 16 \xe2\x80\x94 C++ headers for freestanding implementationsI believe that main() should return either EXIT_SUCCESS or EXIT_FAILURE. They are defined in stdlib.hReturn 0 on success and non-zero for error. This is the standard used by UNIX and DOS scripting to find out what happened with your program.Note that the C and C++ standards define two kinds of implementations: freestanding and hosted.C90 hosted environmentAllowed forms (1):Comments: The former two are explicitly stated as the allowed forms, the others are implicitly allowed because C90 allowed "implicit int" for return type and function parameters. No other form is allowed.C90 freestanding environmentAny form or name of main is allowed (2).C99 hosted environmentAllowed forms (3):Comments: C99 removed "implicit int" so main() is no longer valid.A strange, ambiguous sentence "or in some other implementation-defined manner" has been introduced. This can either be interpreted as "the parameters to int main() may vary" or as "main can have any implementation-defined form". Some compilers have chosen to interpret the standard in the latter way. Arguably, one cannot easily state that they are not strictly conforming by citing the standard in itself, since it is is ambiguous.However, to allow completely wild forms of main() was probably(?) not the intention of this new sentence. The C99 rationale (not normative) implies that the sentence refers to additional parameters to int main (4).Yet the section for hosted environment program termination then goes on arguing about the case where main does not return int (5). Although that section is not normative for how main should be declared, it definitely implies that main might be declared in a completely implementation-defined way even on hosted systems.C99 freestanding environmentAny form or name of main is allowed (6).C11 hosted environmentAllowed forms (7):C11 freestanding environmentAny form or name of main is allowed (8).Note that int main() was never listed as a valid form for any hosted implementation of C in any of the above versions. In C, unlike C++, () and (void) have different meanings. The former is an obsolescent feature which may be removed from the language. See C11 future language directions:6.11.6 Function declaratorsThe use of function declarators with empty parentheses (not prototype-format parameter type declarators) is an obsolescent feature.C++03 hosted environmentAllowed forms (9):Comments:Note the empty parenthesis in the first form. C++ and C are different in this case, because in C++ this means that the function takes no parameters. But in C it means that it may take any parameter.C++03 freestanding environmentThe name of the function called at startup is implementation-defined. If it is named main() it must follow the stated forms (10):C++11 hosted environmentAllowed forms (11):Comments:The text of the standard has been changed but it has the same meaning.C++11 freestanding environmentThe name of the function called at startup is implementation-defined. If it is named main() it must follow the stated forms (12):ReferencesANSI X3.159-1989 2.1.2.2 Hosted environment. "Program startup"The function called at program startup is named main. The\n  implementation declares no prototype for this function. It shall be\n  defined with a return type of int and with no parameters: or with two parameters (referred to here as\n  argc and argv, though any names may be used, as they are local to the\n  function in which they are declared): ANSI X3.159-1989 2.1.2.1 Freestanding environment:In a freestanding environment (in which C program execution may take\n  place without any benefit of an operating system), the name and type\n  of the function called at program startup are implementation-defined.ISO 9899:1999 5.1.2.2 Hosted environment -> 5.1.2.2.1 Program startupThe function called at program startup is named main. The\n  implementation declares no prototype for this function. It shall be\n  defined with a return type of int and with no parameters: or with two parameters (referred to here as\n  argc and argv, though any names may be used, as they are local to the\n  function in which they are declared): or equivalent;9) or in some other implementation-defined\n  manner.Rationale for International Standard \xe2\x80\x94 Programming Languages \xe2\x80\x94 C, Revision 5.10. 5.1.2.2 Hosted environment --> 5.1.2.2.1 Program startupThe behavior of the arguments to main, and of the interaction of exit, main and atexit\n  (see \xc2\xa77.20.4.2) has been codified to curb some unwanted variety in the representation of argv\n  strings, and in the meaning of values returned by main.The specification of argc and argv as arguments to main recognizes extensive prior practice.\n  argv[argc] is required to be a null pointer to provide a redundant check for the end of the list, also on the basis of common practice.main is the only function that may portably be declared either with zero or two arguments. (The\n  number of other functions\xe2\x80\x99 arguments must match exactly between invocation and definition.)\n  This special case simply recognizes the widespread practice of leaving off the arguments to\n  main when the program does not access the program argument strings. While many implementations support more than two arguments to main, such practice is neither blessed nor\n  forbidden by the Standard; a program that defines main with three arguments is not strictly\n  conforming (see \xc2\xa7J.5.1.).ISO 9899:1999 5.1.2.2 Hosted environment --> 5.1.2.2.3 Program terminationIf the return type of the main function is a type compatible with int, a return from the\n  initial call to the main function is equivalent to calling the exit function with the value\n  returned by the main function as its argument;11) reaching the } that terminates the\n  main function returns a value of 0. If the return type is not compatible with int, the\n  termination status returned to the host environment is unspecified.ISO 9899:1999 5.1.2.1 Freestanding environmentIn a freestanding environment (in which C program execution may take place without any\n  benefit of an operating system), the name and type of the function called at program\n  startup are implementation-defined.ISO 9899:2011 5.1.2.2 Hosted environment -> 5.1.2.2.1 Program startupThis section is identical to the C99 one cited above.ISO 9899:1999 5.1.2.1 Freestanding environmentThis section is identical to the C99 one cited above.ISO 14882:2003 3.6.1 Main functionAn implementation shall not predefine the main function. This function shall not be overloaded. It shall\n  have a return type of type int, but otherwise its type is implementation-defined. All implementations\n  shall allow both of the following definitions of main:andISO 14882:2003 3.6.1 Main functionIt is\n  implementation-defined whether a program in a freestanding environment is required to define a main\n  function.ISO 14882:2011 3.6.1 Main functionAn implementation shall not predefine the main function. This function shall not be overloaded. It shall\n  have a return type of type int, but otherwise its type is implementation-defined. All implementations shall\n  allow both\xe2\x80\x94 a function of () returning int and\xe2\x80\x94 a function of (int, pointer to pointer to char) returning intas the type of main (8.3.5).ISO 14882:2011 3.6.1 Main functionThis section is identical to the C++03 one cited above.Keep in mind that,even though you\'re returning an int, some OSes (Windows) truncate the returned value to a single byte (0-255).main() in C89 and K&R C unspecified return types default to intIf you do not write a return statement in int main() then the closing { will return 0 by defaultReturn 0 or return 1 will be received by the environment variable of the OS. So if you are not using that environment variable then you should not worry about the return value of main().See How can I get what my main function has returned?.This way you can see that it is the environment variable $? which receives the last one byte of return value of main().So if you are writing any script then you should take care of the return value of main(), otherwise don\'t.In Unix and DOS scripting, return 0 on success and non-zero for error are usually returned. This is the standard used by Unix and DOS scripting to find out what happened with your program and controlling the whole flow.The return value can be used by the operating system to check how the program was closed.Return value 0 usually means OK in most operating systems (the ones I can think of anyway).It also can be checked when you call a process yourself, and see if the program exited and finished properly.It\'s NOT just a programming convention.I was under the impression that standard specifies that main doesn\'t need a return value as a successful return was OS based (zero in one could be either a success or a failure in another), therefore the absence of return was a cue for the compiler to insert the successful return itself.However I usually return 0.What to return depends on what you want to do with the executable. For example if you are using your program with a command line shell, then you need to return 0 for a success and a non zero for failure. Then you would be able to use the program in shells with conditional processing depending on the outcome of your code. Also you can assign any nonzero value as per your interpretation, for example for critical errors different program exit points could terminate a program with different exit values , and which is available to the calling shell which can decide what to do by inspecting the value returned.\nIf the code is not intended for use with shells and the returned value does not bother anybody then it might be omitted. I personally use the signature int main (void) { .. return 0; .. }If you really have issues related to efficiency of returning an integer from a process, you should probably avoid to call that process so many times that this return value becomes an issue.If you are doing this (call a process so many times), you should find a way to put your logic directly inside the caller, or in a DLL file, without allocate a specific process for each call; the multiple process allocations bring you the relevant efficiency problem in this case.In detail, if you only want to know if returning 0 is more or less efficient than returning 1, it could depend from the compiler in some cases, but generically, assuming they are read from the same source (local, field, constant, embedded in the code, function result, etc.) it requires exactly the same number of clock cycles.The return value of main() shows how the program exited. If the return value is zero it means that the execution was successful while any non-zero value will represent that something went bad in the execution.Returning 0 should tell the programmer that the program has successfully finished the job.This basically depends on your execution environment (the OS). C implies that it will be run by a UNIX like OS which expects the program to return a (small? 1 Byte? can\'t remember) integer to indicate success / failure.You should probably just use int main(int argc, char** argv).Here is a small demonstration of the usage of return codes...When using the various tools that the Linux terminal provides one can use the return code for example for error handling after the process has been completed. Imagine that the following text file myfile is present:This is some example in order to check how grep works.When you execute the grep command a process is created. Once it is through (and didn\'t break) it returns some code between 0 and 255. For example:If you doyou will get a 0. Why? Because grep found a match and returned an exit code 0, which is the usual value for exiting with a success. Let\'s check it out again but with something that is not inside our text file and thus no match will be found:Since grep failed to match the token "foo" with the content of our file the return code is 1 (this is the usual case when a failure occurs but as stated above you have plenty of values to choose from).Now the following bash script (simply type it in a Linux terminal) although very basic should give some idea of error handling:After the second line nothing is printed to the terminal since "foo" made grep return 1 and we check if the return code of grep was equal to 0. The second conditional statement echoes its message in the last line since it is true due to CHECK == 1.As you can see if you are calling this and that process it is sometimes essential to see what it has returned (by the return value of main()).When a C or C++ program reaches the end of main the compiler will automatically generate code to return 0, so there is no need to put return 0; explicitly at the end of main.  Note: when I make this suggestion, it\'s almost invariably followed by one of two kinds of comments:  "I didn\'t know that." or "That\'s bad advice!"  My rationale is that it\'s safe and useful to rely on compiler behavior explicitly supported by the standard.  For C, since C99; see ISO/IEC 9899:1999 section 5.1.2.2.3:[...] a return from the initial call to the main function is equivalent to calling the exit function with the value returned by the main function as its argument; reaching the } that terminates the main function returns a value of 0.For C++, since the first standard in 1998; see ISO/IEC 14882:1998 section 3.6.1:If control reaches the end of main without encountering a return statement, the effect is that of executing return 0;All versions of both standards since then (C99 and C++98) have maintained the same idea.  We rely on automatically generated member functions in C++, and few people write explicit return; statements at the end of a void function.  Reasons against omitting seem to boil down to "it looks weird".  If, like me, you\'re curious about the rationale for the change to the C standard read this question.  Also note that in the early 1990s this was considered "sloppy practice" because it was undefined behavior (although widely supported) at the time.  So I advocate omitting it; others disagree (often vehemently!)  In any case, if you encounter code that omits it, you\'ll know that it\'s explicitly supported by the standard and you\'ll know what it means.void main() is forbidden after C90.  main should return a value. I used to return 0.