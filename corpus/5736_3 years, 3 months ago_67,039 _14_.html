I have an interface which returns java.lang.Iterable<T>.I would like to manipulate that result using the Java 8 Stream API.However Iterable can\'t "Stream". Any better idea how to use streams (without converting Iterable to List)?There\'s a much better answer than using spliteratorUnknownSize directly, which is both easier and gets a better result.  Iterable has a spliterator() method, so you should just use that to get your spliterator.  In the worst case, its the same code (the default implementation uses spliteratorUnknownSize), but in the more common case, where your Iterable is already a collection, you\'ll get a better spliterator, and therefore better stream performance (maybe even good parallelism.)  Its also less code: As you can see, getting a stream from an Iterable (see Why does Iterable<T> not provide stream() and parallelStream() methods?) is not very painful.  If you can use Guava library, since version 21, you can useYou can easily create a Stream out of an Iterable or Iterator:I would like to suggest using JOOL library, it hides spliterator magic behind the Seq.seq(iterable) call and also provides a whole bunch of additional useful functionality.I\'ve created this class:I think it\'s perfectly readable because you don\'t have to think about spliterators and booleans (isParallel).A very simple work-around for this issue is to create a Streamable<T> interface extending Iterable<T> that holds a default <T> stream() method.Now any of your Iterable<T>s can be trivially made streamable just by declaring them implements Streamable<T> instead of Iterable<T>.If you happen to use Vavr(formerly known as Javaslang), this can be as easy as: