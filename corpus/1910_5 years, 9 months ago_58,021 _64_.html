How can the theoretical peak performance of 4 floating point operations (double precision) per cycle be achieved on a modern x86-64 Intel CPU?As far as I understand it take three cycles for an SSE add and five cycles for a mul to complete on most of the modern Intel CPUs (see for example Agner Fog\'s \'Instruction Tables\' ). Due to pipelining one can get a throughput of one add per cycle if the algorithm has at least three independent summations. Since that is true for packed addpd as well as the scalar addsd versions and SSE registers can contain two double\'s the throughput can be as much as two flops per cycle.Furthermore, it seems (although I\'ve not seen any proper documentation on this) add\'s and mul\'s can be executed in parallel giving a theoretical max throughput of four flops per cycle.However, I\'ve not been able to replicate that performance with a simple C/C++ programme. My best attempt resulted in about 2.7 flops/cycle. If anyone can contribute a simple C/C++ or assembler programme which demonstrates peak performance that\'d be greatly appreciated.My attempt:Compiled withproduces the following output on an Intel Core i5-750, 2.66Â GHz.That is, just about 1.4 flops per cycle. Looking at the assembler code with\ng++ -S -O2 -march=native -masm=intel addmul.cpp the main loop seems kind of\noptimal to me:Changing the scalar versions with packed versions (addpd and mulpd) would double the flop count without changing the execution time and so I\'d get just short of 2.8 flops per cycle. Is there a simple example which achieves four flops per cycle?Nice little programme by Mysticial; here are my results (run just for a few seconds though):It all seems a bit complex, but my conclusions so far:gcc -O2 changes the order of independent floating point operations with\nthe aim of alternating\naddpd and mulpd\'s if possible. Same applies to gcc-4.6.2 -O2 -march=core2.gcc -O2 -march=nocona seems to keep the order of floating point operations as defined in\nthe C++ source.cl /O2, the 64-bit compiler from the\nSDK for Windows 7\ndoes loop-unrolling automatically and seems to try and arrange operations\nso that groups of three addpd\'s alternate with three mulpd\'s (well, at least on my system and for my simple programme).My Core i5 750 (Nahelem architecture)\ndoesn\'t like alternating add\'s and mul\'s and seems unable\nto run both operations in parallel. However, if grouped in 3\'s it suddenly works like magic.Other architectures (possibly Sandy Bridge and others) appear to\nbe able to execute add/mul in parallel without problems\nif they alternate in the assembly code.Although difficult to admit, but on my system cl /O2 does a much better job at low-level optimising operations for my system and achieves close to peak performance for the little C++ example above. I measured between\n1.85-2.01 flops/cycle (have used clock() in Windows which is not that precise. I guess, need to use a better timer - thanks Mackie Messer).The best I managed  with gcc was to manually loop unroll and arrange\nadditions and multiplications in groups of three. With\ng++ -O2 -march=nocona  addmul_unroll.cpp\nI get at best 0.207s, 4.825 Gflops which corresponds to 1.8 flops/cycle\nwhich I\'m quite happy with now.In the C++ code I\'ve replaced the for loop withAnd the assembly now looks likeI\'ve done this exact task before. But it was mainly to measure power consumption and CPU temperatures. The following code (which is fairly long) achieves close to optimal on my Core i7 2600K.The key thing to note here is the massive amount of manual loop-unrolling as well as interleaving of multiplies and adds...The full project can be found on my GitHub: https://github.com/Mysticial/FlopsIf you decide to compile and run this, pay attention to your CPU temperatures!!!Make sure you don\'t overheat it. And make sure CPU-throttling doesn\'t affect your results!Furthermore, I take no responsibility for whatever damage that may result from running this code.Notes:Output (1 thread, 10000000 iterations) - Compiled with Visual Studio 2010 SP1 - x64 Release:The machine is a Core i7 2600K @ 4.4 GHz. Theoretical SSE peak is 4 flops * 4.4 GHz = 17.6 GFlops. This code achieves 17.3 GFlops - not bad.Output (8 threads, 10000000 iterations) - Compiled with Visual Studio 2010 SP1 - x64 Release:Theoretical SSE peak is 4 flops * 4 cores * 4.4 GHz = 70.4 GFlops. Actual is 65.5 GFlops.Output (1 thread, 10000000 iterations) - Compiled with Visual Studio 2010 SP1 - x64 Release:Theoretical AVX peak is 8 flops * 4.4 GHz = 35.2 GFlops. Actual is 33.4 GFlops.Output (8 threads, 10000000 iterations) - Compiled with Visual Studio 2010 SP1 - x64 Release:Theoretical AVX peak is 8 flops * 4 cores * 4.4 GHz = 140.8 GFlops. Actual is 138.2 GFlops.Now for some explanations:The performance critical part is obviously the 48 instructions inside the inner loop. You\'ll notice that it\'s broken into 4 blocks of 12 instructions each. Each of these 12 instructions blocks are completely independent from each other - and take on average 6 cycles to execute.So there\'s 12 instructions and 6 cycles between issue-to-use. The latency of multiplication is 5 cycles, so it\'s just enough to avoid latency stalls.The normalization step is needed to keep the data from over/underflowing. This is needed since the do-nothing code will slowly increase/decrease the magnitude of the data.So it\'s actually possible to do better than this if you just use all zeros and get rid of the normalization step. However, since I wrote the benchmark to measure power consumption and temperature, I had to make sure the flops were on "real" data, rather than zeros - as the execution units may very well have special case-handling for zeros that use less power and produce less heat.Threads: 1Theoretical SSE Peak: 4 flops * 3.5 GHz = 14.0 GFlops. Actual is 13.3 GFlops.Threads: 8Theoretical SSE Peak: 4 flops * 4 cores * 3.5 GHz = 56.0 GFlops. Actual is 51.3 GFlops.My processor temps hit 76C on the multi-threaded run! If you runs these, be sure the results aren\'t affected by CPU throttling.Threads: 1Theoretical SSE Peak: 4 flops * 3.2 GHz = 12.8 GFlops. Actual is 12.3 GFlops.Threads: 8Theoretical SSE Peak: 4 flops * 8 cores * 3.2 GHz = 102.4 GFlops. Actual is 97.9 GFlops.There\'s a point in the Intel architecture that people often forget, the dispatch ports are shared between Int and FP/SIMD. This means that you will only get a certain amount of bursts of FP/SIMD before the loop logic will create bubbles in your floating point stream. Mystical got more flops out of his code, because he used longer strides in his unrolled loop.If you look at the Nehalem/Sandy Bridge architecture here \nhttp://www.realworldtech.com/page.cfm?ArticleID=RWT091810191937&p=6\nit\'s quite clear what happens.In contrast, it should be easier to reach peak performance on AMD (Bulldozer) as the INT and FP/SIMD pipes have separate issue ports with their own scheduler.This is only theoretical as I have neither of these processors to test.Branches can definitely keep you from sustaining peak theoretical performance.  Do you see a difference if you manually do some loop-unrolling?  For example, if you put 5 or 10 times as many ops per loop iteration:Using Intels icc Version 11.1 on a 2.4GHz Intel Core 2 Duo I getThat is very close to the ideal 9.6 Gflops.EDIT:Oops, looking at the assembly code it seems that icc not only vectorized the multiplication, but also pulled the additions out of the loop. Forcing a stricter fp semantics the code is no longer vectorized: EDIT2:As requested:The inner loop of clang\'s code looks like this:EDIT3:Finally, two suggestions: First, if you like this type of benchmarking, consider using the rdtsc instruction istead of gettimeofday(2). It is much more accurate and delivers the time in cycles, which is usually what you are interested in anyway. For gcc and friends you can define it like this:Second, you should run your benchmark program several times and use the best performance only. In modern operating systems many things happen in parallel, the cpu may be in a low frequency power saving mode, etc. Running the program repeatedly gives you a result that is closer to the ideal case.