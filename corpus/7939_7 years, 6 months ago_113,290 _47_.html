I have heard that C++ class member function templates can\'t be virtual.  Is this true? If they can be virtual, what is an example of a scenario in which one would use such a function?Templates are all about the compiler generating code at compile-time. Virtual functions are all about the run-time system figuring out which function to call at run-time. Once the run-time system figured out it would need to call a templatized virtual function, compilation is all done and the compiler cannot generate the appropriate instance anymore. Therefore you cannot have virtual member function templates. However, there are a few powerful and interesting techniques stemming from combining polymorphism and templates, notably so-called type erasure. From C++ Templates The Complete Guide:Member function templates cannot be declared virtual. This constraint\n  is imposed because the usual implementation of the virtual function\n  call mechanism uses a fixed-size table with one entry per virtual\n  function. However, the number of instantiations of a member function\n  template is not fixed until the entire program has been translated.\n  Hence, supporting virtual member function templates would require\n  support for a whole new kind of mechanism in C++ compilers and\n  linkers. In contrast, the ordinary members of class templates can be\n  virtual because their number is fixed when a class is instantiatedC++ doesn\'t allow virtual template member functions right now. The most likely reason is the complexity of implementing it. Rajendra gives good reason why it can\'t be done right now but it could be possible with reasonable changes of the standard. Especially working out how many instantiations of a templated function actually exist and building up the vtable seems difficult if you consider the place of the virtual function call. Standards people just have a lot of other things to do right now and C++1x is a lot of work for the compiler writers as well.When would you need a templated member function? I once came across such a situation where I tried to refactor a hierarchy with a pure virtual base class. It was a poor style for implementing different strategies. I wanted to change the argument of one of the virtual functions to a numeric type and instead of overloading the member function and override every overload in all sub-classes I tried to use virtual template functions (and had to find out they don\'t exist.) Let\'s begin with some background on virtual function tables and how they work (source):[20.3] What\'s the difference between how virtual and non-virtual\n  member functions are called?Non-virtual member functions are resolved statically. That is, the\n  member function is selected statically (at compile-time) based on the\n  type of the pointer (or reference) to the object.In contrast, virtual member functions are resolved dynamically (at\n  run-time). That is, the member function is selected dynamically (at\n  run-time) based on the type of the object, not the type of the\n  pointer/reference to that object. This is called "dynamic binding."\n  Most compilers use some variant of the following technique: if the\n  object has one or more virtual functions, the compiler puts a hidden\n  pointer in the object called a "virtual-pointer" or "v-pointer." This\n  v-pointer points to a global table called the "virtual-table" or\n  "v-table."The compiler creates a v-table for each class that has at least one\n  virtual function. For example, if class Circle has virtual functions\n  for draw() and move() and resize(), there would be exactly one v-table\n  associated with class Circle, even if there were a gazillion Circle\n  objects, and the v-pointer of each of those Circle objects would point\n  to the Circle v-table. The v-table itself has pointers to each of the\n  virtual functions in the class. For example, the Circle v-table would\n  have three pointers: a pointer to Circle::draw(), a pointer to\n  Circle::move(), and a pointer to Circle::resize().During a dispatch of a virtual function, the run-time system follows\n  the object\'s v-pointer to the class\'s v-table, then follows the\n  appropriate slot in the v-table to the method code.The space-cost overhead of the above technique is nominal: an extra\n  pointer per object (but only for objects that will need to do dynamic\n  binding), plus an extra pointer per method (but only for virtual\n  methods). The time-cost overhead is also fairly nominal: compared to a\n  normal function call, a virtual function call requires two extra\n  fetches (one to get the value of the v-pointer, a second to get the\n  address of the method). None of this runtime activity happens with\n  non-virtual functions, since the compiler resolves non-virtual\n  functions exclusively at compile-time based on the type of the\n  pointer.I\'m attempting to use something like this now for a cubefile base class with templated optimized load functions which will be implemented differently for different types of cubes (some stored by pixel, some by image, etc).Some code:What I\'d like it to be, but it won\'t compile due to a virtual templated combo:I ended up moving the template declaration to the class level. This solution would have forced programs to know about specific types of data they would read before they read them, which is unacceptable.warning, this isn\'t very pretty but it allowed me to remove repetitive execution code1) in the base class2) and in the children classesNote that LoadAnyCube is not declared in the base class. Here\'s another stack overflow answer with a work around:\nneed a virtual template member workaround. The following code can be compiled and runs properly, using MinGW G++ 3.4.5 on Window 7:and the output is:And later I added a new class X:When I tried to use class X in main() like this:g++ report the following error:So it is obvious that:No they can\'t.  But:has much the same effect if all you want to do is have a common interface and defer implementation to subclasses.To answer the second part of the question:If they can be virtual, what is an example of a scenario in which one would use such a function?This is not an unreasonable thing to want to do.  For instance, Java (where every method is virtual) has no problems with generic methods.One example in C++ of wanting a virtual function template is a member function that accepts a generic iterator.  Or a member function that accepts a generic function object.The solution to this problem is to use type erasure with boost::any_range and boost::function, which will allow you to accept a generic iterator or functor without the need to make your function a template.No, template member functions cannot be virtual. At least with gcc 5.4 virtual functions could be template members but has to be templates themselves.  OutputsThere is a workaround for \'virtual template method\' if set of types for the template method is known in advance.To show the idea, in the example below only two types are used (int and double).There, a \'virtual\' template method (Base::Method) calls corresponding virtual method (one of Base::VMethod) which, in turn, calls template method implementation (Impl::TMethod).One only needs to implement template method TMethod in derived implementations (AImpl, BImpl) and use Derived<*Impl>.Output:NB:\nBase::Method is actually surplus for real code (VMethod can be made public and used directly).\nI added it so it looks like as an actual \'virtual\' template method.