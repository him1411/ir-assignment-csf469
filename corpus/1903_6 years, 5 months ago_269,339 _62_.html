My Activity is trying to create an AlertDialog which requires a Context as a parameter. This works as expected if I use:However, I am leery of using "this" as a context due to the potential for memory leaks when Activity is destroyed and recreated even during something simple like a screen rotation. From a related post on the Android developer\'s blog: There are two easy ways to avoid context-related memory leaks. The most obvious one is to avoid escaping the context outside of its own scope. The example above showed the case of a static reference but inner classes and their implicit reference to the outer class can be equally dangerous. The second solution is to use the Application context. This context will live as long as your application is alive and does not depend on the activities life cycle. If you plan on keeping long-lived objects that need a context, remember the application object. You can obtain it easily by calling Context.getApplicationContext() or Activity.getApplication().But for the AlertDialog() neither getApplicationContext() or getApplication() is acceptable as a Context, as it throws the exception: "Unable to add window \xe2\x80\x94 token null is not for an application\xe2\x80\x9dper references: 1, 2, 3, etc.So, should this really be considered a "bug", since we are officially advised to use Activity.getApplication() and yet it doesn\'t function as advertised?JimInstead of getApplicationContext(), just use ActivityName.this.Using "this" did not work for me, but "MyActivityName.this" did. hope this helps anyone who could not get "this" to work.You can continue to use getApplicationContext(), but before use, you should add this flag: dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT), and the error will not show.Add the following permission to your manifest:Your dialog should not be a "long-lived object that needs a context". The documentation is confusing. Basically if you do something like:(note the static)Then in an activity somewhere you didYou would likely be leaking the original activity during a rotation or similar that would destroy the activity. (Unless you clean up in onDestroy, but in that case you probably wouldn\'t make the Dialog object static)For some data structures it would make sense to make them static and based off the application\'s context, but generally not for UI related things, like dialogs. So something like this:Is fine and shouldn\'t leak the activity as mDialog would be freed with the activity since it\'s not static.You cannot display an application window/dialog through a Context that is not an Activity or Service. Try passing a valid activity referenceIn Activity on click of button showing a dialog box   Worked for me. I had to send my context through a constructor on a custom adapter displayed in a fragment and had this issue with getApplicationContext().  I solved it with: this.getActivity().getWindow().getContext() in the fragments\' onCreate callback.Little hack: you can prevent destroying the activity by GC (Of course, you should not do it, but it can help in some situations):You\'ve correctly identified the problem when you said "... for the AlertDialog() neither getApplicationContext() or getApplication() is acceptable as a Context, as it throws the exception: \'Unable to add window \xe2\x80\x94 token null is not for an application\'"To create a Dialog, you need an Activity Context or a Service Context, not an Application Context (both getApplicationContext() and getApplication() return an Application Context).Here\'s how you get the Activity Context:(1) In an Activity or a Service:AlertDialog.Builder builder = new AlertDialog.Builder(this);(2) In a Fragment:\nAlertDialog.Builder builder = new AlertDialog.Builder(getActivity());Memory leaks is not a problem that is intrinsic to the "this" reference, which is an object\'s reference to itself (i.e. reference to the actual allocated memory for storing the object\'s data). It happens to any allocated memory for which the Garbage Collector (GC) is unable to free up after the allocated memory has outlived its useful lifespan.Most of the time, when a variable goes out of scope, the memory will be reclaimed by the GC. However, memory leaks can occur when the reference to an object held by a variable, say "x", persists even after the object has outlived its useful lifespan. The allocated memory will hence be lost for as long as "x" holds a reference to it because GC will not free up the memory for as long as that memory is still being referenced. Sometimes, memory leaks are not apparent because of a chain of references to the allocated memory. In such a case, the GC will not free up the memory until all references to that memory have been removed.To prevent memory leaks, check your code for logical errors that cause allocated memory to be referenced indefinitely by "this" (or other references). Remember to check for chain references as well. Here are some tools you can use to help you analyze memory use and find those pesky memory leaks:JRockit Mission ControlJProbeYourKitAD4JIf you are using a fragment and using AlertDialog/Toast message then use getActivity() in the context parameter.like thisadding and "android.permission.SYSTEM_ALERT_WINDOW"/> in manifestIt works for me now. After even close and open the application, gave me the error at that time.I was using ProgressDialog in a fragment and was getting this error on passing getActivity().getApplicationContext() as the constructor parameter. Changing it to getActivity().getBaseContext() didn\'t work either.The solution that worked for me was to pass getActivity(); i.e.progressDialog = new ProgressDialog(getActivity());Use MyDialog md = new MyDialog(MyActivity.this.getParent());If you are outside of the Activity then you need to use in your function "NameOfMyActivity.this" as Activity activity, example:If you are using a fragment and using an AlertDialog / Toast message, use getActivity() in the context parameter.Worked for me.Cheers!Try to use the context of an activity which will be under the dialog. But be carefull when you use "this" keyword, because it will not work everytime.Forexample, if you have TabActivity as host with two tabs, and each tab is another activity, and if you try to create dialog from one of the tabs (activities) and if you use "this", then you will get exception, \nIn this case dialog should be connected to host activity which host everything and visible. (you can say most visible parent Activity\'s context)I did not find this info from any document but by trying. This is my solution without strong background, If anybody with better knownledge, feel free to comment.In my case work:Try getParent() at the argument place of context like new AlertDialog.Builder(getParent()); Hope it will work, it worked for me.I think it may happen as well if you are trying to show a dialog from a thread which is not the main UI thread.Use runOnUiThread() in that case.Or another possibility is to create Dialog as follow:For future readers, this should help:After taking a look at the API, you can pass the dialog your activity or getActivity if you\'re in a fragment, then forcefully clean it up with dialog.dismiss() in the return methods to prevent leaks.Though it is not explicitly stated anywhere I know, it seems you are passed back the dialog in the OnClickHandlers just to do this.