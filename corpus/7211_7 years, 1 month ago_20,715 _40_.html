I was going through the exercises in Ruby Koans and I was struck by the following Ruby quirk that I found really unexplainable:So why is array[5,0] not equal to array[4,0]? Is there any reason why array slicing behaves this weird when you start at the (length+1)th position??Slicing and indexing are two different operations, and inferring the behaviour of one from the other is where your problem lies.The first argument in slice identifies not the element but the places between elements, defining spans (and not elements themselves):4 is still within the array, just barely; if you request 0 elements, you get the empty end of the array. But there is no index 5, so you can\'t slice from there.When you do index (like array[4]), you are pointing at elements themselves, so the indices only go from 0 to 3.this has to do with the fact that slice returns an array, relevant source documentation from Array#slice: which suggests to me that if you give the start that is out of bounds, it will return nil, thus in your example array[4,0] asks for the 4th element that exists, but asks to return an array of zero elements. While array[5,0] asks for an index out of bounds so it returns nil. This perhaps makes more sense if you remember that the slice method is returning a new array, not altering the original data structure.EDIT:After reviewing the comments I decided to edit this answer. Slice calls the following code snippet when the arg value is two:if you look in the array.c class where the rb_ary_subseq method is defined, you see that  it is returning nil if the length is out of bounds, not the index:In this case this is what is happening when 4 is passed in, it checks that there are 4 elements and thus does not trigger the nil return. It then goes on and returns an empty array if the second arg is set to zero. while if 5 is passed in, there are not 5 elements in the array, so it returns nil before the zero arg is evaluated. code here at line 944.I believe this to be a bug, or at least unpredictable and not the \'Principle of Least Surprise\'. When I get a few minutes I will a least submit a failing test patch to ruby core. At least note that the behavior is consistent. From 5 on up everything acts the same; the weirdness only occurs at [4,N].Maybe this pattern helps, or maybe I\'m just tired and it doesn\'t help at all.At [4,0], we catch the end of the array. I\'d actually find it rather odd, as far as beauty in patterns go, if the last one returned nil. Because of a context like this, 4 is an acceptable option for the first parameter so that the empty array can be returned. Once we hit 5 and up, though, the method likely exits immediately by nature of being totally and completely out of bounds.This makes sense when you consider than an array slice can be a valid lvalue, not just an rvalue:This wouldn\'t be possible if array[4,0] returned nil instead of []. However, array[5,0] returns nil because it\'s out of bounds (inserting after the 4th element of a 4-element array is meaningful, but inserting after the 5th element of a 4 element array is not).Read the slice syntax array[x,y] as "starting after x elements in array, select up to y elements". This is only meaningful if array has at least x elements.You need to be able to assign to those slices, so they are defined in such a way that the beginning and the end of the string have working zero-length expressions.I agree that this seems like strange behavior, but even the official documentation on Array#slice demonstrates the same behavior as in your example, in the "special cases" below:Unfortunately, even their description of Array#slice doesn\'t seem to offer any insight as to why it works this way:Element Reference\xe2\x80\x94Returns the element at index, or returns a subarray starting at start  and continuing for length  elements, or returns a subarray specified by range. Negative indices count backward from the end of the array (-1 is the last element). Returns nil if the index  (or starting index) are out of range. I found explanation by Gary Wright very helpful as well.\nhttp://www.ruby-forum.com/topic/1393096#990065The answer by Gary Wright is -http://www.ruby-doc.org/core/classes/Array.htmlThe docs certainly could be more clear but the actual behavior is\nself-consistent and useful.\nNote: I\'m assuming 1.9.X version of String.It helps to consider the numbering in the following way:The common (and understandable) mistake is too assume that the semantics\nof the single argument index are the same as the semantics of the\nfirst argument in the two argument scenario (or range).  They are not\nthe same thing in practice and the documentation doesn\'t reflect this.\nThe error though is definitely in the documentation and not in the\nimplementation:single argument:  the index represents a single character position\nwithin the string.  The result is either the single character string\nfound at the index or nil because there is no character at the given\nindex.two integer arguments: the arguments identify a portion of the string to\nextract or to replace.  In particular, zero-width portions of the string\ncan also be identified so that text can be inserted before or after\nexisting characters including at the front or end of the string. In this\ncase, the first argument does not identify a character position but\ninstead identifies the space between characters as shown in the diagram\nabove.  The second argument is the length, which can be 0.The behavior of a range is pretty interesting. The starting point is the\nsame as the first argument when two arguments are provided (as described\nabove) but the end point of the range can be the \'character position\' as\nwith single indexing or the "edge position" as with two integer\narguments.  The difference is determined by whether the double-dot range\nor triple-dot range is used:If you go back through these examples and insist and using the single\nindex semantics for the double or range indexing examples you\'ll just\nget confused.  You\'ve got to use the alternate numbering I show in the\nascii diagram to model the actual behavior.An explanation provided by Jim Weirich One way to think about it is that index position 4 is at the very edge\n  of the array.  When asking for a slice, you return as much of the\n  array that is left.  So consider the array[2,10], array[3,10] and\n  array[4,10] ... each returns the remaining bits of the end of the\n  array: 2 elements, 1 element and 0 elements respectively.  However,\n  position 5 is clearly outside the array and not at the edge, so\n  array[5,10] returns nil.Consider the following array:You can insert an item to the begining (head) of the array by assigning it to a[0,0]. To put the element between "a" and "b", use a[1,0]. Basically, in the notation a[i,n], i represents an index and n a number of elements. When n=0, it defines a position between the elements of the array.Now if you think about the end of the array, how can you append an item to its end using the notation described above? Simple, assign the value to a[3,0]. This is the tail of the array. So, if you try to access the element at a[3,0], you will get []. In this case you are still in the range of the array. But if you try to access a[4,0], you\'ll get nil as return value, since you\'re not within the range of the array anymore.Read more about it at http://mybrainstormings.wordpress.com/2012/09/10/arrays-in-ruby/ .