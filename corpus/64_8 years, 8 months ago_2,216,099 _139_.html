I know it\'s possible to match a word and then reverse the matches using other tools (e.g. grep -v). However, I\'d like to know if it\'s possible to match lines that don\'t contain a specific word (e.g. hede) using a regular expression. Input:Code:Desired output: The notion that regex doesn\'t support inverse matching is not entirely true. You can mimic this behavior by using negative look-arounds:The regex above will match any string, or line without a line break, not containing the (sub)string \'hede\'. As mentioned, this is not something regex is "good" at (or should do), but still, it is possible. And if you need to match line break chars as well, use the DOT-ALL modifier (the trailing s in the following pattern):or use it inline:(where the /.../ are the regex delimiters, i.e., not part of the pattern)If the DOT-ALL modifier is not available, you can mimic the same behavior with the character class [\\s\\S]:A string is just a list of n characters. Before, and after each character, there\'s an empty string. So a list of n characters will have n+1 empty strings. Consider the string "ABhedeCD":where the e\'s are the empty strings. The regex (?!hede). looks ahead to see if there\'s no substring "hede" to be seen, and if that is the case (so something else is seen), then the . (dot) will match any character except a line break. Look-arounds are also called zero-width-assertions because they don\'t consume any characters. They only assert/validate something. So, in my example, every empty string is first validated to see if there\'s no "hede" up ahead, before a character is consumed by the . (dot). The regex (?!hede). will do that only once, so it is wrapped in a group, and repeated zero or more times: ((?!hede).)*. Finally, the start- and end-of-input are anchored to make sure the entire input is consumed: ^((?!hede).)*$As you can see, the input "ABhedeCD" will fail because on e3, the regex (?!hede) fails (there is "hede" up ahead!).Note that the solution to does not start with \xe2\x80\x9chede\xe2\x80\x9d:is generally much more efficient than the solution to does not contain \xe2\x80\x9chede\xe2\x80\x9d:The former checks for \xe2\x80\x9chede\xe2\x80\x9d only at the input string\xe2\x80\x99s first position, rather than at every position.If you\'re just using it for grep, you can use grep -v hede to get all lines which do not contain hede.ETA Oh, rereading the question, grep -v is probably what you meant by "tools options".Explanation:^the beginning of the string( group and capture to \\1 (0 or more times (matching the most amount possible))(?! look ahead to see if there is not:hede your string) end of look-ahead. any character except \\n)* end of \\1 (NOTE: because you are using a quantifier on this capture, only the LAST repetition of the captured pattern will be stored in \\1)$ before an optional \\n, and the end of the stringThe given answers are perfectly fine, just an academic point:Regular Expressions in the meaning of theoretical computer sciences ARE NOT ABLE do it like this. For them it had to look something like this:This only does a FULL match. Doing it for sub-matches would even be more awkward.Here\'s a good explanation of why it\'s not easy to negate an arbitrary regex. I have to agree with the other answers, though: if this is anything other than a hypothetical question, then a regex is not the right choice here.If you want the regex test to only fail if the entire string matches, the following will work:e.g. -- If you want to allow all values except "foo" (i.e. "foofoo", "barfoo", and "foobar" will pass, but "foo" will fail), use: ^(?!foo$).*Of course, if you\'re checking for exact equality, a better general solution in this case is to check for string equality, i.e. You could even put the negation outside the test if you need any regex features (here, case insensitivity and range matching):The regex solution at the top may be helpful, however, in situations where a positive regex test is required (perhaps by an API).FWIW, since regular languages (aka rational languages) are closed under complementation, it\'s always possible to find an regular expression (aka rational expression) that negates another expression.  But not many tools implement this.Vcsn supports this operator (which it denotes {c}, postfix).You first define the type of your expressions: labels are letter (lal_char) to pick from a to z for instance (defining the alphabet when working with complementation is, of course, very important), and the "value" computed for each word is just a Boolean: true the word is accepted, false, rejected.In Python:then you enter your expression:convert this expression to an automaton:finally, convert this automaton back to a simple expression.where + is usually denoted |, \\e denotes the empty word, and [^] is usually written . (any character).  So, with a bit of rewriting ()|h(ed?)?|([^h]|h([^e]|e([^d]|d([^e]|e.)))).*.You can see this example here, and try Vcsn online there.I decided to evaluate some of the presented Options and compare their performance, as well as use some new Features.\nBenchmarking on .NET Regex Engine: http://regexhero.net/tester/The first 7 lines should not match, since they contain the searched Expression, while the lower 7 lines should match!Results are Iterations per second as the median of 3 runs - Bigger Number = BetterSince .NET doesn\'t support action Verbs (*FAIL, etc.) I couldn\'t test the solutions P1 and P2.I tried to test most proposed solutions, some Optimizations are possible for certain words.\nFor Example if the First two letters of the search string are not the Same, answer 03 can be expanded to\n^(?>[^R]+|R+(?!egex Hero))*$ resulting in a small performance gain.But the overall most readable and performance-wise fastest solution seems to be 05 using a conditional statement\nor 04 with the possesive quantifier. I think the Perl solutions should be even faster and more easily readable.With negative lookahead, regular expression can match something not contains specific pattern. This is answered and explained by Bart Kiers. Great explanation!However, with Bart Kiers\' answer, the lookahead part will test 1 to 4 characters ahead while matching any single character. We can avoid this and let the lookahead part check out the whole text, ensure there is no \'hede\', and then the normal part (.*) can eat the whole text all at one time.Here is the improved regex:Note the (*?) lazy quantifier in the negative lookahead part is optional, you can use (*) greedy quantifier instead, depending on your data: if \'hede\' does present and in the beginning half of the text, the lazy quantifier can be faster; otherwise, the greedy quantifier be faster. However if \'hede\' does not present, both would be equal slow.Here is the demo code.For more information about lookahead, please check out the great article: Mastering Lookahead and Lookbehind.Also, please check out RegexGen.js, a JavaScript Regular Expression Generator that helps to construct complex regular expressions. With RegexGen.js, you can construct the regex in a more readable way:Not regex, but I\'ve found it logical and useful to use serial greps with pipe to eliminate noise.eg.  search an apache config file without all the comments-andThe logic of serial grep\'s is (not a comment) and (matches dir)with this, you avoid to test a lookahead on each positions:equivalent to (for .net):Old answer:Here\'s how I\'d do it:Accurate and more efficient than the other answers. It implements Friedl\'s "unrolling-the-loop" efficiency technique and requires much less backtracking.If you want to match a character to negate a word similar to negate character class:For example, a string:Do not use:Use:Notice "(?!bbb)." is neither lookbehind nor lookahead, it\'s lookcurrent, for example:Aforementioned (?:(?!hede).)* is great because it can be anchored.But the following would suffice in this case:This simplification is ready to have "AND" clauses added:The OP did not specify or Tag the post to indicate the context (programming language, editor, tool) the Regex will be used within.  For me, I sometimes need to do this while editing a file using Textpad.  Textpad supports some Regex, but does not support lookahead or lookbehind, so it takes a few steps.  If I am looking to retain all lines that Do NOT contain the string hede, I would do it like this:1. Search/replace the entire file to add a unique "Tag" to the beginning of each line containing any text.2. Delete all lines that contain the string hede (replacement string is empty):  3. At this point, all remaining lines Do NOT contain the string hede. Remove the unique "Tag" from all lines (replacement string is empty):  Now you have the original text with all lines containing the string hede removed.\nIf I am looking to Do Something Else to only lines that Do NOT contain the string hede, I would do it like this:1. Search/replace the entire file to add a unique "Tag" to the beginning of each line containing any text.2. For all lines that contain the string hede, remove the unique "Tag":  3. At this point, all lines that begin with the unique "Tag", Do NOT contain the string hede. I can now do my Something Else to only those lines.4. When I am done, I remove the unique "Tag" from all lines (replacement string is empty):  Through PCRE verb (*SKIP)(*F)This would completely skips the line which contains the exact string hede and matches all the remaining lines.DEMOExecution of the parts:Let us consider the above regex by splitting it into two parts.Part before the | symbol. Part shouldn\'t be matched. Part after the | symbol. Part should be matched. PART 1 Regex engine will start its execution from the first part.Explanation:So the line which contains the string hede would be matched. Once the regex engine sees the following (*SKIP)(*F) (Note: You could write (*F) as (*FAIL)) verb, it skips and make the match to fail. | called alteration or logical OR operator added next to the PCRE verb which inturn matches all the boundaries exists between each and every character on all the lines except the line contains the exact string hede. See the demo here. That is, it tries to match the characters from the remaining string. Now the regex in the second part would be executed.PART 2Explanation:.* In the Multiline mode, . would match any character except newline or carriage return characters. And * would repeat the previous character zero or more times. So .* would match the whole line. See the demo here.Hey why you added .* instead of .+ ?Because .* would match a blank line but .+ won\'t match a blank. We want to match all the lines except hede , there may be a possibility of blank lines also in the input . so you must use .* instead of .+ . .+ would repeat the previous character one or more times. See .* matches a blank line here.$ End of the line anchor is not necessary here.Since the introduction of ruby-2.4.1, we can use the new Absent Operator in Ruby\xe2\x80\x99s Regular Expressionsfrom the official docThus, in your case ^(?~hede)$ does the job for youIt may be more maintainable to two regexes in your code, one to do the first match, and then if it matches run the second regex to check for outlier cases you wish to block for example ^.*(hede).* then have appropriate logic in your code.OK, I admit this is not really an answer to the posted question posted and it may also use slightly more processing than a single regex. But for developers who came here looking for a fast emergency fix for an outlier case then this solution should not be overlooked.The TXR Language supports regex negation.A more complicated example: match all lines that start with a and end with z, but do not contain the substring hede:Regex negation is not particularly useful on its own but when you also have intersection, things get interesting, since you have a full set of boolean set operations: you can express "the set which matches this, except for things which match that".Since no one else answered the question as stated, I\'ll do it.The answer is that with POSIX grep, it\'s impossible to literally satisfy this request:The reason is that POSIX grep is only required to work with Basic Regular Expressions, which are simply not powerful enough for accomplishing that task (they are not capable of parsing regular languages, because of lack of alternation).However, GNU grep implements extensions that allow it. In particular, \\| is the alternation operator in GNU\'s implementation of BREs. If your regular expression engine supports alternation, negative bracket expressions, grouping and the Kleene star, and is able to anchor to the beginning and end of the string, that\'s all you need for this approach.With GNU grep, it would be something like:(found with Grail and some further optimizations made by hand).You can also use a tool that implements Extended Regular Expressions, like egrep, to get rid of the backslashes:Here\'s a script to test it (note it generates a file testinput.txt in the current directory):In my system it prints:as expected.Finally, as everyone has noted, if your regular expression engine supports negative lookahead, that simplifies the task a lot. For example, with GNU grep:The below function will help you get your desired outputA simpler solution is to use the not operator !Your if statement will need to match "contains" and not match "excludes".  I believe the designers of RegEx anticipated the use of not operators.