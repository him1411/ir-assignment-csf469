This question already has an answer here:What is the difference between and When you use a string literal the string can be interned, but when you use new String("...") you get a new string object.In this example both string literals refer the same object:Here, 2 different objects are created and they have different references:In general, you should use the string literal notation when possible. It is easier to read and it gives the compiler a chance to optimize your code.A String literal is a Java language concept. This is a String literal:A String object is an individual instance of the java.lang.String class. All are valid, but have a slight difference. s1 will refer to an interned String object. This means, that the character sequence "abcde" will be stored at a central place, and whenever the same literal "abcde" is used again, the JVM will not create a new String object but use the reference of the cached String.s2 is guranteed to be a new String object, so in this case we have:The long answer is available here, so I\'ll give you the short one. When you do this:You are calling the intern() method on String. This method references an internal pool of String objects. If the String you called intern() on already resides in the pool, then a reference to that String is assigned to str. If not, then the new String is placed in the pool, and a reference to it is then assigned to str.Given the following code:When you check for object identity by doing == (you are literally asking: do these two references point to the same object?), you get true. However, you don\'t need to intern() Strings. You can force the creation on a new Object on the Heap by doing this:In this instance, str and str2 are references to different Objects, neither of which have been interned, so that when you test for Object identity using ==, you will get false.In terms of good coding practice: do not use == to check for String equality, use .equals() instead.As Strings are immutable, when you do:while creating the string, the JVM searches in the pool of strings if there already exists a string value "xyz", if so \'a\' will simply be a reference of that string and no new String object is created.But if you say:you force JVM to create a new String reference, even if "xyz" is in its pool.For more information read this."abc" is a literal String. In Java, these literal strings are pooled internally and the same String instance of "abc" is used where ever you have that string literal declared in your code.  So "abc" == "abc" will always be true as they are both the same String instance.Using the String.intern() method you can add any string you like to the internally pooled strings, these will be kept in memory until java exits.On the other hand, using new String("abc") will create a new string object in memory, which is logically the same as the "abc" literal. \n"abc" == new String("abc") will always be false, as although they are logically equal they refer to different instances.Wrapping a String constructor around a string literal is of no value, it just needlessly uses more memory than it needs to.String is a class in Java different from other programming languages. So as for every class the object declaration and initialization is orHere, st1, st2 and st3 are different objects.That is:Because st1, st2, st3 are referencing 3 different objects, and == checks for the equality in memory location, hence the result. But:Here .equals() method checks for the content, and the content of st1 = "", st2 = "hello" and st3 = "hello". Hence the result.And in the case of the String declaration Here, intern() method of String class is called, and checks if "hello" is in intern pool, and if not, it is added to intern pool, and if "hello" exist in intern pool, then st will point to the memory of the existing "hello". So in case of:Here:Because st3 and st4 pointing to same memory address. Also:In the first case, there are two objects created.In the second case, it\'s just one.Although both ways str is referring to "abc".Some disassembly is always interesting...In addition to the answers already posted, also see this excellent article on javaranch.According to String class documentation they are equivalent.Documentation for String(String original) also says that: Unless an explicit copy of original is needed, use of this constructor is unnecessary since Strings are immutable.Look for other responses, because it seems that Java documentation is misleading :(The following are some comparisons:When intern() is called the reference is changed.There is a subtle differences between String object and string literal.In this simple case, "abc" will go in the pool and s will refer to it.In this case, because we used the new keyword, Java will create a new String object\nin normal (non-pool) memory, and s will refer to it. In addition, the literal "abc" will\nbe placed in the pool.String s = new String("FFFF") creates 2 objects: "FFFF" string and String object, which point to "FFFF" string, so it is like pointer to pointer (reference to reference, I am not keen with terminology).It is said you should never use new String("FFFF")