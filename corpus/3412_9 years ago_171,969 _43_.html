Is output buffering enabled by default in Python\'s interpreter for sys.stdout?If the answer is positive, what are all the ways to disable it?Suggestions so far:Is there any other way to set some global flag in sys/sys.stdout programmatically during execution?From Magnus Lycka answer on a mailing list:You can skip buffering for a whole\n  python process using "python -u" \n  (or#!/usr/bin/env python -u etc) or by\n  setting the environment variable\n  PYTHONUNBUFFERED.You could also replace sys.stdout with\n  some other stream like wrapper which\n  does a flush after every call.Credits: "Sebastian", somewhere on the Python mailing list.I would rather put my answer in How to flush output of Python print? or in Python's print function that flushes the buffer when it's called?, but since they were marked as duplicates of this one (what I do not agree), I\'ll answer it here.Since Python 3.3 print() supports the keyword argument "flush" (see documentation):Yes, it is.You can disable it on the commandline with the "-u" switch.Alternatively, you could call .flush() on sys.stdout on every write (or wrap it with an object that does this automatically)Without saving the old sys.stdout, disable_stdout_buffering() isn\'t idempotent, and multiple calls will result in an error like this:Another possibility is:(Appending to gc.garbage is not such a good idea because it\'s where unfreeable cycles get put, and you might want to check for those.)Yes, it is enabled by default. You can disable it by using the -u option on the command line when calling python.The following works in Python 2.6, 2.7, and 3.2:You can also use fcntl to change the file flags in-fly.One way to get unbuffered output would be to use sys.stderr instead of sys.stdout or to simply call sys.stdout.flush() to explicitly force a write to occur.You could easily redirect everything printed by doing:Or to redirect just for a particular print statement:To reset stdout you can just do:Variant that works without crashing (at least on win32; python 2.7, ipython 0.12) then called subsequently (multiple times):You can also run Python with stdbuf utility:stdbuf -oL python <script>You can create an unbuffered file and assign this file to sys.stdout.You can\'t magically change the system-supplied stdout; since it\'s supplied to your python program by the OS.(I\'ve posted a comment, but it got lost somehow. So, again:)As I noticed, CPython (at least on Linux) behaves differently depending on where the output goes. If it goes to a tty, then the output is flushed after each \'\\n\'\nIf it goes to a pipe/process, then it is buffered and you can use the flush() based solutions or the -u option recommended above.Slightly related to output buffering:\nIf you iterate over the lines in the input withfor line in sys.stdin:\n...then the for implementation in CPython will collect the input for a while and then execute the loop body for a bunch of input lines. If your script is about to write output for each input line, this might look like output buffering but it\'s actually batching, and therefore, none of the flush(), etc. techniques will help that.\nInterestingly, you don\'t have this behaviour in pypy.\nTo avoid this, you can usewhile True:\n   line=sys.stdin.readline()\n...This relates to  Crist\xc3\xb3v\xc3\xa3o D. Sousa\'s answer, but I couldn\'t comment yet.A straight-forward way of using the flush keyword argument of Python 3 in order to always have unbuffered output is:afterwards, print will always flush the output directly (except flush=False is given).Note, (a) that this answers the question only partially as it doesn\'t redirect all the output. But I guess print is the most common way for creating output to stdout/stderr in python, so these 2 lines cover probably most of the use cases.Note (b) that it only works in the module/script where you defined it. This can be good when writing a module as it doesn\'t mess with the sys.stdout.Python 2 doesn\'t provide the flush argument, but you could emulate a Python 3-type print function as described here https://stackoverflow.com/a/27991478/3734258 .It is possible to override only write method of sys.stdout with one that calls flush. Suggested method implementation is below.Default value of w argument will keep original write method reference. After write_flush is defined, the original write might be overridden.The code assumes that stdout is imported this way from sys import stdout.