My Swift program is crashing with EXC_BAD_INSTRUCTION and this error. What does it mean, and how do I fix it?fatal error: unexpectedly found nil while unwrapping an Optional valueThis post is intended to collect answers to "unexpectedly found nil" issues, so they are not scattered and hard to find. Feel free to add your own answer or edit the existing wiki answer.This answer is community wiki. If you feel it could be made better, feel free to edit it!In Swift, Optional is a generic type that can contain a value (of any kind), or no value at all.In many other programming languages, a particular "sentinel" value is often used to indicate a lack of a value. In Objective-C, for example, nil (the null pointer) indicates the lack of an object. But this gets more tricky when working with primitive types \xe2\x80\x94 should -1 be used to indicate the absence of an integer, or perhaps INT_MIN, or some other integer? If any particular value is chosen to mean "no integer", that means it can no longer be treated as a valid value.Swift is a type-safe language, which means the language helps you to be clear about the types of values your code can work with. If part of your code expects a String, type safety prevents you from passing it an Int by mistake.In Swift, any type can be made optional. An optional value can take on any value from the original type, or the special value nil.Optionals are defined with a ? suffix on the type:The lack of a value in an optional is indicated by nil:(Note that this nil is not the same as the nil in Objective-C. In Objective-C, nil is the absence of a valid object pointer; in Swift, Optionals are not restricted to objects/reference types. Optional behaves similarly to Haskell\'s Maybe.)In order to access an optional\xe2\x80\x99s value (if it has one at all), you need to unwrap it. An optional value can be unwrapped safely or forcibly. If you force-unwrap an optional, and it didn\'t have a value, your program will crash with the above message.Xcode will show you the crash by highlighting a line of code. The problem occurs on this line.This crash can occur with two different kinds of force-unwrap:This is done with the ! operator on an optional. For example:As anOptionalString is nil here, you will get a crash on the line where you force unwrap it.These are defined with  a !, rather than a ? after the type.These optionals are assumed to contain a value. Therefore whenever you access an implicitly unwrapped optional, it will automatically be force unwrapped for you. If it doesn\xe2\x80\x99t contain a value, it will crash.In order to work out which variable caused the crash, you can hold \xe2\x8c\xa5 while clicking to show the definition, where you might find the optional type.IBOutlets, in particular, are usually implicitly unwrapped optionals. This is because your xib or storyboard will link up the outlets at runtime, after initialization. You should therefore ensure that you\xe2\x80\x99re not accessing outlets before they\'re loaded in. You also should check that the connections are correct in your storyboard/xib file, otherwise the values will be nil at runtime, and therefore crash when they are implicitly unwrapped.As a general rule, you should never explicitly force unwrap an optional with the ! operator. There may be cases where using ! is acceptable \xe2\x80\x93 but you should only ever be using it if you are 100% sure that the optional contains a value.While there may be an occasion where you can use force unwrapping, as you know for a fact that an optional contains a value \xe2\x80\x93 there is not a single place where you cannot safely unwrap that optional instead.These variables are designed so that you can defer their assignment until later in your code. It is your responsibility to ensure they have a value before you access them. However, because they involve force unwrapping, they are still inherently unsafe \xe2\x80\x93 as they assume your value is non-nil, even though assigning nil is valid.You should only be using implicitly unwrapped optionals as a last resort. If you can use a lazy variable, or provide a default value for a variable \xe2\x80\x93 you should do so instead of using an implicitly unwrapped optional.However, there are a few scenarios where implicitly unwrapped optionals are beneficial, and you are still able to use various ways of safely unwrapping them as listed below \xe2\x80\x93 but you should always use them with due caution.The simplest way to check whether an optional contains a value, is to compare it to nil.However, 99.9% of the time when working with optionals, you\xe2\x80\x99ll actually want to access the value it contains, if it contains one at all. To do this, you can use Optional Binding.Optional Binding allows you to check if an optional contains a value \xe2\x80\x93 and allows you to assign the unwrapped value to a new variable or constant. It uses the syntax if let x = anOptional {...} or if var x = anOptional {...}, depending if you need to modify the value of the new variable after binding it.For example:What this does is first check that the optional contains a value. If it does, then the \xe2\x80\x98unwrapped\xe2\x80\x99 value is assigned to  a new variable (number) \xe2\x80\x93 which you can then freely use as if it were non-optional. If the optional doesn\xe2\x80\x99t contain a value, then the else clause will be invoked, as you would expect.What\xe2\x80\x99s neat about optional binding, is you can unwrap multiple optionals at the same time. You can just separate the statements with a comma. The statement will succeed if all the optionals were unwrapped.Another neat trick is that you can use the where clause to check for a certain condition on the value, after unwrapping it.The only catch with using optional binding within an if statement, is that you can only access the unwrapped value from within the scope of the statement. If you need access to the value from outside of the scope of the statement, you can use a guard statement.A guard statement allows you to define a condition for success \xe2\x80\x93 and the current scope will only continue executing if that condition is met. They are defined with the syntax guard condition else {...}.So, to use them with an optional binding, you can do this:(Note that within the guard body, you must use one of the control transfer statements in order to exit the scope of the currently executing code).If anOptionalInt contains a value, it will be unwrapped and assigned to the new number constant. The code after the guard will then continue executing. If it doesn\xe2\x80\x99t contain a value \xe2\x80\x93 the guard will execute the code within the brackets, which will lead to transfer of control, so that the code immediately after will not be executed.The real neat thing about guard statements is the unwrapped value is now available to use in code that follows the statement (as we know that future code can only execute if the optional has a value). This is a great for eliminating \xe2\x80\x98pyramids of doom\xe2\x80\x99 created by nesting multiple if statements. For example:Guards also support the same neat tricks that the if statement supported, such as unwrapping multiple optionals at the same time and using the where clause.Whether you use an if or guard statement completely depends on whether any future code requires the optional to contain a value.The Nil Coalescing Operator is a nifty shorthand version of the ternary conditional operator, primarily designed to convert optionals to non-optionals. It has the syntax a ?? b, where a is an optional type and b is the same type as a (although usually non-optional).It essentially lets you say \xe2\x80\x9cIf a contains a value, unwrap it. If it doesn\xe2\x80\x99t then return b instead\xe2\x80\x9d. For example, you could use it like this:This will define a number constant of Int type, that will either contain the value of anOptionalInt, if it contains a value, or 0 otherwise.It\xe2\x80\x99s just shorthand for:You can use Optional Chaining in order to call a method or access a property on an optional. This is simply done by suffixing the variable name with a ? when using it.For example, say we have a variable foo, of type an optional Foo instance.If we wanted to call a method on foo that doesn\xe2\x80\x99t return anything, we can simply do:If foo contains a value, this method will be called on it. If it doesn\xe2\x80\x99t, nothing bad will happen \xe2\x80\x93 the code will simply continue executing.(This is similar behaviour to sending messages to nil in Objective-C)This can therefore also be used to set properties as well as call methods. For example:Again, nothing bad will happen here if foo is nil. Your code will simply continue executing.Another neat trick that optional chaining lets you do is check whether setting a property or calling a method was successful. You can do this by comparing the return value to nil.(This is because an optional value will return Void? rather than Void on a method that doesn\xe2\x80\x99t return anything)For example:However, things become a little bit more tricky when trying to access properties or call methods that return a value. Because foo is optional, anything returned from it will also be optional. To deal with this, you can either unwrap the optionals that get returned using one of the above methods \xe2\x80\x93 or unwrap foo itself before accessing methods or calling methods that return values.Also, as the name suggests, you can \xe2\x80\x98chain\xe2\x80\x99 these statements together. This means that if foo has an optional property baz, which has a property qux \xe2\x80\x93 you could write the following:Again, because foo and baz are optional, the value returned from qux will always be an optional regardless of whether qux itself is optional.An often underused feature with optionals is the ability to use the map and flatMap functions. These allow you to apply non-optional transforms to optional variables. If an optional has a value, you can apply a given transformation to it. If it doesn\xe2\x80\x99t have a value, it will remain nil.For example, let\xe2\x80\x99s say you have an optional string:By applying the map function to it \xe2\x80\x93 we can use the stringByAppendingString function in order to concatenate it to another string.Because stringByAppendingString takes a non-optional string argument, we cannot input our optional string directly. However, by using map, we can use allow stringByAppendingString to be used if anOptionalString has a value.For example:However, if anOptionalString doesn\xe2\x80\x99t have a value, map will return nil. For example:flatMap works similarly to map, except it allows you to return another optional from within the closure body. This means you can input an optional into a process that requires a non-optional input, but can output an optional itself.Swift\'s error handling system can be safely used with Do-Try-Catch:If someThrowingFunc() throws an error, the error will be safely caught in the catch block.The error constant you see in the catch block has not been declared by us - it\'s automatically generated by catch. You can also declare error yourself, it has the advantage of being able to cast it to a useful format, for example:Using try this way is the proper way to try, catch and handle errors coming from throwing functions.There\'s also try? which absorbs the error:But Swift\'s error handling system also provides a way to "force try" with try!:The concepts explained in this post also apply here: if an error is thrown, the application will crash.You should only ever use try! if you can prove that its result will never fail in your context - and this is very rare.Most of the time you will use the complete Do-Try-Catch system - and the optional one, try?, in the rare cases where handling the error is not important.With very few exceptions, this rule is golden:In other words, rather use:\nvar nameOfDaughter: String?Instead of:\nvar nameOfDaughter: String!Either unwrap variable like this:Or like this:This answer was intended to be concise, for full comprehension read accepted answerThis question comes up ALL THE TIME on SO. It\'s one of the first things that new Swift developers struggle with.Swift uses the concept of "Optionals" to deal with values that could contain a value, or not. In other languages like C, you might store a value of 0 in a variable to indicate that it contains no value. However, what if 0 is a valid value? Then you might use -1. What if -1 is a valid value? And so on.Swift optionals let you set up a variable of any type to contain either a valid value, or no value.You put a question mark after the type when you declare a variable to mean (type x, or no value).An optional is actually a container than contains either a variable of a given type, or nothing. An optional needs to be "unwrapped" in order to fetch the value inside. The "!" operator is a "force unwrap" operator. It says "trust me. I know what I am doing. I guarantee that when this code runs, the variable will not contain nil." If you are wrong, you crash.Unless you really do know what you are doing, avoid the "!" force unwrap operator. It is probably the largest source of crashes for beginning Swift programmers.There are lots of other ways of dealing with optionals that are safer. Here are some (not an exhaustive list)You can use "optional binding" or "if let" to say "if this optional contains a value, save that value into a new, non-optional variable. If the optional does not contain a value, skip the body of this if statement".Here is an example of optional binding with our foo optional:Note that the variable you define when you use optional biding only exists (is only "in scope") in the body of the if statement.There is also a construct called the "nil coalescing operator". It takes the form "optional_var ?? replacement_val". It returns a non-optional variable with the same type as the data contained in the optional. If the optional contains nil, it returns the value of the expression after the "??" symbol.So you could use code like this:You could also use try/catch or guard error handling, but generally one of the other techniques above is cleaner.Another, slightly more subtle gotcha with optionals is "implicitly unwrapped optionals. When we declare foo, we could say:In that case foo is still an optional, but you don\'t have to unwrap it to reference it.  That means any time you try to reference foo, you crash if it\'s nil.So this code:Will crash on reference to foo\'s capitalizedString property even though we\'re not force-unwrapping foo. the print looks fine, but it\'s not.Thus you want to be really careful with implicitly unwrapped optionals.  (and perhaps even avoid them completely until you have a solid understanding of optionals.)Bottom line: When you are first learning Swift, pretend the "!" character is not part of the language. It\'s likely to get you into trouble.First, you should know what an Optional value is.\nYou can step to The Swift Programming Launagefor detail.Second, you should know the optional value has two status. One is the full value, and the other is nil value. So before you implement an optional value, you should check which state it\'s.You can use if let ... or guard let ... else and so on.One other way, if you don\'t want to check it\'s state before your implement, you can also use var buildingName = buildingName ?? "buildingName" instead.