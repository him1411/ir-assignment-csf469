I\'m sure there\'s a good reason, but could someone please explain why the java.util.Set interface lacks get(int Index), or any similar get() method?It seems that sets are great for putting things into, but I can\'t find an elegant way of retrieving a single item from it.If I know I want the first item, I can use set.iterator().next(), but otherwise it seems I have to cast to an Array to retrieve an item at a specific index?What are the appropriate ways of retrieving data from a set? (other than using an iterator)I\'m sure the fact that it\'s excluded from the API means there\'s a good reason for not doing this -- could someone please enlighten me?EDIT:\nSome extremely great answers here, and a few saying "more context".  The specific scenario was a dbUnit test, where I could reasonably assert that the returned set from a query had only 1 item, and I was trying to access that item.However, the question is more valid without the scenario, as it remains more focussed:What\'s the difference between set and list.Thanks to all for the fantastic answers below.Because sets have no ordering. Some implementations do (particularly those implementing the java.util.SortedSet interface), but that is not a general property of sets.If you\'re trying to use sets this way, you should consider using a list instead.Actually this is a recurring question when writing JavaEE applications which use Object-Relational Mapping (for example with Hibernate); and from all the people who replied here, Andreas Petersson is the only one who understood the real issue and offered the correct answer to it: Java is missing a UniqueList! (or you can also call it OrderedSet, or IndexedSet).Maxwing mentioned this use-case (in which you need ordered AND unique data) and he suggested the SortedSet, but this is not what Marty Pitt really needed.This "IndexedSet" is NOT the same as a SortedSet - in a SortedSet the elements are sorted by using a Comparator (or using their "natural" ordering).But instead it is closer to a LinkedHashSet (which others also suggested), or even more so to an (also inexistent) "ArrayListSet", because it guarantees that the elements are returned in the same order as they were inserted.But the LinkedHashSet is an implementation, not an interface! What is needed is an IndexedSet (or ListSet, or OrderedSet, or UniqueList) interface! This will allow the programmer to specify that he needs a collection of elements that have a specific order and without duplicates, and then instantiate it with any implementation (for example an implementation provided by Hibernate).Since JDK is open-source, maybe this interface will be finally included in Java 7...Just adding one point that was not mentioned in mmyers\' answer.If I know I want the first item, I can\n  use set.iterator().next(), but\n  otherwise it seems I have to cast to\n  an Array to retrieve an item at a\n  specific index?What are the appropriate ways of\n  retrieving data from a set? (other\n  than using an iterator)You should also familiarise yourself with the SortedSet interface (whose most common implementation is TreeSet). A SortedSet is a Set (i.e. elements are unique) that is kept ordered by the natural ordering of the elements or using some Comparator. You can easily access the first and last items using first() and last() methods. A SortedSet comes in handy every once in a while, when you need to keep your collection both duplicate-free and ordered in a certain way.Edit: If you need a Set whose elements are kept in insertion-order (much like a List), take a look at LinkedHashSet.This kind of leads to the question when you should use a set and when you should use a list. Usually, the advice goes:A fourth case that appears often is that you need neither. In this case you see some programmers go with lists and some with sets. Personally I find it very harmful to see set as a list without ordering - because it is really a whole other beast. Unless you need stuff like set uniqueness or set equality, always favor lists.I\'m not sure if anybody has spelled it out exactly this way, but you need to understand the following:There is no "first" element in a set.Because, as others have said, sets have no ordering.  A set is a mathematical concept that specifically does not include ordering.Of course, your computer can\'t really keep a list of stuff that\'s not ordered in memory.  It has to have some ordering.  Internally it\'s an array or a linked list or something.  But you don\'t really know what it is, and it doesn\'t really have a first element; the element that comes out "first" comes out that way by chance, and might not be first next time.  Even if you took steps to "guarantee" a particular first element, it\'s still coming out by chance, because you just happened to get it right for one particular implementation of a Set; a different implementation might not work that way with what you did.  And, in fact, you may not know the implementation you\'re using as well as you think you do.People run into this ALL. THE. TIME. with RDBMS systems and don\'t understand.  An RDBMS query returns a set of records.  This is the same type of set from mathematics: an unordered collection of items, only in this case the items are records.  An RDBMS query result has no guaranteed order at all unless you use the ORDER BY clause, but all the time people assume it does and then trip themselves up some day when the shape of their data or code changes slightly and triggers the query optimizer to work a different way and suddenly the results don\'t come out in the order they expect.  These are typically the people who didn\'t pay attention in database class (or when reading the documentation or tutorials) when it was explained to them, up front, that query results do not have a guaranteed ordering.some data structures are missing from the standard java collections. Bag (like set but can contain elements multiple times)UniqueList (ordered list, can contain each element only once)seems you would need a uniquelist in this caseif you need flexible data structures, you might be interested in Google CollectionsThat\'s true, element in Set are not ordered, by definition of the Set Collection. So they can\'t be access by an index.But why don\'t we have a get(object) method, not by providing the index as parameter, but an object that is equal to the one we are looking for? \nBy this way, we can access the data of the element inside the Set, just by knowing its attributes used by the equal method.If you are going to do lots of random accesses by index in a set, you can get an array view of its elements:There are two main drawbacks though:That is because Set only guarantees uniqueness, but says nothing about the optimal access or usage patterns.  Ie, a Set can be a List or a Map, each of which have very different retrieval characteristics.The only reason I can think of for using a numerical index in a set would be for iteration. For that, use I ran into situations where I actually wanted a SortedSet with access via index (I concur with other posters that accessing an unsorted Set with an index makes no sense). \nAn example would be a tree where I wanted the children to be sorted and duplicate children were not allowed. I needed the access via index to display them and the set attributes came in handy to efficiently eliminate duplicates.Finding no suitable collection in java.util or google collections, I found it straightforward to implement it myself. The basic idea is to wrap a SortedSet and create a List when access via index is required (and forget the list when the SortedSet is changed). This does of course only work efficiently when changing the wrapped SortedSet and accessing the list is separated in the lifetime of the Collection. Otherwise it behaves like a list which is sorted often, i.e. too slow.With large numbers of children, this improved performance a lot over a list I kept sorted via Collections.sort.You can do new ArrayList<T>(set).get(index)The reason why the Set interface doesn\'t have a get index-type call or even something even more basic, such as first() or last(), is because it is an ambiguous operation, and therefore a potentially dangerous operation. If a method returns a Set, and you call, say first() method on it, what is the expected result, given that the a generic Set makes no guarantees on the ordering? The resultant object could very well vary between each call of the method, or it might not and lull you into a false sense of security, until the library you\'re using changes changes the implementation underneath and now you find that all your code breaks for no particular reason.The suggestions about workarounds listed here are good. If you need indexed access, use a list. Be careful with using iterators or toArray with a generic Set, because a) there is no guarantee on the ordering and b) there is no guarantee that the ordering will not change with subsequent invocations or with different underlying implementations. If you need something in between, a SortedSet or a LinkedHashSet is what you want.//\nI do wish the Set interface had a get-random-element though. Please note only 2 basic data structure can be accessed via index.In Java, ArrayList is implemented using Array data structure.While Set data structure usually can be implemented via HashTable/HashMap or BalancedTree data structure, for fast detecting whether an element exists and add non-existing element, usually a well implemented Set can achieve O(1) time complexity contains operation. In Java, HashSet is the most common used implementation of Set, it is implemented by calling HashMap API, and HashMap is implemented using separate chaining with linked lists (a combination of Array and LinkedList).Since Set can be implemented via different data structure, there is no get(int index) method for it.If you don\'t mind the set to be sorted then you may be interested to take a look at the indexed-tree-map project. The enhanced TreeSet/TreeMap provides access to elements by index or getting the index of an element. And the implementation is based on updating node weights in the RB tree. So no iteration or backing up by a list here.java.util.Set is a collection of un-ordered items. It doesn\'t make any sense if the Set has a get(int index), because \nSet doesn\'t has an index and also you only can guess the value. If you really want this, code a method to get random element from Set.To get element in a Set, i use to following one: