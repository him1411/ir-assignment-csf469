What I would like to know is whether I should use System.currentTimeMillis() or System.nanoTime() when updating my object\'s positions in my game?  Their change in movement is directly proportional to the elapsed time since the last call and I want to be as precise as possible.I\'ve read that there are some serious time-resolution issues between different operating systems (namely that Mac / Linux have an almost 1 ms resolution while Windows has a  50ms resolution??).  I\'m primarly running my apps on windows and 50ms resolution seems pretty inaccurate.Are there better options than the two I listed?Any suggestions / comments?If you\'re just looking for extremely precise measurements of elapsed time, use System.nanoTime(). System.currentTimeMillis() will give you the most accurate possible elapsed time in milliseconds since the epoch, but System.nanoTime() gives you a nanosecond-precise time, relative to some arbitrary point.From the Java Documentation:Returns the current value of the most precise available system timer, in nanoseconds.This method can only be used to\n  measure elapsed time and is not\n  related to any  other notion of system\n  or wall-clock time. The value returned\n  represents nanoseconds since some\n  fixed but arbitrary time (perhaps in\n  the future, so values may be\n  negative). This method provides\n  nanosecond precision, but not\n  necessarily nanosecond accuracy. No\n  guarantees are made about how\n  frequently values change. Differences\n  in successive calls that span greater\n  than approximately 292 years (263\n  nanoseconds) will not accurately\n  compute elapsed time due to numerical\n  overflow.For example, to measure how long some code takes to execute:See also: JavaDoc System.nanoTime() and JavaDoc System.currentTimeMillis() for more info.Since none else has mentioned this\xe2\x80\xa6It is not safe to compare the results of System.nanoTime() calls between different Threads. Even if the events of the Threads happen in a predictable order, the difference in nanoseconds can be positive or negative.System.currentTimeMillis() is safe for use between threads.Update by Arkadiy: I\'ve observed more correct behavior of System.currentTimeMillis() on Windows 7 in Oracle Java 8. The time was returned with 1 millisecond precision. The source code in OpenJDK has not changed, so I do not know what causes the better behavior.David Holmes of Sun posted a blog article a couple years ago that has a very detailed look at the Java timing APIs (in particular System.currentTimeMillis() and System.nanoTime()), when you would want to use which, and how they work internally.Inside the Hotspot VM: Clocks, Timers and Scheduling Events - Part I - WindowsOne very interesting aspect of the timer used by Java on Windows for APIs that have a timed wait parameter is that the resolution of the timer can change depending on what other API calls may have been made - system wide (not just in the particular process). He shows an example where using Thread.sleep() will cause this resolution change.System.nanoTime() isn\'t supported in older JVMs.  If that is a concern, stick with currentTimeMillisRegarding accuracy, you are almost correct. On SOME Windows machines, currentTimeMillis() has a resolution of about 10ms (not 50ms). I\'m not sure why, but some Windows machines are just as accurate as Linux machines.I have used GAGETimer in the past with moderate success.As others have said, currentTimeMillis is clock time, which changes due to daylight saving time, users changing the time settings, leap seconds, and internet time sync. If your app depends on monotonically increasing elapsed time values, you might prefer nanoTime instead. You might think that the players won\'t be fiddling with the time settings during game play, and maybe you\'d be right. But don\'t underestimate the disruption due to internet time sync, or perhaps remote desktop users. The nanoTime API is immune to this kind of disruption. If you want to use clock time, but avoid discontinuities due to internet time sync, you might consider an NTP client such as Meinberg, which "tunes" the clock rate to zero it in, instead of just resetting the clock periodically. I speak from personal experience. In a weather application that I developed, I was getting randomly occurring wind speed spikes. It took a while for me to realize that my timebase was being disrupted by the behavior of clock time on a typical PC. All my problems disappeared when I started using nanoTime. Consistency (monotonicity) was more important to my application than raw precision or absolute accuracy. Yes, if such precision is required use System.nanoTime(), but be aware that you are then requiring a Java 5+ JVM.On my XP systems, I see system time reported to at least 100 microseconds 278 nanoseconds using the following code:I\'ve had good experience with nanotime.  It provides wall-clock time as two longs (seconds since the epoch and nanoseconds within that second), using a JNI library.  It\'s available with the JNI part precompiled for both Windows and Linux.For game graphics & smooth position updates, use System.nanoTime() rather than System.currentTimeMillis(). I switched from currentTimeMillis() to nanoTime() in a game and got a major visual improvement in smoothness of motion.While one millisecond may seem as though it should already be precise, visually it is not. The factors nanoTime() can improve include:As other answers suggest, nanoTime does have a performance cost if called repeatedly -- it would be best to call it just once per frame, and use the same value to calculate the entire frame.one thing here is the inconsistency of the nanoTime method.it does not give very consistent values for the same input.currentTimeMillis does much better in terms of performance and consistency,and also ,though not as precise as nanoTime,has a lower margin of error,and therefore more accuracy in its value. i would therefore suggest that you use currentTimeMillis