I\'ve tried to find a comprehensive guide on whether it is best to use import module or from module import. I\'ve just started with Python, with the intention for developing web applications with Django and I\'m trying to start off with best practices in mind.Basically, I was hoping if anyone could share their experiences, what preferences other developers have and whats the best way to avoid any gotchas down the road.The difference between import module and from module import foo is mainly subjective.  Pick the one you like best and be consistent in your use of it.  Here are some points to help you decide.import modulefrom module import fooEither method is acceptable, but don\'t use from module import *.  For any reasonable large set of code, if you import * you will likely be cementing it into the module, unable to be removed.  This is because it is difficult to determine what items used in the code are coming from \'module\', making it easy to get to the point where you think you don\'t use the import any more but it\'s extremely difficult to be sure.Both ways are supported for a reason: there are times when one is more appropriate than the other.import module: nice when you are using many bits from the module. drawback is that you\'ll need to qualify each reference with the module name.from module import ...: nice that imported items are usable directly without module name prefix. The drawback is that you must list each thing you use, and that it\'s not clear in code where something came from.Which to use depends on which makes the code clear and readable, and has more than a little to do with personal preference. I lean toward import module generally because in the code it\'s very clear where an object or function came from. I use from module import ... when I\'m using some object/function a lot in the code.I personally always use and then access everything asetc. The reason is that at the same time you have short invocation, and you clearly define the module namespace of each routine, something that is very useful if you have to search for usage of a given module in your source.Needless to say, do not use the import *, because it pollutes your namespace and it does not tell you where a given function comes from (from which module)Of course, you can run in trouble if you have the same module name for two different modules in two different packages, likein this case, of course you run into troubles, but then there\'s a strong hint that your package layout is flawed, and you have to rethink it.There\'s another detail here, not mentioned, related to writing to a module. Granted this may not be very common, but I\'ve needed it from time to time.Due to the way references and name binding works in Python, if you want to update some symbol in a module, say foo.bar, from outside that module, and have other importing code "see" that change, you have to import foo a certain way. For example:module foo:module a:module b:However, if you import symbol names instead of module names, this will not work.For example, if I do this in module a:No code outside of a will see bar as "oranges" because my setting of bar merely affected the name "bar" inside module a, it did not "reach into" the foo module object and update its "bar".Already many people explained about import vs from, even I want to try to explain a bit more under the hood, where are all the places it got changes:First of all let me explain:import X :For example: X.name or X.attributefrom X import * :Now let\xe2\x80\x99s see when we do import X.Y:Check sys.modules with name os and os.path:Check globals() and locals() namespace dict with name os and os.path:From the above example we found that only os is inserted in the local and global namespace.\nSo, we should be able to use:But not pathOnce you delete the os from locals() namespace, you won\'t be able to access os as well as os.path even though they exist in sys.modules:Now let\'s come to from :** from :**Check sys.modules with name os and os.path:Oh, we found that in sys.modules we found as same as we did before by using import nameOK, let\'s check how it looks like in locals() and globals() namespace dict:You can access by using name path not by os.path:Let\'s delete \'path\' from locals():One final example using an alias:And no path defined:Is best when you will use many functions from the module.Is best when you want to avoid polluting the global namespace with all the functions and types from a module when you only need function.Here is another difference not mentioned.  This is copied verbatim from http://docs.python.org/2/tutorial/modules.htmlNote that when using the item can be either a submodule (or subpackage) of the package, or some other name defined in the package, like a function, class or variable. The import statement first tests whether the item is defined in the package; if not, it assumes it is a module and attempts to load it. If it fails to find it, an ImportError exception is raised.Contrarily, when using syntax like each item except for the last must be a package; the last item can be a module or a package but can\xe2\x80\x99t be a class or function or variable defined in the previous item.To add to what people have said about from x import *: besides making it more difficult to tell where names came from, this throws off code checkers like Pylint.  They will report those names as undefined variables.My own answer to this depends mostly on first, how many different modules I\'ll be using.  If i\'m only going to use one or two, I\'ll often use from ... import since it makes for fewer keystrokes in the rest of the file, but if I\'m going to make use of many different modules, I prefer just import because that means that each module reference is self-documenting.  I can see where each symbol comes from without having to hunt around.Usuaully I prefer the self documenting style of plain import and only change to from.. import when the number of times I have to type the module name grows above 10 to 20, even if there\'s only one module being imported.I\'ve just discovered one more subtle difference between these two methods.If module foo uses a following import:Then module bar can by mistake use count as though it was defined in foo, not in itertools:If foo uses:the mistake is still possible, but less likely to be made. bar needs to:This caused some troubles to me. I had a module that by mistake imported an exception from a module that did not define it, only imported it from other module (using from module import SomeException). When the import was no longer needed and removed, the offending module was broken.With import, the token must be a module (a file containing Python commands) or a package (a folder in the sys.path containing a file __init__.py.)When there are subpackages:the requirements for folder (package) or file (module) are the same, but the folder or file must be inside package2 which must be inside package1, and both package1 and package2 must contain __init__.py files. https://docs.python.org/2/tutorial/modules.htmlWith the from style of import:the package or module enters the namespace of the file containing the import statement as module (or package) instead of package1.package2.module. You can always bind to a more convenient name:Only the from style of import permits you to name a particular function or variable:is allowed, butis not allowed.Import Module - You don\'t need additional efforts to fetch another thing from module. It has disadvantages such as redundant typing Module Import From - Less typing &More control over which items of a module can be accessed.To use a new item from the module you have to update your import statement.