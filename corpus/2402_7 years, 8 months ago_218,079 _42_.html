I have the following repository layout:What I want to achieve is to cherry pick a range of commits from the working branch and merge it into the integration branch. I pretty new to git and I can\'t figure out how to exactly do this (the cherry picking of commit ranges in one operation not the merging) without messing the repository up. Any pointers or thoughts on this? Thanks!When it comes to a range of commits, cherry-picking is was not practical.As mentioned below by Keith Kim, Git 1.7.2+ introduced the ability to cherry-pick a range of commits (but you still need to be aware of the consequence of cherry-picking for future merge)git cherry-pick" learned to pick a range of commits\n  (e.g. "cherry-pick A..B" and "cherry-pick --stdin"), so did "git revert"; these do not support the nicer sequencing control "rebase [-i]" has, though.damian comments and warns us:In the "cherry-pick A..B" form, A should be older than B.\n  If they\'re the wrong order the command will silently fail.If you want to pick the range B through D (inclusive) that would be B^..D.\nSee "Git create branch from range of previous commits?" as an illustration.As Jubobs mentions in the comments: This assumes that B is not a root commit; you\'ll get an "unknown revision" error otherwise.Note: as of Git 2.9.x/2.10 (Q3 2016), you can cherry-pick a range of commit directly on an orphan branch (empty head): see "How to make existing branch an orphan in git".Original answer (January 2010)A rebase --onto would be better, where you replay the given range of commit on top of your integration branch, as Charles Bailey described here.\n(also, look for "Here is how you would transplant a topic branch based on one branch to another" in the git rebase man page, to see a pratical example of git rebase --onto)If your current branch is integration:That will replay everything between:to "tmp" (which points to where integration was pointing before)If there is any conflict when one of those commits is replayed:After that rebase --onto, integration will be back at the last commit of the integration branch (that is "tmp" branch + all the replayed commits)With cherry-picking or rebase --onto, do not forget it has consequences on subsequent merges, as described here.A pure "cherry-pick" solution is discussed here, and would involve something like:If you want to use a patch approach then "git format-patch|git am" and "git cherry" are your options.\n  Currently, git cherry-pick accepts only a single commit, but if you want to pick the range B through D that would be B^..D in git lingo, so But anyway, when you need to "replay" a range of commits, the word "replay" should push you to use the "rebase" feature of Git.As of git v1.7.2 cherry pick can accept a range of commits:git cherry-pick learned to pick a range of commits (e.g. cherry-pick A..B and cherry-pick --stdin), so did git revert; these do not support the nicer sequencing control rebase [-i] has, though.Are you sure you don\'t want to actually merge the branches? If the working branch has some recent commits you don\'t want, you can just create a new branch with a HEAD at the point you want.Now, if you really do want to cherry-pick a range of commits, for whatever reason, an elegant way to do this is to just pull of a patchset and apply it to your new integration branch:This is essentially what git-rebase is doing anyway, but without the need to play games. You can add --3way to git-am if you need to merge. Make sure there are no other *.patch files already in the directory where you do this, if you follow the instructions verbatim...I wrapped VonC\'s code into a short bash script, git-multi-cherry-pick, for easy running:I\'m currently using this as I rebuild the history of a project that had both 3rd-party code and customizations mixed together in the same svn trunk. I\'m now splitting apart core 3rd party code, 3rd party modules, and customizations onto their own git branches for better understanding of customizations going forward. git-cherry-pick is helpful in this situation since I have two trees in the same repository, but without a shared ancestor.All the above options will prompt you to resolve merge conflicts. If you are merging changes committed for a team, it is difficult to get resolved the merge conflicts from developers and proceed. However, "git merge" will do the merge in one shot but you can not pass a range of revisions as argument. we have to use "git diff" and "git apply" commands to do the merge range of revs. I have observed that "git apply" will fail if the patch file has diff for too many file, so we have to create a patch per file and then apply. Note that the script will not be able to delete the files that are deleted in source branch. This is a rare case, you can manually delete such files from target branch. The exit status of "git apply" is not zero if it is not able to apply the patch, however if you use -3way option it will fall back to 3 way merge and you don\'t have to worry about this failure.Below is the script.Another option might be to merge with strategy ours to the commit before the range and then a \'normal\' merge with the last commit of that range (or branch when it is the last one). So suppose only 2345 and 3456 commits of master to be merged into feature branch:in feature branch:Assume that you have 2 branches,"branchA" : includes commits you want to copy (from "commitA" to "commitB""branchB" : the branch you want the commits to be transferred from "branchA"1) 2) get the IDs of "commitA" and "commitB"3) 4) 5) In case you have a conflict, solve it and type to continue the cherry-pick process.