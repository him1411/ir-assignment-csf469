I am getting confused with size_t in C. I know that it is returned by the sizeof operator. But what exactly is it? Is it a data type?Let\'s say I have a for loop:Should I use int i; or size_t i;?From Wikipedia:According to the 1999 ISO C standard\n  (C99), size_t is an unsigned integer\n  type of at least 16 bit (see sections\n  7.17 and 7.18.3).size_tis an unsigned data type\n  defined by several C/C++ standards,\n  e.g. the C99 ISO/IEC 9899 standard,\n  that is defined in stddef.h.1 It can\n  be further imported by inclusion of\n  stdlib.h as this file internally sub\n  includes stddef.h.This type is used to represent the\n  size of an object. Library functions\n  that take or return sizes expect them\n  to be of type or have the return type\n  of size_t. Further, the most\n  frequently used compiler-based\n  operator sizeof should evaluate to a\n  constant value that is compatible with\n  size_t.As an implication, size_t is a type guaranteed to hold any array index.size_t is an unsigned type.  So, it cannot represent any negative values(<0).  You use it when you are counting something, and are sure that it cannot be negative.  For example, strlen() returns a size_t because the length of a string has to be at least 0.In your example, if your loop index is going to be always greater than 0, it might make sense to use size_t, or any other unsigned data type.When you use a size_t object, you have to make sure that in all the contexts it is used, including arithmetic, you want non-negative values.  For example, let\'s say you have:and you want to find the difference of the lengths of str2 and str1.  You cannot do:This is because the value assigned to diff is always going to be a positive number, even when s2 < s1, because the calculation is done with unsigned types.  In this case, depending upon what your use case is, you might be better off using int (or long long) for s1 and s2.There are some functions in C/POSIX that could/should use size_t, but don\'t because of historical reasons.  For example, the second parameter to fgets should ideally be size_t, but is int.size_t is a type that can hold any array index.Depending on the implementation, it can be any of:unsigned charunsigned shortunsigned intunsigned longunsigned long longHere\'s how size_t is defined in stddef.h of my machine:If you are the empirical typeOutput for Ubuntu 14.04 64-bit GCC 4.8:Note that stddef.h is provided by GCC and not glibc under src/gcc/ginclude/stddef.h in GCC 4.2.Interesting C99 appearancesmalloc takes size_t as argument, so it determines the maximum size that may be allocated.And since it is also returned by sizeof, I think it limits the maximum size of a any array.See also: The maximum size of an array in CThe manpage for types.h says:size_t shall be an unsigned integer typeSince nobody has yet mentioned it, the primary linguistic significance of size_t is that the sizeof operator returns a value of that type.  Likewise, the primary significance of ptrdiff_t is that subtracting one pointer from another will yield a value of that type.  Library functions that accept it do so because it will allow such functions to work with objects whose size exceeds UINT_MAX on systems where such objects could exist, without forcing callers to waste code passing a value larger than "unsigned int" on systems where the larger type would suffice for all possible objects.size_t and int are not interchangeable. For instance on 64-bit Linux size_t is 64-bit in size (i.e. sizeof(void*)) but int is 32-bit.Also note that size_t is unsigned. If you need signed version then there is ssize_t on some platforms and it would be more relevant to your example.As a general rule I would suggest using int for most general cases and only use size_t/ssize_t when there is a specific need for it (with mmap() for example).In general, if you are starting at 0 and going upward, always use an unsigned type to avoid an overflow taking you into a negative value situation. This is critically important, because if your array bounds happens to be less than the max of your loop, but your loop max happens to be greater than the max of your type, you will wrap around negative and you may experience a segmentation fault (SIGSEGV). So, in general, never use int for a loop starting at 0 and going upwards. Use an unsigned.size_t is unsigned integer data type. On systems using the GNU C Library, this will be\xc2\xa0unsigned\xc2\xa0int\xc2\xa0or\xc2\xa0unsigned\xc2\xa0long\xc2\xa0int. size_t\xc2\xa0is commonly used for array indexing and loop counting.From my understanding, size_t is an unsigned integer whose bit size is large enough to hold a pointer of the native architecture.So: