I once had the task of determining the following performance parameters from inside a running application:The code had to run on Windows and Linux. Even though this seems to be a standard task, finding the necessary information in the manuals (WIN32 API, GNU docs) as well as on the Internet took me several days, because there\'s so much incomplete/incorrect/outdated information on this topic to be found out there.In order to save others from going through the same trouble, I thought it would be a good idea to collect all the scattered information plus what I found by trial and error here in one place.Some of the above values are easily available from the appropriate WIN32 API, I just list them here for completeness. Others, however, need to be obtained from the Performance Data Helper library (PDH), which is a bit "unintuitive" and takes a lot of painful trial and error to get to work. (At least it took me quite a while, perhaps I\'ve been only a bit stupid...)Note: for clarity all error checking has been omitted from the following code. Do check the return codes...!Total Virtual Memory:Note: The name "TotalPageFile" is a bit misleading here. In reality this parameter gives the "Virtual Memory Size", which is size of swap file plus installed RAM.Virtual Memory currently used:Same code as in "Total Virtual Memory" and thenVirtual Memory currently used by current process:Total Physical Memory (RAM):Same code as in "Total Virtual Memory" and thenPhysical Memory currently used:Physical Memory currently used by current process:Same code as in "Virtual Memory currently used by current process" and thenCPU currently used:CPU currently used by current process:On Linux the choice that seemed obvious at first was to use the POSIX APIs like getrusage() etc. I spent some time trying to get this to work, but never got meaningful values. When I finally checked the kernel sources themselves, I found out that apparently these APIs are not yet completely implemented as of Linux kernel 2.6!?In the end I got all values via a combination of reading the pseudo-filesystem /proc and kernel calls.Total Virtual Memory:Virtual Memory currently used:Same code as in "Total Virtual Memory" and thenVirtual Memory currently used by current process:Total Physical Memory (RAM):Same code as in "Total Virtual Memory" and thenPhysical Memory currently used:Same code as in "Total Virtual Memory" and thenPhysical Memory currently used by current process:Change getValue() in "Virtual Memory currently used by current process" as follows:CPU currently used:CPU currently used by current process:I would assume, that some of the Linux code also works for the Unixes, except for the parts that read the /proc pseudo-filesystem. Perhaps on Unix these parts can be replaced by getrusage() and similar functions?\nIf someone with Unix know-how could edit this answer and fill in the details?!I was hoping to find similar information for Mac OS X as well. Since it wasn\'t here, I went out and dug it up myself. Here are some of the things I found. If anyone has any other suggestions, I\'d love to hear them.This one is tricky on Mac OS X because it doesn\'t use a preset swap partition or file like Linux. Here\'s an entry from Apple\'s documentation:Note: Unlike most Unix-based operating systems, Mac OS X does not use a preallocated swap partition for virtual memory. Instead, it uses all of the available space on the machine\xe2\x80\x99s boot partition.So, if you want to know how much virtual memory is still available, you need to get the size of the root partition. You can do that like this:Calling systcl with the "vm.swapusage" key provides interesting information about swap usage:Not that the total swap usage displayed here can change if more swap is needed as explained in the section above. So the total is actually the current swap total. In C++, this data can be queried this way:Note that the "xsw_usage", declared in sysctl.h, seems not documented and I suspect there there is a more portable way of accessing these values.You can get statistics about your current process using the task_info function. That includes the current resident size of your process and the current virtual size.The amount of physical RAM available in your system is available using the sysctl system function like this:You can get general memory statistics from the host_statistics system function.One thing to note here are that there are five types of memory pages in Mac OS X. They are as follows:It is good to note that just because Mac OS X may show very little actual free memory at times that it may not be a good indication of how much is ready to be used on short notice.See the "Virtual Memory Currently Used by my Process" above. The same code applies.In Linux, this information is available in the /proc file system.  I\'m not a big fan of the text file format used, as each Linux distribution seems to customize at least one important file.  A quick look as the source to \'ps\' reveals the mess.But here is where to find the information you seek:/proc/meminfo contains the majority of the system-wide information you seek.  Here it looks like on my system; I think you are interested in MemTotal, MemFree, SwapTotal, and SwapFree:For CPU utilization, you have to do a little work.  Linux makes available overall CPU utilization since system start; this probably isn\'t what you are interested in.  If you want to know what the CPU utilization was for the last second, or 10 seconds, then you need to query the information and calculate it yourself.The information is available in /proc/stat, which is documented pretty well at http://www.linuxhowtos.org/System/procstat.htm; here is what it looks like on my 4-core box:First, you need to determine how many CPUs (or processors, or processing cores) are available in the system.  To do this, count the number of \'cpuN\' entries, where N starts at 0 and increments.  Don\'t count the \'cpu\' line, which is a combination of the cpuN lines.  In my example, you can see cpu0 through cpu3, for a total of 4 processors.  From now on, you can ignore cpu0..cpu3, and focus only on the \'cpu\' line.Next, you need to know that the fourth number in these lines is a measure of idle time, and thus the fourth number on the \'cpu\' line is the total idle time for all processors since boot time.  This time is measured in Linux "jiffies", which are 1/100 of a second each. But you don\'t care about the total idle time; you care about the idle time in a given period, e.g., the last second.  Do calculate that, you need to read this file twice, 1 second apart.Then you can do a diff of the fourth value of the line.  For example, if you take a sample and get:Then one second later you get this sample:Subtract the two numbers, and you get a diff of 396, which means that your CPU had been idle for 3.96 seconds out of the last 1.00 second.  The trick, of course, is that you need to divide by the number of processors.  3.96 / 4 = 0.99, and there is your idle percentage; 99% idle, and 1% busy.In my code, I have a ring buffer of 360 entries, and I read this file every second.  That lets me quickly calculate the CPU utilization for 1 second, 10 seconds, etc., all the way up to 1 hour.For the process-specific information, you have to look in /proc/pid; if you don\'t care abut your pid, you can look in /proc/self.CPU used by your process is available in /proc/self/stat.  This is an odd-looking file consisting of a single line; for example:The important data here are the 13th and 14th tokens (0 and 770 here).  The 13th token is the number of jiffies that the process has executed in user mode, and the 14th is the number of jiffies that the process has executed in kernel mode.  Add the two together, and you have its total CPU utilization.Again, you will have to sample this file periodically, and calculate the diff, in order to determine the process\'s CPU usage over time.  Edit:  remember that when you calculate your process\'s CPU utilization, you have to take into account 1) the number of threads in your process, and 2) the number of processors in the system.  For example, if your single-threaded process is using only 25% of the CPU, that could be good or bad.  Good on a single-processor system, but bad on a 4-processor system; this means that your process is running constantly, and using 100% of the CPU cycles available to it.For the process-specific memory information, you ahve to look at /proc/self/status, which looks like this:The entries that start with \'Vm\' are the interesting ones:The only item I\'m not sure about is Swapspace currently used by my process.  I don\'t know if this is available.in windows you can get cpu usage by code bellow:A portable way of reading memory and load numbers is the sysinfo callSince this is like a "wikipage of code" I want to add some code from the QNX Knowledge base (note: this is not my work, but I checked it and it works fine on my system):How to get CPU usage in %: http://www.qnx.com/support/knowledgebase.html?id=50130000000P9b5How to get the free (!) memory: http://www.qnx.com/support/knowledgebase.html?id=50130000000mlbxI used this following code in my C++ project and it worked fine:For Linux\nYou can also use /proc/self/statm to get a single line of numbers containing key process memory information which is a faster thing to process than going through a long list of reported information as you get from proc/self/statusSee http://man7.org/linux/man-pages/man5/proc.5.html