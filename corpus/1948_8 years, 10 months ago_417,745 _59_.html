Is it possible to terminate a running thread without setting/checking any flags/semaphores/etc.?It is generally a bad pattern to kill a thread abruptly, in Python and in any language. Think of the following cases:The nice way of handling this if you can afford it (if you are managing your own threads) is to have an exit_request flag that each threads checks on regular interval to see if it is time for it to exit.For example:In this code, you should call stop() on the thread when you want it to exit, and wait for the thread to exit properly using join(). The thread should check the stop flag at regular intervals.There are cases however when you really need to kill a thread. An example is when you are wrapping an external library that is busy for long calls and you want to interrupt it.The following code allows (with some restrictions) to raise an Exception in a Python thread:As noted in the documentation, this is not a magic bullet because if the thread is busy outside the Python interpreter, it will not catch the interruption.A good usage pattern of this code is to have the thread catch a specific exception and perform the cleanup. That way, you can interrupt a task and still have proper cleanup.There is no official API to do that, no.You need to use platform API to kill the thread, e.g. pthread_kill, or TerminateThread. You can access such API e.g. through pythonwin, or through ctypes.Notice that this is inherently unsafe. It will likely lead to uncollectable garbage (from local variables of the stack frames that become garbage), and may lead to deadlocks, if the thread being killed has the GIL at the point when it is killed.If you are trying to terminate the whole program you can set the thread as a "daemon". see\nThread.daemonA multiprocessing.Process can p.terminate()In the cases where I want to kill a thread, but do not want to use flags/locks/signals/semaphores/events/whatever, I promote the threads to full blown processes. For code that makes use of just a few threads the overhead is not that bad.E.g. this comes in handy to easily terminate helper "threads" which execute blocking I/OThe conversion is trivial: In related code replace all threading.Thread with multiprocessing.Process and all queue.Queue with multiprocessing.Queue and add the required calls of p.terminate() to your parent process which wants to kill its child pPython docYou should never forcibly kill a thread without cooperating with it.Killing a thread removes any guarantees that try/finally blocks set up so you might leave locks locked, files open, etc.The only time you can argue that forcibly killing threads is a good idea is to kill a program fast, but never single threads.This is based on thread2 -- killable threads (Python recipe)You need to call PyThreadState_SetasyncExc(), which is only available through ctypes.This has only been tested on Python 2.7.3, but it is likely to work with other recent 2.x releases.As others have mentioned, the norm is to set a stop flag. For something lightweight (no subclassing of Thread, no global variable), a lambda callback is an option. (Note the parentheses in if stop().)Replacing print() with a pr() function that always flushes (sys.stdout.flush()) may improve the precision of the shell output.(Only tested on Windows/Eclipse/Python3.3)In Python, you simply cannot kill a Thread directly.If you do NOT really need to have a Thread (!), what you can do, instead of using the threading package , is to use the \nmultiprocessing package . Here, to kill a process, you can simply call the method:Python will kill your process (on Unix through the SIGTERM signal, while on Windows through the TerminateProcess() call). Pay attention to use it while using a Queue or a Pipe! (it may corrupt the data in the Queue/Pipe)Note that the multiprocessing.Event and the multiprocessing.Semaphore work exactly in the same way of the threading.Event and the threading.Semaphore respectively. In fact, the first ones are clones of the latters.If you REALLY need to use a Thread, there is no way to kill it directly. What you can do, however, is to use a "daemon thread". In fact, in Python, a Thread can be flagged as daemon:The main program will exit when no alive non-daemon threads are left. In other words, when your main thread (which is, of course, a non-daemon thread) will finish its operations, the program will exit even if there are still some daemon threads working.Note that it is necessary to set a Thread as daemon before the start() method is called!Of course you can, and should, use daemon even with multiprocessing. Here, when the main process exits, it attempts to terminate all of its daemonic child processes.Finally, please, note that sys.exit() and os.kill() are not choices.You can kill a thread by installing trace into the thread that will exit the thread.   See attached link for one possible implementation.Kill a thread in Python It is better if you don\'t kill a thread.\nA way could be to introduce a "try" block into the thread\'s cycle and to throw an exception when you want to stop the thread (for example a break/return/... that stops your for/while/...). \nI\'ve used this on my app and it works...It is definitely possible to implement a Thread.stop method as shown in the following example code:The Thread3 class appears to run code approximately 33% faster than the Thread2 class.t is your Thread object.Read the python source (Modules/threadmodule.c and Python/thread_pthread.h) you can see the Thread.ident is an pthread_t type, so you can do anything pthread can do in python use libpthread.One thing I want to add is that if you read official documentation in threading lib Python, it\'s recommended to avoid use of "demonic" threads, when you don\'t want threads end abruptly, with the flag that Paolo Rovelli mentioned.From official documentation:Daemon threads are abruptly stopped at shutdown. Their resources (such as open files, database transactions, etc.) may not be released properly. If you want your threads to stop gracefully, make them non-daemonic and use a suitable signaling mechanism such as an Event.I think that creating daemonic threads depends of your application, but in general (and in my opinion) it\'s better to avoid killing them or making them daemonic. In multiprocessing you can use is_alive() to check process status  and "terminate" for finish them (Also you avoid GIL problems). But you can find more problems, sometimes, when you execute your code in Windows.And always remember that if you have "live threads", the Python interpreter will be running for wait them. (Because of this daemonic can help you if don\'t matter abruptly ends).This is a bad answer, see the commentsHere\'s how to do it:Give it a few seconds then your thread should be stopped. Check also the thread._Thread__delete() method.I\'d recommend a thread.quit() method for convenience. For example if you have a socket in your thread, I\'d recommend creating a quit() method in your socket-handle class, terminate the socket, then run a thread._Thread__stop() inside of your quit().This seems to work with pywin32 on windows 7Start the sub thread with setDaemon(True).I think this is a pretty neat solution: http://code.activestate.com/recipes/496960-thread2-killable-threads/It allows a "thread to raise exceptions in the context of another thread". In this way, the terminated thread can handle the termination without regularly checking an abbort flag.If you really need the ability to kill a sub-task, use an alternate implementation. multiprocessing and gevent both support indiscriminately killing a "thread".Python\'s threading does not support cancellation. Do not even try. Your code is very likely to deadlock, corrupt or leak memory, or have other unintended "interesting" hard-to-debug effects which happen rarely and nondeterministically.You can execute your command in a process and then kill it using the process id.\nI needed to sync between two thread one of which  doesn\xe2\x80\x99t return by itself.