All I know about TypeTags is that they somehow replaced Manifests. Information on the Internet is scarce and doesn\'t provide me with a good sense of the subject.So I\'d be happy if someone shared a link to some useful materials on TypeTags including examples and popular use-cases. Detailed answers and explanations are also welcome.A TypeTag solves the problem that Scala\'s types are erased at runtime (type erasure). If we wanna dowe will get warnings:To solve this problem Manifests were introduced to Scala. But they have the problem not being able to represent a lot of useful types, like path-dependent-types:Thus, they are replaced by TypeTags, which are both much simpler to use and well integrated into the new Reflection API. With them we can solve the problem above about path-dependent-types elegantly:They are also easy to use to check type parameters:At this point, it is extremely important to understand to use =:= (type equality) and <:< (subtype relation) for equality checks. Do never use == or !=, unless you absolutely know what you do:The latter checks for structural equality, which often is not what should be done because it doesn\'t care about things such as prefixes (like in the example).A TypeTag is completely compiler-generated, that means that the compiler creates and fills in a TypeTag when one calls a method expecting such a TypeTag. There exist three different forms of tags:ClassTag substitutes ClassManifest whereas TypeTag is more or less the replacement for Manifest.The former allows to fully work with generic arrays:ClassTag provides only the information needed to create types at runtime (which are type erased):As one can see above, they don\'t care about type erasure, therefore if one wants "full" types TypeTag should be used:As one can see, method tpe of TypeTag results in a full Type, which is the same we get when typeOf is called. Of course, it is possible to use both, ClassTag and TypeTag:The remaining question now is what is the sense of WeakTypeTag ? In short, TypeTag represents a concrete type (this means it only allows fully instantiated types) whereas WeakTypeTag just allows any type. Most of the time one does not care which is what (which means TypeTag should be used), but for example, when macros are used which should work with generic types they are needed:If one replaces WeakTypeTag with TypeTag an error is thrown:For a more detailed explanation about the differences between TypeTag and WeakTypeTag see this question: Scala Macros: \xe2\x80\x9ccannot create TypeTag from a type T having unresolved type parameters\xe2\x80\x9dThe official documentation site of Scala also contains a guide for Reflection.