I have come up against this problem a few times at inopportune moments:Why does this limit exist? Why hasn\'t it been removed yet?  How do you cope with the path limit? ... and no, switching to linux or Mac OS X is not a valid answer to this question ;)Quoting this article http://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx#maxpathMaximum Path Length LimitationIn the Windows API (with some exceptions discussed in the following paragraphs), the maximum length for a path is MAX_PATH, which is defined as 260 characters. A local path is structured in the following order: drive letter, colon, backslash, name components separated by backslashes, and a terminating null character. For example, the maximum path on drive D is "D:\\some 256-character path string<NUL>" where "<NUL>" represents the invisible terminating null character for the current system codepage. (The characters < > are used here for visual clarity and cannot be part of a valid path string.)Now we see that it is 1+2+256+1 or [drive][:\\][path][null] = 260. One could assume that 256 is a reasonable fixed string length from the DOS days. And going back to the DOS APIs we realize that the system tracked the current path per drive, and we have 26 (32 with symbols) maximum drives (and current directories).The INT 0x21 AH=0x47 says \xe2\x80\x9cThis function returns the path description without the drive letter and the initial backslash.\xe2\x80\x9d So we see that the system stores the CWD as a pair (drive, path) and you ask for the path by specifying the drive (1=A, 2=B, \xe2\x80\xa6), if you specify a 0 then it assumes the path for the drive returned by INT 0x21 AH=0x15 AL=0x19. So now we know why it is 260 and not 256, because those 4 bytes are not stored in the path string.Why a 256 byte path string, because 640K is enough RAM.This is not strictly true as the NTFS filesystem supports paths up to 32k characters. You can use the win32 api and "\\\\?\\" prefix the path to use greater than 260 characters.  A detailed explanation of long path from the .Net BCL team blog.\nA small excerpt highlights the issue with long pathsAnother concern is inconsistent behavior that would result by exposing long path support. Long paths with the \\\\?\\ prefix can be used in most of the file-related Windows APIs, but not all Windows APIs. For example, LoadLibrary, which maps a module into the address of the calling process, fails if the file name is longer than MAX_PATH. So this means MoveFile will let you move a DLL to a location such that its path is longer than 260 characters, but when you try to load the DLL, it would fail. There are similar examples throughout the Windows APIs; some workarounds exist, but they are on a case-by-case basis.The question is why does the limitation still exist. Surely modern Windows can increase the side of MAX_PATH to allow longer paths.  Why has the limitation not been removed?Through API contract, Windows has guaranteed all applications that the standard file APIs will never return a path longer than 260 characters.Consider the following correct code:Windows guaranteed my program that it would populate my WIN32_FIND_DATA structure:My application didn\'t declare the value of the constant MAX_PATH, the Windows API did. My application used that defined value.My structure is correctly defined, and only allocates 592 bytes total. That means that i am only able to receive a filename that is less than 260 characters. Windows promised me that if i wrote my application correctly, my application would continue to work in the future. If Windows were to allow filenames longer than 260 characters then my existing application (which used the correct API correctly) would fail.For anyone calling for Microsoft to change the MAX_PATH constant, they first need to ensure that no existing application fails. For example, i still own and use a Windows application that was written to run on Windows 3.11. It still runs on 64-bit Windows 10. That is what backwards compatibility gets you.Microsoft did create a way to use the full 32,768 path names; but they had to create a new API contract to do it. For one, you should use the Shell API to enumerate files (as not all files exist on a hard drive or network share).But they also have to not break existing user applications. The vast majority of applications do not use the shell api for file work. Everyone just calls FindFirstFile/FindNextFile and calls it a day.You can mount a folder as a drive. From the command line, if you have a path C:\\path\\to\\long\\folder you can map it to drive letter X: using:From Windows 10. you can remove the limitation by modifying a registry key.Tip  Starting in Windows 10, version 1607, MAX_PATH limitations have been removed from common Win32 file and directory functions. However, you must opt-in to the new behavior.A registry key allows you to enable or disable the new long path behavior. To enable long path behavior set the registry key at HKLM\\SYSTEM\\CurrentControlSet\\Control\\FileSystem LongPathsEnabled (Type: REG_DWORD). The key\'s value will be cached by the system (per process) after the first call to an affected Win32 file or directory function (list follows). The registry key will not be reloaded during the lifetime of the process. In order for all apps on the system to recognize the value of the key, a reboot might be required because some processes may have started before the key was set.\n  The registry key can also be controlled via Group Policy at Computer Configuration > Administrative Templates > System > Filesystem > Enable NTFS long paths.\n  You can also enable the new long path behavior per app via the manifest:One way to cope with the path limit is to shorten path entries with symbolic links.For example:As to why this still exists - MS doesn\'t consider it a priority, and values backwards compatibility over advancing their OS (at least in this instance).A workaround I use is to use the "short names" for the directories in the path, instead of their standard, human-readable versions. So e.g. for C:\\Program Files\\ I would use C:\\PROGRA~1\\  You can find the short name equivalents using dir /x.As to how to cope with the path size limitation on Windows - using 7zip to pack (and unpack) your path-length sensitive files seems like a viable workaround. I\'ve used it to transport several IDE installations (those Eclipse plugin paths, yikes!) and piles of autogenerated documentation and haven\'t had a single problem so far. Not really sure how it evades the 260 char limit set by Windows (from a technical PoV), but hey, it works! More details on their SourceForge page here: "NTFS can actually support pathnames up to 32,000 characters in\n  length."7-zip also support such long names.But it\'s disabled in SFX code. Some users don\'t like long paths, since\n  they don\'t understand how to work with them. That is why I have\n  disabled it in SFX code.and release notes:IMPORTANT NOTE: For this to work properly, you\'ll need to specify the destination path in the 7zip "Extract" dialog directly, rather than dragging & dropping the files into the intended folder. Otherwise the "Temp" folder will be used as an interim cache and you\'ll bounce into the same 260 char limitation once Windows Explorer starts moving the files to their "final resting place". See the replies to this question for more information.