Use of java.net.URLConnection is asked about pretty often here, and the Oracle tutorial is too concise about it. That tutorial basically only shows how to fire a GET request and read the response. It doesn\'t explain anywhere how to use it to among others perform a POST request, set request headers, read response headers, deal with cookies, submit a HTML form, upload a file, etc. So, how can I use java.net.URLConnection to fire and handle "advanced" HTTP requests?First a disclaimer beforehand: the posted code snippets are all basic examples. You\'ll need to handle trivial IOExceptions and RuntimeExceptions like NullPointerException, ArrayIndexOutOfBoundsException and consorts yourself.We first need to know at least the URL and the charset. The parameters are optional and depend on the functional requirements.The query parameters must be in name=value format and be concatenated by &. You would normally also URL-encode the query parameters with the specified charset using URLEncoder#encode().The String#format() is just for convenience. I prefer it when I would need the String concatenation operator + more than twice.It\'s a trivial task. It\'s the default request method.Any query string should be concatenated to the URL using ?. The Accept-Charset header may hint the server what encoding the parameters are in. If you don\'t send any query string, then you can leave the Accept-Charset header away. If you don\'t need to set any headers, then you can even use the URL#openStream() shortcut method.Either way, if the other side is a HttpServlet, then its doGet() method will be called and the parameters will be available by HttpServletRequest#getParameter().For testing purposes, you can print the response body to stdout as below:Setting the URLConnection#setDoOutput() to true implicitly sets the request method to POST. The standard HTTP POST as web forms do is of type application/x-www-form-urlencoded wherein the query string is written to the request body.Note: whenever you\'d like to submit a HTML form programmatically, don\'t forget to take the name=value pairs of any <input type="hidden"> elements into the query string and of course also the name=value pair of the <input type="submit"> element which you\'d like to "press" programmatically (because that\'s usually been used in the server side to distinguish if a button was pressed and if so, which one).You can also cast the obtained URLConnection to HttpURLConnection and use its HttpURLConnection#setRequestMethod() instead. But if you\'re trying to use the connection for output you still need to set URLConnection#setDoOutput() to true.Either way, if the other side is a HttpServlet, then its doPost() method will be called and the parameters will be available by HttpServletRequest#getParameter().You can fire the HTTP request explicitly with URLConnection#connect(), but the request will automatically be fired on demand when you want to get any information about the HTTP response, such as the response body using URLConnection#getInputStream() and so on. The above examples does exactly that, so the connect() call is in fact superfluous.HTTP response status:You need a HttpURLConnection here. Cast it first if necessary.HTTP response headers:HTTP response encoding:When the Content-Type contains a charset parameter, then the response body is likely text based and we\'d like to process the response body with the server-side specified character encoding then.The server side session is usually backed by a cookie. Some web forms require that you\'re logged in and/or are tracked by a session. You can use the CookieHandler API to maintain cookies. You need to prepare a CookieManager with a CookiePolicy of ACCEPT_ALL before sending all HTTP requests.Note that this is known to not always work properly in all circumstances. If it fails for you, then best is to manually gather and set the cookie headers. You basically need to grab all Set-Cookie headers from the response of the login or the first GET request and then pass this through the subsequent requests.The split(";", 2)[0] is there to get rid of cookie attributes which are irrelevant for the server side like expires, path, etc. Alternatively, you could also use cookie.substring(0, cookie.indexOf(\';\')) instead of split().The HttpURLConnection will by default buffer the entire request body before actually sending it, regardless of whether you\'ve set a fixed content length yourself using connection.setRequestProperty("Content-Length", contentLength);. This may cause OutOfMemoryExceptions whenever you concurrently send large POST requests (e.g. uploading files). To avoid this, you would like to set the HttpURLConnection#setFixedLengthStreamingMode().But if the content length is really not known beforehand, then you can make use of chunked streaming mode by setting the HttpURLConnection#setChunkedStreamingMode() accordingly. This will set the HTTP Transfer-Encoding header to chunked which will force the request body being sent in chunks. The below example will send the body in chunks of 1KB.It can happen that a request returns an unexpected response, while it works fine with a real web browser. The server side is probably blocking requests based on the User-Agent request header. The URLConnection will by default set it to Java/1.6.0_19 where the last part is obviously the JRE version. You can override this as follows:Use the User-Agent string from a recent browser.If the HTTP response code is 4nn (Client Error) or 5nn (Server Error), then you may want to read the HttpURLConnection#getErrorStream() to see if the server has sent any useful error information.If the HTTP response code is -1, then something went wrong with connection and response handling. The HttpURLConnection implementation is in older JREs somewhat buggy with keeping connections alive. You may want to turn it off by setting the http.keepAlive system property to false. You can do this programmatically in the beginning of your application by:You\'d normally use multipart/form-data encoding for mixed POST content (binary and character data). The encoding is in more detail described in RFC2388.If the other side is a HttpServlet, then its doPost() method will be called and the parts will be available by HttpServletRequest#getPart() (note, thus not getParameter() and so on!). The getPart() method is however relatively new, it\'s introduced in Servlet 3.0 (Glassfish 3, Tomcat 7, etc). Prior to Servlet 3.0, your best choice is using Apache Commons FileUpload to parse a multipart/form-data request. Also see this answer for examples of both the FileUpload and the Servelt 3.0 approaches.Sometimes you need to connect a HTTPS URL, perhaps because you\'re writing a web scraper. In that case, you may likely face a javax.net.ssl.SSLException: Not trusted server certificate on some HTTPS sites who doesn\'t keep their SSL certificates up to date, or a java.security.cert.CertificateException: No subject alternative DNS name matching [hostname] found or javax.net.ssl.SSLProtocolException: handshake alert: unrecognized_name on some misconfigured HTTPS sites.The following one-time-run static initializer in your web scraper class should make HttpsURLConnection more lenient as to those HTTPS sites and thus not throw those exceptions anymore.The Apache HttpComponents HttpClient is much more convenient in this all :)If all you want is parsing and extracting data from HTML, then better use a HTML parser like JsoupWhen working with HTTP it\'s almost always more useful to refer to HttpURLConnection rather than the base class URLConnection (since URLConnection is an abstract class when you ask for URLConnection.openConnection() on a HTTP URL that\'s what you\'ll get back anyway).Then you can instead of relying on URLConnection#setDoOutput(true) to implicitly set the request method to POST instead do httpURLConnection.setRequestMethod("POST") which some might find more natural (and which also allows you to specify other request methods such as PUT, DELETE, ...).It also provides useful HTTP constants so you can do:Inspired by this and other questions on SO, I\'ve created a minimal open source basic-http-client that embodies most of the techniques found here.google-http-java-client is also a great open source resource.There are 2 options you can go with HTTP URL Hits : GET / POSTGET Request :-POST request :-I suggest you take a look at the code on kevinsawicki/http-request, its basically a wrapper on top of HttpUrlConnection it provides a much simpler API in case you just want to make the requests right now or you can take a look at the sources (it\'s not too big) to take a look at how connections are handled.Example: Make a GET request with content type application/json and some query parameters:I was also very inspired by this response.I am often on projects where I need to do some HTTP, and I may not want to bring in a lot of 3rd party dependencies (which bring in others and so on and so on, etc.)I started to write my own utilities based on some of this conversation (not any where done):Then there are just a bunch or static methods.Then post...Well you get the idea....Here are the tests:You can find the rest here:https://github.com/RichardHightower/boonMy goal is to provide the common things one would want to do in a bit more easier way then....Initially I was misled by this article which favours HttpClient. Later I have been realized that HttpURLConnection is going to stay from this articleAs per the Google blog:Apache HTTP client has fewer bugs on Eclair and Froyo. It is the best choice for these releases. For Gingerbread , HttpURLConnection is the best choice. Its simple API and small size makes it great fit for Android.Transparent compression and response caching reduce network use, improve speed and save battery. New applications should use HttpURLConnection; it is where we will be spending our energy going forward.After reading this article and some other stack over flow questions, I am convinced that HttpURLConnection is going to stay for longer durations.Some of the SE questions favouring HttpURLConnections:On Android, make a POST request with URL Encoded Form data without using UrlEncodedFormEntityHttpPost works in Java project, not in AndroidYou can also use JdkRequest from jcabi-http (I\'m a developer), which does all this work for you, decorating HttpURLConnection, firing HTTP requests and parsing responses, for example:Check this blog post for more info: http://www.yegor256.com/2014/04/11/jcabi-http-intro.htmlThere is also OkHttp, which is an HTTP client that\xe2\x80\x99s efficient by default:First create an instance of OkHttpClient:Then, prepare your GET request:finally, use OkHttpClient to send prepared Request:For more details, you can consult the OkHttp\'s documentationIn Java 9, you can send a GET request like:Then you can examine the returned HttpResponse:Since this new HTTP Client is in java.httpclient module, you should declare this dependency in your module-info.java file:if you are using http get please remove this line\n urlConnection.setDoOutput(true);