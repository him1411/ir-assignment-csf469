Note: this appears to have been fixed in RoslynThis question arose when writing my answer to this one, which talks about the associativity of the null-coalescing operator.Just as a reminder, the idea of the null-coalescing operator is that an expression of the formfirst evaluates x, then:Now usually there\'s no need for a conversion, or it\'s just from a nullable type to a non-nullable one - usually the types are the same, or just from (say) int? to int. However, you can create your own implicit conversion operators, and those are used where necessary.For the simple case of x ?? y, I haven\'t seen any odd behaviour. However, with (x ?? y) ?? z I see some confusing behaviour.Here\'s a short but complete test program - the results are in the comments:So we have three custom value types, A, B and C, with conversions from A to B, A to C, and B to C.I can understand both the second case and the third case... but why is there an extra A to B conversion in the first case? In particular, I\'d really have expected the first case and second case to be the same thing - it\'s just extracting an expression into a local variable, after all.Any takers on what\'s going on? I\'m extremely hesistant to cry "bug" when it comes to the C# compiler, but I\'m stumped as to what\'s going on...EDIT: Okay, here\'s a nastier example of what\'s going on, thanks to configurator\'s answer, which gives me further reason to think it\'s a bug. EDIT: The sample doesn\'t even need two null-coalescing operators now...The output of this is:The fact that Foo() gets called twice here is hugely surprising to me - I can\'t see any reason for the expression to be evaluated twice.Thanks to everyone who contributed to analyzing this issue. It is clearly a compiler bug. It appears to only happen when there is a lifted conversion involving two nullable types on the left-hand side of the coalescing operator.I have not yet identified where precisely things go wrong, but at some point during the "nullable lowering" phase of compilation -- after initial analysis but before code generation -- we reduce the expressionfrom the example above to the moral equivalent of:Clearly that is incorrect; the correct lowering isMy best guess based on my analysis so far is that the nullable optimizer is going off the rails here. We have a nullable optimizer that looks for situations where we know that a particular expression of nullable type cannot possibly be null. Consider the following naive analysis: we might first say that is the same asand then we might say thatis the same asBut the optimizer can step in and say "whoa, wait a minute, we already checked that temp is not null; there\'s no need to check it for null a second time just because we are calling a lifted conversion operator".  We\'d them optimize it away to justMy guess is that we are somewhere caching the fact that the optimized form of (int?)Foo() is new int?(op_implicit(Foo().Value)) but that is not actually the optimized form we want; we want the optimized form of Foo()-replaced-with-temporary-and-then-converted.Many bugs in the C# compiler are a result of bad caching decisions. A word to the wise: every time you cache a fact for use later, you are potentially creating an inconsistency should something relevant change. In this case the relevant thing that has changed post initial analysis is that the call to Foo() should always be realized as a fetch of a temporary.We did a lot of reorganization of the nullable rewriting pass in C# 3.0. The bug reproduces in C# 3.0 and 4.0 but not in C# 2.0, which means that the bug was probably my bad. Sorry!I\'ll get a bug entered into the database and we\'ll see if we can get this fixed up for a future version of the language. Thanks again everyone for your analysis; it was very helpful!UPDATE: I rewrote the nullable optimizer from scratch for Roslyn; it now does a better job and avoids these sorts of weird errors. For some thoughts on how the optimizer in Roslyn works, see my series of articles which begins here: https://ericlippert.com/2012/12/20/nullable-micro-optimizations-part-one/This is most definitely a bug.This code will output:That made me think that the first part of each ?? coalesce expression is evaluated twice.\nThis code proved it:outputs:This seems to happen only when the expression requires a conversion between two nullable types; I\'ve tried various permutations with one of the sides being a string, and none of them caused this behaviour.If you take a look at the generated code for the Left-grouped case it actually does something like this (csc /optimize-):Another find, if you use first it will generate a shortcut if both a and b are null and return c. Yet if a or b is non-null it re-evaluates a as part of the implicit conversion to B before returning which of a or b is non-null.From the C# 4.0 Specification, \xc2\xa76.1.4:This appears to explain the second unwrapping-wrapping combination.The C# 2008 and 2010 compiler produce very similar code, however this looks like a regression from the C# 2005 compiler (8.00.50727.4927) which generates the following code for the above:I wonder if this is not due to the additional magic given to the type inference system?Actually, I\'ll call this a bug now, with the clearer example.  This still holds, but the double-evaluation is certainly not good.It seems as though A ?? B is implemented as A.HasValue ? A : B. In this case, there\'s a lot of casting too (following the regular casting for the ternary ?: operator).  But if you ignore all that, then this makes sense based on how it\'s implemented:Here you can see that x.HasValue is checked twice, and if x ?? y requires casting, x will be cast twice.I\'d put it down simply as an artifact of how ?? is implemented, rather than a compiler bug.    Take-Away: Don\'t create implicit casting operators with side effects. It seems to be a compiler bug revolving around how ?? is implemented.  Take-away: don\'t nest coalescing expressions with side-effects.I am not a C# expert at all as you can see from my question history, but, I tried this out and I think it is a bug.... but as a newbie, I have to say that I do not understand everything going on here so I will delete my answer if I am way off.I have come to this bug conclusion by making a different version of your program which deals with the same scenario, but much less complicated.I am using three null integer properties with backing stores. I set each to 4 and then run int? something2 = (A ?? B) ?? C;(Full code here)This just reads the A and nothing else.This statement to me looks like to me it should:So, as A is not null, it only looks at A and finishes.In your example, putting a breakpoint at the First Case shows that x, y and z are all not null and therefore, I would expect them to be treated the same as my less complex example.... but I fear I am too much of a C# newbie and have missed the point of this question completely!