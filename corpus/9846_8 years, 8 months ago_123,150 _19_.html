I have a UIImage (Cocoa Touch). From that, I\'m happy to get a CGImage or anything else you\'d like that\'s available. I\'d like to write this function:Thanks! FYI, I combined Keremk\'s answer with my original outline, cleaned-up the typos, generalized it to return an array of colors and got the whole thing to compile.  Here is the result:One way of doing it is to draw the image to a bitmap context that is backed by a given buffer for a given colorspace (in this case it is RGB): (note that this will copy the image data to that buffer, so you do want to cache it instead of doing this operation every time you need to get pixel values)See below as a sample:Apple\'s Technical Q&A QA1509 shows the following simple approach: Use CFDataGetBytePtr to get to the actual bytes (and various CGImageGet* methods to understand how to interpret them).Here is a SO thread where @Matt renders only the desired pixel into a 1x1 context by displacing the image so that the desired pixel aligns with the one pixel in the context.According the the Apple Reference on UIImage the object is immutable and you have no access to the backing bytes. While it is true that you can access the CGImage data if you populated the UIImage with a CGImage (explicitly or implicitly), it will return NULL if the UIImage is backed by a CIImage and vice-versa.Image objects not provide direct access to their underlying image\n  data. However, you can retrieve the image data in other formats for\n  use in your app. Specifically, you can use the cgImage and ciImage\n  properties to retrieve versions of the image that are compatible with\n  Core Graphics and Core Image, respectively. You can also use the\n  UIImagePNGRepresentation(:) and UIImageJPEGRepresentation(:_:)\n  functions to generate an NSData object containing the image data in\n  either the PNG or JPEG format.As stated your options areNeither of these are particularly good tricks if you want output that isn\'t ARGB, PNG, or JPEG data and the data isn\'t already backed by CIImage.While developing your project it might make more sense for you to avoid UIImage altogether and pick something else. UIImage, as a Obj-C image wrapper, is often backed by CGImage to the point where we take it for granted. CIImage tends to be a better wrapper format in that you can use a CIContext to get out the format you desire without needing to know how it was created. In your case, getting the bitmap would be a matter of calling - render:toBitmap:rowBytes:bounds:format:colorSpace:As an added bonus you can start doing nice manipulations to the image by chaining filters onto the image. This solves a lot of the issues where the image is upside down or needs to be rotated/scaled etc.Building on Olie and Algal\'s answer, here is an updated answer for Swift 3 swiftBased on different answers but mainly on this, this works for what I need:As a result of this lines, you will have a pixel in AARRGGBB format with alpha always set to FF in the 4 byte unsigned integer pixel1.