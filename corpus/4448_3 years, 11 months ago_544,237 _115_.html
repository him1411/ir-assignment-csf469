Could anyone tell me why the following statement does not send the post data to the designated url? The url is called but on the server when I print $_POST - I get an empty array. If I print message in the console before adding it to the data - it shows the correct content.I\'ve also tried it with the data as string (with the same outcome):It seem to be working when I use it in the following format:but is there a way of doing it with the $http.post() - and do I always have to include the header in order for it to work? I believe that the above content type is specifying format of the sent data, but can I send it as javascript object?I had the same problem using asp.net MVC and found the solution hereThere is much confusion among newcomers to AngularJS as to why the\n  $http service shorthand functions ($http.post(), etc.) don\xe2\x80\x99t appear to\n  be swappable with the jQuery equivalents (jQuery.post(), etc.)The difference is in how jQuery and AngularJS serialize and transmit the data. Fundamentally, the problem lies with your server language of choice being unable to understand AngularJS\xe2\x80\x99s transmission natively ... By default, jQuery transmits data using and the familiar foo=bar&baz=moe serialization.AngularJS, however, transmits data using and { "foo": "bar", "baz": "moe" }JSON serialization, which unfortunately some Web server languages\xe2\x80\x94notably\n   PHP\xe2\x80\x94do not unserialize natively.Works like a charm.CODEIt\'s not super clear above, but if you are receiving the request in PHP you can use:$params = json_decode(file_get_contents(\'php://input\'),true);To access an array in PHP from an AngularJS POST.You can set the default "Content-Type" like this:About the data format:The $http.post and $http.put methods accept any JavaScript object (or a string) value as their data parameter. If data is a JavaScript object it will be, by default, converted to a JSON string.Try to use this variationI have had a similar issue, and I wonder if this can be useful as well: https://stackoverflow.com/a/11443066Regards,I like to use a function to convert objects to post params.This has finally been addressed in angular 1.4 using $httpParamSerializerJQLikeSee https://github.com/angular/angular.js/issues/6039I use jQuery param with AngularJS post requrest. Here is a example ... create AngularJS application module, where myapp is defined with ng-app in your HTML code.Now let us create a Login controller and POST email and password.I don\'t like to exaplain the code, it is simple enough to understand :) Note that param is from jQuery, so you must install both jQuery and AngularJS to make it working. Here is a screenshot.Hope this is helpful. Thanks!Unlike JQuery and for the sake of pedantry, Angular uses JSON format for POST \ndata transfer from a client to the server (JQuery applies x-www-form-urlencoded presumably, although JQuery and Angular uses JSON for data imput). Therefore there are two parts of problem: in js client part and in your server part. So you need:put js Angular client part like this:ANDwrite in your server part to receive data from a client (if it is php).Note: $_POST will not work!The solution works for me fine, hopefully, and for you.I had the same problem with AngularJS and Node.js + Express 4 + RouterRouter expects the data from post\'s request in body. This body was always empty if i followed the example from Angular Docs Notation 1But if i used it in the dataNotation 2 Edit 1:Otherwise node.js router will expect the data in req.body if used notation 1:Which also sends the information as JSON payload. This is better in some cases where you have arrays in your json and x-www-form-urlencoded will give some problems.it worked. Hope it helps.To build on @felipe-miosso\'s answer: Add it to your application:To send data via Post methode with $http of angularjs you need to change data: "message=" + message, with  data: $.param({message:message})This code solved the issue for me. It is an application-level solution:I don\'t have the reputation to comment, but in response/addition to Don F\'s answer:$params = json_decode(file_get_contents(\'php://input\'));A second parameter of true needs to be added to the json_decode function in order to properly return an associative array:$params = json_decode(file_get_contents(\'php://input\'), true);AngularWebAPI 2Add this in your js file:and add this to your server file:That should work.this is probably a late answer but i think the most proper way is to use the same piece of code angular use when doing a "get" request using you $httpParamSerializer will have to inject it to your controller \nso you can simply do the following without having to use Jquery at all ,\n$http.post(url,$httpParamSerializer({param:val}))I know has accepted answer. But, following might help to future readers, if the answer doesn\'t suit them for any reason.Angular doesn\'t do ajax same as jQuery. While I tried to follow the guide to modify angular $httpprovider , I encountered other problems. E.g. I use codeigniter in which $this->input->is_ajax_request() function always failed (which was written by another programmer and used globally, so cant change) saying this was not real ajax request.To solve it, I took help of deferred promise.  I tested it in Firefox, and ie9 and it worked.I have following function defined outside any of the angular code. This function makes regular jquery ajax call and returns deferred/promise (I\'m still learning) object.Then I\'m calling it angular code using the following code. Please note that we have to update the $scope manually using $scope.$apply() .This may not be the perfect answer, but it allowed me to use jquery ajax calls with angular and allowed me to update the $scope.I also faced similar problem and i was doing something like this and that didn\'t worked. My Spring controller was not able read data parameter.But reading this forum and API Doc, I tried following  way and that worked for me.\nIf some one also have similar problem, You can try below way as well.Please check https://docs.angularjs.org/api/ng/service/$http#post  for what param config does.\n{data:\'"id":"1"\'} \xe2\x80\x93 Map of strings or objects which will be turned to URL?data="id:1" I am using asp.net WCF webservices with angular js and below code\n  worked:Hope it helps.Didn\'t find a complete code snippet of how to use $http.post method to send data to the server and why it was not working in this case.Explanations of below code snippet...Setting the Content-Type in the config variable that will be passed along with the request of angularJS $http.post that instruct the server that we are sending data in www post format.Notice the $htttp.post method, where I am sending 1st parameter as url,  2nd parameter as data (serialized) and 3rd parameter as config.Remaining code is self understood.Look at the code example of $http.post method here.If using Angular >= 1.4, here\'s the cleanest solution using the serializer provided by Angular:And then you can simply do this anywhere in your app:And it will correctly serialize the data as param1=value1&param2=value2 and send it to /requesturl with the application/x-www-form-urlencoded; charset=utf-8 Content-Type header as it\'s normally expected with POST requests on endpoints.TL;DRDuring my research I found that the answer to this problem comes in many different flavors; some are very convoluted and depend on custom functions, some depend on jQuery and and some are incomplete in suggesting that you only need to set the header.If you just set the Content-Type header, the end point will see the POST data, but it won\'t be in the standard format because unless you provide a string as your data, or manually serialize your data object, it will all be serialized as JSON by default and may be incorrectly interpreted at the endpoint.e.g. if the correct serializer was not set in the above example, it would be seen in the endpoint as:And that can lead to unexpected parsing, e.g. ASP.NET treats it as a null parameter name, with {"param1":"value1","param2":"value2"} as value; or Fiddler interprets it the other way, with {"param1":"value1","param2":"value2"} as the parameter name, and null as the value.When I had this problem the parameter I was posting turned out to be an array of objects instead of a simple object.I had the same problem in express .. to resolve you have to use bodyparser to parse json objects before sending http requests .. Just updated from angular 1.2 to 1.3, have found a problem in the code. Transforming a resource will lead to an endless-loop because (I think) of the $promise holding again the same object. Maybe it will help someone...I could fix that by:I\'ve been using the accepted answer\'s code (Felipe\'s code) for a while and it\'s been working great (thanks, Felipe!).However, recently I discovered that it has issues with empty objects or arrays.\nFor example, when submitting this object:PHP doesn\'t seem to see B and C at all. It gets this:A look at the actual request in Chrome shows this:I wrote an alternative code snippet. It seems to work well with my use-cases but I haven\'t tested it extensively so use with caution.I used TypeScript because I like strong typing but it would be easy to convert to pure JS:It\'s less efficient than Felipe\'s code but I don\'t think it matters much since it should be immediate compared to the overall overhead of the HTTP request itself.Now PHP shows:As far as I know it\'s not possible to get PHP to recognize that B.a and C are empty arrays, but at least the keys appear, which is important when there\'s code that relies on the a certain structure even when its essentially empty inside.Also note that it converts undefineds and nulls to empty strings.If your using PHP this is a easy way to access an array in PHP from an AngularJS POST.In my case I resolve the problem like this :You need to use JSON.stringify for each param containing a JSON object, and then build your data object with "$.param" :-)NB : My "objJSON" is a JSON object containing array, integer, string and html content. His total size is >3500 characters.I solved this by below codes:Client Side (Js):notice that data is an object.On the server (ASP.NET MVC):and \'AllowCrossSiteJsonAttribute\' is needed for cross domain requests:Hope this was useful.It\'s not angular\'s fault. Angular is designed to work in JSON world. So when $http service send AJAX request, it send all your data as a payload, not as form-data so that your backend application can handle it. But jQuery does some things internally. You instruct jQuery\'s $ajax module to bind form-data as JSON but before sending AJAX request, it serialized JSON and add application/x-www-form-urlencoded header. This way your backend application able to received form-data in form of post parameters and not JSON.But you can modify angular $http service\'s default behavior by$httpParamSerializerJQLike is angular\'s in-built service which serializes json in the same way $.param does of jQuery.If you need a plugin to serialize form-data into JSON first, use this one https://github.com/marioizquierdo/jquery.serializeJSONSimilar to the OP\'s suggested working format & Denison\'s answer, except using $http.post instead of just $http and is still dependent on jQuery.The good thing about using jQuery here is that complex objects get passed properly; against manually converting into URL parameters which may garble the data.