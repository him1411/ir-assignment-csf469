I\'m currently involved in developing a product (developed in C#) that\'ll be available for downloading and installing for free but in a very limited version. To get access to all the features the user has to pay a license fee and receive a key. That key will then be entered into the application to "unlock" the full version.As using a license key like that is kind of usual I\'m wondering :  I guess I should also tie the key to the version of application somehow so it\'ll be possible to charge for new keys in feature versions.Anything else I should think about in this scenario?Caveat: you can\'t prevent users from pirating, but only make it easier for honest users to do the right thing.Assuming you don\'t want to do a special build for each user, then:But, I repeat: this won\'t prevent piracy I have recently read that this approach is not cryptographically very sound. But this solution is already weak (as the software itself has to include the secret key somewhere), so I don\'t think this discovery invalidates the solution as far as it goes.Just thought I really ought to mention this, though; if you\'re planning to derive something else from this, beware.There are many ways to generate license keys, but very few of those ways are truly secure. And it\'s a pity, because for companies, license keys have almost the same value as real cash.Ideally, you would want your license keys to have the following properties:Only your company should be able to generate license keys for your products, even if someone completely reverse engineers your products (which WILL happen, I speak from experience). Obfuscating the algorithm or hiding an encryption key within your software is really out of the question if you are serious about controlling licensing. If your product is successful, someone will make a key generator in a matter of days from release.A license key should be useable on only one computer (or at least you should be able to control this very tightly)A license key should be short and easy to type or dictate over the phone. You don\'t want every customer calling the technical support because they don\'t understand if the key contains a "l" or a "1". Your support department would thank you for this, and you will have lower costs in this area.So how do you solve these challenges ?The answer is simple but technically challenging: digital signatures using public key cryptography. Your license keys should be in fact signed "documents", containing some useful data, signed with your company\'s private key. The signatures should be part of the license key. The product should validate the license keys with the corresponding public key. This way, even if someone has full access to your product\'s logic, they cannot generate license keys because they don\'t have the private key. A license key would look like this: BASE32(CONCAT(DATA, PRIVATE_KEY_ENCRYPTED(HASH(DATA))))\nThe biggest challenge here is that the classical public key algorithms have large signature sizes. RSA512 has an 1024-bit signature. You don\'t want your license keys to have hundreds of characters.\nOne of the most powerful approaches is to use elliptic curve cryptography (with careful implementations to avoid the existing patents). ECC keys are like 6 times shorter than RSA keys, for the same strength. You can further reduce the signature sizes using algorithms like the Schnorr digital signature algorithm (patent expired in 2008 - good :) )This is achievable by product activation (Windows is a good example). Basically, for a customer with a valid license key, you need to generate some "activation data" which is a signed message embedding the computer\'s hardware id as the signed data. This is usually done over the internet, but only ONCE: the product sends the license key and the computer hardware id to an activation server, and the activation server sends back the signed message (which can also be made short and easy to dictate over the phone). From that moment on, the product does not check the license key at startup, but the activation data, which needs the computer to be the same in order to validate (otherwise, the DATA would be different and the digital signature would not validate). Note that the activation data checking do not require verification over the Internet: it is sufficient to verify the digital signature of the activation data with the public key already embedded in the product.Well, just eliminate redundant characters like "1", "l", "0", "o" from your keys. Split the license key string into groups of characters.Simple answer - No matter what scheme you use it can be cracked.Don\'t punish honest customers with a system meant to prevent hackers, as hackers will crack it regardless.A simple hashed code tied to their email or similar is probably good enough.  Hardware based IDs always become an issue when people need to reinstall or update hardware.Good thread on the issue:\nhttp://discuss.joelonsoftware.com/default.asp?biz.5.82298.34When generating the key, don\'t forget to concatenate the version and build number to the string you calculate the hash on. That way there won\'t be a single key that unlocks all everything you ever released.  After you find some keys or patches floating in astalavista.box.sk you\'ll know that you succeeded in making something popular enough that somebody bothered to crack. Rejoice!Besides what has already been stated....Any use of .NET applications are inherently breakable because of the intermediate language issues.  A simple disassembly of the .NET code will open your product to anyone.  They can easily bypass your licensing code at that point. You can\'t even use hardware values to create a key anymore.  Virtual machines now allow someone to create an image of a \'licensed\' machine and run it on any platform they choose.If it\'s expensive software there are other solutions.  If it\'s not, just make it difficult enough for the casual hacker.  And accept the fact that there will be unlicensed copies out there eventually.If your product is complicated, the inherent support issues will be create some protection for you.The C# / .NET engine we use for licence key generation is now maintained as open source:https://github.com/appsoftware/.NET-Licence-Key-Generator.It\'s based on a "Partial Key Verification" system which means only a subset of the key that you use to generate the key has to be compiled into your distributable. You create the keys your self, so the licence implementation is unique to your software.As stated above, if your code can be decompiled, it\'s relatively easy to circumvent most licencing systems. I\'ve used Crypkey in the past. It\'s one of many available.You can only protect software up to a point with any licensing scheme. I don\'t know how elaborate you want to getbut i believe that .net can access the hard drive serial number.you could have the program send you that and something eles ( like user name and mac address of the nic)you compute a code based off that and email them back the key.they will keep them from switching machines after they have the key.The only way to do everything you asked for is to require an internet access and verification with a server. The application needs to sign in to the server with the key, and then you need to store the session details, like the IP address. This will prevent the key from being used on several different machines. This is usually not very popular with the users of the application, and unless this is a very expensive and complicated application it\'s not worth it.You could just have a license key for the application, and then check client side if the key is good, but it is easy to distribute this key to other users, and with a decompiler new keys can be generated.I\'ve implemented internet-based one-time activation on my company\'s software (C# .net) that requires a license key that refers to a license stored in the server\'s database.  The software hits the server with the key and is given license information that is then encrypted locally using an RSA key generated from some variables (a combination of CPUID and other stuff that won\'t change often) on the client computer and then stores it in the registry.  It requires some server-side coding, but it has worked really well for us and I was able to use the same system when we expanded to browser-based software.  It also gives your sales people great info about who, where and when the software is being used.  Any licensing system that is only handled locally is fully vulnerable to exploitation, especially with reflection in .NET.  But, like everyone else has said, no system is wholly secure.  In my opinion, if you aren\'t using web-based licensing, there\'s no real point to protecting the software at all.  With the headache that DRM can cause, it\'s not fair to the users who have actually paid for it to suffer.I strongly believe, that only public key cryptography based licensing system is the right approach here, because you don\'t have to include essential information required for license generation into your sourcecode.In the past, I\'ve used Treek\'s Licensing Library many times, because it fullfills this requirements and offers really good price. It uses the same license protection for end users and itself and noone cracked that until now. You can also find good tips on the website to avoid piracy and cracking.It is not possible to prevent software piracy completely. You can prevent casual piracy and that\'s what all licensing solutions out their do. Node (machine) locked licensing is best if you want to prevent reuse of license keys. I have been using Cryptlex for about a year now for my software. It has a free plan also, so if you don\'t expect too many customers you can use it for free.Like a few others mentioned, I\'m a huge opponent of being hostile to customers by default\xe2\x80\x94something that the licensing industry is notorious for. So I\'ll expand on a good solution for your problem that also offers a good customer UX.To start off, you mentioned that you have a "limited" version of your software that you\'re using to try and convert customers to "upgrade" for additional features. So what you\'re looking for are feature licenses for your product e.g. a customer can purchase a license for feature-X or feature-Y.I built Keygen with this type of licensing in mind. Keygen is a licensing REST API that allows you to manage user accounts, licenses and also track machine usage/associations.What I would do is set up 2 license types (a policy within Keygen) where one is a base policy for the limited free version, and the other is a policy for the paid version.I\'m not sure what you\'re using for payments, but let\'s assume you\'re using something like Stripe (pretty standard nowadays) that offers webhooks. Keygen also has webhooks (whether you use it or not, all this is still applicable). You can integrate Keygen to talk with your payment provider using webhooks from both sides (think: customer.created->create base license for customer, license.created->charge customer for the new license).So by utilizing webhooks, we can automate license creation for new customers. So what about license validation within the application itself? This can be done in a variety of ways, but the most popular way is by requiring your customer to enter a long license key into an input field which you can then validate; I think this is a terrible way to handle license validation in your application.Why do I think that? Well first off, you\'re requiring your customer to input a tediously long license key that is meant for machine consumption, and second your requiring you and your customer to keep track of said tediously long license key.Okay, so what\'s an alternative? I think the best alternative is doing something all of your customers are used to: allowing them to create an account for your product using an email/password. You can then associate all of their licenses and their machines with that account. So now instead of inputting a license key, they can simply log in using their credentials.What advantage does that give you? Firstly, it gets rid of the need for you and your customers to keep track of license keys, since it\'s all handled behind-the-scenes inside of their user account and most importantly: you can now offer your customers self-serve license and machine activation! i.e. since all of their licenses and machines are associated with their user account, you can prompt them to purchase a license when they fire up your application on an unrecognized machine.Now onto license validation: whenever your customer logs into your application with their email/password, you can query their user account for the licenses they own to determine if they can use feature-X or feature-Y. And since your application is now self-serve, you can allow your customers to purchase additional features directly from within your application!So we\'ve introduced a ton of automation to our licensing system, we can license individual features (i.e. a limited vs. full version), we\'ve offered an awesome UX for our customers and we\'ve also alleviated one of the biggest reasons for support requests: license key recovery.Anyways, this got long but hopefully it helps somebody!