I\'m building a Django site and I am looking for a search engine.A few candidates:Lucene/Lucene with Compass/SolrSphinxPostgresql built-in full text searchMySQl built-in full text searchSelection criteria:Anyone who has had experience with the search engines above, or other engines not in the list -- I would love to hear your opinions.EDIT: As for indexing needs, as users keep entering data into the site, those data would need to be indexed continuously. It doesn\'t have to be real time, but ideally new data would show up in index with no more than 15 - 30 minutes delayGood to see someone\'s chimed in about Lucene - because I\'ve no idea about that.Sphinx, on the other hand, I know quite well, so let\'s see if I can be of some help.I\'ve no idea how applicable to your situation this is, but Evan Weaver compared a few of the common Rails search options (Sphinx, Ferret (a port of Lucene for Ruby) and Solr), running some benchmarks. Could be useful, I guess.I\'ve not plumbed the depths of MySQL\'s full-text search, but I know it doesn\'t compete speed-wise nor feature-wise with Sphinx, Lucene or Solr.I don\'t know Sphinx, but as for Lucene vs a database full-text search, I think that Lucene performance is unmatched. You should be able to do almost any search in less than 10 ms, no matter how many records you have to search, provided that you have set up your Lucene index correctly.Here comes the biggest hurdle though: personally, I think integrating Lucene in your project is not easy. Sure, it is not too hard to set it up so you can do some basic search, but if you want to get the most out of it, with optimal performance, then you definitely need a good book about Lucene.As for CPU & RAM requirements, performing a search in Lucene doesn\'t task your CPU too much, though indexing your data is, although you don\'t do that too often (maybe once or twice a day), so that isn\'t much of a hurdle.It doesn\'t answer all of your questions but in short, if you have a lot of data to search, and you want great performance, then I think Lucene is definitely the way to go. If you\'re not going to have that much data to search, then you might as well go for a database full-text search. Setting up a MySQL full-text search is definitely easier in my book.I am surprised that there isn\'t more information posted about Solr. Solr is quite similar to Sphinx but has more advanced features (AFAIK as I haven\'t used Sphinx -- only read about it).The answer at the link below details a few things about Sphinx which also applies to Solr.\nComparison of full text search engine - Lucene, Sphinx, Postgresql, MySQL?Solr also provides the following additional features:BTW, there are tons more features; however, I\'ve listed just the features that I have actually used in production. BTW, out of the box, MySQL supports #1, #3, and #11 (limited) on the list above. For the features you are looking for, a relational database isn\'t going to cut it. I\'d eliminate those straight away.Also, another benefit is that Solr (well, Lucene actually) is a document database (e.g. NoSQL) so many of the benefits of any other document database can be realized with Solr. In other words, you can use it for more than just search (i.e. Performance). Get creative with it :)Apart from answering OP\'s queries, Let me throw some insights on Apache Solr from simple introduction to detailed installation and implementation.Anyone who has had experience with the search engines above, or other\n  engines not in the list -- I would love to hear your opinions.Solr shouldn\'t be used to solve real-time problems. For search engines, Solr is pretty much game and works flawlessly.Solr works fine on High Traffic web-applications (I read somewhere that it is not suited for this, but I am backing up that statement). It utilizes the RAM, not the CPU.The boost helps you rank your results show up on top. Say, you\'re trying to search for a name john in the fields firstname and lastname, and you want to give relevancy to the firstname field, then you need to boost up the firstname field as shown. As you can see, firstname field is boosted up with a score of 2.More on SolrRelevancyThe speed is unbelievably fast and no compromise on that. The reason I moved to Solr.Regarding the indexing speed, Solr can also handle JOINS from your database tables. A higher and complex JOIN do affect the indexing speed. However, an enormous RAM config can easily tackle this situation.The higher the RAM, The faster the indexing speed of Solr is.Never attempted to integrate Solr and Django, however you can achieve to do that with Haystack. I found some interesting article on the same and here\'s the github for it.Solr breeds on RAM, so if the RAM is high, you don\'t to have to worry about Solr.Solr\'s RAM usage shoots up on full-indexing if you have some billion records, you could smartly make use of Delta imports to tackle this situation. As explained, Solr is only a near real-time solution.Solr is highly scalable. Have a look on SolrCloud.\nSome key features of it.For the above scenario, you could use the SpellCheckComponent that is packed up with Solr. There are a lot other features, The SnowballPorterFilterFactory helps to retrieve records say if you typed, books instead of book, you will be presented with results related to book.This answer broadly focuses on Apache Solr & MySQL.  Django is out of scope.  Assuming that you are under LINUX environment, you could proceed to this article further. (mine was an Ubuntu 14.04 version)Download Apache Solr from here. That would be version is 4.8.1. You could download new versions, I found this stable.After downloading the archive , extract it to a folder of your choice. \nSay ..  Downloads or whatever.. So it will look like Downloads/solr-4.8.1/On your prompt..  Navigate inside the directoryshankar@shankar-lenovo: cd Downloads/solr-4.8.1So now you are here .. shankar@shankar-lenovo: ~/Downloads/solr-4.8.1$Jetty is available inside the examples folder of the solr-4.8.1 directory , so navigate inside that and start the Jetty Application Server.shankar@shankar-lenovo:~/Downloads/solr-4.8.1/example$ java -jar start.jarNow , do not close the terminal , minimize it and let it stay aside. ( TIP : Use & after start.jar to make the Jetty Server run in the\n  background )To check if Apache Solr runs successfully, visit this URL on the browser. http://localhost:8983/solrIt runs on the port 8983 as default. You could change the port either here or directly inside the jetty.xml file.java -Djetty.port=9091 -jar start.jarThis JAR file acts as a bridge between MySQL and JDBC , Download the Platform Independent Version hereAfter downloading it, extract the folder and copy themysql-connector-java-5.1.31-bin.jar and paste it to the lib directory.shankar@shankar-lenovo:~/Downloads/solr-4.8.1/contrib/dataimporthandler/libTo put Solr to use, You need to have some tables and data to search for. For that, we will use MySQL for creating a table and pushing some random names and then we could use Solr to connect to MySQL and index that table and it\'s entries.Add these two directives to this file..Now add the DIH (Data Import Handler)If the file exists then ignore, add these lines to that file. As you can see the first line, you need to provide the credentials of your MySQL database. The Database name, username and password.( TIP : You can have any number of entities but watch out for id field,\n  if they are same then indexing will skipped. )Add this to your schema.xml as shown.. This is where the real deal is. You need to do the indexing of data from MySQL to Solr inorder to make use of Solr Queries.Hit the URL http://localhost:8983/solr on your browser. The screen opens like this. As the marker indicates, go to Logging inorder to check if any of the above configuration has led to errors.Ok so now you are here, As you can there are a lot of yellow messages (WARNINGS). Make sure you don\'t have error messages marked in red. Earlier, on our configuration we had added a select query on our db-data-config.xml, say if there were any errors on that query, it would have shown up here.Fine, no errors. We are good to go. Let\'s choose collection1 from the list as depicted and select DataimportUsing the DIH, you will be connecting to MySQL from Solr through the configuration file db-data-config.xml from the Solr interface and retrieve the 10 records from the database which gets indexed onto Solr.To do that, Choose full-import , and check the options Clean and Commit. Now click Execute as shown.Alternatively, you could use a direct full-import query like this too..After you clicked Execute, Solr begins to index the records, if there were any errors, it would say Indexing Failed and you have to go back to the Logging section to see what has gone wrong.Assuming there are no errors with this configuration and if the indexing is successfully complete., you would get this notification.Seems like everything went well, now you could use Solr Queries to query the data that was indexed. Click the Query on the left and then press Execute button on the bottom.You will see the indexed records as shown.The corresponding Solr query for listing all the records isWell, there goes all 10 indexed records. Say, we need only names starting with Ja , in this case, you need to target the column name solr_name, Hence your query goes like this.That\'s how you write Solr Queries. To read more about it, Check this beautiful article.I\'m looking at PostgreSQL full-text search right now, and it has all the right features of a modern search engine, really good extended character and multilingual support, nice tight integration with text fields in the database.  But it doesn\'t have user-friendly search operators like + or AND (uses & | !) and I\'m not thrilled with how it works on their documentation site.  While it has bolding  of match terms in the results snippets, the default algorithm for which match terms is not great. Also, if you want to index rtf, PDF, MS Office, you have to find and integrate a file format converter.OTOH, it\'s way better than the MySQL text search, which doesn\'t even index words of three letters or fewer.  It\'s the default for the MediaWiki search, and I really think it\'s no good for end-users: http://www.searchtools.com/analysis/mediawiki-search/In all cases I\'ve seen, Lucene/Solr and Sphinx are really great.  They\'re solid code and have evolved with significant improvements in usability, so the tools are all there to make search that satisfies almost everyone.for SHAILI - SOLR includes the Lucene search code library and has the components to be a nice stand-alone search engine.Just my two cents to this very old question. I would highly recommend taking a look at ElasticSearch. Elasticsearch is a search server based on Lucene. It provides a distributed, multitenant-capable full-text search engine with a RESTful web interface and schema-free JSON documents. Elasticsearch is developed in Java and is released as open source under the terms of the Apache License.The advantages over other FTS (full text search) Engines are:We are using this search engine at our project and very happy with it.SearchTools-Avi said "MySQL text search, which doesn\'t even index words of three letters or fewer."FYIs, The MySQL fulltext min word length is adjustable since at least MySQL 5.0. Google \'mysql fulltext min length\' for simple instructions.That said, MySQL fulltext has limitations: for one, it gets slow to update once you reach a million records or so, ...I would add mnoGoSearch to the list. Extremely performant and flexible solution, which works as Google : indexer fetches data from multiple sites, You could use basic criterias, or invent Your own hooks to have maximal search quality. Also it could fetch the data directly from the database.The solution is not so known today, but it feets maximum needs. You could compile and install it or on standalone server, or even on Your principal server, it doesn\'t need so much ressources as Solr, as it\'s written in C and runs perfectly even on small servers.In the beginning You need to compile it Yourself, so it requires some knowledge. I made a tiny script for Debian, which could help. Any adjustments are welcome.As You are using Django framework, You could use or PHP client in the middle, or find a solution in Python, I saw some articles.And, of course mnoGoSearch is open source, GNU GPL.