How would I validate that a program exists, in a way that will either return an error and exit, or continue with the script?It seems like it should be easy, but it\'s been stumping me.Avoid which.  Not only is it an external process you\'re launching for doing very little (meaning builtins like hash, type or command are way cheaper), you can also rely on the builtins to actually do what you want, while the effects of external commands can easily vary from system to system.Why care?So, don\'t use which.  Instead use one of these:(Minor side-note: some will suggest 2>&- is the same 2>/dev/null but shorter \xe2\x80\x93 this is untrue.  2>&- closes FD 2 which causes an error in the program when it tries to write to stderr, which is very different from successfully writing to it and discarding the output (and dangerous!))If your hash bang is /bin/sh then you should care about what POSIX says.  type and hash\'s exit codes aren\'t terribly well defined by POSIX, and hash is seen to exit successfully when the command doesn\'t exist (haven\'t seen this with type yet).  command\'s exit status is well defined by POSIX, so that one is probably the safest to use.If your script uses bash though, POSIX rules don\'t really matter anymore and both type and hash become perfectly safe to use.  type now has a -P to search just the PATH and hash has the side-effect that the command\'s location will be hashed (for faster lookup next time you use it), which is usually a good thing since you probably check for its existence in order to actually use it.As a simple example, here\'s a function that runs gdate if it exists, otherwise date:Where bash is your shell/hashbang, consistently use hash (for commands) or type (to consider built-ins & keywords).When writing a POSIX script, use command -v.I agree with lhunath to discourage use of which, and his solution is perfectly valid for BASH users. However, to be more portable, command -v shall be used instead:Command command is POSIX compliant, see here for its specification: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/command.htmlNote: type is POSIX compliant, but type -P is not.The following is a portable way to check whether a command exists in PATH and is executable:Example:Although if it\'s not executable, it may be better to special-case that, as that probably indicates a more serious issue.Note: This will fail if the command you are looking for has been defined as an alias.I have a function defined in my .bashrc that makes this easier.Here\'s an example of how it\'s used (from my .bash_profile.)It depends whether you want to know whether it exists in one of the directories in the $PATH variable or whether you know the absolute location of it. If you want to know if it is in the $PATH variable, useotherwise useThe redirection to /dev/null/ in the first example suppresses the output of the which program.Expanding on @lhunath\'s and @GregV\'s answers, here\'s the code for the people who want to easily put that check inside an if statement:Here\'s how to use it:Try using:or From the bash manpage under Conditional Expressions:To use hash, as @lhunath suggests, in a bash script:This script runs hash and then checks if the exit code of the most recent command, the value stored in $?, is equal to 1.  If hash doesn\'t find foo, the exit code will be 1.  If foo is present, the exit code will be 0.&> /dev/null redirects standard error and standard output from hash so that it doesn\'t appear onscreen and echo >&2 writes the message to standard error.I never did get the above solutions to work on the box I have access to. For one, type has been installed (doing what more does). So the builtin directive is needed. This command works for me:If you check for program existence, you are probably going to run it later anyway. Why not try to run it in the first place?It\'s a more trustworthy check that the program runs than merely looking at PATH directories and file permissions.Plus you can get some useful result from your program, such as its version.Of course the drawbacks are that some programs can be heavy to start and some don\'t have a --version option to immediately (and successfully) exit.Why not use Bash builtins if you can?...For those interested, none of the methodologies above work if you wish to detect an installed library. I imagine you are left either with physically checking the path (potentially for header files and such), or something like this (if you are on a Debian-based distro):As you can see from the above, a "0" answer from the query means the package is not installed. This is a function of "grep" - a "0" means a match was found, a "1" means no match was found.Check for multiple dependencies and inform status to end usersSample output:Adjust the 10 to the maximum command length. Not automatic because I don\'t see a non verbose way to do it.The  which command might be useful. man which It returns 0 if the executable is found, 1 if it\'s not found or not executable:Nice thing about which is that it figures out if the executable is available in the environment that which is run in - saves a few problems...-AdamI\'d say there\'s no portable and 100% reliable way due to dangling aliases.  For example:Of course only the last one is problematic (no offence to Ringo!)  But all of them are valid aliases from the point of view of command -v.In order to reject dangling ones like ringo, we have to parse the output of the shell built-in alias command and recurse into them (command -v is no superior to alias here.) There\'s no portable solution for it, and even a Bash-specific solution is rather tedious.Note that solution like this will unconditionally reject alias ls=\'ls -F\'To mimic Bash\'s type -P cmd we can use POSIX compliant env -i type cmd 1>/dev/null 2>&1.The hash-variant has one pitfall: On the command line you can for example type into have process executed. For this the parent folder of one_folder must be in $PATH. But when you try to hash this command, it will always succeed:I second the use of "command -v". E.g. like this:hash foo 2>/dev/null: works with zsh, bash, dash and ash.type -p foo: it appears to work with zsh, bash and ash (busybox), but not dash (it interprets -p as an argument).command -v foo: works with zsh, bash, dash, but not ash (busybox) (-ash: command: not found).Also note that builtin is not available with ash and dash.If there is no external type command available (as taken for granted here), we can use POSIX compliant env -i sh -c \'type cmd 1>/dev/null 2>&1\':At least on Mac OS X 10.6.8 using Bash 4.2.24(2) command -v ls does not match a moved /bin/ls-temp.If you guys can\'t get the things above/below to work and pulling hair out of your back, try to run the same command using bash -c. Just look at this somnambular delirium, this is what really happening when you run $(sub-command): First. It can give you completely different output.Second. It can give you no output at all.my setup for a debian server. \ni had a the problem when multiple packages contains the same name.\nfor example apache2. \nso this was my solution. I use this because it\'s very easy:orIt uses shell builtin and program echo status to stdout and nothing to stderr by the other hand if a command is not found, it echos status only to stderr.In case you want to check if a program exists and is really a program, not a bash built-in command, then command, type and hash are not appropriate for testing as they all return 0 exit status for built-in commands.For example, there is the time program which offers more features than the time built-in command. To check if the program exists, I would suggest using which as in the following example:ScriptResultI had to check if git was installed as part of deploying our CI server. My final bash script was as follows (Ubuntu server):Hope this help someone else!I couldn\'t get one of the solutions to work, but after editing it a little I came up with this. Which works for me: