I\'ve been developing JavaScript for a few years and I don\'t understand the fuss about promises at all.It seems like all I do is change:Which I could use a library like async for anyway, with something like:Which is more code and less readable. I didn\'t gain anything here, it\'s not suddenly magically \'flat\' either. Not to mention having to convert things to promises.So, what\'s the big fuss about promises here?Promises are not callbacks. A promise represents the future result of an asynchronous operation. Of course, writing them the way you do, you get little benefit. But if you write them the way they are meant to be used, you can write asynchronous code in a way that resembles synchronous code and is much more easy to follow:Certainly, not much less code, but much more readable. But this is not the end. Let\'s discover the true benefits: What if you wanted to check for any error in any of the steps? It would be hell to do it with callbacks, but with promises, is a piece of cake:Pretty much the same as a try { ... } catch block. Even better:And even better: What if those 3 calls to api, api2, api3 could run simultaneously (e.g. if they were AJAX calls) but you needed to wait for the three? Without promises, you should have to create some sort of counter. With promises, using the ES6 notation, is another piece of cake and pretty neat:Hope you see Promises in a new light now.Yes, Promises are asynchronous callbacks. They can\'t do anything that callbacks can\'t do, and you face the same problems with asynchrony as with plain callbacks.However, Promises are more than just callbacks. They are a very mighty abstraction, allow cleaner and better, functional code with less error-prone boilerplate.So what\'s the main idea?Promises are objects representing the result of a single (asynchronous) computation. They resolve to that result only once. There\'s a few things what this means:Promises implement an observer pattern:Promises are chainable (monadic, if you want):Sounds complicated? Time for a code example.Flattening does not come magically, but you can easily do it. For your heavily nested example, the (near) equivalent would beIf seeing the code of these methods helps understanding, here\'s a most basic promise lib in a few lines.What\'s the big fuss about promises?The Promise abstraction allows much better composability of functions. For example, next to then for chaining, the all function creates a promise for the combined result of multiple parallel-waiting promises.Last but not least Promises come with integrated error handling. The result of the computation might be that either the promise is fulfilled with a value, or it is rejected with a reason. All the composition functions handle this automatically and propagate errors in promise chains, so that you don\'t need to care about it explicitly everywhere - in contrast to a plain-callback implementation. In the end, you can add a dedicated error callback for all occurred exceptions.Not to mention having to convert things to promises.That\'s quite trivial actually with good promise libraries, see How do I convert an existing callback API to promises?In addition to the awesome answers by Oscar and Bergi, with ES6 arrow functions Promises turn from a modestly shining small blue star straight into a red giant. That is about to collapse into a supernova:No promises are just wrapper on callbacksexample\n    You can use javascript native promises with node jsPromises are not callbacks, both are programming idioms that facilitate async programming. Using an async/await-style of programming using coroutines or generators that return promises could be considered a 3rd such idiom. A comparison of these idioms across different programming languages (including Javascript) is here: https://github.com/KjellSchubert/promise-future-taskIn addition to the other answers, the ES2015 syntax blends seamlessly with promises, reducing even more boilerplate code: