When comparing floats to integers, some pairs of values take much longer to be evaluated than other values of a similar magnitude.For example:But if the float or integer is made smaller or larger by a certain amount, the comparison runs much more quickly:Changing the comparison operator (e.g. using == or > instead) does not affect the times in any noticeable way. This is not solely related to magnitude because picking larger or smaller values can result in faster comparisons, so I suspect it is down to some unfortunate way the bits line up. Clearly, comparing these values is more than fast enough for most use cases. I am simply curious as to why Python seems to struggle more with some pairs of values than with others.A comment in the Python source code for float objects acknowledges that:Comparison is pretty much a nightmareThis is especially true when comparing a float to an integer, because, unlike floats, integers in Python can be arbitrarily large and are always exact. Trying to cast the integer to a float might lose precision and make the comparison inaccurate. Trying to cast the float to an integer is not going to work either because any fractional part will be lost.To get around this problem, Python performs a series of checks, returning the result if one of the checks succeeds. It compares the signs of the two values, then whether the integer is "too big" to be a float, then compares the exponent of the float to the length of the integer. If all of these checks fail, it is necessary to construct two new Python objects to compare in order to obtain the result.When comparing a float v to an integer/long w, the worst case is that:And this is exactly what we have for the values in the question:We see that 49 is both the exponent of the float and the number of bits in the integer. Both numbers are positive and so the four criteria above are met.Choosing one of the values to be larger (or smaller) can change the number of bits of the integer, or the value of the exponent, and so Python is able to determine the result of the comparison without performing the expensive final check.This is specific to the CPython implementation of the language.The float_richcompare function handles the comparison between two values v and w.Below is a step-by-step description of the checks that the function performs. The comments in the Python source are actually very helpful when trying to understand what the function does, so I\'ve left them in where relevant. I\'ve also summarised these checks in a list at the foot of the answer.The main idea is to map the Python objects v and w to two appropriate C doubles, i and j, which can then be easily compared to give the correct result. Both Python 2 and Python 3 use the same ideas to do this (the former just handles int and long types separately).The first thing to do is check that v is definitely a Python float and map it to a C double i. Next the function looks at whether w is also a float and maps it to a C double j. This is the best case scenario for the function as all the other checks can be skipped. The function also checks to see whether v is inf or nan: Now we know that if w failed these checks, it is not a Python float. Now the function checks if it\'s a Python integer. If this is the case, the easiest test is to extract the sign of v and the sign of w (return 0 if zero, -1 if negative, 1 if positive). If the signs are different, this is all the information needed to return the result of the comparison:If this check failed, then v and w have the same sign. The next check counts the number of bits in the integer w. If it has too many bits then it can\'t possibly be held as a float and so must be larger in magnitude than the float v:On the other hand, if the integer w has 48 or fewer bits, it can safely turned in a C double j and compared:From this point onwards, we know that w has 49 or more bits. It will be convenient to treat w as a positive integer, so change the sign and the comparison operator as necessary:Now the function looks at the exponent of the float. Recall that a float can be written (ignoring sign) as significand * 2exponent and that the significand represents a number between 0.5 and 1:This checks two things. If the exponent is less than 0 then the float is smaller than 1 (and so smaller in magnitude than any integer). Or, if the exponent is less than the number of bits in w then we have that v < |w| since significand * 2exponent is less than 2nbits. Failing these two checks, the function looks to see whether the exponent is greater than the number of bit in w. This shows that significand * 2exponent is greater than 2nbits and so v > |w|:If this check did not succeed we know that the exponent of the float v is the same as the number of bits in the integer w.The only way that the two values can be compared now is to construct two new Python integers from v and w. The idea is to discard the fractional part of v, double the integer part, and then add one. w is also doubled and these two new Python objects can be compared to give the correct return value. Using an example with small values, 4.65 < 4 would be determined by the comparison (2*4)+1 == 9 < 8 == (2*4) (returning false).For brevity I\'ve left out the additional error-checking and garbage-tracking Python has to do when it creates these new objects. Needless to say, this adds additional overhead and explains why the values highlighted in the question are significantly slower to compare than others.Here is a summary of the checks that are performed by the comparison function.Let v be a float and cast it as a C double. Now, if w is also a float:Check whether w is nan or inf. If so, handle this special case separately depending on the type of w.If not, compare v and w directly by their representations as C doubles.If w is an integer:Extract the signs of v and w. If they are different then we know v and w are different and which is the greater value.(The signs are the same.) Check whether w has too many bits to be a float (more than size_t). If so, w has greater magnitude than v.Check if w has 48 or fewer bits. If so, it can be safely cast to a C double without losing its precision and compared with v.(w has more than 48 bits. We will now treat w as a positive integer having changed the compare op as appropriate.) Consider the exponent of the float v. If the exponent is negative, then v is less than 1 and therefore less than any positive integer. Else, if the exponent is less than the number of bits in w then it must be less than w.If the exponent of v is greater than the number of bits in w then v is greater than w.(The exponent is the same as the number of bits in w.)The final check. Split v into its integer and fractional parts. Double the integer part and add 1 to compensate for the fractional part. Now double the integer w. Compare these two new integers instead to get the result.Using gmpy2 with arbitrary precision floats and integers it is possible to get more uniform comparison performance: