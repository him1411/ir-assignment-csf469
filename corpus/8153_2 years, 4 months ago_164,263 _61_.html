I would like my C++ code to stop running if a certain condition is met, but I\'m not sure how to do that. So just at any point if an if statement is true terminate the code like this:There are several ways, but first you need to understand why object cleanup is important, and hence the reason std::exit is marginalized among C++ programmers.C++ makes use of a idiom called RAII, which in simple terms means objects should perform initialization in the constructor and cleanup in the destructor. For instance the std::ofstream class [may] open the file during the constructor, then the user performs output operations on it, and finally at the end of its life cycle, usually determined by its scope, the destructor is called that essentially closes the file and flushes any written content into the disk.What happens if you don\'t get to the destructor to flush and close the file? Who knows! But possibly it won\'t write all the data it was supposed to write into the file.For instance consider this codeWhat happens in each possibility is:But don\'t be so certain about what I just told you (mainly possibilities 2 and 3); continue reading and we\'ll find out how to perform a proper exception based cleanup.You should do this whenever possible; always prefer to return from your program by returning a proper exit status from main.The caller of your program, and possibly the operating system, might want to know whether what your program was supposed to do was done successfully or not. For this same reason you should return either zero or EXIT_SUCCESS to signal that the program successfully terminated and EXIT_FAILURE to signal the program terminated unsuccessfully, any other form of return value is implementation-defined (\xc2\xa718.5/8).However you may be very deep in the call stack, and returning all of it may be painful...Throwing a exception will perform proper object cleanup using stack unwinding, by calling the destructor of every object in any previous scope.But here\'s the catch! It\'s implementation-defined whether stack unwinding is performed when a thrown exception is not handled (by the catch(...) clause) or even if you have a noexcept function in the middle of the call stack. This is stated in \xc2\xa715.5.1 [except.terminate]:In some situations exception handling must be abandoned for less subtle error handling techniques. [Note: These situations are:[...]\xe2\x80\x94  when the exception handling mechanism cannot find a handler for a thrown exception (15.3), or when the search for a handler (15.3) encounters the outermost block of a function with a noexcept-specification that does not allow the exception (15.4), or [...][...]In such cases, std::terminate() is called (18.8.3). In the situation where no matching handler is found, it is implementation-defined whether or not the stack is unwound before std::terminate() is called [...]So we have to catch it!Since uncaught exceptions may not perform stack unwinding (and consequently won\'t perform proper cleanup), we should catch the exception in main and then return a exit status (EXIT_SUCCESS or EXIT_FAILURE).So a possibly good setup would be:This does not perform any sort of stack unwinding, and no alive object on the stack will call its respective destructor to perform cleanup.This is enforced in \xc2\xa73.6.1/4 [basic.start.init]:Terminating the program without leaving the current block (e.g., by calling the function std::exit(int) (18.5)) does not destroy any objects with automatic storage duration (12.4). If std::exit is called to end a program during the destruction of an object with static or thread storage duration, the program has undefined behavior.Think about it now, why would you do such a thing? How many objects have you painfully damaged?There are other ways to terminate a program (other than crashing), but they aren\'t recommended. Just for the sake of clarification they are going to be presented here. Notice how normal program termination does not mean stack unwinding but an okay state for the operating system.As Martin York mentioned, exit doesn\'t perform necessary clean-up like return does.It\'s always better to use return in the place of exit.\nIn case if you are not in main, wherever you would like to exit the program, return to main first.Consider the below example.\nWith the following program, a file will be created with the content mentioned.\nBut if return is commented & uncommented exit(0), the compiler doesn\'t assure you that the file will have the required text.Not just this, Having multiple exit points in a program will make debugging harder.\nUse exit only when it can be justified.Call the std::exit function.   People are saying "call exit(return code)," but this is bad form. In small programs it is fine, but there are a number of issues with this:Really, the only time you should exit the problem is with this line in main.cpp:If you are using exit() to handle errors, you should learn about exceptions (and nesting exceptions), as a much more elegant and safe method. return 0; put that wherever you want within int main() and the program will immediately close. Either return a value from your main or use the exit function.  Both take an int.  It doesn\'t really matter what value you return unless you have an external process watching for the return value.The program will terminate when the execution flow reaches the end of the main function.To terminate it before then, you can use the exit(int status) function, where status is a value returned to whatever started the program. 0 normally indicates a non-error stateIf you have an error somewhere deep in the code, then either throw an exception or set the error code. It\'s always better to throw an exception instead of setting error codes.Generally you would use the exit() method with an appropriate exit status. Zero would mean a successful run. A non-zero status indicates some sort of problem has occurred. This exit code is used by parent processes (e.g. shell scripts) to determine if a process has run successfully.Beyond calling exit(error_code) - which calls atexit handlers, but not RAII destructors, etc.\n- more and more I am using exceptions.More and more my main program looks likewhere secondary_main\nin where all the stuff that was originally is put --\ni.e. the original main is renamed secondary_main, and the stub main above is added.\nThis is just a nicety, so that there isn\'t too much code between the tray and catch in main.If you want, catch other exception types.\nI quite like catching string error types, like std::string or char*, and printing those \nin the catch handler in main.Using exceptions like this at least allows RAII destructors to be called, so that they can do cleanup.  Which can be pleasant and useful.Overall, C error handling - exit and signals - and C++ error handling - try/catch/throw exceptions - play together inconsistently at best.Then, where you detect an erroror some more specific exception type.To break a condition use the return(0);So, in your case it would be: If your if statement is in Loop You can use If you want to  escape some code & continue to loop  Use : continue;If your if statement not in Loop You can use :Dude... exit() function is defined under stdlib.hSo you need to add a preprocessor. Put include stdlib.h in the header section   Then use exit(); wherever you like but remember to put an interger number in the parenthesis of exit. for example: If the condition I\'m testing for is really bad news, I do this:This gives me a nice coredump from where I can examine the situation.