I want to write a function in Python that returns different fixed values based on the value of an input index.  In other languages I would use a switch or case statement, but Python does not appear to have a switch statement.  What are the recommended Python solutions in this scenario?You could use a dictionary:If you\'d like defaults you could use the dictionary get(key[, default]) method:I\'ve always liked doing it this wayFrom hereIn addition to the dictionary methods (which I really like, BTW), you can also use if-elif-else to obtain the switch/case/default functionality:This of course is not identical to switch/case - you cannot have fall-through as easily as leaving off the break; statement, but you can have a more complicated test.  Its formatting is nicer than a series of nested ifs, even though functionally that\'s what it is closer to.Usage:Tests:My favorite Python recipe for switch/case is:Short and simple for simple scenarios. Compare to 11+ lines of C code:You can even assign multiple variables by using tuples:There\'s a pattern that I learned from Twisted Python code.You can use it any time you need to dispatch on a token and execute extended piece of code. In a state machine you would have state_ methods, and dispatch on self.state. This switch can be cleanly extended by inheriting from base class and defining your own do_ methods. Often times you won\'t even have do_ methods in the base class.Edit: how exactly is that usedIn case of SMTP you will receive HELO from the wire. The relevant code (from twisted/mail/smtp.py, modified for our case) looks like thisYou\'ll receive \'  HELO   foo.bar.com \' (or you might get \'QUIT\' or \'RCPT TO: foo\'). This is tokenized into parts as [\'HELO\', \'foo.bar.com\']. The actual method lookup name is taken from parts[0].(The original method is also called state_COMMAND, because it uses the same pattern to implement a state machine, i.e. getattr(self, \'state_\' + self.mode))My favorite one is a really nice recipe. You\'ll really like it. It\'s the closest one I\'ve seen to actual switch case statements, especially in features.Here\'s an example:Let\'s say you don\'t want to just return a value, but want to use methods that change something on an object. Using the approach stated here would be:What happens here is that python evaluates all methods in the dictionary.\nSo even if your value is \'a\', the object will get incremented and decremented by x.Solution:So you get a list containing a function and its arguments. This way, only the function pointer and the argument list get returned, not evaluated. \'result\' then evaluates the returned function call.expanding on the "dict as switch" idea. if you want to use a default value for your switch:If you\'re searching extra-statement, as "switch", I built a python module that extends Python. It\'s called ESPY as "Enhanced Structure for Python" and it\'s available for both Python 2.x and Python 3.x.For example, in this case, a switch statement could be performed by the following code:that can be used like this:so espy translate it in Python as:If you have a complicated case block you can consider using a function dictionary lookup table... If you haven\'t done this before its a good idea to step into your debugger and view exactly how the dictionary looks up each function.  NOTE: Do not use "()" inside the case/dictionary lookup or it will call each of your functions as the dictionary / case block is created.  Remember this because you only want to call each function once using a hash style lookup.I didn\'t find the simple answer I was looking for anywhere on Google search. But I figured it out anyway. It\'s really quite simple. Decided to post it, and maybe prevent a few less scratches on someone else\'s head. The key is simply "in" and tuples. Here is the switch statement behavior with fall-through, including RANDOM fall-through.Provides:I found that a common switch structure:can be expressed in Python as follows:or formatted in a clearer way:Instead of being a statement, the python version is an expression, which evaluates to a value.The solutions I use: A combination of 2 of the solutions posted here, which is relatively easy to read and supports defaults.wherelooks up "lambda x: x - 2" in the dict and uses it with x=23 doesn\'t find it in the dict and uses the default "lambda x: x - 22" with x=44.I liked Mark Bies\'s answerSince the x variable must used twice, I modified the lambda functions to parameterless.I have to run with  results[value](value)Edit: I noticed that I can use None type with with dictionaries. So this would emulate switch ; case elseI have made a (relatively) flexible and re-usable solution for this. It can be found at GitHub as this gist. If the result of the switch function is callable, it is automatically called.Short and easy to read, has a default value and supports expressions in both conditions and return values.However, it is less efficient than the solution with a dictionary. For example, Python has to scan through all the conditions before returning the default value.Defining:allows you to use a fairly straightforward syntax, with the cases bundled into a map:I kept trying to redefine switch in a way that would let me get rid of the "lambda:", but gave up.  Tweaking the definition:Allowed me to map multiple cases to the same code, and to supply a default option:Each replicated case has to be in its own dictionary; switch() consolidates the dictionaries before looking up the value.  It\'s still uglier than I\'d like, but it has the basic efficiency of using a hashed lookup on the expression, rather than a loop through all the keys.I think the best way is to use the python language idioms to keep your code testable. As showed in previous answers, I use dictionaries to take advantage of python structures and language and keep the "case" code isolated in different methods. Below there is a class, but you can use directly a module, globals and functions. The class has methods that can be tested with isolation.\nDependending to your needs, you can play with static methods and attributes too.It is possible to take advantage of this method using also classes as keys of "__choice_table". In this way you can avoid isinstance abuse and keep all clean and testable.Supposing you have to process a lot of messages or packets from the net or your MQ. Every packet has its own structure and its management code (in a generic way).\nWith the above code it is possible to do something like this:So complexity is not spread in the code flow but it is rendered in code structure.If you don\'t worry losing syntax highlight inside the case suites, you can do the following:Where value is the value. In C, this would be:We can also create a helper function to do this:So we can use it like this for the example with one, two and three:I would just use if/elif/else statements. I think that it\'s good enough to replace the switch statement.Expanding on Greg Hewgill\'s answer - We can encapsulate the dictionary-solution using a decorator:This can then be used with the @case-decoratorThe good news are that this has already been done in NeoPySwitch-module. Simply install using pip:For the sake of completeness, here are some of my attempts back in stone-age:http://code.activestate.com/recipes/269708-some-python-style-switches/?in=user-1521341I especially enjoy the use of "3. Select values with \'range comparisons\'"If you are really just returning a predetermined, fixed value, you could create a dictionary with all possible input indexes as the keys, along with their corresponding values. Also, you might not really want a function to do this - unless you\'re computing the return value somehow.Oh, and if you feel like doing something switch-like, see here.I was quite confused after reading the answer, but this cleared it all up:This code is analogous to:Check the Source for more about dictionary mapping to functions.I\'m just going to drop my two cents in here.  The reason there isn\'t a case/switch statement in Python is because Python follows the principle of \'Theres only one right way to do something\'.   So obviously you could come up with various ways of recreating switch/case functionality, but the Pythonic way of accomplishing this is the if/elif construct. ieI just felt PEP 8 deserved a nod here.  One of the beautiful things about Python is its simplicity and elegance.  That is largely derived from principles laid our in PEP 8, including "There\'s only one right way to do something"Greg\'s solutions will not work for unhashable entries. For example when indexing lists.Luckily though tuples are hashable.Similarly there probably are immutable (thus probably hashable) versions of dictionaries or sets too.