Here is the extract from the program in question. The matrix img[][] has the size SIZE\xc3\x97SIZE, and is initialized at:img[j][i] = 2 * j + iThen, you make a matrix res[][], and each field in here is made to be the average of the 9 fields around it in the img matrix. The border is left at 0 for simplicity.That\'s all there\'s to the program. For completeness\' sake, here is what comes before. No code comes after. As you can see, it\'s just initialization.Basically, this program is slow when SIZE is a multiple of 2048, e.g. the execution times:The compiler is GCC.\nFrom what I know, this is because of memory management, but I don\'t really know too much about that subject, which is why I\'m asking here.Also how to fix this would be nice, but if someone could explain these execution times I\'d already be happy enough.I already know of malloc/free, but the problem is not amount of memory used, it\'s merely execution time, so I don\'t know how that would help.The difference is caused by the same super-alignment issue from the following related questions:But that\'s only because there\'s one other problem with the code.Starting from the original loop:First notice that the two inner loops are trivial. They can be unrolled as follows:So that leaves the two outer-loops that we\'re interested in.Now we can see the problem is the same in this question: Why does the order of the loops affect performance when iterating over a 2D array?You are iterating the matrix column-wise instead of row-wise.To solve this problem, you should interchange the two loops.This eliminates all the non-sequential access completely so you no longer get random slow-downs on large powers-of-two.Core i7 920 @ 3.5 GHzOriginal code:Interchanged Outer-Loops:The following tests have been done with Visual C++ compiler as it is used by the default Qt Creator install (I guess with no optimization flag). When using GCC, there is no big difference between Mystical\'s version and my "optimized" code. So the conclusion is that compiler optimizations take care off micro optimization better than humans (me at last). I leave the rest of my answer for reference.It\'s not efficient to process images this way. It\'s better to use single dimension arrays. Processing all pixels is the done in one loop. Random access to points could be done using:In this particular case, it\'s better to compute and cache the sum of three pixels groups horizontally because they are used three times each.I\'ve done some tests and I think it\'s worth sharing. Each result is an average of five tests.Original code by user1615209:Mystical\'s version:Two pass using a 1D array: first pass for horizontal sums, second for vertical sum and average.\nTwo pass addressing with three pointers and only increments like this:Two pass using a 1D array and addressing like this:One pass caching horizontal sums just one row ahead so they stay in cache:Conclusion:I\'m sure it\'s possible to do much better.NOTE\nPlease, note that I wrote this answer to target general performance issues rather than the cache problem explained in Mystical\'s excellent answer. At the beginning it was just pseudo code. I was asked to do tests in the comments... Here is a completely refactored version with tests.