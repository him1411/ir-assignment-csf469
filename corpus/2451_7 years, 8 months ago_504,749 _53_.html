How to find number of days between two dates using PHP?If you\'re using PHP 5.3 >, this is by far the most accurate way of calculating the difference:Convert your dates to unix timestamps, then substract one from the another. That will give you the difference in seconds, which you divide by 86400 (amount of seconds in a day) to give you an approximate amount of days in that range.If your dates are in format 25.1.2010, 01/25/2010 or 2010-01-25, you can use the strtotime function:Using ceil rounds the amount of days up to the next full day. Use floor instead if you want to get the amount of full days between those two dates.If your dates are already in unix timestamp format, you can skip the converting and just do the $days_between part. For more exotic date formats, you might have to do some custom parsing to get it right.From PHP Version 5.3 and up, new date/time functions have been added to get difference:Result as below:Hope it helps !Easy to using date_diffTL;DR do not use UNIX timestamps. If you do, be prepared.Most of the answers using UNIX timestamps make two mistakes that put together can lead to wrong results and subtle bugs that may be difficult to track, even days, weeks or months after a successful deployment.First mistake is not considering that when asked, "How many days passed since yesterday?", a computer might truthfully answer zero if between the present and the instant indicated by "yesterday" less than one whole day has passed.Usually when converting a "day" to a UNIX timestamp, what is obtained is the timestamp for the midnight of that particular day.So between the midnights of October 1st and October 15th, fifteen days have elapsed. But between 13:00 of October 1st and 14:55 of October 15th, fifteen days minus 5 minutes have elapsed, and most solutions using floor() or doing implicit integer conversion will report one day less than expected.Second mistake is equating one day to 86400 seconds. This is almost always true - it happens often enough to overlook the times it doesn\'t. But the distance in seconds between two consecutive midnights is surely not 86400 at least twice a year when daylight saving time comes into play.So even if you use the "hack" of forcing all date timestamps to a fixed hour, say midnight (this is also done implicitly by various languages and frameworks when you only specify day-month-year and not also hour-minute-second), the widely used formulawill return, say, 17 when DATE1 and DATE2 are in the same DST segment of the year; but it may return 17.042, and worse still, 16.958. The use of floor() or any implicit truncation to integer will then convert what should have been a 17 to a 16.And things grow even uglier since such code is not portable across platforms, because some of them may apply leap seconds and some might not. On those platforms that do, the difference between two dates will not be 86400 but 86401, or maybe 86399. So code that worked in May and actually passed all tests will break next June when 12.99999 days are considered 12 days instead of 13. Two dates that worked in 2015 will not work in 2017 -- the same dates, and neither year is a leap year.So if you really want to use UNIX timestamps:use round() function wisely, not floor().as an alternative (after all, floor is round shifted 0.5), do not calculate differences between D1-M1-YYY1 and D2-M2-YYY2. Those dates will be really considered as D1-M1-YYY1 00:00:00 and D2-M2-YYY2 00:00:00. Rather, convert between D1-M1-YYY1 22:30:00 and D2-M2-YYY2 04:30:00. You will always get a remainder of about twenty hours. This may become twenty-one hours or nineteen, and maybe eighteen hours, fifty-nine minutes thirty-six seconds. No matter. It is a large margin which will stay there and stay positive for the foreseeable future. Now you can truncate it with floor() in safety.The correct solution though is touse a time library (Datetime, Carbon, whatever); don\'t roll your ownwrite comprehensive test cases using really evil date choices - across DST boundaries, across leap years, across leap seconds, and so on, as well as commonplace dates. Ideally (calls to datetime are fast!) generate four whole years\' (and one day) worth of dates by assembling them from strings, sequentially, and ensure that the difference between the first day and the day being tested increases steadily by one. This will ensure that if anything changes in the low-level routines and leap seconds fixes try to wreak havoc, at least you will know.run those tests regularly together with the rest of the test suite. They\'re a matter of milliseconds, and may save you literally hours of head scratching.This actually happened some months ago. An ingenious programmer decided to save several microseconds off a calculation that took about thirty seconds at most, by plugging in the infamous "(MidnightOfDateB-MidnightOfDateA)/86400" code in several places. It was so obvious an optimization that he did not even document it, and the optimization passed the integration tests and lurked in the code for several months, all unnoticed.This happened in a program that calculates the wages for several top-selling salesmen, the least of which has a frightful lot more clout than a whole humble five-people programmer team taken together. One day some months ago, for reasons that matter little, the bug struck -- and some of those guys got shortchanged one whole day of fat commissions. They were definitely not amused.Infinitely worse, they lost the (already very little) faith they had in the program not being designed to surreptitiously shaft them, and pretended - and obtained - a complete, detailed code review with test cases ran and commented in layman\'s terms (plus a lot of red-carpet treatment in the following weeks).What can I say: on the plus side, we got rid of a lot of technical debt, and were able to rewrite and refactor several pieces of a spaghetti mess that hearkened back to a COBOL infestation in the swinging \'90s. The program undoubtedly runs better now, and there\'s a lot more debugging information to quickly zero in when anything looks fishy. I estimate that just this last one thing will save perhaps one or two man-days per month for the foreseeable future.On the minus side, the whole brouhaha costed the company about \xe2\x82\xac200,000 up front - plus face, plus undoubtedly some bargaining power (and, hence, yet more money).The guy responsible for the "optimization" had changed job a year ago, before the disaster, but still there was talk to sue him for damages. And it didn\'t go well with the upper echelons that it was "the last guy\'s fault" - it looked like a set-up for us to come up clean of the matter, and in the end, we\'re still in the doghouse and one of the team is planning to quit.Ninety-nine times out of one hundred, the "86400 hack" will work flawlessly. This, ladies and gentlemen, was one instance when it did not. As with air-bags and seat belts, you will perhaps never really need the complexity (and ease of use) of DateTime or Carbon. But the day when you might will come as a thief in the night. Be prepared.Object oriented style:Procedural style:Well, the selected answer is not the most correct one because it will fail outside UTC.\nDepending on the timezone (list) there could be time adjustments creating days "without" 24 hours, and this will make the calculation (60*60*24) fail.Here it is an example of it:So the correct solution will be using DateTimeUsed this :)Now it worksI\'m using Carbon in my composer projects for this and similar purposes.It\'d be as easy as this:If you have the times in seconds (I.E. unix time stamp) , then you can simply subtract the times and divide by 86400 (seconds per day)and, if needed:If you want to echo all days between the start and end date, I came up with this :If you are using MySql}}Here is my improved version which shows 1 Year(s) 2 Month(s) 25 day(s) if the 2nd parameter is passed.Try using CarbonAlso you can use to create an object of Carbon date using given timestamp string.This works!