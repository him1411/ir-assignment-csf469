we use svn at work but for my personal projects I decided to use git. So I installed git yesterday and I wonder what is the revision number equivalent in git.Let\'s say we work on version 3.0.8 and every bug fix has its own revision number we can use when we talk about this bug fix. So if I tag the code in git to 3.0.8 what then I can use as a revision number or some other more detailed kind of identification. I find the hash not so user friendly for humans.Good or bad news for you, that hash IS the revision number.  I also had trouble with this when I made the switch from SVN to git.You can use "tagging" in git to tag a certain revision as the "release" for a specific version, making it easy to refer to that revision.  Check out this blog post.The key thing to understand is that git cannot have revision numbers - think about the decentralized nature.  If users A and B are both committing to their local repositories, how can git reasonably assign a sequential revision number?  A has no knowledge of B before they push/pull each other\'s changes.Another thing to look at is simplified branching for bugfix branches:Start with a release: 3.0.8.  Then, after that release, do this:This will create a branch for bugfixes.  Checkout the branch:Now make any bugfix changes you want.Commit them, and switch back to the master branch:Then pull in those changes from the other branch:That way, you have a separate release-specific bugfix branch, but you\'re still pulling the bugfix changes into your main dev trunk.With modern git (1.8.3.4 in my case) and not using branches you can do:The git describe command creates a slightly more human readable name that refers to a specific commit. For example, from the documentation:With something like git.git current tree, I get:i.e. the current head of my "parent" branch is based on v1.0.4, but since it has a few commits on top of that, describe has added the number of additional commits ("14") and an abbreviated object name for the commit itself ("2414721") at the end.As long as you use sensibly named tags to tag particular releases, this can be considered to be roughly equivalent to a SVN "revision number".The other posters are right, there is no "revision-number".I think the best way is to use Tags for "releases"!But I made use of the following to fake revision numbers (just for clients to see revisions and the progress, as they wanted to have the same increasing revisions from git as they where use to by subversion).Show the "current revision" of "HEAD" is simulated by using this:git rev-list HEAD | wc -lBut what if the client tells me that there is a bug in "revision" 1302 ?For this I added the following to the [alias] section of my ~/.gitconfig:show-rev-number = !sh -c \'git rev-list --reverse HEAD | nl | awk \\"{ if(\\\\$1 == "$0") { print \\\\$2 }}\\"\'using git show-rev-number 1302 will then print the hash for the "revision" :)I made a Blog Post (in german) about that "technique" some time ago.Git does not have the same concept of revision numbers as subversion. Instead each given snapshot made with a commit is tagged by a SHA1 checksum. Why? There are several problems with a running revno in a distributed version control system:First, since development is not linear at all, the attachment of a number is rather hard as a problem to solve in a way which will satisfy your need as a programmer. Trying to fix this by adding a number might quickly become problematic when the number does not behave as you expect.Second, revision numbers may be generated on different machines. This makes synchronization of numbers much harder - especially since connectivity is one-way; you may not even have access to all machines that has the repository.Third, in git, somewhat pioneered by the now defunct OpenCM system, the identity of a commit (what the commit is) is equivalent to its name (the SHA id). This naming = identity concept is very strong. When you sit with a commit name in hand it also identifies the commit in an unforgeable way. This in turn lets you check all of your commits back to the first initial one for corruption with the git fsck command.Now, since we have a DAG (Directed Acyclic Graph) of revisions and these constitute the current tree, we need some tools to solve your problem: How do we discriminate different versions. First, you can omit part of the hash if a given prefix, 1516bd say, uniquely identifies your commit. But this is also rather contrived. Instead, the trick is to use tags and or branches. A tag or branch is akin to a "yellow stick it note" you attach to a given commit SHA1-id. Tags are, in essence, meant to be non-moving whereas a branch will move when new commits are made to its HEAD. There are ways to refer to a commit around a tag or branch, see the man page of git-rev-parse.Usually, if you need to work on a specific piece of code, that piece is undergoing changes and should as such be a branch with a saying topic name. Creating lots of branches (20-30 per programmer is not unheard of, with some 4-5 published for others to work on) is the trick for effective git. Every piece of work should start as its own branch and then be merged in when it is tested. Unpublished branches can be rewritten entirely and this part of destroying history is a force of git.When the change is accepted into master it somewhat freezes and becomes archeology. At that point, you can tag it, but more often a reference to the particular commit is made in a bug tracker or issue tracker via the sha1 sum. Tags tend to be reserved for version bumps and branch points for maintenance branches (for old versions).If you\'re interested, I managed version numbers automatically from git infos here under the format where build is the total number of commits. You\'ll see the interesting code in the Makefile. Here is the relevant part to access the different part of the version number:in case this helps anyone else, a bash function outputs something likethat is The SHA1 hash of the commit is the equivalent to a Subversion revision number.Each commit has a unique hash. Other than that there are no revision numbers in git. You\'ll have to tag commits yourself if you want more user-friendliness.The problem with using the git hash as the build number is that it\'s not monotonically increasing. OSGi suggests using a time-stamp for the build number. It looks like the number of commits to the branch could be used in place of the subversion or perforce change number.I wrote some powershell utilities for retrieving version information from git and simplifying tagging functions: Get-LastVersion, Get-Revision, Get-NextMajorVersion, Get-NextMinorVersion, TagNextMajorVersion,TagNextMinorVersion\n:I know this is an old thread, but I recently had to come up with a solution so I thought I would share it. This is what I did in my makefile based on others solutions. Note not only does this give your code a rev number, it also appends the hash which allows you to recreate the release. I\'d just like to note another possible approach - and that is by using git git-notes(1), in existence since v 1.6.6 (Note to Self - Git) (I\'m using git version 1.7.9.5).Basically, I used git svn to clone an SVN repository with linear history (no standard layout, no branches, no tags), and I wanted to compare revision numbers in the cloned git repository. This git clone doesn\'t have tags by default, so I cannot use git describe. The strategy here likely would work only for linear history - not sure how it would turn out with merges etc.; but here is the basic strategy:First, let\'s note that git has a default location of notes - but you can also specify a ref(erence) for notes - which would store them in a different directory under .git; for instance, while in a git repo folder, you can call git notes get-ref to see what directory that will be:The thing to be noted is that if you notes add with a --ref, you must also afterwards use that reference again - otherwise you may get errors like "No note found for object XXX...".For this example, I have chosen to call the ref of the notes "linrev" (for linear revision) - this also means it is not likely the procedure will interfere with already existing notes. I am also using the --git-dir switch, since being a git newbie, I had some problems understanding it - so I\'d like to "remember for later" :); and I also use --no-pager to suppress spawning of less when using git log.So, assuming you\'re in a directory, with a subfolder  myrepo_git which is a git repository; one could do:So, at least in my specific case of fully linear history with no branches, the revision numbers seem to match with this approach - and additionally, it seems that this approach will allow using git log with revision ranges, while still getting the right revision numbers - YMMV with a different context, though...Hope this helps someone,\nCheers!EDIT: Ok, here it is a bit easier, with git aliases for the above loops, called setlinrev and unsetlinrev; when in your git repository folder, do (Note the nasty bash escaping, see also #16136745 - Add a Git alias containing a semicolon): ... so you can simply invoke git setlinrev before trying to do log involving linear revision notes; and git unsetlinrev to delete those notes when you\'re done; an example from inside the git repo directory:The time it would take the shell to complete these aliases, would depend on the size of the repository history. Along with SHA1 id of the commit, date and time of the server time would have helped?\nSomething like this: commit happened at 11:30:25 on 19 aug 2013 would show as \n  6886bbb7be18e63fc4be68ba41917b48f02e09d7_19aug2013_113025For people who have an ant build process, you can generate a version number for a project on git with this target :The result looks like this :The dirty flag is here when you have file(s) not commited when you generate the version number. Because usually, when you build/package your application every code modification has to be in the repository.From the git manual, tags are a brilliant answer to this issue:Creating an annotated tag in Git is simple. The easiest way is to\n  specify -a when you run the tag command:$ git tag -a v1.4 -m \'my version 1.4\' Check out 2.6 Git Basics - TaggingTortoiseGit appears to assume that the first 7 digits of a SHA-1 is the revision. When you view a log on a file, the dialogue shows at the bottom:Showing N revision(s), from revision ABCDEF1 to revision FEFCBA1Is this the right answer if TortoiseGit has deemed it so?After researching in the on line repositories for a long time I found that logically there is no difference between revision number and commit number in git. 