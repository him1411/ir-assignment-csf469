I am trying to write an app that does something specific when it is brought back to the foreground after some amount of time. Is there a way to detect when an app is sent to the background or brought to the foreground?The onPause() and onResume() methods are called when the application is brought to the background and into the foreground again. However, they are also called when the application is started for the first time and before it is killed. You can read more in Activity.There isn\'t any direct approach to get the application status while in the background or foreground, but even I have faced this issue and found the solution with onWindowFocusChanged and onStop.For more details check here Android: Solution to detect when an Android app goes to the background and come back to the foreground without getRunningTasks or getRunningAppProcesses.Here\'s how I\'ve managed to solve this. It works on the premise that using a time reference between activity transitions will most likely provide adequate evidence that an app has been "backgrounded" or not.First, I\'ve used an android.app.Application instance (let\'s call it MyApplication) which has a Timer, a TimerTask, a constant to represent the maximum number of milliseconds that the transition from one activity to another could reasonably take (I went with a value of 2s), and a boolean to indicate whether or not the app was "in the background":The application also provides two methods for starting and stopping the timer/task:The last piece of this solution is to add a call to each of these methods from the onResume() and onPause() events of all activities or, preferably, in a base Activity from which all of your concrete Activities inherit:So in the case when the user is simply navigating between the activities of your app, the onPause() of the departing activity starts the timer, but almost immediately the new activity being entered cancels the timer before it can reach the max transition time. And so wasInBackground would be false.On the other hand when an Activity comes to the foreground from the Launcher, device wake up, end phone call, etc., more than likely the timer task executed prior to this event, and thus wasInBackground was set to true.UPDATE / NOTES (November 2015): People has been making two comments, first is that >= should be used instead of == because the documentation states that you shouldn\'t check for exact values. This is fine for most cases, but bear in mind that if you only care about doing something when the app went to the background, you will have to use == and also combine it with another solution (like Activity Lifecycle callbacks), or you may not get your desired effect. The example (and this happened to me) is that if you want to lock your app with a password screen when it goes to the background (like 1Password if you\'re familiar with it), you may accidentally lock your app if you run low on memory and are suddenly testing for >= TRIM_MEMORY, because Android will trigger a LOW MEMORY call and that\'s higher than yours. So be careful how/what you test.Additionally, some people have asked about how to detect when you get back. The simplest way I can think of is explained below, but since some people are unfamiliar with it, I\'m adding some pseudo code right here. Assuming you have YourApplication and the MemoryBoss classes, in your class BaseActivity extends Activity (you will need to create one if you don\'t have one).I recommend onStart because Dialogs can pause an activity so I bet you don\'t want your app to think "it went to the background" if all you did was display a full screen dialog, but your mileage may vary. And that\'s all. The code in the if block will only be executed once, even if you go to another activity, the new one (that also extends BaseActivity) will report wasInBackground is false so it won\'t execute the code, until onMemoryTrimmed is called and the flag is set to true again.Hope that helps. UPDATE / NOTES (April 2015): Before you go all Copy and Paste on this code, note that I have found a couple of instances where it may not be 100% reliable and must be combined with other methods to achieve the best results.\nNotably, there are two known instances where the onTrimMemory call back is not guaranteed to be executed:If your phone locks the screen while your app is visible (say your device locks after nn minutes), this callback is not called (or not always) because the lockscreen is just on top, but your app is still "running" albeit covered. If your device is relatively low on memory (and under memory stress), the Operating System seems to ignore this call and go straight to more critical levels.Now, depending how important it\'s for you to know when your app went to the background, you may or may not need to extend this solution together with keeping track of the activity lifecycle and whatnot. Just keep the above in mind and have a good QA team ;)END OF UPDATEIt may be late but there\'s a reliable method in Ice Cream Sandwich (API 14) and Above.Turns out that when your app has no more visible UI, a callback is triggered. The callback, which you can implement in a custom class, is called ComponentCallbacks2 (yes, with a two). This callback is only available in API Level 14 (Ice Cream Sandwich) and above.You basically get a call to the method: The Level is 20 or more specifically I\'ve been testing this and it always works, because level 20 is just a "suggestion" that you might want to release some resources since your app is no longer visible.To quote the official docs: Level for onTrimMemory(int): the process had been showing a user interface, and is no longer doing so. Large allocations with the UI should be released at this point to allow memory to be better managed.Of course, you should implement this to actually do what it says (purge memory that hasn\'t been used in certain time, clear some collections that have been sitting unused, etc. The possibilities are endless (see the official docs for other possible more critical levels).But, the interesting thing, is that the OS is telling you: HEY, your app went to the background!Which is exactly what you wanted to know in the first place.How do you determine when you got back? Well that\'s easy, I\'m sure you have a "BaseActivity" so you can use your onResume() to flag the fact that you\'re back. Because the only time you will be saying you\'re not back is when you actually receive a call to the above onTrimMemory method. It works. You don\'t get false positives. If an activity is resuming, you\'re back, 100% of the times. If the user goes to the back again, you get another onTrimMemory() call.You need to suscribe your Activities (or better yet, a custom class).The easiest way to guarantee that you always receive this is to create a simple class like this:In order to use this, in your Application implementation (you have one, RIGHT?), do something like:If you create an Interface you could add an else to that if and implement ComponentCallbacks (without the 2) used in anything below API 14. That callback only has the onLowMemory() method and does not get called when you go to the background, but you should use it to trim memory.Now launch your App and press home. Your onTrimMemory(final int level) method should be called (hint: add logging).The last step is to unregister from the callback. Probably the best place is the onTerminate() method of your App, but, that method doesn\'t get called on a real device: So unless you really have a situation where you no longer want to be registered, you can safety ignore it, since your process is dying at OS level anyway.If you decide to unregister at some point (if you, for example, provide a shutdown mechanism for your app to clean up and die), you can do:And that\'s it. If your app consists of multiple activites and/or stacked activites like a tab bar widget, then overriding onPause() and onResume() will not work. I.e when starting a new activity the current activites will get paused before the new one is created. The same applies when finishing (using "back" button) an activity.I\'ve found two methods that seem to work as wanted.The first one requires the GET_TASKS permission and consists of a simple method that checks if the top running activity on the device belongs to application, by comparing package names:This method was found in the Droid-Fu (now called Ignition) framework.The second method that I\'ve implemented my self does not require the GET_TASKS permission, which is good. Instead it is a little more complicated to implement.In you MainApplication class you have a variable that tracks number of running activities in your application. In onResume() for each activity you increase the variable and in onPause() you decrease it. When the number of running activities reaches 0, the application is put into background IF the following conditions are true:When you can detect that the application has resigned to the background it is easy detect when it is brought back to foreground as well.We use this method. It looks too simple to work, but it was well-tested in our app and in fact works surprisingly well in all cases, including going to home screen by "home" button, by "return" button, or after screen lock. Give it a try.Idea is, when in foreground, Android always starts new activity just before stopping previous one. That\'s not guaranteed, but that\'s how it works. BTW, Flurry seems to use the same logic (just a guess, I didn\'t check that, but it hooks at the same events). Edit: as per comments, we also moved to onStart() in later versions of the code. Also, I\'m adding super calls, which were missing from my initial post, because this was more of a concept than a working code.Based on Mart\xc3\xadn Marconcinis answer (thanks!) I finally found a reliable (and very simple) solution.Then add this to your onCreate() of your Application classYes. I know it\'s hard to believe this simple solution works since we have so many weird solutions here.But there is hope.Create a class that extends Application. Then in it we can use its override method, onTrimMemory().To detect if the application went to the background, we will use:Consider using onUserLeaveHint. This will only be called when your app goes into the background. onPause will have corner cases to handle, since it can be called for other reasons; for example if the user opens another activity in your app such as your settings page, your main activity\'s onPause method will be called even though they are still in your app; tracking what is going in will lead to bugs when you can instead simply use the onUserLeaveHint callback which does what you are asking.When on  UserLeaveHint is called, you can set a boolean inBackground flag to true. When onResume is called, only assume you came back into the foreground if the inBackground flag is set. This is because onResume will also be called on your main activity if the user was just in your settings menu and never left the app.Remember that if the user hits the home button while in your settings screen, onUserLeaveHint will be called in your settings activity, and when they return onResume will be called in your settings activity. If you only have this detection code in your main activity you will miss this use case. To have this code in all your activities without duplicating code, have an abstract activity class which extends Activity, and put your common code in it. Then each activity you have can extend this abstract activity.For example:ActivityLifecycleCallbacks might be of interest, but it isn\'t well documented. Though, if you call registerActivityLifecycleCallbacks() you should be able to get callbacks for when Activities are created, destroyed, etc. You can call getComponentName() for the Activity.In your Application add the callback and check for root activity in a way like this:I have created a project on Github app-foreground-background-listenCreate a BaseActivity for all Activity in your application.Now use this BaseActivity as a super class of all your Activity like MainActivity extends BaseActivity and onAppStart will be called when you start your application and onAppPause() will be called when the application goes the background from any screen.Edit 2: What I\'ve written below will not actually work. Google has rejected an app that includes a call to ActivityManager.getRunningTasks(). From the documentation, it is apparent that this API is for debugging and development purposes only. I\'ll be updating this post as soon as I have time to update the GitHub project below with a new scheme that uses timers and is almost as good.Edit 1: I\'ve written up a blog post and created a simple GitHub repository to make this really easy.The accepted and top rated answer are both not really the best approach. The top rated answer\'s implementation of isApplicationBroughtToBackground() does not handle the situation where the Application\'s main Activity is yielding to an Activity that is defined in the same Application, but it has a different Java package. I came up with a way to do this that will work in that case.Call this in onPause(), and it will tell you if your application is going into the background because another application has started, or the user has pressed the home button.My solution was inspired by @d60402\'s answer and also relies on a time-window, but not using the Timer:where the SingletonApplication is an extension of Application class:I found a good method to detect application whether enter foreground or background.\nHere is my code. \nHope this help you.}You can use:protected void onRestart ()To differ between new starts and restarts. i know its a little late but i think all these answers do have some problems while i did it like below and that works perfect.create a activity life cycle callback like this:and just register it on your application class like below:ProcessLifecycleOwner seems to be a promising solution also.ProcessLifecycleOwner will dispatch ON_START, ON_RESUME events, as a first activity moves through these events. ON_PAUSE, ON_STOP, events will be dispatched with a delay after a last activity passed through them. This delay is long enough to guarantee that ProcessLifecycleOwner won\'t send any events if activities are destroyed and recreated due to a configuration change.An implementation can be as simple asAccording to source code, current delay value is 700ms.What I did is make sure that all in-app activities are launched with startActivityForResult then checking if onActivityResult was called before onResume. If it wasn\'t, it means we just returned from somewhere outside our app.This is my solution https://github.com/doridori/AndroidUtils/blob/master/App/src/main/java/com/doridori/lib/app/ActivityCounter.javaBasically involved counting the lifecycle methods for all Activity\'s with a timer to catch cases where there is no activity currently in the foreground but the app is (i.e. on rotation) Here is my solution. Just register this ActivityLifecycleCallbacks in your main Application class. In the comments, I mention a user profile Activity edge case. That Activity is simply one with transparent edges.My app needs to "reboot" after return from background - show a series of activities, according to client solicitations. After extensive search on how to manage the background/foreground transitions (treated very differently between iOS and Android), I crossed this question. Found very useful help here, specially from the most voted answer and the one flagged as correct. However, simply reinstantiate the root activity EVERY TIME the app enters foreground looked too annoying, when you think about UX. The solution that worked for me, and the one I think\'s most adequated - based on the Youtube and Twitter apps functionality - was to combine the answers from @GirishNair and @d60402: Calling the timer when the app\'s trimming memory, as follows:My Timer limit is set to 30 seconds - I\'m thinking about increasing this a little.And when app goes into foreground, is relaunched, or the app\'s destroyed, call the method to cancel timer.On App extension:On the activity (preferably on a base activity, inherited by the others):In my case, when app goes foreground after the max time, a new task is created, so the stopActivityTransitionTimer() is called upon onActivityCreated() or onActivityDestroyed(), in the app extension class - turning unnecessary to call the method in an activity.\nHope it helps.I was using this with Google Analytics EasyTracker, and it worked. It could be extended to do what you seek using a simple integer.How about this solutionAll Activity need to extends BaseActivity.When an activity call another (A->B) then currentAct is not equal getLocalClassName() because the onStart() of the second activity (B) is called before the onStop() of the first (A) (https://developer.android.com/guide/components/activities.html#CoordinatingActivities). When the user press the home button or change between application will just call onStop() and then currentAct is equal getLocalClassName().This appears to be one of the most complicated questions in Android since (as of this writing) Android doesn\'t have iOS equivalents of applicationDidEnterBackground() or applicationWillEnterForeground() callbacks. I used an AppState Library that was put together by @jenzz. [AppState is] a simple, reactive Android library based on RxJava that monitors app state changes. It notifies subscribers every time the app goes into background and comes back into foreground.It turned out this is exactly what I needed, especially because my app had multiple activities so simply checking onStart() or onStop() on an activity wasn\'t going to cut it. First I added these dependencies to gradle:Then it was a simple matter of adding these lines to an appropriate place in your code:Depending on how you subscribe to the observable, you may have to unsubscribe from it to avoid memory leaks. Again more info on the  github page.  These answers don\'t seem to be correct. These methods are also called when another activity starts and ends. What you can do is keep a global flag (yes, globals are bad:) and set this to true each time you start a new activity. Set it to false in the onCreate of each activity. Then, in the onPause you check this flag. If it\'s false, your app is going into the background, or it\'s getting killed.I\'m using this solution:\nhttp://nathanael.hevenet.com/android-dev-detecting-when-your-app-is-in-the-background-across-activities/In short- Build a dedicate service that every activity report him about each lifecycle event, and this service get the info about the status of the app.Very much like @oldschool4664 solution, but cleaner in my opinion The principal problem is that you have to get an specific behavior when you start an activity from background. If you override your onPause() and onResume() methods, you\'ll have a close answer, but not the solution. The problem is that onPause() and onResume() methods are called even if you don\'t minimize your application, they can be called when you start an activity and later you press the back button to return to your activity.\nTo eliminate that problem and to know really when your application comes from background, you must to get the running process and compare with your process:Now you have to declare a boolean variable:And ask when your activity comes to background:Now, when your activity comes to the screen again, ask in onResume() method:And this is it. Now, when your activity comes to background, and later the user brings it to foreground, the lock screen will appear.If you want to repeat this behavior for whatever activity of your app, you have to create an activity (could be BaseActivity), put this methods, and all your activities have to inherit from BaseActivity.I hope that this help to you.Greetings!