Can some one please explain me Promise vs Observable in Angular?Any sample of each would be help in understanding both cases.\nAnd when to use each case with scenario.PromiseA Promise handles a single event when an async operation completes or fails. Note: There are Promise libraries out there that support cancellation, but ES6 Promise doesn\'t so far.ObservableAn Observable is like a Stream (in many languages) and allows to pass zero or more events where the callback is called for each event.Often Observable is preferred over Promise because it provides the features of Promise and more. With Observable it doesn\'t matter if you want to handle 0, 1, or multiple events. You can utilize the same API in each case. Observable also has the advantage over Promise to be cancelable. If the result of an HTTP request to a server or some other expensive async operation isn\'t needed anymore, the Subscription of an Observable allows to cancel the subscription, while a Promise will eventually call the success or failed callback even when you don\'t need the notification or the result it provides anymore.Observable provides operators like map, forEach, reduce, ... similar to an arrayThere are also powerful operators like retry(), or replay(), ... that are often quite handy.! Promises vs ObservablesBoth Promises and Observables provide us with abstractions that help us deal with the asynchronous nature of our applications. The difference between them was pointed out clearly by @G\xc3\xbcnter and @Relu. Since a code snippet is worth a thousand words, let go through the below example to understand them easier. Thanks @Christoph Burgdorf for the awesome articleAngular 2 uses Rx.js Observables instead of promises for dealing with HTTP.Suppose that you are building a search function that should instantly show you results as you type. Sound familiar but there are a lot of challenges that come with that task.The demo will simply consist of two files: app.ts and wikipedia-service.ts. In a real world scenario, we would most likely split things further up, though.Below is Promise-based implementation that doesn\xe2\x80\x99t handle any of the described edge cases.wikipedia-service.tsWe are injecting the Jsonp service to make a GET request against the Wikipedia API with a given search term. Notice that we call toPromise in order to get from an Observable<Response> to a Promise<Response>. Eventually end up with a Promise<Array<string>> as the return type of our search method.app.tsNot much of a surprise here either. We inject our WikipediaService and expose it\xe2\x80\x99s functionality via a search method to the template. The template simply binds to keyup and calls search(term.value).We unwrap the result of the Promise that the search method of the WikipediaService returns and expose it as a simple Array of strings to the template so that we can have *ngFor loop through it and build up a list for us.See the example of Promise-based implementation on PlunkerWhere Observables really shineLet\xe2\x80\x99s change our code to not hammer the endpoint with every keystroke but instead only send a request when the user stopped typing for 400 msTo unveil such super powers we first need to get an Observable<string> that carries the search term that the user types in. Instead of manually binding to the keyup event, we can take advantage of Angular\xe2\x80\x99s formControl directive. To use this directive, we first need to import the ReactiveFormsModule into our application module.app.tsOnce imported, we can use formControl from within our template and set it to the name "term".In our component, we create an instance of FormControl from @angular/form and expose it as a field under the name term on our component.Behind the scenes, term automatically exposes an Observable<string> as property valueChanges that we can subscribe to. Now that we have an Observable<string>, overcoming the user input is as easy as calling debounceTime(400) on our Observable. This will return a new Observable<string> that will only emit a new value when there haven\xe2\x80\x99t been coming new values for 400ms.It would be a waste of resources to send out another request for a search term that our app already shows the results for.  All we have to do to achieve the desired behavior is to call the distinctUntilChanged operator right after we called debounceTime(400)See the example of Observable implementation on PlunkerFor dealing with out-of-order responses, please check the full article\n  http://blog.thoughtram.io/angular/2016/01/06/taking-advantage-of-observables-in-angular2.htmlAs far as I am using Http in Angular 2, I agree that in the normal use cases there is not much difference when using Observable over Promise. None of the advantages are really relevant here in practice. Hope I can see some advanced use case in the future :)Learn morePromisesObservablesOne operator retry can be used to retry when ever needed, also if we need to retry the observable based on some conditions retryWhen can be used.Note: A list of operators along with their interactive diagrams is available here at RxMarbles.comBoth Promises and Observables will help us work with the asynchronous functionalities of JavaScript. They are very similar in most cases, however, there are some differences between the two, promises are values that will resolve in asynchronous way like http calls. On the other hand, observables deal with sequence of asynchronous events. The main differences are as below:promise:observable:Also, I\'ve created the graphical image for you below to show the differences visually:There is one downside of Observables missing in the answers. Promises allow to use the ES7 async/await functions. With them you can write asynchronous code like it would be a synchronous function call, so you don\'t need callbacks anymore. The only possibility for Observables to do this, is to convert them to Promises. But when you convert them to Promises, you can only have one return value again:Further reading: How can I `await` on an Rx Observable? I\'ve just dealt with an issue where Promises were the best solution, and I\'m sharing it here for anyone stumbling across this question in the event it\'s useful (this was exactly the answer I was looking for earlier):In an Angular2 project I have a service that takes some parameters and returns a value list to populate drop down menus on a form. When the form component initializes, I need to call the same service multiple times with different parameters to define a number of different dropdown menus, however if I simply queue up all the variables to call the service, only the last one succeeds and the rest error out. The service fetching from the database could only handle one request at a time.The only way to successfully populate all the dropdown menu variables was to call the service in a way that prevented a new request from being processed until the last request was finished, and the Promise / .then mechanism solved the problem nicely.I defined the functions in the component, and then called initializeDropDowns() in ngOnInit.The fetchValueList function returns a Promise, so the first call passes the first listCode and when the Promise resolves, the return value is in the data variable in the .then block where we can assign it to the this.firstValList variable. As the function has returned data, we know the service has finished and it\'s safe to call again with the second listCode, the return value is in the data variable in the next .then block and we assign it to the this.secondValList variable.We can chain this as many times as required to populate all the variables, and on the last code block we simply omit the return statement and the block terminates.This is a very specific use case where we have a single service that needs to be called multiple times as the component initializes, and where the service has to complete its fetch and return a value before it can be called again, but in this case, the Promise / .then method was ideal.I believe all the other answers should clear your doubts.\nNevertheless, I just wanted to add that observables are based on functional programming, and I find very useful the functions that come with it like map, flatmap, reduce, zip. The consistency the web achieves especially when it depends on API requests is a brutal improvement.I strongly recommend this documentation, since it\'s the official documentation of reactiveX and I find it to be the most clear out there.If you want to get into observables I would suggest this 3part post:\nhttp://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/Although it\'s meant for RxJava, the concepts are the same, and it\'s really well explained. In reactiveX documentation you have the equivalences for each function. You must look for RxJS.I Hope this helps, just tried contribute here. :)