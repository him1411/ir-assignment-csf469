Why does the order in which libraries are linked sometimes cause errors in GCC?(See the history on this answer to get the more elaborate text, but I now think it\'s easier for the reader to see real command lines).Common files shared by all below commandsThe linker searches from left to right, and notes unresolved symbols as it go. If a library resolves the symbol, it takes the object files of that library to resolve the symbol (b.o out of libb.a in this case). Dependencies of static libraries against each other work the same - the library that needs symbols must be first, then the library that resolves the symbol.If a static library depends on another library, but the other library again depends on the former library, there is a cycle. You can resolve this by enclosing the cyclically dependent libraries by -( and -), such as -( -la -lb -) (you may need to escape the parens, such as -\\( and -\\)). The linker then searches those enclosed lib multiple times to ensure cycling dependencies are resolved. Alternatively, you can specify the libraries multiple times, so each is before one another: -la -lb -la.It\'s the same here - the libraries must follow the object files of the program. The difference here with the static libraries is that you must not care about the dependencies of the libraries against each other, because dynamic libraries sort out their dependencies themselves. Some recent distributions apparently default to using the --as-needed linker flag, which enforces that the program\'s object files come before the dynamic libraries. If that flag is passed, the linker will not link to libraries that are not actually needed by the executable (and it detects this from left to right). My recent archlinux distribution doesn\'t use this flag by default, so it didn\'t give an error for not following the correct order.It is not correct to omit the dependency of b.so against d.so when creating the former. You will be required to specify the library when linking a then, but a doesn\'t really need the integer b itself, so it should not be made to care about b\'s own dependencies. Here is an example of the implications if you miss specifying the dependencies for libb.soIf you now look into what dependencies the binary has, you note the binary itself depends also on libd, not just libb as it should. The binary will need to be relinked if libb later depends on another library, if you do it this way. And if someone else loads libb using dlopen at runtime (think of loading plugins dynamically), the call will fail as well. So the "right" really should be a wrong as well. The GNU ld linker is a so-called smart linker.  It will keep track of the functions used by preceding static libraries, permanently tossing out those functions that are not used from its lookup tables.  The result is that if you link a static library too early, then the functions in that library are no longer available to static libraries later on the link line.  The typical UNIX linker works from left to right, so put all your dependent libraries on the left, and the ones that satisfy those dependencies on the right of the link line.  You may find that some libraries depend on others while at the same time other libraries depend on them.  This is where it gets complicated.  When it comes to circular references, fix your code!Here\'s an example to make it clear how things work with GCC when static libraries are involved. So let\'s assume we have the following scenario:How do we link this? (Note: examples from compiling on Cygwin using gcc 4.3.4)If you add -Wl,--start-group to the linker flags it does not care which order they\'re in or if there are circular dependencies.On Qt this means adding: Saves loads of time messing about and it doesn\'t seem to slow down linking much (which takes far less time than complication anyway)You may can use -Xlinker option.is ALMOST equal toCareful !Another alternative would be to specify the list of libraries twice:Doing this, you don\'t have to bother with the right sequence since the reference will be resolved in the second block.I have seen this a lot, some of our modules link in excess of a 100 libraries of our code plus system & 3rd party libs. Depending on different linkers HP/Intel/GCC/SUN/SGI/IBM/etc you can get unresolved functions/variables etc, on some platforms you have to list libraries twice. For the most part we use structured hierarchy of libraries, core, platform, different layers of abstraction, but for some systems you still have to play with the order in the link command.Once you hit upon a solution document it so the next developer does not have to work it out again.My old lecture used to say, "high cohesion & low coupling", it\xe2\x80\x99s still true today.A quick tip that tripped me up: if you\'re invoking the linker as "gcc" or "g++", then using "--start-group" and "--end-group" won\'t pass those options through to the linker -- nor will it flag an error. It will just fail the link with undefined symbols if you had the library order wrong.You need to write them as "-Wl,--start-group" etc. to tell GCC to pass the argument through to the linker.Link order certainly does matter, at least on some platforms. I have seen crashes for applications linked with libraries in wrong order (where wrong means A linked before B but B depends on A).I would imagine it is because some of those libraries have dependencies on other libraries, and if they have not been linked yet then you would get linker errors.