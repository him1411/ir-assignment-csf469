What is a segmentation fault? Is it different in C and C++? How are segmentation faults and dangling pointers related?Segmentation fault is a specific kind of error caused by accessing memory that \xe2\x80\x9cdoes not belong to you.\xe2\x80\x9d It\xe2\x80\x99s a helper mechanism that keeps you from corrupting the memory and introducing hard-to-debug memory bugs. Whenever you get a segfault you know you are doing something wrong with memory \xe2\x80\x93 accessing variable that has already been freed, writing to a read-only portion of the memory, etc. Segmentation fault is essentially the same in most languages that let you mess with the memory management, there is no principial difference between segfaults in C and C++.There are many ways to get a segfault, at least in the lower-level languages such as C(++). A\xc2\xa0common way to get a segfault is to dereference a null pointer:Another segfault happens when you try to write to a portion of memory that was marked as read-only:Dangling pointer points to a thing that does not exist any more, like here:The pointer p dangles because it points to character variable c that ceased to exist after the block ended. And when you try to dereference dangling pointer (like *p=\'A\'), you would probably get a segfault.It would be worth noting that segmentation fault isn\'t caused by directly accessing another process memory (this is what I\'m hearing sometimes), as it is simply not possible. With virtual memory every process has its own virtual address space and there is no way to access another one using any value of pointer. Exception to this can be shared libraries which are same physical address space mapped to (possibly) different virtual addresses and kernel memory which is even mapped in the same way in every process (to avoid TLB flushing on syscall, I think). And things like shmat ;) - these are what I count as \'indirect\' access. One can, however, check that they are usually located long way from process code and we are usually able to access them (this is why they are there, nevertheless accessing them in a improper way will produce segmentation fault).Still, segmentation fault can occur in case of accessing our own (process) memory in improper way (for instance trying to write to non-writable space). But the most common reason for it is the access to the part of the virtual address space that is not mapped to physical one at all.And all of this with respect to virtual memory systems.A segmentation fault is caused by a request for a page that the process does not have listed in its descriptor table, or an invalid request for a page that it does have listed (e.g. a write request on a read-only page).A dangling pointer is a pointer that may or may not point to a valid page, but does point to an "unexpected" segment of memory.To be honest, as other posters have mentioned, Wikipedia has a very good article on this so have a look there. This type of error is very common and often called other things such as Access Violation or General Protection Fault.They are no different in C, C++ or any other language that allows pointers. These kinds of errors are usually caused by pointers that areAccording to wikipedia:A segmentation fault occurs when a\n  program attempts to access a memory\n  location that it is not allowed to\n  access, or attempts to access a memory\n  location in a way that is not allowed\n  (for example, attempting to write to a\n  read-only location, or to overwrite\n  part of the operating system).While Zoul\'s answer explains what a segmentation fault is, I have found that these kind of bugs can be particular hard to catch, especially if you are new to low-level languages like C++ or C. Here are some of the common ways to get a segmentation fault in your program:Improper format control string in printf or scanf statementsFormat control string should have the same number of conversion specifiers (%s, %d etc.) as the printf or scanf has arguments to be printed or read. The same applies for fprintf and fscanf.Not using & on the arguments to scanfFunction scanf takes as arguments the format control string and the addresses of variables in which it will place the data that it reads in. The & (address of) operator is used to supply the address of a variable.Out-of-bounds array referencesMake sure that you have not violated the bounds of any array you are using; i.e., you have not subscripted the array with a value less than the index of its lowest element or greater than the index of its highest element. Valgrind can come in handy to detect such references - you can use valgrind with the --tool=exp-sgcheck flag.Accessing uninitialized pointersA pointer variable must be assigned a valid address before being accessed. Make sure that you have initialized all pointers to point to a valid area of memory.Incorrect use of the & (address of) and * (dereferencing) operatorsYou would need to be careful when using these, especially while passing parameters by reference/using pointers.Shell LimitsSometimes segmentation faults are not caused by bugs in the program but are caused instead by system memory limits being set too low. Usually it is the limit on stack size that causes this kind of problem (stack overflows). To check memory limits, use the ulimit command in bash.Debugging using gdbYou can use the debugger gdb to view the backtrace of the core file dumped by your program. Whenever programs segfault, they usually dump the content of memory at the time of the crash into a core file (core dumped). Compile your program with the -g flag, run in gdb and use bt (backtrace). Segmentation fault is also caused by hardware failures, in this case the RAM memories. This is the less common cause, but if you don\'t find an error in your code, maybe a memtest could help you.The solution in this case, change the RAM.edit:Here there is a reference: Segmentation fault by hardwareSegmentation fault occurs when a process (running instance of a program) is trying to access read-only memory address or memory range which is being used by other process or access the non-existent (invalid) memory address.\nDangling Reference (pointer) problem means that trying to access an object or variable whose contents have already been deleted from memory, e.g:Wikipedia\'s Segmentation_fault page has a very nice description about it, just pointing out the causes and reasons. Have a look into the wiki for a detailed description.In computing, a segmentation fault (often shortened to segfault) or access violation is a fault raised by hardware with memory protection, notifying an operating system (OS) about a memory access violation.The following are some typical causes of a segmentation fault:These in turn are often caused by programming errors that result in invalid memory access:Dereferencing or assigning to an uninitialized pointer (wild pointer, which points to a random memory address)Dereferencing or assigning to a freed pointer (dangling pointer, which points to memory that has been freed/deallocated/deleted)A buffer overflow.A stack overflow.Attempting to execute a program that does not compile correctly. (Some compilers will output an executable file despite the presence of compile-time errors.)In simple words: segmentation fault is the operating system sending a signal to the program\nsaying that it has detected an illegal memory access and is prematurely terminating the program to prevent\nmemory from being corrupted.A segmentation fault or access violation occurs when a program attempts to access a memory location that is not exist, or attempts to access a memory location in a way that is not allowed.Here i[1000] not exist, so segfault occurs.Causes of segmentation fault: