Is there a way to determine how many cores a machine has from C/C++ in a platform-independent way? If no such thing exists, what about determining it per-platform (Windows/*nix/Mac)?Reference: std::thread::hardware_concurrencyIn C++ prior to C++11, there\'s no portable way.  Instead, you\'ll need to use one or more of the following methods (guarded by appropriate #ifdef lines):This functionality is part of the C++11 standard.For older compilers, you can use the Boost.Thread library.In either case, hardware_concurrency() returns the number of threads that the hardware is capable of executing concurrently based on the number of CPU cores and hyper-threading units.OpenMP is supported on many platforms (including Visual Studio 2005) and it offers a function that returns the number of processors/cores available at the time of call.If you have assembly-language access, you can use the CPUID instruction to get all sorts of information about the CPU. It\'s portable between operating systems, though you\'ll need to use manufacturer-specific information to determine how to find the number of cores. Here\'s a document that describes how to do it on Intel chips, and page 11 of this one describes the AMD specification.(Almost) Platform Independent function in c-codeOn Linux, you can read the /proc/cpuinfo file and count the cores.Note that "number of cores" might not be a particularly useful number, you might have to qualify it a bit more.  How do you want to count multi-threaded CPUs such as Intel HT, IBM Power5 and Power6, and most famously, Sun\'s Niagara/UltraSparc T1 and T2? Or even more interesting, the MIPS 1004k with its two levels of hardware threading (supervisor AND user-level)... Not to mention what happens when you move into hypervisor-supported systems where the hardware might have tens of CPUs but your particular OS only sees a few.The best you can hope for is to tell the number of logical processing units that you have in your local OS partition. Forget about seeing the true machine unless you are a hypervisor. The only exception to this rule today is in x86 land, but the end of non-virtual machines is coming fast...You probably won\'t be able to get it in a platform independent way.  Windows you get number of processors.Win32 System InformationOne more Windows recipe: use system-wide environment variable NUMBER_OF_PROCESSORS:Windows Server 2003 and later lets you leverage the GetLogicalProcessorInformation functionhttp://msdn.microsoft.com/en-us/library/ms683194.aspxUnrelated to C++, but on Linux I usually do:Handy for scripting languages like bash/perl/python/ruby.hwloc (http://www.open-mpi.org/projects/hwloc/) is worth looking at. Though requires another library integration into your code but it can provide all the information about your processor (number of cores, the topology, etc.)More on OS X: sysconf(_SC_NPROCESSORS_ONLN) is available only versions >= 10.5, not 10.4.An alternative is the HW_AVAILCPU/sysctl() BSD code which is available on versions >= 10.2.On linux the best programmatic way as far as I know is to useorThese aren\'t standard, but are in my man page for Linux.On Linux, it\'s may not be safe to to use _SC_NPROCESSORS_ONLN as it\'s not part of POSIX standard and the sysconf manual states as much. So there\'s a possibility that _SC_NPROCESSORS_ONLN may not be present:A simple approach would be to read /proc/stat or /proc/cpuinfo and count them:Using /proc/cpuinfo:The same approach in shell using grep:OrOS X alternative: The solution described earlier based on [[NSProcessInfo processInfo] processorCount] is only available on OS X 10.5.0, according to the docs.  For earlier versions of OS X, use the Carbon function MPProcessors().If you\'re a Cocoa programmer, don\'t be freaked out by the fact that this is Carbon.  You just need to need to add the Carbon framework to your Xcode project and MPProcessors() will be available.For Win32:While GetSystemInfo() gets you the number of logical processors, use\nGetLogicalProcessorInformationEx()\n  to get the number of physical processors.The number of groups of logical processors sharing a single processor core. (Using GetLogicalProcessorInformationEx, see GetLogicalProcessorInformation as well)Note that the implementation of NumberOfPhysicalCores is IMHO far from trivial (i.e. "use GetLogicalProcessorInformation or GetLogicalProcessorInformationEx"). Instead it is rather subtle if one reads the documentation (explicitly present for GetLogicalProcessorInformation and implicitly present for GetLogicalProcessorInformationEx) at MSDN.The number of logical processors. (Using GetSystemInfo)Note that both methods can easily be converted to C/C++98/C++03.you can use WMI in .net too but you\'re then dependent on the wmi service running\netc. Sometimes it works locally, but then fail when the same code is run on servers.\nI believe that\'s a namespace issue, related to the "names" whose values you\'re reading.In Linux, you can checkout dmesg and filter the lines where ACPI initializes the CPUs, something like:dmesg | grep \'ACPI: Processor\'Other possibility is to use dmidecode to filter out the processor information.