If I throw a Javascript exception myself (eg, throw "AArrggg"), how can I get the stack trace (in Firebug or otherwise)?  Right now I just get the message.edit: As many people below have posted, it is possible to get a stack trace for a JavaScript exception but I want to get a stack trace for my exceptions.  For example:When foo is called, I want to get a stack trace which includes the calls to foo, bar, bar.A modified version of this snippet may somewhat help:EDIT (2017) :In all modern browsers you can simply call: console.trace(); (MDN Reference)EDIT :A better (and simpler) solution as pointed out in the comments on the original question is to use the stack property of an Error object like so:This will generate output like this:Giving the name of the calling function along with the URL, its calling function, and so on.Note that chromium/chrome (other browsers using V8) do have a convenient interface to get a stacktrace through a stack property on Error objects.It applies for the base exceptions as well as for the ones you throw yourself. (Considered that you use the Error class, which is anyway a good practice).See details on V8 documentationIn Firefox it seems that you don\'t need to throw the exception.  It\'s sufficient to doIf you have firebug, there\'s a break on all errors option in the script tab. Once the script has hit your breakpoint, you can look at firebug\'s stack window:I don\'t think there\'s anything built in that you can use however I did find lots of examples of people rolling their own.A good (and simple) solution as pointed out in the comments on the original question is to use the stack property of an Error object like so:This will generate output like this:Giving the name of the calling function along with the URL and line number, its calling function, and so on.I have a really elaborate and pretty solution that I have devised for a project I am currently working on and I have extracted and reworked it a bit to be generalized. Here it is:Check it out on GitHub (currently v1.2)! You can use it like Console.debug("Whatever"); and it will, depending on the settings in Console, print the output and a stack trace (or just simple info/nothing extra at all). Here\'s an example:Make sure to play around with the settings in the Console object! You can add spacing between the lines of the trace and turn it off entirely. Here it is with Console.trace set to false:You can even turn off the first bit of info shown (set Console.settings.debug.showInfo to false) or disable debugging entirely (set Console.settings.debug.enabled to false) so you never have to comment out a debug statement again! Just leave them in and this will do nothing.You can access the stack (stacktrace in Opera) properties of an Error instance even if you threw it. The thing is, you need to make sure you use throw new Error(string) (don\'t forget the new instead of throw string.Example:one way to get a the real stack trace on Firebug is to create a real error like calling an undefined function:Or use console.error() followed by a throw statement since console.error() shows the stack trace.With Chrome browser, you can use console.trace method: https://developer.chrome.com/devtools/docs/console-api#consoletraceobjectAn update to Eugene\'s answer: The error object must be thrown in order for IE (specific versions?) to populate the stack property. The following should work better than his current example, and should avoid returning undefined when in IE.Note 1: This sort of thing should only be done when debugging, and disabled when live, especially if called frequently. Note 2: This may not work in all browsers, but seems to work in FF and IE 11, which suits my needs just fine.This will give a stack trace (as array of strings) for modern Chrome, Opera, Firefox and IE10+Usage:It excludes from the stack its own call as well as title "Error" that is used by Chrome and Firefox (but not IE).It shouldn\'t crash on older browsers but just return empty array. If you need more universal solution look at stacktrace.js. Its list of supported browsers is really impressive but to my mind it is very big for that small task it is intended for: 37Kb of minified text including all dependencies. In Google Chrome (version 19.0 and beyond), simply throwing an exception works perfectly. For example:will show the stack trace at the browser\'s console output:Hope this help.this script will show the errorfunction:use case:You could use this library http://www.stacktracejs.com/ . It\'s very goodFrom documentationYou can also pass in your own Error to get a stacktrace not available\n  in IE or Safari 5-This polyfill code working in modern (2017) browsers (IE11, Opera, Chrome, FireFox, Yandex):Other answers: not working in IE 11 !Using arguments.callee.caller - not working in strict mode in any browser!It is easier to get a stack trace on Firefox than it is on IE but fundamentally here is what you want to do:Wrap the "problematic" piece of code in a try/catch block:If you will examine the contents of the "error" object it contains the following fields:e.fileName : The source file / page where the issue came from\ne.lineNumber : The line number in the file/page where the issue arose \ne.message : A simple message describing what type of error took place\ne.name : The type of error that took place, in the example above it should be \'TypeError\'\ne.stack : Contains the stack trace that caused the exceptionI hope this helps you out.Kind of late to the party, but, here is another solution, which autodetects if arguments.callee is available, and uses new Error().stack if not.\nTested in chrome, safari and firefox.2 variants - stackFN(n) gives you the name of the function n away from the immediate caller, and stackArray() gives you an array, stackArray()[0] being the immediate caller.Try it out at http://jsfiddle.net/qcP9y/6/I had to investigate an endless recursion in smartgwt with IE11, so in order to investigate deeper, I needed a stack trace. The problem was, that I was unable to use the dev console, because the reproduction was more difficult that way.\nUse the following in a javascript method:Wow - I don\'t see a single person in 6 years suggesting that we check first to see if stack is available before using it! The worst thing you can do in an error handler is throw an error because of calling something that doesn\'t exist.As others have said, while stack is mostly safe to use now it is not supported in IE9 or earlier.I log my unexpected errors and a stack trace is pretty essential. For maximum support I first check to see if Error.prototype.stack exists and is a function. If so then it is safe to use error.stack. Edit: It appears that since stack is a property and not a method you can safely call it even on older browsers. I\'m still confused because I was pretty sure checking Error.prototype worked for me previously and now it doesn\'t - so I\'m not sure what\'s going on.Using console.error(e.stack) Firefox only shows the stacktrace in logs,\nChrome also shows the message.\nThis can be a bad surprise if the message contains vital information. Always log both.Here is an answer that gives you max performance (IE 6+) and max compatibility. Compatible with IE 6!Just tryThis works pretty well for chrome: