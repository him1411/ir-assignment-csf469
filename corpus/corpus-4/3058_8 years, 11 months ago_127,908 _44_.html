The MSDN documentation says thatis "a problem if the instance can be accessed publicly". I\'m wondering why? Is it because the lock will be held longer than necessary? Or is there some more insidious reason?It is bad form to use this in lock statements because it is generally out of your control who else might be locking on that object.In order to properly plan parallel operations, special care should be taken to consider possible deadlock situations, and having an unknown number of lock entry points hinders this. For example, any one with a reference to the object can lock on it without the object designer/creator knowing about it. This increases the complexity of multi-threaded solutions and might affect their correctness.A private field is usually a better option as the compiler will enforce access restrictions to it, and it will encapsulate the locking mechanism. Using this violates encapsulation by exposing part of your locking implementation to the public. It is also not clear that you will be acquiring a lock on this unless it has been documented. Even then, relying on documentation to prevent a problem is sub-optimal.Finally, there is the common misconception that lock(this) actually modifies the object passed as a parameter, and in some way makes it read-only or inaccessible. This is false. The object passed as a parameter to lock merely serves as a key. If a lock is already being held on that key, the lock cannot be made; otherwise, the lock is allowed.This is why it\'s bad to use strings as the keys in lock statements, since they are immutable and are shared/accessible across parts of the application. You should use a private variable instead, an Object instance will do nicely.Run the following C# code as an example.Console outputBecause if people can get at your object instance (ie: your this) pointer, then they can also try to lock that same object. Now they might not be aware that you\'re locking on this internally, so this may cause problems (possibly a deadlock)In addition to this, it\'s also bad practice, because it\'s locking "too much"For example, you might have a member variable of List<int>, and the only thing you actually need to lock is that member variable. If you lock the entire object in your functions, then other things which call those functions will be blocked waiting for the lock. If those functions don\'t need to access the member list, you\'ll be causing other code to wait and slow down your application for no reason at all.Take a look at the MSDN Topic Thread Synchronization (C# Programming Guide)Generally, it is best to avoid locking\n  on a public type, or on object\n  instances beyond the control of your\n  application. For example, lock(this)\n  can be problematic if the instance can\n  be accessed publicly, because code\n  beyond your control may lock on the\n  object as well. This could create\n  deadlock situations where two or more\n  threads wait for the release of the\n  same object. Locking on a public\n  data type, as opposed to an object,\n  can cause problems for the same\n  reason. Locking on literal strings is\n  especially risky because literal\n  strings are interned by the common\n  language runtime (CLR). This means\n  that there is one instance of any\n  given string literal for the entire\n  program, the exact same object\n  represents the literal in all running\n  application domains, on all threads.\n  As a result, a lock placed on a string\n  with the same contents anywhere in the\n  application process locks all\n  instances of that string in the\n  application. As a result, it is best\n  to lock a private or protected member\n  that is not interned. Some classes\n  provide members specifically for\n  locking. The Array type, for example,\n  provides SyncRoot. Many collection\n  types provide a SyncRoot member as\n  well.I know this is an old thread, but because people can still look this up and rely on it, it seems important to point out that lock(typeof(SomeObject)) is significantly worse than lock(this).  Having said that; sincere kudos to Alan for pointing out that lock(typeof(SomeObject)) is bad practice.An instance of System.Type is one of the most generic, coarse-grained objects there is.  At the very least, an instance of System.Type is global to an AppDomain, and .NET can run multiple programs in an AppDomain.  This means that two entirely different programs could potentially cause interference in one another even to the extent of creating a deadlock if they both try to get a synchronization lock on the same type instance.So lock(this) isn\'t particularly robust form, can cause problems and should always raise eyebrows for all the reasons cited.  Yet there is widely used, relatively well-respected and apparently stable code like log4net that uses the lock(this) pattern extensively, even though I would personally prefer to see that pattern change.But lock(typeof(SomeObject)) opens up a whole new and enhanced can of worms.For what it\'s worth....and the exact same arguments apply to this construct as well:Imagine that you have a skilled secretary at your office that\'s a shared resource in the department. Once in a while, you rush towards them because you have a task, only to hope that another one of your co-workers has not already claimed them. Usually you only have to wait for a brief period of time. Because caring is sharing, your manager decides that customers can use the secretary directly as well. But this has a side effect: A customer might even claim them while you\'re working for this customer and you also need them to execute part of the tasks. A deadlock occurs, because claiming is no longer a hierarchy. This could have been avoided all together by not allowing customers to claim them in the first place. lock(this) is bad as we\'ve seen. An outside object might lock on the object and since you don\'t control who\'s using the class, anyone can lock on it... Which is the exact example as described above. Again, the solution is to limit exposure of the object. However, if you have a private, protected or internal class you could already control who is locking on your object, because you\'re sure that you\'ve written your code yourself. So the message here is: don\'t expose it as public. Also, ensuring that a lock is used in similar scenario\'s avoids deadlocks.The complete opposite of this is to lock on resources that are shared throughout the app domain -- the worst case scenario. It\'s like putting your secretary outside and allowing everyone out there to claim them. The result is utter chaos - or in terms of source code: it was a bad idea; throw it away and start over. So how do we do that?Types are shared in the app domain as most people here point out. But there are even better things we can use: strings. The reason is that strings are pooled. In other words: if you have two strings that have the same contents in an app domain, there\'s a chance that they have the exact same pointer. Since the pointer is used as the lock key, what you basically get is a synonym for "prepare for undefined behavior".Similarly, you shouldn\'t lock on WCF objects, HttpContext.Current, Thread.Current, Singletons (in general), etc. The easiest way to avoid all of this? private [static] object myLock = new object();Locking on the this pointer can be bad if you are locking over a shared resource.  A shared resource can be a static variable or a file on your computer - i.e. something that is shared between all users of the class.  The reason is that the this pointer will contain a different reference to a location in memory each time your class is instantiated.  So, locking over this in once instance of a class is different than locking over this in another instance of a class.Check out this code to see what I mean.  Add the following code to your main program in a Console application:Create a new class like the below.Here is a run of the program locking on this.Here is a run of the program locking on myLock.There\'s also some good discussion about this here: Is this the proper use of a mutex? Sorry guys but I can\'t agree with the argument that locking this might cause deadlock. You are confusing two things: deadlocking and starving.Here is a picture which illustrates the difference.Conclusion\nYou can still safely use lock(this) if thread starvation is not an issue for you. You still have to keep in mind that when the thread, which is starving thread using lock(this) ends in a lock having your object locked, it will finally end in eternal starvation ;)There is very good article about it http://bytes.com/topic/c-sharp/answers/249277-dont-lock-type-objects by Rico Mariani, performance architect for the Microsoft\xc2\xae .NET runtimeExcerpt:\nThe basic problem here is that you don\'t own the type object, and you don\'t know who else could access it. In general, it\'s a very bad idea to rely on locking an object you didn\'t create and don\'t know who else might be accessing. Doing so invites deadlock. The safest way is to only lock private objects.Because any chunk of code that can see the instance of your class can also lock on that reference. You want to hide (encapsulate) your locking object so that only code that needs to reference it can reference it. The keyword this refers to the current class instance, so any number of things could have reference to it and could use it to do thread synchronization.To be clear, this is bad because some other chunk of code could use the class instance to lock, and might prevent your code from obtaining a timely lock or could create other thread sync problems. Best case: nothing else uses a reference to your class to lock. Middle case: something uses a reference to your class to do locks and it causes performance problems. Worst case: something uses a reference of your class to do locks and it causes really bad, really subtle, really hard-to-debug problems.Here is some sample code that is simpler to follow (IMO): (Will work in LinqPad, reference following namespaces: System.Net and System.Threading.Tasks)There will be a problem if the instance can be accessed publicly because there could be other requests that might be using the same object instance. It\'s better to use private/static variable.Please refer to the following link which explains why lock (this) is not a good idea.http://blogs.msdn.com/b/bclteam/archive/2004/01/20/60719.aspxSo the solution is to add a private object, for example, lockObject to the class and place the code region inside the lock statement as shown below: