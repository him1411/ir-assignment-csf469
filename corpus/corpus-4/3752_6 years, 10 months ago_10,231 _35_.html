I was playing around in jsfiddle.net and I\'m curious as to why this returns true?So does this:But this doesn\'t:Is this quirk ever useful?Order of operations causes (0 < 5 < 3) to be interpreted in javascript as ((0 < 5) < 3) which produces (true < 3) and true is counted as 1, causing it to return true.This is also why (0 < 5 < 1) returns false, (0 < 5) returns true, which is interpreted as 1, resulting in (1 < 1).My guess is because 0 < 5 is true, and true < 3 gets cast to 1 < 3 which is true.probably because true is assumed as 1 soBecause true < 3, because true == 1As to your question whether this quirk is ever useful: I suppose there could be some case where it would useful (if condensed code is what you are after), but relying on it will (most likely) severely reduce the understandability of your code.It\'s kind of like using post/pre increment/decrement as a part of bigger expressions.  Can you determine what this code\'s result is at a glance?Note: with this code, you can sometimes even get different results depending on the language and compiler.It\'s a good idea to make life easy for yourself and the next guy who will read your code.  Clearly write out what you actually want to have happen rather then relying on side effects like the implicit conversion of booleans.The answer to the second part of the question, "is this quirk ever useful?" is perhaps no, as noted by a previous answer, if it is indeed a quirk of the language (Javascript) that true is cast to 1, but that the programmer does not in general view 1 and true  (and 0 and false) as the same thing. If however you have a mental model of 1 being true and 0 being false, then it leads to all sorts of nice boolean techniques that are extremely useful, powerful, and direct. For example, you could increment a counter directly with the result of  A > 100, which would increment the counter if A is greater than 100. This technique might be viewed as a quirk or a trick in Java, but in an array or functional language may be idiomatic. A classic example in the array language APL would be to count the number of items in an array that are (say) greater than 100:Where if A is the 5 item array 107 22 256 110 3 then:yields the 5 item boolean array:1 0 1 1 0and summing this boolean result:yields the final answer:3  This question is a perfect example of where this technique would be very useful, especially if the problem is generalized to determine if n out of m boolean values are true.Check if at least two out of three booleans are trueThat\'s easy. Start with left to right so it evaluates the first 0 < 5. Is it true? Yes. Since TRUE=1, it evaluates 1 < 3. Since 1 is less than 3 so it\'s true. Now with thisIs 0 less than 5? Yes. So make it TRUE which also means 1. Now with that fact in mind, it evaluates to (1 < 1). Is 1 less than 1? No, therefore it\'s false. It has to be equal. is it evaluating 0<5 which would return 1 for true when 1<3 which is true?C# want let you do this "Operator \'<\' cannot be applied to operands of type \'bool\' and \'int\'"I ran into this a little while ago in Obj-C and was very puzzled by it. I got the results I wanted by doing something like this:Which of course is false so you wouldn\'t get that "true" alert.\nGlad I read this, I now know why.In addition to python, CoffeeScript is another language that supports chained comparisons, thus 3 < x < 10 would be converted to (3 < x && x < 10) in vanilla JSA boolean operand when operated over a math operator returns a number.\nto check this we do So 0 < 5, the returned boolean(true) operated with math operator(<) will return a number. So it boils to 1<3 which returns true