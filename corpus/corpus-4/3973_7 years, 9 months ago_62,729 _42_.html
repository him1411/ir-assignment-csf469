I\'m trying to get my head around how to properly use the repository pattern. The central concept of an Aggregate Root keeps coming up. When searching both the web and Stack Overflow for help with what an aggregate root is, I keep finding discussions about them and dead links to pages that are supposed to contain base definitions.In the context of the repository pattern, what is an aggregate root?In the context of the repository pattern, aggregate roots are the only objects your client code loads from the repository.The repository encapsulates access to child objects - from a caller\'s perspective it automatically loads them, either at the same time the root is loaded or when they\'re actually needed (as with lazy loading).For example, you might have an Order object which encapsulates operations on multiple LineItem objects. Your client code would never load the LineItem objects directly, just the Order that contains them, which would be the aggregate root for that part of your domain.From Evans DDD:An AGGREGATE is a cluster of associated objects that we treat as a unit for the purpose of data changes. Each AGGREGATE has a root and a boundary. The boundary defines what is inside the AGGREGATE. The root is a single, specific ENTITY contained in the AGGREGATE.And:The root is the only member of the AGGREGATE that outside objects are allowed to hold references to[.]This means that aggregate roots are the only objects that can be loaded from a repository.An example is a model containing a Customer entity and an Address entity. We would never access an Address entity directly from the model as it does not make sense without the context of an associated Customer. So we could say that Customer and Address together form an aggregate and that Customer is an aggregate root.Aggregate root is a complex name for simple idea.Well designed class diagram encapsulates its internals. Point through which you access this structure is called aggregate root.Internals of your solution may be very complicated, but user of this hierarchy will just use root.doSomethingWhichHasBusinessMeaning(). Check this simple class hierarchy\nHow do you want to ride your car? Chose better apiOption A (it just somehow works):Option B (user has access to class inernals):If you think that option A is better then congratulations. You get main reason behind aggregate root.Aggregate root encapsulates multiple classes. you can manipulate whole hierarchy only through main object.Imagine you have a Computer entity, this entity also cannot live without its Software entity and Hardware entity. These form the Computer aggregate, the mini-ecosystem for the Computer portion of the domain.Aggregate Root is the mothership entity inside the aggregate (in our case Computer), it is a common practice to have your repository only work with the entities that are Aggregate Roots, and this entity is responsible for initializing the other entities.Consider Aggregate Root as an Entry-Point to an Aggregate.In C# code:Keep in mind that Hardware would likely be a ValueObject too (do not have identity on its own), consider it as an example only.If you follow a database-first approach, you aggregate root is usually the table on the 1 side of a 1-many relationship.The most common example being a Person. Each person has many addresses, one or more pay slips, invoices, CRM entries, etc. It\'s not always the case, but 9/10 times it is.We\'re currently working on an e-commerce platform, and we basically have two aggregate roots:Customers supply contact info, we assign transactions to them, transactions get line items, etc.Sellers sell products, have contact people, about us pages, special offers, etc.These are taken care of by the Customer and Seller repository respectively.From a broken link:Within an Aggregate there is an Aggregate Root. The Aggregate Root is the parent Entity to all other Entities and Value Objects within the Aggregate.A Repository operates upon an Aggregate Root.More info can also be found here.Dinah:In the Context of a Repository the Aggregate Root is an Entity with no parent Entity. It contains zero, One or Many Child Entities whose existence is dependent upon the Parent for it\'s identity.  That\'s a One To Many relationship in a Repository. Those Child Entities are plain Aggregates. In Erlang there is no need to differentiate between aggregates, once the aggregate is composed by data structures inside the state, instead of OO composition. See an example: https://github.com/bryanhunter/cqrs-with-erlang/tree/ndc-londonAggregate means collection of something.\nroot is like top node of tree, from where we can access everything like <html> node in web page document.\nBlog Analogy, A user can have many posts and each post can have many comments. so if we fetch any user then it can act as root to access all the related posts and further comments of those posts. These are all together said to be collection or AggregatedAggregate is where you protect your invariants and force consistency by limiting its access thought aggregate root. Do not forget, aggregate should design upon your project business rules and invariants, not database relationship. you should not inject any repository and no queries are not allowed.