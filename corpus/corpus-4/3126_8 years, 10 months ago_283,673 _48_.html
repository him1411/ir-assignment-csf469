I\'ve got a few Unix shell scripts where I need to check that certain environment variables are set before I start doing stuff, so I do this sort of thing:which is a lot of typing. Is there a more elegant idiom for checking that a set of environment variables is set?EDIT: I should mention that these variables have no meaningful default value - the script should error out if any are unset.The obvious answer is to use one of the special forms of parameter expansion:Or, better (see section on \'Position of double quotes\' below):The first variant (using just ?) requires STATE to be set, but STATE="" (an empty string) is OK â€” not exactly what you want, but the alternative and older notation.The second variant (using :?) requires DEST to be set and non-empty.If you supply no message, the shell provides a default message.The ${var?} construct is portable back to Version 7 UNIX and the Bourne Shell (1978 or thereabouts).  The ${var:?} construct is slightly more recent: I think it was in System III UNIX circa 1981, but it may have been in PWB UNIX before that.  It is therefore in the Korn Shell, and in the POSIX shells, including specifically Bash.It is usually documented in the shell\'s man page in a section called Parameter Expansion.  For example, the bash manual says:Display Error if Null or Unset.  If parameter is null or unset, the expansion of word (or a message to that effect if word is not present) is written to the standard error and the shell, if it is not interactive, exits.  Otherwise, the value of parameter is substituted.I should probably add that the colon command simply has its arguments evaluated and then succeeds.  It is the original shell comment notation (before \'#\' to end of line).  For a long time, Bourne shell scripts had a colon as the first character.  The C Shell would read a script and use the first character to determine whether it was for the C Shell (a \'#\' hash) or the Bourne shell (a \':\' colon).  Then the kernel got in on the act and added support for \'#!/path/to/program\' and the Bourne shell got \'#\' comments, and the colon convention went by the wayside.  But if you come across a script that starts with a colon, now you will know why.blong asked in a comment:Any thoughts on this discussion? https://github.com/koalaman/shellcheck/issues/380#issuecomment-145872749The gist of the discussion is:\xe2\x80\xa6\xc2\xa0However, when I shellcheck it (with version 0.4.1), I get this message:Any advice on what I should do in this case? The short answer is "do as shellcheck suggests":To illustrate why, study the following.  Note that the : command doesn\'t echo its arguments (but the shell does evaluate the arguments).  We want to see the arguments, so the code below uses printf "%s\\n" in place of :.Note how the value in $x is expanded to first * and then a list of file names when the overall expression is not in double quotes.  This is what shellcheck is recommending should be fixed.  I have not verified that it doesn\'t object to the form where the expression is enclosed in double quotes, but it is a reasonable assumption that it would be OK.Try this:Your question is dependent on the shell that you are using.Bourne shell leaves very little in the way of what you\'re after.BUT...It does work, just about everywhere.Just try and stay away from csh. It was good for the bells and whistles it added, compared the Bourne shell, but it is really creaking now. If you don\'t believe me, just try and separate out STDERR in csh! (-:There are two possibilities here. The example above, namely using:for the first time you need to refer to $MyVariable. This takes the env. var MyVariable and, if it is currently not set, assigns the value of SomeDefault to the variable for later use.You also have the possibility of:which just substitutes SomeDefault for the variable where you are using this construct. It doesn\'t assign the value SomeDefault to the variable, and the value of MyVariable will still be null after this statement is encountered.Surely the simplest approach is to add the -u switch to the shebang (the line at the top of your script), assuming you\xe2\x80\x99re using bash:#!/bin/sh -uThis will cause the script to exit if any unbound variables lurk within.If MyVariable is set and not null, it will reset the variable value (= nothing happens).\nElse, MyVariable is set to SomeDefault.In my opinion the simplest and most compatible check for #!/bin/sh is:Again, this is for /bin/sh and is compatible also on old Solaris systems.I always used:Not that much more concise, I\'m afraid.Under CSH you have $?STATE.bash 4.2 introduced the -v operator which tests if a name is set to any value, even the empty string.None of the above solutions worked for my purposes, in part because I checking the environment for an open-ended list of variables that need to be set before starting a lengthy process. I ended up with this:We can write a nice assertion to check a bunch of variables all at once:Sample invocation:Output:For future poeple like me, I wanted to go a step forward and parameterize the var name, so I can loop over a variable sized list of variable names:This can be a way too:http://unstableme.blogspot.com/2007/02/checks-whether-envvar-is-set-or-not.htmlThe $? syntax is pretty neat: