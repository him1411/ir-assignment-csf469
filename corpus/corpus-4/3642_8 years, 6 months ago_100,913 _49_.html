What are the differences between multidimensional arrays double[,] and array-of-arrays double[][] in C#?If there is a difference, what is the best use for each one?Array of arrays (jagged arrays) are faster than multi-dimensional arrays and can be used more effectively. Multidimensional arrays have nicer syntax.If you write some simple code using jagged and multidimensional arrays and then inspect the compiled assembly with an IL disassembler you will see that the storage and retrieval from jagged (or single dimensional) arrays are simple IL instructions while the same operations for multidimensional arrays are method invocations which are always slower.Consider the following methods:Their IL will be the following:When using jagged arrays you can easily perform such operations as row swap and row resize. Maybe in some cases usage of multidimensional arrays will be more safe, but even Microsoft FxCop tells that jagged arrays should be used instead of multidimensional when you use it to analyse your projects.A multidimensional array creates a nice linear memory layout while a jagged array implies several extra levels of indirection.Looking up the value jagged[3][6] in a jagged array var jagged = new int[10][5] works like this: Look up the element at index 3 (which is an array) and look up the element at index 6 in that array (which is a value). For each dimension in this case, there\'s an additional look up (this is an expensive memory access pattern).A multidimensional array is laid out linearly in memory, the actual value is found by multiplying together the indexes. However, given the array var mult = new int[10,30], the Length property of that multidimensional array returns the total number of elements i.e. 10 * 30 = 300.The Rank property of a jagged array is always 1, but a multidimensional array can have any rank. The GetLength method of any array can be used to get the length of each dimension. For the multidimensional array in this example mult.GetLength(1) returns 30.Indexing the multidimensional array is faster. e.g. given the multidimensional array in this example mult[1,7] = 30 * 1 + 7 = 37, get the element at that index 37. This is a better memory access pattern because only one memory location is involved, which is the base address of the array.A multidimensional array therefore allocates a continuous memory block, while a jagged array does not have to be square, e.g. jagged[1].Length does not have to equal jagged[2].Length, which would be true for any multidimensional array. Performance wise, multidimensional arrays should be faster. A lot faster, but due to a really bad CLR implementation they are not.The first row are timings of jagged arrays, the second shows multidimensional arrays and the third, well that\'s how it should be. The program is shown below, FYI this was tested running mono. (The windows timings are vastly different, mostly due to the CLR implementation variations).On windows, the timings of the jagged arrays are greatly superior, about the same as my own interpretation of what multidimensional array look up should be like, see \'Single()\'. Sadly the windows JIT-compiler is really stupid, and this unfortunately makes these performance discussions difficult, there are too many inconsistencies. These are the timings I got on windows, same deal here, the first row are jagged arrays, second multidimensional and third my own implementation of multidimensional, note how much slower this is on windows compared to mono.Source code:Simply put multidimensional arrays are similar to a table in DBMS.\nArray of Array (jagged array) lets you have each element hold another array of the same type of variable length.So, if you are sure that the structure of data looks like a table (fixed rows/columns), you can use a multi-dimensional array. Jagged array are fixed elements & each element can hold an array of variable lengthE.g. Psuedocode:Think of the above as a 2x2 table:Think of the above as each row having variable number of columns:Preface: This comment is intended to address the answer provided by okutane, but because of SO\'s silly reputation system, I can not post it where it belongs.Your assertion that one is slower than the other because of the method calls isn\'t correct.  One is slower than the other because of more complicated bounds-checking algorithms.  You can easily verify this by looking, not at the IL, but at the compiled assembly.  For example, on my 4.5 install, accessing an element (via pointer in edx) stored in a two-dimensional array pointed to by ecx with indexes stored in eax and edx looks like so:Here, you can see that there\'s no overhead from method calls.  The bounds checking is just very convoluted thanks to the possibility of non-zero indexes, which is a functionality not on offer with jagged arrays.  If we remove the sub,cmp,and jmps for the non-zero cases, the code pretty much resolves to (x*y_max+y)*sizeof(ptr)+sizeof(array_header).  This calculation is about as fast (one multiply could be replaced by a shift, since that\'s the whole reason we choose bytes to be sized as powers of two bits) as anything else for random access to an element.  Another complication is that there are plenty of cases where a modern compiler will optimize away the nested bounds-checking for element access while iterating over a single-dimension array.  The result is code that basically just advances an index pointer over the contiguous memory of the array.  Naive iteration over multi-dimensional arrays generally involves an extra layer of nested logic, so a compiler is less likely to optimize the operation.  So, even though the bounds-checking overhead of accessing a single element amortizes out to constant runtime with respect to array dimensions and sizes, a simple test-case to measure the difference may take many times longer to execute.Multi-dimension arrays are (n-1)-dimension matrices.So int[,] square = new int[2,2] is square matrix 2x2, int[,,] cube = new int [3,3,3] is a cube - square matrix 3x3. Proportionality is not required.Jagged arrays are just array of arrays - an array where each cell contains an array.So MDA are proportional, JD may be not! Each cell can contains an array of arbitrary length!This might have been mentioned in the above answers but not explicitly: with jagged array you can use array[row] to refer a whole row of data, but this is not allowed for multi-d arrays. I would like to update on this, because in .NET Core multi-dimensional arrays are faster than jagged arrays. I ran the tests from John Leidegren and these are the results on .NET Core 2.0 preview 2. I increased the dimension value to make any possible influences from background apps less visible.I looked into disassemblies and this is what I found jagged[i][j][k] = i * j * k; needed 34 instructions to executemulti[i, j, k] = i * j * k; needed 11 instructions to executesingle[i * dim * dim + j * dim + k] = i * j * k; needed 23 instructions to executeI wasn\'t able to identify why single-dimensional arrays were still faster than multi-dimensional but my guess is that it has to do with some optimalization made on the CPUIn addition to the other answers, note that a multidimensional array is allocated as one big chunky object on the heap.  This has some implications:I am parsing .il files generated by ildasm to build a database of assemnblies, classes, methods, and stored procedures for use doing a conversion. I came across the following, which broke my parsing.The book Expert .NET 2.0 IL Assembler, by Serge Lidin, Apress, published 2006, Chapter 8, Primitive Types and Signatures, pp. 149-150 explains. <type>[] is termed a Vector of <type>, <type>[<bounds> [<bounds>**] ] is termed an array of <type>** means may be repeated, [ ] means optional.Examples: Let <type> = int32.1) int32[...,...] is a two-dimensional array of undefined lower bounds and sizes2) int32[2...5] is a one-dimensional array of lower bound 2 and size 4.3) int32[0...,0...] is a two-dimensional array of lower bounds 0 and undefined size.Tom