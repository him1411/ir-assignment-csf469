Possible Duplicate:\n  Meaning of “const” last in a C++ method declaration? Hi\nI got a book, where there is written something like:Also, a by-the-way question: why should/shouldn\'t I use const before argument declarations? What does that change ?EDIT:\nSo if I do now:Will the (const-tagged) Bar function exist 3 times or 1 time in memory?A "const function", denoted with the keyword const after a function declaration, makes it a compiler error for this class function to change a member variable of the class.  However, reading of a class variables is ok inside of the function, but writing inside of this function will generate a compiler error.  Another way of thinking about such "const function" is by viewing an class function as a normal function taking an implicit this pointer. So a method int Foo::Bar(int random_arg) (without the const at the end) results in a function like int Foo_Bar(Foo* this, int random_arg), and a call such as Foo f; f.Bar(4) will internally correspond to something like Foo f; Foo_Bar(&f, 4). Now adding the const at the end (int Foo::Bar(int random_arg) const) can then be understood as a declaration with a const this pointer: int Foo_Bar(const Foo* this, int random_arg). Since the type of this in such case is const, no modifications of member variables are possible.It is possible to loosen the "const function" restriction of not allowing the function to write to any variable of a class. To allow some of the variables to be writable even when the function is marked as a "const function", these class variables are marked with the keyword mutable.  Thus, if a class variable is marked as mutable, and a "const function" writes to this variable then the code will compile cleanly and the variable is possible to change. (C++11)As usual when dealing with the const keyword, changing the location of the const key word in a C++ statement has entirely different meanings.  The above usage of const only apply when adding const to the end of the function declaration after the parenthesis.  const is a highly overused qualifier in C++ and the syntax and ordering is often not straightforward in combination with pointers. Some readings about const correctness and the const keyword:Const correctnessThe C++ \'const\' Declaration: Why & HowConsider two class-typed variables:Now you are able to call any member function of Boo on b0, but only const-qualified member functions on b1.Bar is guaranteed not to change the object it is being invoked on. See the section about const correctness in the C++ FAQ, for example.Similar to this question.In essence it means that the method Bar will not modify non mutable member variables of Foo.I always find it conceptually easier to think of that you are making the this pointer const (which is pretty much what it does).Function can\'t change its parameters via the pointer/reference you gave it.I go to this page every time I need to think about it:http://www.parashift.com/c++-faq-lite/const-correctness.htmlI believe there\'s also a good chapter in Meyers\' "More Effective C++".