When I submit a simple form like this with a file attached:How does it send the file internally? Is the file sent as part of the HTTP body as data? In the headers of this request, I don\'t see anything related to the name of the file. I just would like the know the internal workings of the HTTP when sending a file.Let\'s take a look at what happens when you select a file and submit your form (I\'ve truncated the headers for brevity):Instead of URL encoding the form parameters, the form parameters (including the file data) are sent as sections in a multipart document in the body of the request.In the example above, you can see the input MAX_FILE_SIZE with the value set in the form, as well as a section containing the file data.  The file name is part of the Content-Disposition header.The full details are here.How does it send the file internally?The format is called multipart/form-data, as asked at: What does enctype='multipart/form-data' mean?I\'m going to:There are three possibilities for enctype:Once you see an example of each method, it becomes obvious how they work, and when you should use each one.You can produce examples using:Save the form to a minimal .html file:We set the default text value to a&#x03C9;b, which means a\xcf\x89b because \xcf\x89 is U+03C9, which are the bytes 61 CF 89 62 in UTF-8.Create files to upload:Run our little echo server:Open the HTML on your browser, select the files and click on submit and check the terminal. nc prints the request received.Tested on: Ubuntu 14.04.3, nc BSD 1.105, Firefox 40.Firefox sent:For the binary file and text field, the bytes 61 CF 89 62 (a\xcf\x89b in UTF-8) are sent literally. You could verify that with nc -l localhost 8000 | hd, which says that the bytes:were sent (61 == \'a\' and 62 == \'b\').Therefore it is clear that:Content-Type: multipart/form-data; boundary=---------------------------9051914041544843365972754266 sets the content type to multipart/form-data and says that the fields are separated by the given boundary string.every field gets some sub headers before its data: Content-Disposition: form-data;, the field name, the filename, followed by the data.The server reads the data until the next boundary string. The browser must choose a boundary that will not appear in any of the fields, so this is why the boundary may vary between requests.Because we have the unique boundary, no encoding of the data is necessary: binary data is sent as is.TODO: what is the optimal boundary size (log(N) I bet), and name / running time of the algorithm that finds it? Asked at: https://cs.stackexchange.com/questions/39687/find-the-shortest-sequence-that-is-not-a-sub-sequence-of-a-set-of-sequencesContent-Type is automatically determined by the browser.How it is determined exactly was asked at: How is mime type of an uploaded file determined by browser?Now change the enctype to application/x-www-form-urlencoded, reload the browser, and resubmit.Firefox sent:Clearly the file data was not sent, only the basenames. So this cannot be used for files.As for the text field, we see that usual printable characters like a and b were sent in one byte, while non-printable ones like 0xCF and 0x89 took up 3 bytes each: %CF%89!File uploads often contain lots of non-printable characters (e.g. images), while text forms almost never do.From the examples we have seen that:multipart/form-data: adds a few bytes of boundary overhead to the message, and must spend some time calculating it, but sends each byte in one byte.application/x-www-form-urlencoded: has a single byte boundary per field (&), but adds a linear overhead factor of 3x for every non-printable character.Therefore, even if we could send files with application/x-www-form-urlencoded, we wouldn\'t want to, because it is so inefficient.But for printable characters found in text fields, it does not matter and generates less overhead, so we just use it.In the given answers/examples the file is (most likely) uploaded with a HTML form or using the FormData API. The file is only a part of the data sent in the request, hence the multipart/form-data Content-Type header.If you want to send the file as the only content then you can directly add it as the request body and you set the Content-Type header to the MIME type of the file you are sending. The file name can be added in the Content-Disposition header. You can upload like this:If you don\'t (want to) use forms and you are only interested in uploading one single file this is the easiest way to include your file in the request.An HTTP message may have a body of data sent after the header lines. In a response, this is where the requested resource is returned to the client (the most common use of the message body), or perhaps explanatory text if there\'s an error. In a request, this is where user-entered data or uploaded files are sent to the server.http://www.tutorialspoint.com/http/http_messages.htmI have this sample Java Code:and I have this test.html file:and finally the file I will be using for testing purposes, named a.dat has the following content:if you interpret the bytes above as ASCII or UTF-8 characters, they will actually will be representing:So let \'s run our Java Code, open up test.html inChrome, upload a.dat and submit the form and see what our server receives:Well I am not surprised to see the characters 9ie because we told Java to print them treating them as UTF-8 characters. You may as well choose to read them as raw bytes..is actually the last HTTP Header here. After that comes the HTTP Body, where meta and contents of the file we uploaded actually can be seen.