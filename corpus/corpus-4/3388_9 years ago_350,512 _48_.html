How do you generate all the permutations of a list in Python, independently of the type of elements in that list?For example:EDIT:\nEliben pointed to a solution that\'s similar to mine although simpler, so I\'m choosing it as the accepted answer, although Python 2.6+ has a builtin solution in the itertools module:Starting with Python 2.6 (and if you\'re on Python 3) you have a standard-library tool for this: itertools.permutations.If you\'re using an older Python (<2.6) for some reason or are just curious to know how it works, here\'s one nice approach, taken from  http://code.activestate.com/recipes/252178/:A couple of alternative approaches are listed in the documentation of itertools.permutations. Here\'s one:And another, based on itertools.product:And in Python 2.6 onwards:(returned as a generator.  Use list(permutations(l)) to return as a list.)The following code with Python 2.6 and above ONLYFirst, import itertools:called as:This solution implements a generator, to avoid holding all the permutations on memory:Output:As I\'m swapping the content of the list it\'s required a mutable sequence type as input. E.g. perm(list("ball")) will work and perm("ball") won\'t because you can\'t change a string. This Python implementation is inspired by the algorithm presented in the book Computer Algorithms by Horowitz, Sahni and Rajasekeran.The following code is an in-place permutation of a given list, implemented as a generator. Since it only returns references to the list, the list should not be modified outside the generator.\nThe solution is non-recursive, so uses low memory. Work well also with multiple copies of elements in the input list.A quite obvious way in my opinion might be also:In a functional styleThe result:Output:Note that this algorithm has an n factorial time complexity, where n is the length of the input listPrint the results on the run:Example: Output:I used an algorithm based on the factorial number system- For a list of length n, you can assemble each permutation item by item, selecting from the items left at each stage. You have n choices for the first item, n-1 for the second, and only one for the last, so you can use the digits of a number in the factorial number system as the indices. This way the numbers 0 through n!-1 correspond to all possible permutations in lexicographic order.output:This method is non-recursive, but it is slightly slower on my computer and xrange raises an error when n! is too large to be converted to a C long integer (n=13 for me). It was enough when I needed it, but it\'s no itertools.permutations by a long shot.One can indeed iterate over the first element of each permutation, as in tzwenn\'s answer; I prefer to write this solution this way:This solution is about 30\xc2\xa0% faster, apparently thanks to the recursion ending at len(elements) <= 1 instead of 0.\nIt is also much more memory-efficient, as it uses a generator function (yield), like in Riccardo Reyes\'s solution.For performance, a numpy solution inspired by Knuth, (p22) :Copying large blocs of memory saves time - \nit\'s  20x faster than list(itertools.permutations(range(n)) :Forgive my python illiteracy as I won\'t be offering the solution in python.\nAs I do not know what method python 2.6 uses to generate the permutations and eliben\'s one looks like Johnson-Trotter permutation generation, you might look for article\nin Wikipedia on Permutations and their generation that looks quite like unrank function in paper by Myrvold and Ruskey.It would seem to me that this could be used in a generator in the same way as in other replies to lessen the memory requirement considerably. Just remember that the permutations will not be in lexicographic order.Here is an algorithm that works on a list without creating new intermediate lists similar to Ber\'s solution at https://stackoverflow.com/a/108651/184528. You can try the code out for yourself here: http://repl.it/J9vThis is inspired by the Haskell implementation using list comprehension: The beauty of recursion:This algorithm is the most effective one, it avoids of array passing and manipulation in recursive calls, works in Python 2, 3:Usage:Generate all possible permutationsI\'m using python3.4:Test Cases:I see a lot of iteration going on inside these recursive functions, not exactly pure recursion...so for those of you who cannot abide by even a single loop, here\'s a gross, totally unnecessary fully recursive solutionAnother solution:This way is better than the alternatives I\'m seeing, check it out.for Python we can use itertools and import both permutations and combinations to solve your problem