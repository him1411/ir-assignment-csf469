In a comment on the answer to another question, someone said they weren\'t sure what functools.wraps was doing.  So I\'m asking this question so that there will be a record of it on StackOverflow for future reference: what does functools.wraps do, exactly?When you use a decorator, you\'re replacing one function with another.  In other words, if you have a decoratorthen when you sayit\'s exactly the same as sayingand your function f is replaced with the function with_logging.  Unfortunately, this means that if you then sayit will print with_logging because that\'s the name of your new function.  In fact, if you look at the docstring for f, it will be blank because with_logging has no docstring, and so the docstring you wrote won\'t be there anymore.  Also, if you look at the pydoc result for that function, it won\'t be listed as taking one argument x; instead it\'ll be listed as taking *args and **kwargs because that\'s what with_logging takes.If using a decorator always meant losing this information about a function, it would be a serious problem.  That\'s why we have functools.wraps.  This takes a function used in a decorator and adds the functionality of copying over the function name, docstring, arguments list, etc.  And since wraps is itself a decorator, the following code does the correct thing:I very often use classes, rather than functions, for my decorators.  I was having some trouble with this because an object won\'t have all the same attributes that are expected of a function.  For example, an object won\'t have the attribute __name__.  I had a specific issue with this that was pretty hard to trace where Django was reporting the error "object has no attribute \'__name__\'".  Unfortunately, for class-style decorators, I don\'t believe that @wrap will do the job.  I have instead created a base decorator class like so:This class proxies all the attribute calls over to the function that is being decorated.  So, you can now create a simple decorator that checks that 2 arguments are specified like so: