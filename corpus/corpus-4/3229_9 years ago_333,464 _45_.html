Which is better to use for timing in Python? time.clock() or time.time()? Which one provides more accuracy?for example:vs.As of 3.3, time.clock() is deprecated, and it\'s suggested to use time.process_time() or time.perf_counter() instead.Previously in 2.7, according to the time module docs:time.clock()On Unix, return the current processor time as a floating point number\n  expressed in seconds. The precision, and in fact the very definition\n  of the meaning of \xe2\x80\x9cprocessor time\xe2\x80\x9d, depends on that of the C function\n  of the same name, but in any case, this is the function to use for\n  benchmarking Python or timing algorithms.On Windows, this function returns wall-clock seconds elapsed since the\n  first call to this function, as a floating point number, based on the\n  Win32 function QueryPerformanceCounter(). The resolution is typically\n  better than one microsecond.Additionally, there is the timeit module for benchmarking code snippets.The short answer is: most of the time time.clock() will be better.\nHowever, if you\'re timing some hardware (for example some algorithm you put in the GPU), then time.clock() will get rid of this time and time.time() is the only solution left.Note: whatever the method used, the timing will depend on factors you cannot control (when will the process switch, how often, ...), this is worse with time.time() but exists also with time.clock(), so you should never run one timing test only, but always run a series of test and look at mean/variance of the times.Others have answered re: time.time() vs. time.clock(). However, if you\'re timing the execution of a block of code for benchmarking/profiling purposes, you should take a look at the timeit module.One thing to keep in mind:\n  Changing the system time affects time.time() but not time.clock().I needed to control some automatic tests executions. If one step of the test case took more than a given amount of time, that TC was aborted to go on with the next one.But sometimes a step needed to change the system time (to check the scheduler module of the application under test), so after setting the system time a few hours in the future, the TC timeout expired and the test case was aborted. I had to switch from time.time() to time.clock() to handle this properly.Depends on what you care about. If you mean WALL TIME (as in, the time on the clock on your wall), time.clock() provides NO accuracy because it may manage CPU time. Usually time() is more precise, because operating systems do not store the process running time with the precision they store the system time (ie, actual time)For my own practice. time() has better precision than clock() on Linux. clock() only has precision less than 10 ms. While time() gives prefect precision.\nMy test is on CentOS 6.4\xef\xbc\x8c python 2.6using clock():The difference is very platform-specific.clock() is very different on Windows than on Linux, for example.For the sort of examples you describe, you probably want the "timeit" module instead.On Unix time.clock() measures the amount of CPU time that has been used by the current process, so it\'s no good for measuring elapsed time from some point in the past. On Windows it will measure wall-clock seconds elapsed since the first call to the function. On either system time.time() will return seconds passed since the epoch. If you\'re writing code that\'s meant only for Windows, either will work (though you\'ll use the two differently - no subtraction is necessary for time.clock()). If this is going to run on a Unix system or you want code that is guaranteed to be portable, you will want to use time.time().Short answer: use time.clock() for timing in Python.On *nix systems, clock() returns the processor time as a floating point number, expressed in seconds. On Windows, it returns the seconds elapsed since the first call to this function, as a floating point number.time() returns the the seconds since the epoch, in UTC, as a floating point number. There is no guarantee that you will get a better precision that 1 second (even though time() returns a floating point number). Also note that if the system clock has been set back between two calls to this function, the second function call will return a lower value.To the best of my understanding, time.clock() has as much precision as your system will allow it.I use this code to compare 2 methods .My OS is windows 8 , processor core i5 , RAM 4GBoutput:time() = 0.0993799996376clock() = 0.0993572257367Right answer : They\'re both the same length of a fraction.But which faster if subject is time ?A little test case :I am not work an Swiss labs but I\'ve tested.. Based of this question : time.clock() is better than time.time()Edit : time.clock() is internal counter so can\'t use outside, got limitations max 32BIT FLOAT, can\'t continued counting if not store first/last values. Can\'t merge another one counter... Comparing test result between Ubuntu Linux and Windows 7.On UbuntuOn Windows 7To extend on @Hill\'s results, here\'s a test using python 2.7.6 on Xubuntu 14.04 through wine:\n(timeit.default_timer will use time.clock() because it sees the OS as \'win32\')Note, my laptop is slow and I\'m currently hosting 3 servers while running 5 resource-hungry tabs in chromium with alot of extensions.\nSo yes, I have alot of overhead making this look like it\'s taking more time than it should.Use the time.time() is preferred.