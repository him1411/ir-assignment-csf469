I have a public async void Foo() method that I want to call from synchronous method. So far all I have seen from MSDN documentation is calling async methods via async methods, but my whole program is not built with async methods.Is this even possible?Here\'s one example of calling these methods from an asynchronous method: http://msdn.microsoft.com/en-us/library/hh300224(v=vs.110).aspxNow I\'m looking into calling these async methods from sync methods.Asynchronous programming does "grow" through the code base. It has been compared to a zombie virus. The best solution is to allow it to grow, but sometimes that\'s not possible.I have written a few types in my Nito.AsyncEx library for dealing with a partially-asynchronous code base. There\'s no solution that works in every situation, though.Solution AIf you have a simple asynchronous method that doesn\'t need to synchronize back to its context, then you can use Task.WaitAndUnwrapException:You do not want to use Task.Wait or Task.Result because they wrap exceptions in AggregateException.This solution is only appropriate if MyAsyncMethod does not synchronize back to its context. In other words, every await in MyAsyncMethod should end with ConfigureAwait(false). This means it can\'t update any UI elements or access the ASP.NET request context.Solution BIf MyAsyncMethod does need to synchronize back to its context, then you may be able to use AsyncContext.RunTask to provide a nested context:*Update 4/14/2014: In more recent versions of the library the API is as follows:(It\'s OK to use Task.Result in this example because RunTask will propagate Task exceptions).The reason you may need AsyncContext.RunTask instead of Task.WaitAndUnwrapException is because of a rather subtle deadlock possibility that happens on WinForms/WPF/SL/ASP.NET:This is one reason why it\'s a good idea to use ConfigureAwait(false) within every async method as much as possible.Solution CAsyncContext.RunTask won\'t work in every scenario. For example, if the async method awaits something that requires a UI event to complete, then you\'ll deadlock even with the nested context. In that case, you could start the async method on the thread pool:However, this solution requires a MyAsyncMethod that will work in the thread pool context. So it can\'t update UI elements or access the ASP.NET request context. And in that case, you may as well add ConfigureAwait(false) to its await statements, and use solution A.Microsoft built an AsyncHelper (internal) class to run Async as Sync.  The source looks like:The Microsoft.AspNet.Identity base classes only have Async methods and in order to call them as Sync there are classes with extension methods that look like (example usage):Adding a solution that finally solved my problem, hopefully saves somebody\'s time.Firstly read a couple articles of Stephen Cleary:From the "two best practices" in "Don\'t Block on Async Code", the first one didn\'t work for me and the second one wasn\'t applicable (basically if I can use await, I do!).So here is my workaround: wrap the call inside a Task.Run<>(async () => await FunctionAsync()); and hopefully no deadlock anymore.Here is my code:You read the \'await\' keyword as "start this long running task, then return control to the calling method". Once the long-running task is done, then it executes the code after it. The code after the await is similar to what used to be CallBack methods. The big difference being the logical flow is not interrupted which makes it much easier to write and read.I\'m not 100% sure, but I believe the technique described in this blog should work in many circumstances: You can thus use task.GetAwaiter().GetResult() if you want to directly invoke this propagation logic.The most accepted answer is not entirely correct. There IS a solution that works in every situation: an ad-hoc message pump (SynchronizationContext).The calling thread will be blocked as expected, while still ensuring that all continuations called from the async function don\'t deadlock as they\'ll be marshaled to the ad-hoc SynchronizationContext (message pump) running on the calling thread.The code of the ad-hoc message pump helper:Usage:More detailed description of the async pump is available here.You can call any asynchronous method from synchronous code, that is, until you need to await on them, in which case they have to be marked async too.As a lot of people are suggesting here, you could call Wait() or Result on the resulting task in your synchronous method, but then you end up with a blocking call in that method, which sort of defeats the purpose of async. I you really can\'t make your method async and you don\'t want to lock up the synchronous method, then you\'re going to have to use a callback method by passing it as parameter to the ContinueWith method on task.Here is a very simple example of calling an async method from a synchronous one:Those windows async methods have a nifty little method called AsTask(). You can use this to have the method return itself as a task so that you can manually call Wait() on it.For example, on a Windows Phone 8 Silverlight application, you can do the following:Hope this helps!First of all you need to change public async void Foo() to public async Task Foo(). async void must be used only in event handlers.Example 1:Example 2:Use Task.Run<> method to do this.Also that\'s how I execute all the LINQ queries and Entity Framework operations that don\'t have the -Async methods.If you\'re using MVVM, check out these videos on async and await.