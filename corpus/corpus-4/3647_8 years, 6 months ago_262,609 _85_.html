Can this be done with standard means?The Windows Server 2003 Resource Kit contains timeit.exe that displays detailed execution stats.  Here is an example, timing the command "timeit -?":You can get TimeIt in the Windows 2003 Resource Kit. Download it\nhere.Alternatively, Windows PowerShell has a built in command that is similar to Bash\'s "time" command. It is called "Measure-Command." You\'ll have to ensure that PowerShell is installed on the machine that runs it.Example Input:Example Output:If you wantTry copying the following script into a new batch file (e.g. timecmd.bat):UsageIf you put timecmd.bat in a directory in your path, you can call it from anywhere like this:E.g.If you want to do output redirection, you can quote the command like this:This should handle commands that run from before- to after-midnight, but the output will be wrong if your command runs for 24 hours or more.Hehe, the most simple solution might be this:This works on every Windows out of the box.In case of an application using console output, it might be convenient to store the starting time in a temporary variable:The one-liner I use in Windows Server 2008 R2 is:So long as mycommand doesn\'t require quotes (which screws with cmd\'s quote processing). The /v:on is to allow for the two different TIME values to be evaluated independently rather than once at the execution of the command.Just a little expansion of the answer from Casey.K about using the Measure-Command from PowerShell:You can invoke PowerShell from the standard command prompt, like this:This will eat the standard output, but you can prevent that by adding | Out-Default like this from PowerShell:Or from a command prompt:Of course, you\'re free to wrap this in a script file *.ps1 or *.bat.If you have a command window open and call the commands manually, you can display a timestamp on each prompt, e.g.It gives you something like:23.03.2009 15:45:50,77C:\\>If you have a small batch script that executes your commands, have an empty line before each command, e.g.(empty line)myCommand.exe(next empty line)myCommand2.exeYou can calculate the execution time for each command by the time information in the prompt. The best would probably be to pipe the output to a textfile for further analysis:Since others are recommending installing things like freeware and PowerShell, you could also install Cygwin, which would give you access to many basic Unix commands like time:Not sure how much overhead Cygwin adds.Not quite as elegant as some of the functionality on Unix, but create a cmd file which looks like:That will display the start and stop times like so:I use freeware called "GS Timer".Just make a batch file like this:If you need a set of times, just pipe the output of timer /s into a .txt file.You can get it here: Gammadyne\'s Free DOS UtilitiesThe resolution is 0.1 seconds.I\'m using WindowsÂ XP and for some reason timeit.exe does not work for me. I found another alternative - PTIME. This works very well.http://www.pc-tools.net/win32/ptime/Example -As long as it doesn\'t last longer than 24hours...There\'s also TimeMem (March 2012):This is a Windows utility which executes a program and displays its\n  execution time, memory usage, and IO statistics. It is similar in\n  functionality to the Unix time utility.This is a one-liner which avoids delayed expansion, which could disturb certain commands:The output is something like:For long-term tests replace $T by $D, $T and %TIME% by %DATE%, %TIME% to include the date.To use this inside of a batch file, replace %Z by %%Z.Here is an improved one-liner (without delayed expansion too):The output looks similar to this:This approach does not include the process of instancing a new cmd in the result, nor does it include the prompt command(s).In case anyone else has come here looking for an answer to this question, there\'s a Windows API function called GetProcessTimes(). It doesn\'t look like too much work to write a little C program that would start the command, make this call, and return the process times.The following script uses only "cmd.exe" and outputs the number of milliseconds from the time a pipeline is created to the time that the process preceding the script exits. i.e., Type your command, and pipe the to the script. Example: "timeout 3 | runtime.cmd" should yield something like "2990." If you need both the runtime output and the stdin output, redirect stdin before the pipe - ex: "dir /s 1>temp.txt | runtime.cmd" would dump the output of the "dir" command to "temp.txt" and would print the runtime to the console.This is a comment/edit to Luke Sampson\'s nice timecmd.bat and reply toFor some reason this only gives me output in whole seconds... which for me is useless. I mean that I run timecmd pause, and it always results in 1.00 sec, 2.00 sec, 4.00 sec... even 0.00 sec! Windows 7. \xe2\x80\x93 Camilo Martin Sep 25 \'13 at 16:00  "On some configurations the delimiters may differ. The following change should cover atleast most western countries.The %time% milliseconds work on my system after adding that \',\'(*because site doesn\'t allow anon comment and doesn\'t keep good track of identity even though I always use same guest email which combined with ipv6 ip and browser fingerprint should be enough to uniquely identify without password)In the directory where your program is, type notepad mytimer.bat, click \'yes\' to create a new file.Paste the code below, replacing YourApp.exe with your program, then save.Type mytimer.bat in the command line then press Enter.Process Explorer will show kernel time, user time, and wall time (and lots of other stuff) as long as you click on the process before it exits. It is not a command-line tool, but it is immensely useful anyway.The answer of driblio can be made a little shorter (though not much readable)To the remark of Luke Sampson this version is octal safe, though the task should be completed in 24 hours.The following script emulates *nix epoch time, but it is local and regional. It should handle calender edge cases including leap years. If Cygwin is available, epoch values can be compared by specifying the Cygwin option.I\'m in EST and the difference reported is 4 hours which is relatively correct. There are some interesting solutions to remove the TZ and regional dependencies, but nothing trivial that I noticed.Here is aUsage example:timeout 1 | TimeIt.cmdCopy & paste this into some editor like for example Notepad++ and save it as TimeIt.cmd:^ - Based on \'Daniel Sparks\' VersionUsing a sub to return time in hundredths of second"Lean and Mean" TIMER with Regional format, 24h and mixed input support\nAdapting Aacini\'s substitution method body, no IF\'s, just one FOR (my regional fix)1: File timer.bat placed somewhere in %PATH% or the current dir  Usage:\ntimer & echo start_cmds & timeout /t 3 & echo end_cmds & timer\ntimer & timer "23:23:23,00"\ntimer "23:23:23,00" & timer\ntimer "13.23.23,00" & timer "03:03:03.00"\ntimer & timer "0:00:00.00" no & cmd /v:on /c echo until midnight=!timer_end!\nInput can now be mixed, for those unlikely, but possible time format changes during execution2: Function :timer bundled with the batch script (sample usage below):  :: to test it, copy-paste both above and below code sections CE,DE and CS,DS stand for colon end, dot end and colon set, dot set - used for mixed format supportFor Luke Sampson\'s nice script, the corrections for negative values should be done in the reverse order since they can make a previously 0 value go negative.Take for example a time were the initial subtraction gives 1 hour, 0 min. and -29 seconds. As done in the post the result will be 1 hour, -1 min, and 31 seconds. If the seconds are corrected before minutes and minutes before hours you instead get 31 seconds, 59 min, 0 hours.Here is my method, no conversion and no ms. It is useful to determine encoding durations (limited to 24 hours though):