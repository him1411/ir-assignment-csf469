What is the difference between action and actionListener, and when should I use action versus actionListener?Use actionListener if you want have a hook before the real business action get executed, e.g. to log it, and/or to set an additional property (by <f:setPropertyActionListener>), and/or to have access to the component which invoked the action (which is available by ActionEvent argument). So, purely for preparing purposes before the real business action gets invoked.The actionListener method has by default the following signature:And it\'s supposed to be declared as follows, without any method parentheses:Note that you can\'t pass additional arguments by EL 2.2. You can however override the ActionEvent argument altogether by passing and specifying custom argument(s). The following examples are valid:Note the importance of the parentheses in the argumentless method expression. If they were absent, JSF would still expect a method with ActionEvent argument.If you\'re on EL 2.2+, then you can declare multiple action listener methods via <f:actionListener binding>.Note the importance of the parentheses in the binding attribute. If they were absent, EL would confusingly throw a javax.el.PropertyNotFoundException: Property \'actionListener1\' not found on type com.example.Bean, because the binding attribute is by default interpreted as a value expression, not as a method expression. Adding EL 2.2+ style parentheses transparently turns a value expression into a method expression. See also a.o. Why am I able to bind <f:actionListener> to an arbitrary method if it's not supported by JSF?Use action if you want to execute a business action and if necessary handle navigation. The action method can (thus, not must) return a String which will be used as navigation case outcome (the target view). A return value of null or void will let it return to the same page and keep the current view scope alive. A return value of an empty string or the same view ID will also return to the same page, but recreate the view scope and thus destroy any currently active view scoped beans and, if applicable, recreate them. The action method can be any valid MethodExpression, also the ones which uses EL 2.2 arguments such as below:With this method:Note that when your action method solely returns a string, then you can also just specify exactly that string in the action attribute. Thus, this is totally clumsy:With this senseless method returning a hardcoded string:Instead, just put that hardcoded string directly in the attribute:Please note that this in turn indicates a bad design: navigating by POST. This is not user nor SEO friendly. This all is explained in When should I use h:outputLink instead of h:commandLink? and is supposed to be solved asSee also How to navigate in JSF? How to make URL reflect current page (and not previous one).Since JSF 2.x there\'s a third way, the <f:ajax listener>.The ajaxListener method has by default the following signature:In Mojarra, the AjaxBehaviorEvent argument is optional, below works as good.But in MyFaces, it would throw a MethodNotFoundException. Below works in both JSF implementations when you want to omit the argument.Ajax listeners are not really useful on command components. They are more useful on input and select components <h:inputXxx>/<h:selectXxx>. In command components, just stick to action and/or actionListener for clarity and better self-documenting code. Moreover, like actionListener, the f:ajax listener does not support returning a navigation outcome.For explanation on execute and render attributes, head to Understanding PrimeFaces process/update and JSF f:ajax execute/render attributes.The actionListeners are always invoked before the action in the same order as they are been declared in the view and attached to the component. The f:ajax listener is always invoked before any action listener. So, the following example:Will invoke the methods in the following order:The actionListener supports a special exception: AbortProcessingException. If this exception is thrown from an actionListener method, then JSF will skip any remaining action listeners and the action method and proceed to render response directly. You won\'t see an error/exception page, JSF will however log it. This will also implicitly be done whenever any other exception is being thrown from an actionListener. So, if you intend to block the page by an error page as result of a business exception, then you should definitely be performing the job in the action method. If the sole reason to use an actionListener is to have a void method returning to the same page, then that\'s a bad one. The action methods can perfectly also return void, on the contrary to what some IDEs let you believe via EL validation. Note that the PrimeFaces showcase examples are littered with this kind of actionListeners over all place. This is indeed wrong. Don\'t use this as an excuse to also do that yourself.In ajax requests, however, a special exception handler is needed. This is regardless of whether you use listener attribute of <f:ajax> or not. For explanation and an example, head to Exception handling in JSF ajax requests.As BalusC indicated, the actionListener by default swallows exceptions, but in JSF 2.0 there is a little more to this. Namely, it doesn\'t just swallows and logs, but actually publishes the exception.This happens through a call like this:The default listener for this event is the ExceptionHandler which for Mojarra is set to com.sun.faces.context.ExceptionHandlerImpl. This implementation will basically rethrow any exception, except when it concerns an AbortProcessingException, which is logged. ActionListeners wrap the exception that is thrown by the client code in such an AbortProcessingException which explains why these are always logged.This ExceptionHandler can be replaced however in faces-config.xml with a custom implementation:Instead of listening globally, a single bean can also listen to these events. The following is a proof of concept of this:(note, this is not how one should normally code listeners, this is only for demonstration purposes!)Calling this from a Facelet like this:Will result in an error page being displayed.ActionListener gets fired first, with an option to modify the response, before Action gets called and determines the location of the next page.If you have multiple buttons on the same page which should go to the same place but do slightly different things, you can use the same Action for each button, but use a different ActionListener to handle slightly different functionality.Here is a link that describes the relationship:http://www.java-samples.com/showtutorial.php?tutorialid=605