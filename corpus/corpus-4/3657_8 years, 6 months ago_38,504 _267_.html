For a number of years now I have been unable to get a decent answer to the following question: why are some developers so against checked exceptions?  I have had numerous conversations, read things on blogs, read what Bruce Eckel had to say (the first person I saw speak out against them).  I am currently writing some new code and paying very careful attention to how I deal with exceptions.  I am trying to see the point of view of the "we don\'t like checked exceptions" crowd and I still cannot see it.Every conversation I have ends with the same question going unanswered... let me set it up:In general (from how Java was designed), A common argument I hear is that if an exception happens then all the developer is going to do is exit the program.Another common argument I hear is that checked exceptions make it harder to refactor code.For the "all I am going to do is exit" argument I say that even if you are exiting you need to display a reasonable error message.  If you are just punting on handling errors then your users won\'t be overly happy when the program exits without a clear indication of why.For the "it makes it hard to refactor" crowd, that indicates that the proper level of abstraction wasn\'t chosen.  Rather than declare a method throws an IOException, the IOException should be transformed into an exception that is more suited for what is going on. I don\'t have an issue with wrapping Main with catch(Exception) (or in some cases catch(Throwable) to ensure that the program can exit gracefully - but I always catch the specific exceptions I need to.  Doing that allows me to, at the very least, display an appropriate error message.The question that people never reply to is this: If you throw RuntimeException\n  subclasses instead of Exception\n  subclasses then how do you know what\n  you are supposed to catch?If the answer is catch Exception then you are also dealing with programmer errors the same way as system exceptions.  That seems wrong to me.If you catch Throwable then you are treating system exceptions and VM errors (and the like) the same way.  That seems wrong to me.If the answer is that you catch only the exceptions you know are thrown then how do you know what ones are thrown?  What happens when programmer X throws a new exception and forgot to catch it?  That seems very dangerous to me.I would say that a program that displays a stack trace is wrong.  Do people who don\'t like checked exceptions not feel that way?So, if you don\'t like checked exceptions can you explain why not AND answer the question that doesn\'t get answered please?Edit: I am not looking for advice on when to use either model, what I am looking for is why people extend from RuntimeException because they don\'t like extending from Exception and/or why they catch an exception and then rethrow a RuntimeException rather than add throws to their method.  I want to understand the motivation for disliking checked exceptions. I think I read the same Bruce Eckel interview that you did - and it\'s always bugged me. In fact, the argument was made by the interviewee (if this is indeed the post you\'re talking about) Anders Hejlsberg, the MS genius behind .NET and C#.http://www.artima.com/intv/handcuffs.htmlFan though I am of Hejlsberg and his work, this argument has always struck me as bogus. It basically boils down to: "Checked exceptions are bad because programmers just abuse them by always catching them and dismissing them which leads to problems being hidden and ignored that would otherwise be presented to the user". By "otherwise presented to the user" I mean if you use a runtime exception the lazy programmer will just ignore it (versus catching it with an empty catch block) and the user will see it.The summary of the summary of the argument is that "Programmers wont use them properly and not using them properly is worse than not having them".There is some truth to this argument and in fact I suspect Goslings motivation for not putting operator overrides in Java comes from a similar argument - they confuse the programmer because they are often abused.But in the end I find it a bogus argument of Hejlsberg\'s and possibly a post-hoc one created to explain the lack rather than a well thought out decision.I would argue that while the over-use of checked exceptions is a bad thing and tends to lead to sloppy handling by users, but the proper use of them allows the API programmer to give great benefit to the API client programmer.Now the API programmer has to be careful not to throw checked exceptions all over the place, or they will simply annoy the client programmer. The very lazy client programmer will resort to catch (Exception) {} as Hejlsberg warns and all benefit will be lost and hell will ensue.\nBut in some circumstances there\'s just no substitute for a good checked exception. For me the classic example is the file-open API. Every programming language in the history of languages (on file systems at least) has an API somewhere that lets you open a file. And every client programmer using this API knows that they have to deal with the case that the file they are trying to open doesn\'t exist. \nLet me rephrase that: Every client programmer using this API should know that they have to deal with this case. \nAnd there\'s the rub: can the API progammer help them know they should deal with it through commenting alone or can they indeed insist the client deal with it.In C the idiom goes something likewhere fopen indicates failure by returning 0 and C (foolishly) lets you treat 0 as a boolean and... Basically you learn this idiom and you\'re okay. But what if you\'re a noob and you didn\'t learn the idiom. Then of course you start out withand learn the hard way.Note that we\'re only talking about strongly typed languages here: There\'s a clear idea of what an API is in a strongly typed language: It\'s a smorgasbord of functionality (methods) for you to use with a clearly defined protocol for each one.That clearly defined protocol is typically defined by a method signature. \nHere fopen requires that you pass it a string (or a char* in the case of C). If you give it something else you get a compile-time error. You didn\'t follow the protocol - you\'re not using the API properly.In some (obscure) languages the return type is part of the protocol too. If you try to call the equivalent of fopen() in some languages without assigning it to a variable you\'ll also get a compile time error (you can only do that with void functions).The point I\'m trying to make is that: In a statically typed language the API programmer encourages the client to use the API properly by preventing their client code from compiling if it makes any obvious mistakes.(In a dynamically typed language, like Ruby, you can pass anything, say a float, as the file name - and it will compile. Why hassle the user with checked exceptions if you\'re not even going to control the method arguments. The arguments made here apply to statically-typed languages only.)So, what about checked exceptions?Well here\'s one of the Java APIs you can use for opening a file.See that catch? Here\'s the signature for that API method:Note that FileNotFoundException is a checked exception.The API programmer is saying this to you:\n  "You may use this constructor to create a new FileInputStream but you a) must pass in the file name as a\n    String\nb) must accept the\n    possibility that the file might not\n    be found at runtime"And that\'s the whole point as far as I\'m concerned.The key is basically what the question states as "Things that are out of the programmers control". My first thought was that he/she means things that are out of the API programmers control. But in fact, checked exceptions when used properly should really be for things that are out of both the client programmer\'s and the API programmer\'s control. I think this is the key to not abusing checked exceptions.I think the file-open illustrates the point nicely. The API programmer knows you might give them a file name that turns out to be nonexistent at the time the API is called, and that they won\'t be able to return you what you wanted, but will have to throw an exception. They also know that this will happen pretty regularly and that the client programmer might expect the file name to be correct at the time they wrote the call, but it might be wrong at runtime for reasons beyond their control too.So the API makes it explicit: There will be cases where this file doesn\'t exist at the time you call me and you had damn well better deal with it.This would be clearer with a counter-case. Imagine I\'m writing a table API. I have the table model somewhere with an API including this method:Now as an API programmer I know there will be cases where some client passes in a negative value for the row or a row value outside of the table. So I might be tempted to throw a checked exception and force the client to deal with it:(I wouldn\'t really call it "Checked" of course.)This is bad use of checked exceptions. The client code is going to be full of calls to fetch row data, every one of which is going to have to use a try/catch, and for what? Are they going to report to the user that the wrong row was sought? Probably not - because whatever the UI surrounding my table view is, it shouldn\'t let the user get into a state where an illegal row is being requested. So it\'s a bug on the part of the client programmer. The API programmer can still predict that the client will code such bugs and should handle it with a runtime exception like an IllegalArgumentException. With a checked exception in getRowData, this is clearly a case that\'s going to lead to Hejlsberg\'s lazy programmer simply adding empty catches. When that happens, the illegal row values will not be obvious even to the tester or the client developer debugging, rather they\'ll lead to knock-on errors that are hard to pinpoint the source of. Arianne rockets will blow up after launch. Okay, so here\'s the problem: I\'m saying that the checked exception FileNotFoundException is not just a good thing but an essential tool in the API programmers toolbox for defining the API in the most useful way for the client programmer. But the CheckedInvalidRowNumberException is a big inconvenience, leading to bad programming and should be avoided. But how to tell the difference. I guess it\'s not an exact science and I guess that underlies and perhaps justifies to a certain extent Hejlsberg\'s argument. But I\'m not happy throwing the baby out with the bathwater here, so allow me to extract some rules here to distinguish good checked exceptions from bad:Out of client\'s control or Closed vs Open: Checked exceptions should only be used where the error case is out of control of both the API and the client programmer.\nThis has to do with how open or closed the system is. In a constrained UI where the client programmer has control, say, over all of the buttons, keyboard commands etc that add and delete rows from the table view (a closed system), it is a client programming bug if it attempts to fetch data from a nonexistent row. In a file based operating system where any number of users/applications can add and delete files (an open system) it is conceivable that the file the client is requesting has been deleted without their knowledge so they should be expected to deal with it.  Ubiquity:Checked exceptions should not be used on an API call that is made frequently by the client.\nBy frequently I mean from a lot of places in the client code - not frequently in time. So a client code doesn\'t tend to try to open the same file a lot, but my table view gets RowData all over the place from different methods. In particular I\'m going to be writing a lot of code likeand it will be painful to have to wrap in try/catch every time.Informing the User:Checked exceptions should be used in cases where you can imagine a useful error message being presented to the end user. \nThis is the "and what will you do when it happens?" question I raised above. It also relates to item 1. Since you can predict that something outside of your client-API system might cause the file to not be there, you can reasonably tell the user about it:Since your illegal row number was caused by an internal bug and through no fault of the user, there\'s really no useful information you can give them. If your app doesn\'t let runtime exceptions fall through to the console it will probably end up giving them some ugly message like:In short, if you don\'t think your client programmer can explain your exception in a way that helps the user, then you should probably not be using a checked exception.So those are my rules. Somewhat contrived, and there will doubtless be exceptions (please help me refine them if you will). But my main argument is that there are cases like FileNotFoundException where the checked exception is as important and useful a part of the API contract as the parameter types. So we should not dispense with it just because it is misused. Sorry, didn\'t mean to make this so long and waffly. Let me finish with two suggestions:A: API programmers: use checked exceptions sparingly to preserve their usefulness. When in doubt use an unchecked exception.B: Client programmers: get in the habit of creating a wrapped exception (google it) early on in your development. JDK 1.4 and later provide a constructor in RuntimeException for this, but you can easily create your own too. Here\'s the constuctor:Then get in the habit of whenever you have to handle a checked exception and you\'re feeling lazy (or you think the API programmer was overzealous in using the checked exception in the first place), don\'t just swallow the exception, wrap it and rethrow it.Put this in one of your IDE\'s little code templates and use it when you\'re feeling lazy. This way if you really need to handle the checked exception you\'ll be forced to come back and deal with it after seeing the problem at runtime. Because, believe me (and Anders Hejlsberg), you\'re never going to come back to that TODO in yourThe thing about checked exceptions is that they are not really exceptions by the usual understanding of the concept. Instead, they are API alternative return values.The whole idea of exceptions is that an error thrown somewhere way down the call chain can bubble up and be handled by code somewhere further up, without the intervening code having to worry about it. Checked exceptions, on the other hand, require every level of code between the thrower and the catcher to declare they know about all forms of exception that can go through them. This is really little different in practice to if checked exceptions were simply special return values which the caller had to check for. eg.[pseudocode]:Since Java can\'t do alternative return values, or simple inline tuples as return values, checked exceptions are are a reasonable response.The problem is that a lot of code, including great swathes of the standard library, misuse checked exceptions for real exceptional conditions that you might very well want to catch several levels up. Why is IOException not a RuntimeException? In every other language I can let an IO exception happen, and if I do nothing to handle it, my application will stop and I\'ll get a handy stack trace to look at. This is the best thing that can happen.Maybe two methods up from the example you want to catch all IOExceptions from the whole writing-to-stream process, abort the process and jump into the error reporting code; in Java you can\'t do that without adding \xe2\x80\x98throws IOException\xe2\x80\x99 at every call level, even levels that themselves do no IO. Such methods should not need\xe2\x80\x89to know about the exception handling; having to add exceptions to their signatures:And then there\'s plenty of just ridiculous library exceptions like:When you have to clutter up your code with ludicrous crud like this, it is no wonder checked exceptions receive a bunch of hate, even though really this is just simple poor API design.Another particular bad effect is on Inversion of Control, where component A supplies a callback to generic component B. Component A wants to be able to let an exception throw from its callback back to the place where it called component B, but it can\'t because that would change the callback interface which is fixed by B. A can only do it by wrapping the real exception in a RuntimeException, which is yet more exception-handling boilerplate to write.Checked exceptions as implemented in Java and its standard library mean boilerplate, boilerplate, boilerplate. In an already verbose language this is not a win.Rather than rehash all the (many) reasons against checked exceptions, I\'ll pick just one.  I\'ve lost count of the number of times I\'ve written this block of code:99% of the time I can\'t do anything about it.  Finally blocks do any necessary cleanup (or at least they should).I\'ve also lost count of the number of times I\'ve seen this:Why?  Because someone had to deal with it and was lazy.  Was it wrong?  Sure.  Does it happen?  Absolutely.  What if this were an unchecked exception instead?  The app would\'ve just died (which is preferable to swallowing an exception).And then we have infuriating code that uses exceptions as a form of flow control, like java.text.Format does.  Bzzzt.  Wrong.  A user putting "abc" into a number field on a form is not an exception.Ok, i guess that was three reasons.Well, it\'s not about displaying a stacktrace or silently crashing.  It\'s about being able to communicate errors between layers.The problem with checked exceptions is they encourage people to swallow important details (namely, the exception class).  If you choose not to swallow that detail, then you have to  keep adding throws declarations across your whole app.  This means 1) that a new exception type will affect lots of function signatures, and 2) you can miss a specific instance of the exception you actually -want- to catch (say you open a secondary file for a function that writes data to a file.  The secondary file is optional, so you can ignore its errors, but because the signature throws IOException, it\'s easy to overlook this).I\'m actually dealing with this situation now in an application.  We repackaged almost exceptions as AppSpecificException.  This made signatures really clean and we didn\'t have to worry about exploding throws in signatures.Of course, now we need to specialize the error handling at the higher levels, implementing retry logic and such.  Everything is AppSpecificException, though, so we can\'t say "If an IOException is thrown, retry" or "If ClassNotFound is thrown, abort completely".  We don\'t have a reliable way of getting to the real exception because things get repackaged again and again as they pass between our code and third-party code.This is why I\'m a big fan of the exception handling in python.  You can catch only the things you want and/or can handle.  Everything else bubbles up as if you rethrew it yourself (which you have done anyways).I\'ve found, time and time again, and throughout the project I mentioned, that exception handling falls into 3 categories:I know this is an old question but I\'ve spent a while wrestling with checked exceptions and I\'ve something to add. Please forgive me for the length of it!My main beef with checked exceptions is that they ruin polymorphism. It\'s impossible to make them play nicely with polymorphic interfaces.Take the good ol\' Java List interface. We have common in-memory implementations like ArrayList and LinkedList. We also have the the skeletal class AbstractList which makes it easy to design new types of list. For a read-only list we need to implement only two methods: size() and get(int index).This example WidgetList class reads some fixed-size objects of type Widget (not shown) from a file:By exposing the Widgets using the familiar List interface, you can retrieve items (list.get(123)) or iterate a list (for (Widget w : list) ...) without needing to know about WidgetList itself. One can pass this list to any standard methods that use generic lists, or wrap it in a Collections.synchronizedList. Code that uses it need neither know nor care whether the "Widgets" are made up on the spot, come from an array, or are read from a file, or a database, or from across the network, or from a future subspace relay. It will still work correctly because the List interface is correctly implemented.Except it isn\'t. The above class doesn\'t compile because the file access methods may throw an IOException, a checked exception which you have to "catch or specify". You can\'t specify it as thrown -- the compiler won\'t let you because that would violate the contract of the List interface. And there is no useful way that WidgetList itself can handle the exception (as I\'ll expound on later).Apparently the only thing to do is catch and rethrow checked exceptions as some unchecked exception:((Edit: Java 8 has added an UncheckedIOException class for exactly this case: for catching and rethrowing IOExceptions across polymorphic method boundaries. Kind of proves my point!))So checked exceptions simply don\'t work in cases like this. You can\'t throw them. Ditto for a clever Map backed by a database, or an implementation of java.util.Random connected to a quantum entropy source via a COM port. As soon as you try to do anything novel with the implementation of a polymorphic interface, the concept of checked exceptions fails. But checked exceptions are so insidious that they still won\'t leave you in peace, because you still have to catch and rethrow any from lower-level methods, cluttering the code and cluttering the stack trace.I find that the ubiquitous Runnable interface is often backed into this corner, if it calls something which throws checked exceptions. It can\'t throw the exception as is, so all it can do is clutter the code by catching and rethrowing as a RuntimeException.Actually, you can throw undeclared checked exceptions if you resort to hacks. The JVM, at run time, doesn\'t care about checked exception rules, so we need to fool only the compiler. The easiest way to do this is to abuse generics. This is my method for it (class name shown because (before Java 8) it\'s required in the calling syntax for the generic method):Hurray! Using this we can throw a checked exception any depth up the stack without declaring it, without wrapping it in a RuntimeException, and without cluttering the stack trace! Using the "WidgetList" example again:Unfortunately, the final insult of checked exceptions is that the compiler refuses to allow you to catch a checked exception if, in its flawed opinion, it could not have been thrown. (Unchecked exceptions do not have this rule.) To catch the sneakily thrown exception we have to do this:That is a bit awkward, but on the plus side, it is still slightly simpler than the code for extracting a checked exception that was wrapped in a RuntimeException.Happily, the throw t; statement is legal here, even though the type of t is checked, thanks to a rule added in Java 7 about rethrowing caught exceptions.When checked exceptions meet polymorphism, the opposite case is also a problem: when a method is spec\'d as potentially throwing a checked exception, but an overridden implementation doesn\'t. For example, the abstract class OutputStream\'s write methods all specify throws IOException. ByteArrayOutputStream is a subclass that writes to an in-memory array instead of a true I/O source. Its overridden write methods cannot cause IOExceptions, so they have no throws clause, and you can call them without worrying about the catch-or-specify requirement.Except not always. Suppose that Widget has a method for saving it out to a stream:Declaring this method to accept a plain OutputStream is the right thing to do, so it can be used polymorphically with all kinds of outputs: files, databases, the network, and so on. And in-memory arrays. With an in-memory array, however, there is a spurious requirement to handle an exception that can\'t actually happen:As usual, checked exceptions get in the way. If your variables are declared as a base type that has more open-ended exception requirements, you have to add handlers for those exceptions even if you know they won\'t occur in your application.But wait, checked exceptions are actually so annoying, that they won\'t even let you do the reverse! Imagine you currently catch any IOException thrown by write calls on an OutputStream, but you want to change the variable\'s declared type to a ByteArrayOutputStream, the compiler will berate you for trying to catch a checked exception that it says cannot be thrown.That rule causes some absurd problems. For example, one of the three write methods of OutputStream is not overridden by ByteArrayOutputStream. Specifically, write(byte[] data) is a convenience method that writes the full array by calling write(byte[] data, int offset, int length) with an offset of 0 and the length of the array. ByteArrayOutputStream overrides the three-argument method but inherits the one-argument convenience method as-is. The inherited method does exactly the right thing, but it includes an unwanted throws clause. That was perhaps an oversight in the design of ByteArrayOutputStream, but they can never fix it because it would break source compatibility with any code that does catch the exception -- the exception that has never, is never, and never will be thrown!That rule is annoying during editing and debugging too. E.g., sometimes I\'ll comment out a method call temporarily, and if it could have thrown a checked exception, the compiler will now complain about the existence of the local try and catch blocks. So I have to comment those out too, and now when editing the code within, the IDE will indent to the wrong level because the { and } are commented out. Gah! It\'s a small complaint but it seems like the only thing checked exceptions ever do is cause trouble.I\'m nearly done. My final frustration with checked exceptions is that at most call sites, there\'s nothing useful you can do with them. Ideally when something goes wrong we\'d have a competent application-specific handler that can inform the user of the problem and/or end or retry the operation as appropriate. Only a handler high up the stack can do this because it\'s the only one that knows the overall goal.Instead we get the following idiom, which is rampant as a way to shut the compiler up:In a GUI or automated program the printed message won\'t be seen. Worse, it plows on with the rest of the code after the exception. Is the exception not actually an error? Then don\'t print it. Otherwise, something else is going to blow up in a moment, by which time the original exception object will be gone. This idiom is no better than BASIC\'s On Error Resume Next or PHP\'s error_reporting(0);.Calling some kind of logger class is not much better:That is just as lazy as e.printStackTrace(); and still plows on with code in an indeterminate state. Plus, the choice of a particular logging system or other handler is application-specific, so this hurts code reuse.But wait! There is an easy and universal way to find the application-specific handler. It\'s higher up the call stack (or it is set as the Thread\'s uncaught exception handler). So in most places, all you need to do is throw the exception higher up the stack. E.g., throw e;. Checked exceptions just get in the way.I\'m sure checked exceptions sounded like a good idea when the language was designed, but in practice I\'ve found them to be all bother and no benefit.Artima published an interview with one of the architects of .NET, Anders Hejlsberg, which acutely covers the arguments against checked exceptions.  A short taster:The throws clause, at least the way it\'s implemented in Java, doesn\'t necessarily force you to handle the exceptions, but if you don\'t handle them, it forces you to acknowledge precisely which exceptions might pass through. It requires you to either catch declared exceptions or put them in your own throws clause. To work around this requirement, people do ridiculous things. For example, they decorate every method with, "throws Exception." That just completely defeats the feature, and you just made the programmer write more gobbledy gunk. That doesn\'t help anybody.In short:Exceptions are an API design question.  -- No more, no less.The argument for checked exceptions:To understand why checked exceptions might not be good thing, let\'s turn the question around and ask: When or why are checked exceptions attractive, i.e. why would you want the compiler to enforce declaration of exceptions?The answer is obvious: Sometimes you need to catch an exception, and that is only possible if the code being called offers a specific exception class for the error that you are interested in.Hence, the argument for checked exceptions is that the compiler forces programmers to declare which exceptions are thrown, and hopefully the programmer will then also document specific exception classes and the errors that cause them.In reality though, ever too often a package com.acme only throws an AcmeException rather than specific subclasses.  Callers then need to handle, declare, or re-signal AcmeExceptions, but still cannot be certain whether an AcmeFileNotFoundError happened or an AcmePermissionDeniedError.So if you\'re only interested in an AcmeFileNotFoundError, the solution is to file a feature request with the ACME programmers and tell them to implement, declare, and document that subclass of AcmeException.So why bother?Hence, even with checked exceptions, the compiler cannot force programmers to throw useful exceptions.  It is still just a question of the API\'s quality.As a result, languages without checked exceptions usually do not fare much worse.  Programmers might be tempted to throw unspecific instances of a general Error class rather than an AcmeException, but if they care at all about their API quality, they will learn to introduce an AcmeFileNotFoundError after all.Overall, the specification and documentation of exceptions is not much different from the specification and documentation of, say, ordinary methods.  Those, too, are an API design question, and if a programmer forgot to implement or export a useful feature, the API needs to be improved so that you can work with it usefully.If you follow this line of reasoning, it should be obvious that the "hassle" of declaring, catching, and re-throwing of exceptions that is so common in languages like Java often adds little value.It is also worth noting that the Java VM does not have checked exceptions -- only the Java compiler checks them, and class files with changed exception declarations are compatible at run time.  Java VM security is not improved by checked exceptions, only coding style.Firstly, checked exceptions decrease the "signal-to-noise ratio" for the code. Anders Hejlsberg also talks about imperative vs declarative programming which is a similar concept. Anyway consider the following code snippets:Update UI from non UI-thread in Java:Update UI from non UI-thread in C#:Which seems a lot clearer to me. When you start to do more and more UI work in Swing checked exceptions start to become really annoying and useless.To implement even the most basic of implementations, such as Java\'s List interface, checked exceptions as a tool for design by contract fall down. Consider a list that is backed by a database or a filesystem or any other implementation that throws a checked exception. The only possible implementation is to catch the checked exception and rethrow it as an unchecked exception:And now you have to ask what is the point of all that code? The checked exceptions just add noise, the exception has been caught but not handled and design by contract (in terms of checked exceptions) has broken down.I blogged about this previously.I initially agreed with you, as I\'ve always been in favour of checked exceptions, and began to think about why I don\'t like not having checked exceptions in .Net. But then I realised that I don\'t infact like checked exceptions.To answer you question, yes, I like my programs to show stack traces, preferably really ugly ones. I want the application to explode into a horrible heap of the ugliest error messages you could ever want to see.And the reason is because, if it does that, I have to fix it, and I have to fix it right away. I want to know immediately that there is a problem.How many times do you actually handle exceptions? I\'m not talking about catching exceptions -- I\'m talking about handling them? It\'s too easy to write the following:And I know you can say that it\'s bad practice, and that \'the answer\' is to do something with the exception (let me guess, log it?), but in the Real World (tm), most programmers just don\'t do it.So yes, I don\'t want to catch exceptions if I don\'t have to do so, and I want my program to blow up spectacularly when I screw up. Silently failing is the worst  possible outcome.The article Effective Java Exceptions explains nicely when to use unchecked and when to use checked exceptions. Here are some quotes from that article to highlight the main points:Contingency:\n  An expected condition demanding an alternative response from a method that can be expressed in terms of the method\'s intended purpose. The caller of the method expects these kinds of conditions and has a strategy for coping with them.Fault:\n  An unplanned condition that prevents a method from achieving its intended purpose that cannot be described without reference to the method\'s internal implementation.(SO doesn\'t allow tables, so you might want to read the following from the original page...)ContingencyFaultI have been working with several developers in the last three years in relatively complex applications.  We have a code base that uses Checked Exceptions quite often with proper error handling, and some other that doesn\'t.So far, I have it found easier to work with the code base with Checked Exceptions.  When I am using someone else\'s API, it is nice that I can see exactly what kind of error conditions I can expect when I call the code and handle them properly, either by logging, displaying or ignoring (Yes, there is valid cases for ignoring exceptions, such as a ClassLoader implementation). That gives the code I am writing an opportunity to recover. All runtime exceptions I propagate up until they are cached and handled with some generic error handling code.  When I find a checked exception that I don\'t really want to handle at a specific level, or that I consider a programming logic error, then I wrap it into a RuntimeException and let it bubble up. Never, ever swallow an exception without a good reason (and good reasons for doing this are rather scarce) When I work with the codebase that does not have checked exceptions, it makes it to me a little bit harder to know before hand what can I expect when calling the function, which can break some stuff terribly.This is all of course a matter of preference and developer skill.  Both ways of programming and error handling can be equally effective (or noneffective), so I wouldn\'t say that there is The One Way.All in all, I find it easier to work with Checked Exceptions, specially in large projects with lot of developers.When talking about exceptions I always refer back to Eric Lippert\'s Vexing exceptions blog article. He places exceptions into these categories:An API user:The fact that the API user must handle a particular exception is part of the method\'s contract between the caller and the callee. The contract specifies, among other things: the number and types of arguments the callee expects, the type of return value the caller can expect, and the exceptions the caller is expected to handle.Since vexing exceptions should not exist in an API, only these exogenous exceptions must be checked exceptions to be part of the method\'s contract. Relatively few exceptions are exogenous, so any API should have relatively few checked exceptions.A checked exception is an exception that must be handled. Handling an exception can be as simple as swallowing it. There! The exception is handled. Period. If the developer wants to handle it that way, fine. But he can\'t ignore the exception, and has been warned.But any API that has checked vexing and fatal exceptions (e.g. the JCL) will put unnecessary strain on the API users. Such exceptions have to be handled, but either the exception is so common that it should not have been an exception in the first place, or nothing can be done when handling it. And this causes Java developers to hate checked exceptions.Also, many APIs don\'t have a proper exception class hierarchy, causing all kinds of non-exogenous exception causes to be represented by a single checked exception class (e.g. IOException). And this also causes Java developers to hate checked exceptions.Exogenous exceptions are those that are not your fault, could not have been prevented, and which should be handled. These form a small subset of all the exceptions that can get thrown. APIs should only have checked exogenous exceptions, and all other exceptions unchecked. This will make better APIs, put less strain on the API user, and therefore reduce the need to catch all, swallow or rethrow unchecked exceptions.So don\'t hate Java and its checked exceptions. Instead, hate the APIs that overuse checked exceptions.Ok... Checked exceptions are not ideal and have some caveat but they do serve a purpose.  When creating an API there are specific cases of failures that are contractual of this API.  When in the context of a strongly statically typed language such as Java if one does not use checked exceptions then one must rely on ad-hoc documentation and convention to convey the possibility of error.  Doing so removes all benefit that the compiler can bring in handling error and you are left completely to the good will of programmers.So, one removes Checked exception, such as was done in C#, how then can one programmatically and structurally convey the possibility of error ?  How to inform the client code that such and such errors can occur and must be dealt with ?I hear all sorts of horrors when dealing with checked exceptions, they are misused this is certain but so are unchecked exceptions.  I say wait a few years when APIs are stacked many layers deep and you will be begging for the return of some kind of structured mean to convey failures.Take the case when the exception was thrown somewhere at the bottom of the API layers and just bubbled up because nobody knew it was even possible for this error to occur, this even though it was a type of error that was very plausible when the calling code threw it (FileNotFoundException for example as opposed to VogonsTrashingEarthExcept... in which case it would not matter if we handle it or not since there is nothing left to handle it with).Many have argued that not being able to load the file was almost always the end of the world for the process and it must die a horrible and painful death.  So yeah.. sure ... ok.. you build an API for something and it loads file at some point... I as the user of said API can only respond... "Who the hell are you to decide when my program should crash !"  Sure Given the choice where exceptions are gobbled up and leave no trace or the EletroFlabbingChunkFluxManifoldChuggingException with a stack trace deeper than the Marianna trench I would take the latter without a cinch of hesitation, but does this mean that it is the desirable way to deal with exception ?  Can we not be somewhere in the middle, where the exception would be recast and wrapped each time it traversed into a new level of abstraction so that it actually means something ?Lastly, most of the argument I see is "I don\'t want to deal with exceptions, many people do not want to deal with exceptions.  Checked exceptions force me to deal with them thus I hate checked exception"  To eliminate such mechanism altogether and relegate it to the chasm of goto hell is just silly and lacks jugement and vision.  If we eliminate checked exception we could also eliminate the return type for functions and always return a "anytype" variable...  That would make life so much simpler now would it not ?Anders speaks about the pitfalls of checked exceptions and why he left them out of C# in episode 97 of Software Engineering radio. Indeed, checked exceptions on the one hand increase robustness and correctness of your program (you\'re forced to make correct declarations of your interfaces -the exceptions a method throws are basically a special return type). On the other hand you face the problem that, since exceptions "bubble up", very often you need to change a whole lot of methods (all the callers, and the callers of the callers, and so on) when you change the exceptions one method throws.Checked exceptions in Java do not solve the latter problem; C# and VB.NET throw out the baby with the bathwater.A nice approach that takes the middle road is described in this OOPSLA 2005 paper (or the related technical report.)In short, it allows you to say: method g(x) throws like f(x), which means that g throws all the exceptions f throws. Voila, checked exceptions without the cascading changes problem.Although it is an academic paper, I\'d encourage you to read (parts of) it, as it does a good job of explaining what the benefits and downsides of checked exceptions are.The worst problem I see with exception handling mechanism is that it introduces code duplication in a big scale! Let\'s be honest: In most of projects in 95% of the time all that developers really need to do with exception is to communicate it somehow to the user (and, in some cases, to the development team as well, e.g. by sending an e-mail with the stack trace). So usually the same line/block of code is used in every place the exception is handled.Let\'s assume that we do simple logging in each catch block for some type of checked exception:If it\'s a common exception there may be even several hundreds of such try-catch blocks in a larger codebase. Now let\'s assume that we need to introduce popup dialog based exception handling instead of console logging or start to additionally send an e-mail to the development team.Wait a moment... are we really going to edit all of that several hundreds of locations in the code?! You get my point :-).What we did to adress that issue was introducing the concept of exception handlers (to which I\'ll further refer as EH\'s) to centralize exception handling. To every class that needs to hande exceptions an instance of exception handler is injected by our Dependency Injection framework. So the typical pattern of exception handling now looks like this:Now to customize our exception handling we only need to change the code in a single place (EH code). Of course for more complex cases we can implement several subclasses of EHs and leverage features that our DI framework provides us. By changing our DI framework configuration we can easily switch EH implementation globally or provide specific implementations of EH to classes with special exception handling needs (for example using Guice @Named annotation). That way we can differentiate exception handling behaviour in development and release version of application (eg. development - logging the error and halting the application, prod - logging the error with more details and letting the application continue its execution) with no effort.Last but not least, it may seem that the same kind of centralisation can be obtained by just passing our exceptions "up" until they arrive to some top level exception handling class. But that leads to cluttering of code and signatures of our methods and introduces maintenance problems mentioned by others in this thread. As folks have already stated, checked exceptions don\'t exist in Java bytecode. They are simply a compiler mechanism, not unlike other syntax checks. I see checked exceptions a lot like I see the compiler complaining about unreachable code at b: if(true) { a; } b;. That\'s helpful but I might have done this on purpose, so let me ignore your warnings.The fact of the matter is, you aren\'t going to be able to force every programmer to "do the right thing" if you enforce checked exceptions and everyone else is now collateral damage who just hates you for the rule you made.Fix the bad programs out there! Don\'t try to fix the language to not allow them! For most folks, "doing something about an exception" is really just telling the user about it. I can tell the user about an unchecked exception just as well, so keep your checked exception classes out of my API.My writeup on c2.com is still mostly unchanged from its original form: CheckedExceptionsAreIncompatibleWithVisitorPatternIn summary:Visitor Pattern and its relatives are a class of interfaces where the indirect caller and interface implementation both know about an exception but the interface and direct caller form a library that cannot know.The fundamental assumption of CheckedExceptions is all declared exceptions can be thrown from any point that calls a method with that declaration. The VisitorPattern reveals this assumption to be faulty.The final result of checked exceptions in cases like these is a lot of otherwise useless code that essentially removes the compiler\'s checked exception constraint at runtime.As for the underlying problem:My general idea is the top-level handler needs to interpret the exception and display an appropriate error message. I almost always see either IO exceptions, communication exceptions (for some reason APIs distinguish), or task-fatal errors (program bugs or severe problem on backing server), so this should not be too hard if we allow a stack trace for a severe server problem.To attempt to address just the unanswered question:If you throw RuntimeException subclasses instead of Exception subclasses then how do you know what you are supposed to catch?The question contains specious reasoning IMHO. Just because the API tells you what it throws doesn\'t mean you deal with it in the same way in all cases. \nTo put it another way, the exceptions you need to catch vary depending on the context in which you use the component throwing the exception.For example:If I\'m writing a connection tester for a database, or something to check the validity of a user entered XPath, then I\'d probably want to catch and report on all checked and unchecked exceptions that are thrown by the operation.If, however, I am writing a processing engine, I will likely treat an XPathException (checked) in the same way as an NPE: I would let it run up to the top of the worker thread, skip the rest of that batch, log the issue (or send it to a support department for diagnosis) and leave feedback for the user to contact support. Here\'s one argument against checked exceptions (from joelonsoftware.com):The reasoning is that I consider exceptions to be no better than\n  "goto\'s", considered harmful since the 1960s, in that they create an\n  abrupt jump from one point of code to another. In fact they are\n  significantly worse than goto\'s:This article is the best piece of text on exception handling in Java I have ever read. It favours unchecked over checked exceptions but this choice is explained very thouroughly and based on strong arguments.I don\'t want to cite too much of the article content here (it\'s best to read it as a whole) but it covers most of arguments of unchecked exceptions advocates from this thread. Especially this argument (which seems to be quite popular) is covered:Take the case when the exception was thrown somewhere at the bottom of the API layers and just bubbled up because nobody knew it was even possible for this error to occur, this even though it was a type of error that was very plausible when the calling code threw it (FileNotFoundException for example as opposed to VogonsTrashingEarthExcept... in which case it would not matter if we handle it or not since there is nothing left to handle it with).The author "responses":It is absolutely incorrect to assume that all runtime exceptions\n  should not be caught and allowed to propagate to the very "top" of the\n  application. (...) For every exceptional condition that is required to\n  be handled distinctly - by the system/business requirements -\n  programmers must decide where to catch it and what to do once the\n  condition is caught. This must be done strictly according to the\n  actual needs of the application, not based on a compiler alert. All\n  other errors must be allowed to freely propagate to the topmost\n  handler where they would be logged and a graceful (perhaps,\n  termination) action will be taken.And the main thought or article is:When it comes to error handling in software, the only safe and correct assumption that may ever be made is that a failure may occur in absolutely every subroutine or module that exists!So if "nobody knew it was even possible for this error to occur" there is something wrong with that project. Such exception should be handled by at least the most generic exception handler (e.g. the one that handles all Exceptions not handled by more specific handlers) as author suggests.So sad not many poeple seems to discover this great article :-(. I recommend wholeheartly everyone who hesitates which approach is better to take some time and read it.A problem with checked exceptions is that exceptions are often attached to methods of an interface if even one implementation of that interface uses it.Another problem with checked exceptions is that they tend to be misused.  The perfect example of this is in java.sql.Connection\'s close() method.  It can throw a SQLException, even though you\'ve already explicitly stated that you\'re done with the Connection.  What information could close() possibly convey that you\'d care about?Usually, when I close() a connection*, it looks something like this:Also, don\'t get me started on the various parse methods and NumberFormatException... .NET\'s TryParse, which doesn\'t throw exceptions, is so much easier to use it\'s painful to have to go back to Java (we use both Java and C# where I work).*As an additional comment, a PooledConnection\'s Connection.close() doesn\'t even close a connection, but you still have to catch the SQLException due to it being a checked exception.Checked exceptions were, in their original form, an attempt to handle contingencies rather than failures. The laudable goal was to highlight specific predictable points (unable to connect, file not found, etc) & ensure developers handled these.What was never included in the original concept, was to force a vast range of systemic & unrecoverable failures to be declared. These failures were never correct to be declared as checked exceptions.Failures are generally possible in code, and EJB, web & Swing/AWT containers already cater for this by providing an outermost \xe2\x80\x9cfailed request\xe2\x80\x9d exception-handler. The most basic correct strategy is to rollback the transaction & return an error.One crucial point, is that runtime & checked exceptions are functionally equivalent. There is no handling or recovery which checked exceptions can do, that runtime exceptions can\xe2\x80\x99t.The biggest argument against \xe2\x80\x9cchecked\xe2\x80\x9d exceptions is that most exceptions can\xe2\x80\x99t be fixed. The simple fact is, we don\xe2\x80\x99t own the code/ subsystem that broke. We can\xe2\x80\x99t see the implementation, we\xe2\x80\x99re not responsible for it, and can\xe2\x80\x99t fix it.If our application is not a DB.. we shouldn\'t try and fix the DB. That would violate the  principle of encapsulation.Particularly problematic have been the areas of JDBC (SQLException) and RMI for EJB (RemoteException). Rather than identifying fixable contingencies as per the original \xe2\x80\x9cchecked exception\xe2\x80\x9d concept, these forced pervasive systemic reliability issues, not actually fixable, to be widely declared.The other severe flaw in the Java design, was that exception-handling should correctly placed at the highest possible "business" or "request" level. The principle here is "throw early, catch late". Checked exceptions do little but get in the way of this.We have an obvious issue in Java of requiring thousands of do-nothing try-catch blocks, with a significant proportion (40%+) being miscoded. Almost none of these implement any genuine handling or reliability, but impose major coding overhead.Lastly, "checked exceptions" are pretty much incompatible with FP functional programming. Their insistence on "handle immediately" is at odds with both "catch late" exception-handling best practice, and any FP structure which abstracts loops/ or flow of control.Many people talk about "handling" checked exceptions, but are talking through their hats. Continuing after a failure with null, incomplete or incorrect data to pretend success is not handling anything. It\'s engineering/ reliability malpractice of the lowest form.Failing cleanly, is the most basic correct strategy for handling an exception. Rolling back the transaction, logging the error & reporting a "failure" response to the user are sound practice -- and most importantly, prevent incorrect business data being committed to the database.Other strategies for exception-handling are "retry", "reconnect" or "skip", at the business, subsystem, or request level. All of these are general reliability strategies, and work well/ better with runtime exceptions.Lastly, it is far preferable to fail, than to run with incorrect data. Continuing will either cause secondary errors, distant from the original cause & harder to debug; or will eventually result in erroneous data being committed. People get fired for that.See:\n- http://literatejava.com/exceptions/checked-exceptions-javas-biggest-mistake/I think that this is an excellent question and not at all argumentative. I think that 3rd party libraries should (in general) throw unchecked exceptions. This means that you can isolate your dependencies on the library (i.e. you don\'t have to either re-throw their exceptions or throw Exception - usually bad practice). Spring\'s DAO layer is an excellent example of this.On the other hand, exceptions from the core Java API should in general be checked if they could ever be handled. Take FileNotFoundException or (my favourite) InterruptedException. These conditions should almost always be handled specifically (i.e. your reaction to an InterruptedException is not the same as your reaction to an IllegalArgumentException). The fact that your exceptions are checked forces developers to think about whether a condition is handle-able or not. (That said, I\'ve rarely seen InterruptedException handled properly!)One more thing - a RuntimeException is not always "where a developer got something wrong". An illegal argument exception is thrown when you try and create an enum using valueOf and there\'s no enum of that name. This is not necessarily a mistake by the developer!We\'ve seen some references to C#\'s chief architect.Here\'s an alternate point of view from a Java guy about when to use checked exceptions. He acknowledges many of the negatives others have mentioned:\nEffective ExceptionsThe good proves that Checked Exception are not needed are:I was happy if java would provide me with a choice what to use, when working with core libs, like I/O. Like provides two copies of same classes - one wrapped with RuntimeEception. Then we can compare what people would use. For now, though, many people would better go for some framework on top on java, or different language. Like Scala, JRuby whatever. Many just believe that SUN was right.Despite having read the whole page, I still can\'t find a single reasonable argument against checked exceptions. Most people are instead talking about poor API design, either at some Java classes or at their own classes.The only scenario where this feature may be annoying is prototiping. This could be solved by adding some mechanism to the language (for instance, some @supresscheckedexceptions annotation). But for regular programming, I think checked exceptions are a good thing.The programmer needs to know all of the exceptions that a method may throw, in order to use it correctly. So, beating him over the head with just some of the exceptions does not necessarily help a careless programmer avoid errors.The slim benefit is outweighed by the burdensome cost (especially in larger, less flexible code bases where constantly modifying the interface signatures is not practical).Static analysis can be nice, but truly reliable static analysis often inflexibly demands strict work from the programmer. There is a cost-benefit calculation, and the bar needs to be set high for a check that leads to a compile time error. It would be more helpful if the IDE took on the role of communicating which exceptions a method may throw (including which are unavoidable). Although perhaps it would not be as reliable without forced exception declarations, most exceptions would still be declared in documentation, and the reliability of an IDE warning is not so crucial.This isn\'t an argument against the pure concept of checked exceptions, but the class hierarchy Java uses for them is a freak show. We always call the things simply "exceptions" \xe2\x80\x93 which is correct, because the language specification calls them that too \xe2\x80\x93 but how is an exception named and represented in the type system?By the class Exception one imagines? Well no, because Exceptions are exceptions, and likewise exceptions are Exceptions, except for those exceptions that are not Exceptions, because other exceptions are actually Errors, which are the other kind of exception, a kind of extra-exceptional exception that should never happen except when it does, and which you should never catch except sometimes you have to. Except that\'s not all because you can also define other exceptions that are neither Exceptions nor Errors but merely Throwable exceptions.Which of these are the "checked" exceptions? Throwables are checked exceptions, except if they\'re also Errors, which are unchecked exceptions, and then there\'s the Exceptions, which are also Throwables and are the main type of checked exception, except there\'s one exception to that too, which is that if they are also RuntimeExceptions, because that\'s the other kind of unchecked exception.What are RuntimeExceptions for? Well just like the name implies, they\'re exceptions, like all Exceptions, and they happen at run-time, like all exceptions actually, except that RuntimeExceptions are exceptional compared to other run-time Exceptions because they aren\'t supposed to happen except when you make some silly error, although RuntimeExceptions are never Errors, so they\'re for things that are exceptionally erroneous but which aren\'t actually Errors. Except for RuntimeErrorException, which really is a RuntimeException for Errors. But aren\'t all exceptions supposed to represent erroneous circumstances anyway? Yes, all of them. Except for ThreadDeath, an exceptionally unexceptional exception, as the documentation explains that it\'s a "normal occurrence" and that that\'s why they made it a type of Error.Anyway, since we\'re dividing all exceptions down the middle into Errors (which are for exceptional execution exceptions, so unchecked) and Exceptions (which are for less exceptional execution errors, so checked except when they\'re not), we now need two different kinds of each of several exceptions. So we need IllegalAccessError and IllegalAccessException, and InstantiationError and InstantiationException, and NoSuchFieldError and NoSuchFieldException, and NoSuchMethodError and NoSuchMethodException, and ZipError and ZipException.Except that even when an exception is checked, there are always (fairly easy) ways to cheat the compiler and throw it without it being checked. If you do you that you may get an UndeclaredThrowableException, except in other cases, where it could throw up as an UnexpectedException, or an UnknownException (which is unrelated to UnknownError, which is only for "serious exceptions"), or an ExecutionException, or an InvocationTargetException, or an ExceptionInInitializerError.Oh, and we mustn\'t forget Java 8\'s snazzy new UncheckedIOException, which is a RuntimeException exception designed to let you throw the exception checking concept out the window by wrapping checked IOException exceptions caused by I/O errors (which don\'t cause IOError exceptions, although that exists too) that are exceptionally difficult to handle and so you need them to not be checked.Thanks Java!I\'ve read a lot about exception handling, even if (most of the time) I cannot really say I\'m happy or sad about the existence of checked exceptions this is my take : checked exceptions in low-level code(IO, networking, OS, etc) and unchecked exceptions in high-level APIs/application level. Even if there is not so easy to draw a line between them, I find that it is really annoying/difficult to integrate several APIs/libraries under the same roof without wrapping all the time lots of checked exceptions but on the other hand, sometime it is useful/better to be forced to catch some exception and provide a different one which makes more sense in the current context.The project I\'m working on takes lots of libraries and integrates them under the same API, API which is completely based on unchecked exceptions.This frameworks provides a high-level API which in the beginning was full of checked exceptions and had only several unchecked exceptions(Initialization Exception, ConfigurationException, etc) and I must say was not very friendly. Most of the time you had to catch or re-throw exceptions which you don\'t know how to handle, or you don\'t even care(not to be confused with you should ignore exceptions), especially on the client side where a single click could throw 10 possible (checked) exceptions.The current version(3rd one) uses only unchecked exceptions, and it has a global exception handler which is responsible to handle anything uncaught. The API provides a way to register exception handlers, which will decide if an exception is considered an error(most of the time this is the case) which means log & notify somebody, or it can mean something else - like this exception, AbortException, which means break the current execution thread and don\'t log any error \'cause it is desired not to. Of course, in order to work out all custom thread must handle the run() method with a try {...} catch(all).public void run() {}This is not necessary if you use the WorkerService to schedule jobs(Runnable, Callable, Worker), which handles everything for you.Of course this is just my opinion, and it might not be the right one, but it looks like a good approach to me. I will see after I will release the project if what I think it is good for me, it is good for others too... :)