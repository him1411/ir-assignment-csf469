When I create a new Date object, it is initialized to the current time but in the local timezone. How can I get the current date and time in GMT?java.util.Date has no specific time zone, although its value is most commonly thought of in relation to UTC. What makes you think it\'s in local time?To be precise: the value within a java.util.Date is the number of milliseconds since the Unix epoch, which occurred at midnight January 1st 1970, UTC. The same epoch could also be described in other time zones, but the traditional description is in terms of UTC. As it\'s a number of milliseconds since a fixed epoch, the value within java.util.Date is the same around the world at any particular instant, regardless of local time zone.I suspect the problem is that you\'re displaying it via an instance of Calendar which uses the local timezone, or possibly using Date.toString() which also uses the local timezone, or a SimpleDateFormat instance, which, by default, also uses local timezone.If this isn\'t the problem, please post some sample code.I would, however, recommend that you use Joda-Time anyway, which offers a much clearer API.Generate a String to represent that value:2016-09-13T23:30:52.123ZAs the correct answer by Jon Skeet stated, a java.util.Date object has no time zone\xe2\x80\xa0. But its toString implementation applies the JVM\xe2\x80\x99s default time zone when generating the String representation of that date-time value. Confusingly to the na\xc3\xafve programmer, a Date seems to have a time zone but does not.The java.util.Date, j.u.Calendar, and java.text.SimpleDateFormat classes bundled with Java are notoriously troublesome. Avoid them. Instead, use either of these competent date-time libraries: Java 8 brings an excellent new java.time.* package to supplant the old java.util.Date/Calendar classes. Getting current time in UTC/GMT is a simple one-liner\xe2\x80\xa6That Instant class is the basic building block in java.time, representing a moment on the timeline in UTC with a resolution of nanoseconds. In Java 8, the current moment is captured with only up to milliseconds resolution. Java 9 brings a fresh implementation of Clock captures the current moment in up to the full nanosecond capability of this class, depending on the ability of your host computer\xe2\x80\x99s clock hardware.It\xe2\x80\x99s toString method generates a String representation of its value using one specific ISO 8601 format. That format outputs zero, three, six or nine digits digits (milliseconds, microseconds, or nanoseconds) as necessary to represent the fraction-of-second.If you want more flexible formatting, adjustments in or out of various time zones, or other additional features, then apply a time zone (ZoneId object) to get a ZonedDateTime. The time zone can be for UTC or any other time zone. The subclass of ZoneId, ZoneOffset holds a constant for UTC.Dump to console\xe2\x80\xa6When run\xe2\x80\xa6The java.time classes are defined by JSR 310. They were inspired by Joda-Time but are entirely re-architected.UPDATE: The Joda-Time project, now in maintenance mode, advises migration to the java.time classes.Using the Joda-Time 3rd-party open-source free-of-cost library, you can get the current date-time in just one line of code.Joda-Time inspired the new java.time.* classes in Java 8, but has a different architecture. You may use Joda-Time in older versions of Java. Joda-Time continues to work in Java 8 and continues to be actively maintained (as of 2014). However, the Joda-Time team does advise migration to java.time.More detailed example code (Joda-Time 2.3)\xe2\x80\xa6Dump to console\xe2\x80\xa6When run\xe2\x80\xa6For more example code doing time zone work, see my answer to a similar question.I recommend you always specify a time zone rather than relying implicitly on the JVM\xe2\x80\x99s current default time zone (which can change at any moment!). Such reliance seems to be a common cause of confusion and bugs in date-time work.When calling now() pass the desired/expected time zone to be assigned. Use the DateTimeZone class.That class holds a constant for UTC time zone.If you truly want to use the JVM\xe2\x80\x99s current default time zone, make an explicit call so your code is self-documenting.Read about ISO 8601 formats. Both java.time and Joda-Time use that standard\xe2\x80\x99s sensible formats as their defaults for both parsing and generating strings.\xe2\x80\xa0 Actually, java.util.Date does have a time zone, buried deep under layers of source code. For most practical purposes, that time zone is ignored. So, as shorthand, we say java.util.Date has no time zone. Furthermore, that buried time zone is not the one used by Date\xe2\x80\x99s toString method; that method uses the JVM\xe2\x80\x99s current default time zone. All the more reason to avoid this confusing class and stick with Joda-Time and java.time.This definitely returns UTC time: as String and Date objects !Actually not time, but it\'s representation could be changed.Time is the same in any point of the Earth, but our perception of time could be different depending on location.Calendar aGMTCalendar = Calendar.getInstance(TimeZone.getTimeZone("GMT"));\n  Then all operations performed using the aGMTCalendar object will be done with the GMT time zone and will not have the daylight savings time or fixed offsets appliedWrong!and will return the same time. Idem for This works for getting UTC milliseconds in Android.This code prints the current time UTC.ResultJon Skeet asks: @Downvoter: Care to comment? What exactly is incorrect in my answer? \xe2\x80\x93\n  Jon Skeet Oct 26 \'09 at 21:09I am not the Downvoter, but here is what seems to be incorrect in that answer. You said:java.util.Date is always in UTC. What makes you think it\'s in local\n  time? I suspect the problem is that you\'re displaying it via an\n  instance of Calendar which uses the local timezone, or possibly using\n  Date.toString() which also uses the local timezone.However, the code:gives the local hours, not GMT (UTC hours), using no Calendar and no SimpleDateFormat at all.That is why is seems something is incorrect.Putting together the responses, the code: shows the GMT hours instead of the local hours -- note that getTime.getHours() is missing because that would create a Date() object, which theoretically stores the date in GMT, but gives back the hours in the local time zone.If you want a Date object with fields adjusted for UTC you can do it like this with Joda Time:You can use:Then all operations performed using the aGMTCalendar object will be done with the GMT time zone and will not have the daylight savings time or fixed offsets applied. I think the previous poster is correct that the Date() object always returns a GMT it\'s not until you go to do something with the date object that it gets converted to the local time zone.With:Then cal have the current date and time.\nYou also could get the current Date and Time for timezone with:You could ask cal.get(Calendar.DATE); or other Calendar constant about others details.\nDate and Timestamp are deprecated in Java. Calendar class it isn\'t.Here an other suggestion to get a GMT Timestamp object:Here is another way to get GMT time in String formatYou can directly use thisSample code to render system time in a specific time zone and a specific format.OutputJust to make this simpler, to create a Date in UTC you can use Calendar :Which will construct a new instance for Calendar using the "UTC" TimeZone.If you need a Date object from that calendar you could just use getTime().Converting Current DateTime in UTC:This worked for me, returns the timestamp in GMT!To put it simple. A calendar object stores information about time zone but when you perform cal.getTime() then the timezone information will be lost. So for Timezone conversions I will advice to use DateFormat classes...Use this Class to get ever the right UTC Time from a Online NTP Server: And use it with:If you need UTC Time "now" as DateTimeString use function:and use it with:Here is my implementation of toUTC:There\'s probably several ways to improve it, but it works for me.this is my implementation:If you\'re using joda time and want the current time in milliseconds without your local offset you can use this:If you want to avoid parsing the date and just want a timestamp in GMT, you could use: