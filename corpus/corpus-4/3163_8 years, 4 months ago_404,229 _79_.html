I just can\'t figure out how do I make sure an argument passed to my script is a number or not.All I want to do is something like this:Any help?One approach is to use a regular expression, like so:If the value is not necessarily an integer, consider amending the regex appropriately; for instance:...or, to handle negative numbers:Without bashisms (works even in the System V sh),This rejects empty strings and strings containing non-digits, accepting everything else.Negative or floating-point numbers need some additional work. An idea is to exclude - / . in the first "bad" pattern and add more "bad" patterns containing the inappropriate uses of them (?*-* / *.*.*)I use this:as in:Redirection of standard error is there to hide the "integer expression expected" message that bash prints out in case we do not have a number.CAVEATS (thanks to the comments below):I\'m surprised at the solutions directly parsing number formats in shell.\nshell is not well suited to this, being a DSL for controlling files and processes.\nThere are ample number parsers a little lower down, for example:Change \'%f\' to whatever particular format you require.This tests if a number is a non negative integer and is both shell independent (i.e. without bashisms) and uses only shell built-ins:BUT IS WRONG.\nAs jilles commented and suggested in his answer this is the correct way to do it using shell-patterns.Nobody suggested bash\'s extended pattern matching:Just a follow up to @mary. But because I don\'t have enough rep, couldn\'t post this as a comment to that post. Anyways, here is what I used:The function will return "1" if the argument is a number, otherwise will return "0". This works for integers as well as floats. Usage is something like:I was looking at the answers and...\nrealized that nobody thought about FLOAT numbers (with dot)!Using grep is great too.\n-E means extended regexp\n-q means quiet (doesn\'t echo)\n-qE is the combination of both.To test directly in the command line:Using in a bash script:To match JUST integers, use this:Old question, but I just wanted to tack on my solution. This one doesn\'t require any strange shell tricks, or rely on something that hasn\'t been around forever.Basically it just removes all digits from the input, and if you\'re left with a non-zero-length string then it wasn\'t a number.http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_04_03.htmlYou can also use bash\'s character classes.Numerics will include space, the decimal point, and "e" or "E" for floating point.But, if you specify a C-style hex number, i.e. "0xffff" or "0XFFFF", [[:digit:]] returns true.  A bit of a trap here, bash allows you do to something like "0xAZ00" and still count it as a digit (isn\'t this from some weird quirk of GCC compilers that let you use 0x notation for bases other than 16???)You might want to test for "0x" or "0X" before testing if it\'s a numeric if your input is completely untrusted, unless you want to accept hex numbers.  That would be accomplished by:I would try this:Note: this recognizes nan and inf as number.Can\'t comment yet so I\'ll add my own answer, which is an extension to glenn jackman\'s answer using bash pattern matching.My original need was to identify numbers and distinguish integers and floats. The function definitions deducted to:I used unit testing (with shUnit2) to validate my patterns worked as intended:Notes: The isFloat pattern can be modified to be more tolerant about decimal point (@(.,)) and the E symbol (@(Ee)). My unit tests test only values that are either integer or float, but not any invalid input.I use expr. It returns a non-zero if you try to add a zero to a non-numeric value:It might be possible to use bc if you need non-integers, but I don\'t believe bc has quite the same behavior. Adding zero to a non-number gets you zero and it returns a value of zero too. Maybe you can combine bc and expr. Use bc to add zero to $number. If the answer is 0, then try expr to verify that $number isn\'t zero.Don\'t forget - to include negatives!${i//[0-9]} replaces any digit in the value of $i with an empty string, see man -P \'less +/parameter\\/\' bash. -z checks if resulting string has zero length.if you also want to exclude the case when $i is empty, you could use one of these constructions:The simplest way is to check whether it contains non-digit characters. You replace all digit characters with nothing and check for length. If there\'s length it\'s not a number.I use the following (for integers):I tried ultrasawblade\'s recipe as it seemed the most practical to me, and couldn\'t make it work. In the end i devised another way though, based as others in parameter substitution, this time with regex replacement:It removes every :digit: class character in $var and checks if we are left with an empty string, meaning that the original was only numbers.What i like about this one is its small footprint and flexibility. In this form it only works for non-delimited, base 10 integers, though surely you can use pattern matching to suit it to other needs.A clear answer has already been given by @charles Dufy and others.\nA pure bash solution would be using the following :Although for real numbers it is not mandatory to have a number before the radix point.To provide a more thorough support of floating numbers and scientific notation (many programs in C/Fortran or else will export float this way), a useful addition to this line would be the following :Thus leading to a way to differentiate types of number, if you are looking for any specific type :Note: We could list the syntactical requirements for decimal and scientific notation, one being to allow comma as radix point, as well as ".". We would then assert that there must be only one such radix point. There can be two +/- signs in an [Ee] float. I have learned a few more rules from Aulu\'s work, and tested against bad strings such as \'\' \'-\' \'-E-1\' \'0-0\'. Here are my regex/substring/expr tools that seem to be holding up:As i had to tamper with this lately and like karttu\'s appoach with the unit test the most. I revised the code and added some other solutions too, try it out yourself to see the results:So isNumber() includes dashes, commas and exponential notation and therefore returns TRUE on integers & floats where on the other hand isFloat() returns FALSE on integer values and isInteger() likewise returns FALSE on floats. For your convenience all as one liners:Quick & Dirty: I know it\'s not the most elegant way, but I usually just added a zero to it and test the result. like so:$(($1+0)) will return 0 or bomb if $1 is NOT an integer. for Example:NOTE: I guess I never thought to check for floats or mixed types that will make the entire script bomb... in my case, I didn\'t want it go any further. I\'m gonna play around with mrucci\'s solution and Duffy\'s regex - they seem the most robust within the bash framework... I found quite a short version:variable to checknumber=12345 or number=-23234 or number=23.167 or number=-345.234check numeric or non-numericecho $number | grep -E \'^-?[0-9]*\\.?[0-9]*$\' > /dev/nulldecide on further actions based on the exit status of the aboveif [ $? -eq 0 ]; then echo "Numeric"; else echo "Non-Numeric"; fiTo catch negative numbers:You could use "let" too like this :But I prefer use the "=~" Bash 3+ operator like some answers in this thread.I use printf as other answers mentioned, if you supply the format string "%f" or "%i" printf will do the checking for you. Easier than reinventing the checks, the syntax is simple and short and printf is ubiquitous. So its a decent choice in my opinion - you can also use the following idea to check for a range of things, its not only useful for checking numbers. >$ var=45>$ (($(check_number $var "${CHECK_INTEGER}" "Error: Found $var - An integer is required."))) && { echo "$var+5" | bc; } I like Alberto Zaccagni\'s answer.Important prerequisites:\n- no subshells spawned\n- no RE parsers invoked\n- most shell applications don\'t use real numbersBut if $var is complex (e.g. an associative array access), and if the number will be a non-negative integer (most use-cases), then this is perhaps more efficient?Following up on David W\'s answer from Oct \'13, if using expr this might be betterIf numeric, multiplied by 1 gives you the same value, (including negative numbers).  Otherwise you get null which you can test for Numbers can be calculated, so run numbers through a calculator.This approach handles integers, floats, negative numbers and fails on everything else including undeclared and empty variables.The accepted answer does not work here, I am on MacOS. The following code works: