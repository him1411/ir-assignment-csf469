Here\'s the example:Of course this won\'t work.  But why not?One of the possible issues would be, what happens when you call:In this case, I think it should just call an empty method (i.e. {}).  All subclasses would be forced to implement the static method, so they\'d all be fine when calling the static method.  So why isn\'t this possible?EDIT: I guess I\'m looking for answer that\'s deeper than "because that\'s the way Java is". Is there a particular technological reason why static methods can\'t be overwritten? That is, why did the designers of Java decide to make instance methods overrideable but not static methods?EDIT: The problem with my design is I\'m trying to use interfaces to enforce a coding convention.That is, the goal of the interface is twofold:I want the IXMLizable interface to allow me to convert classes that implement it to XML elements (using polymorphism, works fine).If someone wants to make a new instance of a class that implements the IXMLizable interface, they will always know that there will be a newInstanceFromXML(Element e) static constructor.Is there any other way to ensure this, other than just putting a comment in the interface?EDIT: As of Java 8, static methods are now allowed in interfaces.With Java 8, interfaces can have static methods. They can also have concrete instance methods, but not instance fields.There are really two questions here: There was no strong technical reason why an interfaces couldn\'t have had static methods in previous versions. This is summed up nicely by the poster of a duplicate question. Static interface methods were initially considered as a small language change, and then there was an official proposal to add them in Java 7, but it was later dropped due to unforeseen complications.Finally, Java 8 introduced static interface methods, as well as override-able instance methods with a default implementation. They still can\'t have instance fields though. These features are part of the lambda expression support, and you can read more about them in Part H of JSR 335.The answer to the second question is a little more complicated.Static methods are resolvable at compile time. Dynamic dispatch makes sense for instance methods, where the compiler can\'t determine the the concrete type of the object, and, thus, can\'t resolve the method to invoke. But invoking a static method requires a class, and since that class is known statically—at compile time—dynamic dispatch is unnecessary.A little background on how instance methods work is necessary to understand what\'s going on here. I\'m sure the actual implementation is quite different, but let me explain my notion of method dispatch, which models observed behavior accurately.Pretend that each class has a hash table that maps method signatures (name and parameter types) to an actual chunk of code to implement the method. When the virtual machine attempts to invoke a method on an instance, it queries the object for its class, and looks up the requested signature in the class\'s table. If a method body is found, it is invoked. Otherwise, the parent class of the class is obtained, and the lookup is repeated there. This proceeds until the method is found, or there are no more parent classes—which results in a NoSuchMethodError.If a super class and a sub class both have an entry in their tables for the same method signature, the sub class\'s version is encountered first, and the super class\'s version is never used—this is an "override".Now, suppose we skip the object instance, and just start with a subclass. The resolution could proceed as above, giving you a sort of "overridable" static method. The resolution can all happen at compile-time, however, since the compiler is starting from a known class, rather than waiting until runtime to query an object of unspecified type for its class. There is no point in "overriding" a static method, since one can always specify the class that contains the desired version.Here\'s a little more material to address the recent edit to the question.It sounds like you want to effectively mandate a constructor-like method for each implementation of IXMLizable. Forget about trying to enforce this with an interface for a minute, and pretend that you have some classes that meet this requirement. How would you use it?Since you have to explicitly name the concrete type Foo when "constructing" the new object, the compiler can verify that it does indeed have the necessary factory method. And if it doesn\'t, so what? If I can implement an IXMLizable that lacks the "constructor", and I create an instance and pass it to your code, it is an IXMLizable with all the necessary interface.Construction is part of the implementation, not the interface. Any code that works successfully with the interface doesn\'t care about the constructor. Any code that cares about the constructor needs to know the concrete type anyway, and the interface can be ignored.This was already asked and answered, hereTo duplicate my answer:There is never a point to declaring a static method in an interface. They cannot be executed by the normal call MyInterface.staticMethod(). If you call them by specifying the implementing class MyImplementor.staticMethod() then you must know the actual class, so it is irrelevant whether the interface contains it or not.More importantly, static methods are never overridden, and if you try to do:the rules for static say that the method defined in the declared type of var must be executed. Since this is an interface, this is impossible. The reason you can\'t execute "result=MyInterface.staticMethod()" is that it would have to execute the version of the method defined in MyInterface. But there can\'t be a version defined in MyInterface, because it\'s an interface. It doesn\'t have code by definition.While you can say that this amounts to "because Java does it that way", in reality the decision is a logical consequence of other design decisions, also made for very good reason.Normally this is done using a Factory patternWith the advent of Java 8 it is possible now to write default and static methods in interface.\ndocs.oracle/staticMethodFor example:Result : 6TIP : Calling an static interface method doesn\'t require to be implemented by any class. Surely, this happens because the same rules for static methods in superclasses applies for static methods on interfaces.Because static methods cannot be overridden in subclasses, and hence they cannot be abstract. And all methods in an interface are, de facto, abstract.Why can\'t I define a static method in a Java interface?Actually you can in Java 8.As per Java doc:A static method is a method that is associated with the class in which\n  it is defined rather than with any object. Every instance of the class\n  shares its static methodsIn Java 8 an interface can have default methods and static methods. This makes it easier for us to organize helper methods in our libraries. We can keep static methods specific to an interface in the same interface rather than in a separate class. instead ofFirst, all language decisions are decisions made by the language creators.  There is nothing in the world of software engineering or language defining or compiler / interpreter writing which says that a static method cannot be part of an interface.  I\'ve created a couple of languages and written compilers for them -- it\'s all just sitting down and defining meaningful semantics.  I\'d argue that the semantics of a static method in an interface are remarkably clear -- even if the compiler has to defer resolution of the method to run-time.Secondly, that we use static methods at all means there is a valid reason for having an interface pattern which includes static methods -- I can\'t speak for any of you, but I use static methods on a regular basis.The most likely correct answer is that there was no perceived need, at the time the language was defined, for static methods in interfaces.  Java has grown a lot over the years and this is an item that has apparently gained some interest.  That it was looked at for Java 7 indicates that its risen to a level of interest that might result in a language change.  I, for one, will be happy when I no longer have to instantiate an object just so I can call my non-static getter method to access a static variable in a subclass instance ...Let me re-word that question for your by filling in the definitions.Or, to put in more completely, If I want to call a method without an instance, but knowing the class, how can I have it resolved based upon the instance that I don\'t have.Interfaces are concerned with polymorphism which is inherently tied to object instances, not classes.  Therefore static doesn\'t make sense in the context of an interface.Static methods aren\'t virtual like instance methods so I suppose the Java designers decided they didn\'t want them in interfaces.But you can put classes containing static methods inside interfaces.  You could try that!Well, without generics, static interfaces are useless because all static method calls are resolved at compile time. So, there\'s no real use for them.With generics, they have use -- with or without a default implementation. Obviously there would need to be overriding and so on. However, my guess is that such usage wasn\'t very OO (as the other answers point out obtusely) and hence wasn\'t considered worth the effort they\'d require to implement usefully.Several answers have discussed the problems with the concept of overridable static methods.  However sometimes you come across a pattern where it seems like that\'s just what you want to use.For example, I work with an object-relational layer that has value objects, but also has commands for manipulating the value objects.  For various reasons, each value object class has to define some static methods that let the framework find the command instance.  For example, to create a Person you\'d do:and to load a Person by ID you\'d doThis is fairly convenient, however it has its problems; notably the existence of the static methods can not be enforced in the interface.  An overridable static method in the interface would be exactly what we\'d need, if only it could work somehow.EJBs solve this problem by having a Home interface; each object knows how to find its Home and the Home contains the "static" methods.  This way the "static" methods can be overridden as needed, and you don\'t clutter up the normal (it\'s called "Remote") interface with methods that don\'t apply to an instance of your bean.  Just make the normal interface specify a "getHome()" method.  Return an instance of the Home object (which could be a singleton, I suppose) and the caller can perform operations that affect all Person objects.All methods in an interface are explicitly abstract and hence you cannot define them as static  because static methods cannot be abstract.An interface can never be dereferenced statically, e.g. ISomething.member. An interface is always dereferenced via a variable that refers to an instance of a subclass of the interface. Thus, an interface reference can never know which subclass it refers to without an instance of its subclass.Thus the closest approximation to a static method in an interface would be a non-static method that ignores "this", i.e. does not access any non-static members of the instance. At the low-level abstraction, every non-static method (after lookup in any vtable) is really just a function with class scope that takes "this" as an implicit formal parameter. See Scala\'s singleton object and interoperability with Java as evidence of that concept.\nAnd thus every static method is a function with class scope that does not take a "this" parameter. Thus normally a static method can be called statically, but as previously stated, an interface has no implementation (is abstract).Thus to get closest approximation to a static method in an interface, is to use a non-static method, then don\'t access any of the non-static instance members. There would be no possible performance benefit any other way, because there is no way to statically link (at compile-time) a ISomething.member(). The only benefit I see of a static method in an interface is that it would not input (i.e. ignore) an implicit "this" and thus disallow access to any of the non-static instance members. This would declare implicitly that the function that doesn\'t access "this", is immutate and not even readonly with respect to its containing class. But a declaration of "static" in an interface ISomething would also confuse people who tried to access it with ISomething.member() which would cause a compiler error. I suppose if the compiler error was sufficiently explanatory, it would be better than trying to educate people about using a non-static method to accomplish what they want (apparently mostly factory methods), as we are doing here (and has been repeated for 3 Q&A times on this site), so it is obviously an issue that is not intuitive for many people. I had to think about it for a while to get the correct understanding.The way to get a mutable static field in an interface is use non-static getter and setter methods in an interface, to access that static field that in the subclass. Sidenote, apparently immutable statics can be declared in a Java interface with static final.Commenting EDIT: As of Java 8, static methods are now allowed in interfaces.It is right, static methods since Java 8 are allowed in interfaces, but your example still won\'t work. You cannot just define a static method: you have to implement it or you will obtain a compilation error.Interfaces just provide a list of things a class will provide, not an actual implementation of those things, which is what your static item is.If you want statics, use an abstract class and inherit it, otherwise, remove the static.Hope that helps!You can\'t define static methods in an interface because static methods belongs to a class not to an instance of class, and interfaces are not Classes. Read more here.However, If you want you can do this:In this case what you have is two classes with 2 distinct static methods called methodX().Suppose you could do it; consider this example:Something that could be implemented is static interface (instead of static method in an interface). All classes implementing a given static interface should implement the corresponding static methods. You could get static interface SI from any Class clazz usingthen you can call si.method(params).\nThis would be useful (for factory design pattern for example) because you can get (or check the implementation of) SI static methods implementation from a compile time unknown class !\nA dynamic dispatch is necessary and you can override the static methods (if not final) of a class by extending it (when called through the static interface).\nObviously, these methods can only access static variables of their class.While I realize that Java 8 resolves this issue, I thought I\'d chime in with a scenario I am currently working on (locked into using Java 7) where being able to specify static methods in an interface would be helpful.I have several enum definitions where I\'ve defined "id" and "displayName" fields along with helper methods evaluating the values for various reasons. Implementing an interface allows me to ensure that the getter methods are in place but not the static helper methods. Being an enum, there really isn\'t a clean way to offload the helper methods into an inherited abstract class or something of the like so the methods have to be defined in the enum itself. Also because it is an enum, you wouldn\'t ever be able to actually pass it as an instanced object and treat it as the interface type, but being able to require the existence of the static helper methods through an interface is what I like about it being supported in Java 8.Here\'s code illustrating my point.Interface definition:Example of one enum definition:Generic enum utility definition:Let\'s suppose static methods were allowed in interfaces:\n* They would force all implementing classes to declare that method. \n* Interfaces would usually be used through objects, so the only effective methods on those would be the non-static ones. \n* Any class which knows a particular interface could invoke its static methods. Hence a implementing class\' static method would be called underneath, but the invoker class does not know which. How to know it? It has no instantiation to guess that! Interfaces were thought to be used when working with objects. This way, an object is instantiated from a particular class, so this last matter is solved. The invoking class need not know which particular class is because the instantiation may be done by a third class. So the invoking class knows only the interface. If we want this to be extended to static methods, we should have the possibility to especify an implementing class before, then pass a reference to the invoking class. This could use the class through the static methods in the interface. But what is the differente between this reference and an object? We just need an object representing what it was the class. Now, the object represents the old class, and could implement a new interface including the old static methods - those are now non-static. Metaclasses serve for this purpose. You may try the class Class of Java. But the problem is that Java is not flexible enough for this. You can not declare a method in the class object of an interface. This is a meta issue - when you need to do ass..blah blah anyway you have an easy workaround - making the method non-static with the same logic. But then you would have to first create an object to call the method.I think java does not have static interface methods because you do not need them. You may think you do, but...\nHow would you use them? If you want to call them likethen you do not need to declare it in the interface. If you want to call them likethen it should not be static.\nIf you are actually going to use first way, but just want to enforce each implementation to have such  static method, then it is really a coding convention, not a contract between instance that implements an interface and calling code.Interfaces allow you to define contract between instance of class that implement the interface and calling code. And java helps you to be sure that this contract is not violated, so you can rely on it and don\'t worry what class implements this contract, just "someone who signed a contract" is enough. In case of static interfaces your code does not rely on the fact that each interface implementation has this method, so you do not need java to help you to be sure with it.What is the need of static method in interface, static methods are used basically when you don\'t have to create an instance of object whole idea of interface is to bring in OOP concepts with introduction of static method you\'re diverting from concept.