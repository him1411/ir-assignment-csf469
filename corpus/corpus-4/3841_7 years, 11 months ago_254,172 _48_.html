I am wondering if there is a way to handle the user pressing Enter while typing in an EditText, something like the onSubmit HTML event.Also wondering if there is a way to manipulate the virtual keyboard in such a way that the "Done" button is labeled something else (for example "Go") and performs a certain action when clicked (again, like onSubmit).I am wondering if there is a way to\n  handle the user pressing Enter while\n  typing in an EditText, something like\n  the onSubmit HTML event.Yes. Also wondering if there is a way to\n  manipulate the virtual keyboard in\n  such a way that the "Done" button is\n  labeled something else (for example\n  "Go") and performs a certain action\n  when clicked (again, like onSubmit).Also yes.You will want to look at the android:imeActionId and android:imeOptions attributes, plus the setOnEditorActionListener() method, all on TextView.For changing the text of the "Done" button to a custom string, use: Here\'s what you do. It\'s also hidden in the Android Developer\'s sample code \'Bluetooth Chat\'. Replace the bold parts that say "example" with your own variables and methods.First, import what you need into the main Activity where you want the return button to do something special:Now, make a variable of type TextView.OnEditorActionListener for your return key (here I use exampleListener);Then you need to tell the listener two things about what to do when the return button is pressed. It needs to know what EditText we\'re talking about (here I use exampleView), and then it needs to know what to do when the Enter key is pressed (here, example_confirm()). If this is the last or only EditText in your Activity, it should do the same thing as the onClick method for your Submit (or OK, Confirm, Send, Save, etc) button.Finally, set the listener (most likely in your onCreate method);Hardware keyboards always yield enter events, but software keyboards return different actionIDs  and nulls in singleLine EditTexts.  This code responds every time the user presses enter in an EditText that this listener has been set to, regardless of EditText or keyboard type.The default appearance of the enter key in singleLine=false gives a bent arrow enter keypad. When singleLine=true in the last EditText the key says DONE, and on the EditTexts before it it says NEXT. By default, this behavior is consistent across all vanilla, android, and google emulators. The scrollHorizontal attribute doesn\'t make any difference. The null test is important because the response of phones to soft enters is left to the manufacturer and even in the emulators, the vanilla Level 16 emulators respond to long soft enters in multi-line and scrollHorizontal EditTexts with an actionId of NEXT and a null for the event.I know this is a year old, but I just discovered this works perfectly for an EditText.It prevents anything but text and space. I could not tab, "return" ("\\n"), or anything.Just as an addendum to Chad\'s response (which worked almost perfectly for me), I found that I needed to add a check on the KeyEvent action type to prevent my code executing twice (once on the key-up and once on the key-down event).See http://developer.android.com/reference/android/view/KeyEvent.html for info about repeating action events (holding the enter key) etc.I had a similar purpose. I wanted to resolve pressing the "Enter" key on the keyboard (which I wanted to customize) in an AutoCompleteTextView which extends TextView. I tried different solutions from above and they seemed to work. BUT I experienced some problems when I switched the input type on my device (Nexus 4 with AOKP ROM) from SwiftKey 3 (where it worked perfectly) to the standard Android keyboard (where instead of handling my code from the listener, a new line was entered after pressing the "Enter" key. It took me a while to handle this problem, but I don\'t know if it will work under all circumstances no matter which input type you use. So here\'s my solution:Set the input type attribute of the TextView in the xml to "text":Customize the label of the "Enter" key on the keyboard:Set an OnEditorActionListener to the TextView:I hope this can help others to avoid the problems I had, because they almost drove me nuts.In your xml, add the imeOptions attribute to the editTextThen, in your Java code, add the OnEditorActionListener to the same EditTextHere is the explanation-\nThe imeOptions=actionDone will assign "actionDone" to the EnterKey. The EnterKey in the keyboard will change from "Enter" to "Done". So when Enter Key is pressed, it will trigger this action and thus you will handle it.This page describes exactly how to do this.https://developer.android.com/training/keyboard-input/style.htmlSet the android:imeOptions then you just check the actionId in onEditorAction. So if you set imeOptions to \'actionDone\' then you would check for \'actionId == EditorInfo.IME_ACTION_DONE\' in onEditorAction. Also, make sure to set the android:inputType.Here\'s the EditText from the example linked above:You can also set this programmatically using the setImeOptions(int) function. Here\'s the OnEditorActionListener from the example linked above:You can also do it..Works very fine for me\nIn addition hide keyboardFirst, you have to set EditText listen to key pressSecond, define the event upon the key press, for example, event to set TextView\'s text:And finally, do not forget to import EditText,TextView,OnKeyListener,KeyEvent at top:working perfectly}working perfectlyThis works fine on LG Android phones. It prevents ENTER and other special characters to be interpreted as normal character. Next or Done button appears automatically and ENTER works as expected.A dependable way to respond to an <enter> in an EditText is with a TextWatcher, a LocalBroadcastManager, and a BroadcastReceiver. You need to add the v4 support library to use the LocalBroadcastManager. I use the tutorial at vogella.com: 7.3 "Local broadcast events with LocalBroadcastManager" because of its complete concise code Example. In onTextChanged before is the index of the end of the change before the change>;minus start. When in the TextWatcher the UI thread is busy updating editText\'s editable, so we send an Intent to wake up the BroadcastReceiver when the UI thread is done updating editText.InputType on the textfield must be "text" in order for what CommonsWare said to work. Just tried all of this, no inputType before the trial and nothing worked, Enter kept registering as soft enter. After inputType = text, everything including the setImeLabel worked.XmlThis should work Jared Law\'s answer works like a charm for me.just added these depencendy: