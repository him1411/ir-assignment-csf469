Is there a way to get the name of the currently executing method in Java?Thread.currentThread().getStackTrace() will usually contain the method you\xe2\x80\x99re calling it from but there are pitfalls (see Javadoc):Some virtual machines may, under some circumstances, omit one or more stack frames from the stack trace. In the extreme case, a virtual machine that has no stack trace information concerning this thread is permitted to return a zero-length array from this method. Technically this will work... However, a new anonymous inner class will be created during compile time (e.g. YourClass$1.class). So this will create a .class file for each method that deploys this trick. Additionally an otherwise unused object instance is created on each invocation during runtime. So this may be an acceptable debug trick, but it does come with significant overhead.An advantage of this trick is that getEncosingMethod() returns java.lang.reflect.Method which can be used to retrieve all other information of the method including annotations and parameter names. This makes it possible to distinguish between specific methods with the same name (method overload).Note that according to the JavaDoc of getEnclosingMethod() this trick should not throw a SecurityException as inner classes should be loaded using the same class loader. So there is no need to check the access conditions even if a security manager is present.It is required to use getEnclosingConstructor() for constructors. During blocks outside of (named) methods, getEnclosingMethod() returns null.January 2009:\nA full code would be (to use with @Bombe\'s caveat in mind):More in this question.Update December 2011:  bluish comments:I use JRE 6 and gives me incorrect method name.\n  It works if I write ste[2 + depth].getMethodName(). virgo47\'s answer (upvoted) actually computes the right index to apply in order to get back the method name.We used this code to mitigate potential variability in stack trace index - now just call methodName util:Seems overengineered, but we had some fixed number for JDK 1.5 and were a bit surprised it changed when we moved to JDK 1.6. Now it\'s the same in Java 6/7, but you just never know. It is not proof to changes in that index during runtime - but hopefully HotSpot doesn\'t do that bad. :-)name  will have value foo.The fastest way I found is that:It accesses the native method getStackTraceElement(int depth) directly. And stores the accessible Method in a static variable.Use the following Code : Both of these options work for me with Java:Or:This is an expansion on virgo47\'s answer (above).It provides some static methods to get the current and invoking class / method names.To get the name of the method that called the current method you can use:This works on my MacBook as well as on my Android phoneI also tried:but Android will return "getStackTrace"\nI could fix this for Android withbut then I get the wrong answer on my MacBookUtil.java:SomeClass.java:An alternative method is to create, but not throw, an Exception, and use that object from which to get the stack trace data, since the enclosing method will typically be at index 0 - as long as the JVM stores that information, as others have mentioned above.  This not the cheapest method, however.From Throwable.getStackTrace() (this has been the same since Java 5 at least):The zeroth element of the array (assuming the array\'s length is non-zero) represents the top of the stack, which is the last method invocation in the sequence. Typically, this is the point at which this throwable was created and thrown. The snippet below assumes the class is non-static (because of getClass()), but that\'s an aside.I don\'t know what is the intention behind getting the currently executed method\'s name, but if that\'s just for debugging purpose, then logging frameworks like "logback" can help here. For example, in logback, all you need to do is to use the pattern "%M" in your logging configuration. However, this should be used with caution as this may degrade performance.I\'ve got solution using this (In Android)What\'s wrong with this approach:And before people go crazy about using System.out.println(...) you could always, and should, create some method so that output can be redirected, e.g: