I\'d like to have a private static constant for a class (in this case a shape-factory).\nI\'d like to have something of the sort.Unfortunately I get all sorts of error from the C++ (g++) compiler, such as:ISO C++ forbids initialization of\n  member \xe2\x80\x98RECTANGLE\xe2\x80\x99 invalid in-class initialization of static data member of non-integral type \xe2\x80\x98std::string\xe2\x80\x99 error: making \xe2\x80\x98RECTANGLE\xe2\x80\x99 staticThis tells me that this sort of member design is not compliant with the standard. How do you have a private literal constant (or perhaps public) without having to use a #define directive (I want to avoid the uglyness of data globality!)Any help is appreciated. Thanks.You have to define your static member outside the class definition and provide the initializer there.Firstand thenThe syntax you were originally trying to use (initializer inside class definition) is only allowed with integral and enum types.In C++11 you can do now:Inside class definitions you can only declare static members. They have to be defined outside of the class. For compile-time integral constants the standard makes the exception that you can "initialize" members. It\'s still not a definition, though. Taking the address would not work without definition, for example.I\'d like to mention that I don\'t see the benefit of using std::string over const char[] for constants. std::string is nice and all but it requires dynamic initialization. So, if you write something likeat namespace scope the constructor of foo will be run right before execution of main starts and this constructor will create a copy of the constant "hello" in the heap memory. Unless you really need RECTANGLE to be a std::string you could just as well writeThere! No heap allocation, no copying, no dynamic initialization.Cheers, s.This is just extra information, but if you really want the string in a header file, try something like:Though I doubt that\'s recommended. To use that in-class initialization\n  syntax, the constant must be a static\n  const of integral or enumeration type\n  initialized by a constant expression.This is the restriction. Hence, in this case you need to define variable outside the class. refer answwer from @AndreyTpossible just do:or The current standard only allows such initialization for static constant integral types. So you need to do as AndreyT explained. However, that will be available in the next standard through the new member initialization syntax.You can either go for the const char* solution mentioned above, but then if you need string all the time, you\'re going to have a lot of overhead.\nOn the other hand, static string needs dynamic initialization, thus if you want to use its value during another global/static variable\'s initialization, you might hit the problem of initialization order. To avoid that, the cheapest thing is accessing the static string object through a getter, which checks if your object is initialized or not.  Remember to only use A::getS(). Because any threading can only started by main(), and A_s_initialized is initialized before main(), you don\'t need locks even in a multithreaded environment. A_s_initialized is 0 by default (before the dynamic initialization), so if you use getS() before s is initialized, you call the init function safely.Btw, in the answer above: "static const std::string RECTANGLE() const" , static functions cannot be const because they cannot change the state if any object anyway (there is no this pointer).The class static variables can be declared in the header but must be defined in a .cpp file. This is because there can be only one instance of a static variable and the compiler can\'t decide in which generated object file to put it so you have to make the decision, instead.To keep the definition of a static value with the declaration in C++11 \na nested static structure can be used. In this case the static member \nis a structure and has to be defined in a .cpp file, but the values \nare in the header.Instead of initializing individual members the whole static structure is initialized in .cpp:The values are accessed withor -- since the members are private and are meant to be used only from A -- with Note that this solution still suffers from the problem of the order of \ninitialization of the static variables. When a static value is used to \ninitialize another static variable, the first may not be initialized, \nyet.In this case the static variable headers will contain either { "" } \nor { ".h", ".hpp" }, depending on the order of initialization created by the linker.As mentioned by @abyss.7 you could also use constexpr if the value of the variable can be computed at compile time. But if you declare your strings with static constexpr const char* and your program uses std::string otherwise there will be an overhead because a new std::string object will be created every time you use such a constant: