Anyone have a quick method for de-duplicating a generic List in C#?Perhaps you should consider using a HashSet.From the MSDN link:If you\'re using .Net 3+, you can use Linq.How about:-In .net 3.5?Simply initialize a HashSet with a List of the same type:Or, if you want a List returned:Sort it, then check two and two next to each others, as the duplicates will clump together.Something like this:It worked for me. simply useReplace "Type" with your desired type e.g. int.As kronoz said in .Net 3.5 you can use Distinct().In .Net 2 you could mimic it:This could be used to dedupe any collection and will return the values in the original order.It\'s normally much quicker to filter a collection (as both Distinct() and this sample does) than it would be to remove items from it.I like to use this command:I have these fields in my list: Id, StoreName, City, PostalCode \nI wanted to show list of cities in a dropdown which has duplicate values.\nsolution: Group by city then pick the first one for the list.I hope it helps :) An extension method might be a decent way to go... something like this:And then call like this, for example:In Java (I assume C# is more or less identical):If you really wanted to mutate the original list:To preserve order, simply replace HashSet with LinkedHashSet.As a helper method (without Linq):Here\'s an extension method for removing adjacent duplicates in-situ. Call Sort() first and pass in the same IComparer. This should be more efficient than Lasse V. Karlsen\'s version which calls RemoveAt repeatedly (resulting in multiple block memory moves).If you don\'t care about the order you can just shove the items into a HashSet, if you do want to maintain the order you can do something like this:Or the Linq way:Edit: The HashSet method is O(N) time and O(N) space while sorting and then making unique (as suggested by @lassevk and others) is O(N*lgN) time and O(1) space so it\'s not so clear to me (as it was at first glance) that the sorting way is inferior (my apologies for the temporary down vote...)Might be easier to simply make sure that duplicates are not added to the list.Another way in .Net 2.0There are many ways to solve - the duplicates issue in the List, below is one of them:Cheers\nRavi GanesanInstalling the MoreLINQ package via Nuget, you can easily distinct object list by a property Here\'s a simple solution that doesn\'t require any hard-to-read LINQ or any prior sorting of the list.David J.\'s answer is a good method, no need for extra objects, sorting, etc. It can be improved on however:for (int innerIndex = items.Count - 1; innerIndex > outerIndex ; innerIndex--)So the outer loop goes top bottom for the entire list, but the inner loop goes bottom "until the outer loop position is reached".The outer loop makes sure the entire list is processed, the inner loop finds the actual duplicates, those can only happen in the part that the outer loop hasn\'t processed yet.Or if you don\'t want to do bottom up for the inner loop you could have the inner loop start at outerIndex + 1.You can use Union