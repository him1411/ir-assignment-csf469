What\'s the difference between:and:I\'ve seen super being used quite a lot in classes with only single inheritance. I can see why you\'d use it in multiple inheritance but am unclear as to what the advantages are of using it in this kind of situation.The benefits of super() in single-inheritance are minimal -- mostly, you don\'t have to hard-code the name of the base class into every method that uses its parent methods.However, it\'s almost impossible to use multiple-inheritance without super(). This includes common idioms like mixins, interfaces, abstract classes, etc. This extends to code that later extends yours. If somebody later wanted to write a class that extended Child and a mixin, their code would not work properly.means to call SomeBaseClass\'s __init__. whilemeans to call a bound __init__ from the parent class that follows Child in the instance\'s method resolution order. If the instance is a subclass of Child, there may be a different parent that comes next in the method resolution order. This works in Python 2 and 3:This only works in Python 3:It works with no arguments by moving up in the stack frame and getting the first argument to the method (usually self for an instance method or cls for a class method - but could be other names) and finding the class (e.g. Child) in the free variables (it is looked up with the name __class__ as a free closure variable in the method).I prefer to demonstrate the cross-compatible way of using super, but if you are only using Python 3, you can call it with no arguments.What does it give you? For single inheritance, the examples from the question are practically identical from a static analysis point of view. However, using super gives you a layer of indirection with forward compatibility.Forward compatibility is very important to seasoned developers. You want your code to keep working with minimal changes as you change it. When you look at your revision history, you want to see precisely what changed when. You may start off with single inheritance, but if you decide to add another base class, you only have to change the line with the bases - if the bases change in a class you inherit from (say a mixin is added) you\'d change nothing in this class. Particularly in Python 2, getting the arguments to super and the correct method arguments right can be difficult. If you know you\'re using super correctly with single inheritance, that makes debugging less difficult going forward.Other people can use your code and inject parents into the method resolution:Say you add another class to your object, and want to inject a class between Foo and Bar (for testing or some other reason):Using the un-super child fails to inject the dependency because the child you\'re using has hard-coded the method to be called after its own:However, the class with the child that uses super can correctly inject the dependency:Always use super to reference the parent class. What you intend is to reference the parent class that is next-in-line, not specifically the one you see the child inheriting from.Not using super can put unnecessary constraints on users of your code.Doesn\'t all of this assume that the base class is a new-style class?Will not work in Python 2. class A must be new-style, i.e: class A(object)When calling super() to resolve to a parent\'s version of a classmethod, instance method, or staticmethod, we want to pass the current class whose scope we are in as the first argument, to indicate which parent\'s scope we\'re trying to resolve to, and as a second argument the object of interest to indicate which object we\'re trying to apply that scope to.Consider a class hierarchy A, B, and C where each class is the parent of the one following it, and a, b, and c respective instances of each.e.g. using super() from within the __new__() methodExplanation: 1- even though it\'s usual for __new__() to take as its first param a reference to the calling class, it is not implemented in Python as a classmethod, but rather a staticmethod. That is, a reference to a class has to be passed explicitly as the first argument when calling __new__() directly:2- when calling super() to get to the parent class we pass the child class A as its first argument, then we pass a reference to the object of interest, in this case it\'s the class reference that was passed when A.__new__(cls) was called. In most cases it also happens to be a reference to the child class. In some situations it might not be, for instance in the case of multiple generation inheritances.3- since as a general rule __new__() is a staticmethod, super(A, cls).__new__ will also return a staticmethod and needs to be supplied all arguments explicitly, including the reference to the object of insterest, in this case cls.4- doing the same thing without supere.g. using super() from within __init__()Explanation:1- __init__ is an instance method, meaning that it takes as its first argument a reference to an instance. When called directly from the instance, the reference is passed implicitly, that is you don\'t need to specify it:2- when calling super() within __init__() we pass the child class as the first argument and the object of interest as a second argument, which in general is a reference to an instance of the child class.3- The call super(A, self) returns a proxy that will resolve the scope and apply it to self as if it\'s now an instance of the parent class. Let\'s call that proxy s. Since __init__() is an instance method the call s.__init__(...) will implicitly pass a reference of self as the first argument to the parent\'s __init__().4- to do the same without super we need to pass a reference to an instance explicitly to the parent\'s version of __init__().Explanation:1- A classmethod can be called from the class directly and takes as its first parameter a reference to the class. 2- when calling super() within a classmethod to resolve to its parent\'s version of it, we want to pass the current child class as the first argument to indicate which parent\'s scope we\'re trying to resolve to, and the object of interest as the second argument to indicate which object we want to apply that scope to, which in general is a reference to the child class itself or one of its subclasses.3- The call super(B, cls) resolves to the scope of A and applies it to cls. Since alternate_constructor() is a classmethod the call super(B, cls).alternate_constructor(...) will implicitly pass a reference of cls as the first argument to A\'s version of alternate_constructor()4- to do the same without using super() you would need to get a reference to the unbound version of A.alternate_constructor() (i.e. the explicit version of the function). Simply doing this would not work:The above would not work because the A.alternate_constructor() method takes an implicit reference to A as its first argument. The cls being passed here would be its second argument.I had played a bit with super(), and had recognized that we can change calling order.For example, we have next hierarchy structure:In this case MRO of D will be (only for Python 3):Let\'s create a class where super() calls after method execution.So we can see that resolution order is same as in MRO. But when we call super() in the beginning of the method:We have a different order it is reversed a order of the MRO tuple.For additional reading I would recommend next answers: