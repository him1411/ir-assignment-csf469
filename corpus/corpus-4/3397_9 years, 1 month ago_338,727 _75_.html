What is the best way of doing case-insensitive string comparison in C++ without transforming a string to all uppercase or all lowercase?Please indicate whether the methods are Unicode-friendly and how portable they are.Boost includes a handy algorithm for this:Take advantage of the standard char_traits. Recall that a std::string is in fact a typedef for std::basic_string<char>, or more explicitly, std::basic_string<char, std::char_traits<char> >. The char_traits type describes how characters compare, how they copy, how they cast etc. All you need to do is typedef a new string over basic_string, and provide it with your own custom char_traits that compare case insensitively.The details are on Guru of The Week number 29.Are you talking about a dumb case insensitive compare or a full normalized Unicode compare?A dumb compare will not find strings that might be the same but are not binary equal. Example:Are all equivalent but they also have different binary representations.That said, Unicode Normalization should be a mandatory read especially if you plan on supporting Hangul, Tha\xc3\xaf and other asian languages.Also, IBM pretty much patented most optimized Unicode algorithms and made them publicly available. They also maintain an implementation : IBM ICUThe trouble with boost is that you have to link with and depend on boost. Not easy in some cases (e.g. android).And using char_traits means all your comparisons are case insensitive, which isn\'t usually what you want.This should suffice. It should be reasonably efficient. Doesn\'t handle unicode or anything though.If you are on a POSIX system, you can use strcasecmp.  This function is not part of standard C, though, nor is it available on Windows.  This will perform a case-insensitive comparison on 8-bit chars, so long as the locale is POSIX.  If the locale is not POSIX, the results are undefined (so it might do a localized compare, or it might not).  A wide-character equivalent is not available.Failing that, a large number of historic C library implementations have the functions stricmp() and strnicmp().  Visual C++ on Windows renamed all of these by prefixing them with an underscore because they aren\xe2\x80\x99t part of the ANSI standard, so on that system they\xe2\x80\x99re called _stricmp or _strnicmp.  Some libraries may also have wide-character or multibyte equivalent functions (typically named e.g. wcsicmp, mbcsicmp and so on).C and C++ are both largely ignorant of internationalization issues, so there\'s no good solution to this problem, except to use a third-party library.  Check out IBM ICU (International Components for Unicode) if you need a robust library for C/C++.  ICU is for both Windows and Unix systems.My first thought for a non-unicode version was to do something like this:boost::iequals is not utf-8 compatible in the case of string.\nYou can use boost::locale.Visual C++ string functions supporting unicode: http://msdn.microsoft.com/en-us/library/cc194799.aspxthe one you are probably looking for is _wcsnicmpI\'m trying to cobble together a good answer from all the posts, so help me edit this:Here is a method of doing this, although it does transforming the strings, and is not Unicode friendly, it should be portable which is a plus:From what I have read this is more portable than stricmp() because stricmp() is not in fact part of the std library, but only implemented by most compiler vendors.To get a truly Unicode friendly implementation it appears you must go outside the std library. One good 3rd party library is the IBM ICU (International Components for Unicode)Also boost::iequals provides a fairly good utility for doing this sort of comparison.You can use strcasecmp on Unix, or stricmp on Windows.One thing that hasn\'t been mentioned so far is that if you are using stl strings with these methods, it\'s useful to first compare the length of the two strings, since this information is already available to you in the string class. This could prevent doing the costly string comparison if the two strings you are comparing aren\'t even the same length in the first place.The Boost.String library has a lot of algorithms for doing case-insenstive comparisons and so on.You could implement your own, but why bother when it\'s already been done?FYI, strcmp() and stricmp() are vulnerable to buffer overflow, since they just process until they hit a null terminator. It\'s safer to use _strncmp() and _strnicmp().For my basic case insensitive string comparison needs I prefer not to have to use an external library, nor do I want a separate string class with case insensitive traits that is incompatible with all my other strings.So what I\'ve come up with is this:A simple function with one overload for char and another for whar_t. Doesn\'t use anything non-standard so should be fine on any platform.The equality comparison won\'t consider issues like variable length encoding and Unicode normalization, but basic_string has no support for that that I\'m aware of anyway and it isn\'t normally an issue.In cases where more sophisticated lexicographical manipulation of text is required, then you simply have to use a third party library like Boost, which is to be expected.Assuming you are looking for a method and not a magic function that already exists, there is frankly no better way. We could all write code snippets with clever tricks for limited character sets, but at the end of the day at somepoint you have to convert the characters.The best approach for this conversion is to do so prior to the comparison. This allows you a good deal of flexibility when it comes to encoding schemes, which your actual comparison operator should be ignorant of.You can of course \'hide\' this conversion behind your own string function or class, but you still need to convert the strings prior to comparison.I wrote a case-insensitive version of char_traits for use with std::basic_string in order to generate a std::string that is not case-sensitive when doing comparisons, searches, etc using the built-in std::basic_string member functions.So in other words, I wanted to do something like this....which std::string can\'t handle.  Here\'s the usage of my new char_traits:...and here\'s the implementation:See std::lexicographical_compareDemoI\'ve had good experience using the International Components for Unicode libraries - they\'re extremely powerful, and provide methods for conversion, locale support, date and time rendering, case mapping (which you don\'t seem to want), and collation, which includes case- and accent-insensitive comparison (and more). I\'ve only used the C++ version of the libraries, but they appear to have a Java version as well. Methods exist to perform normalized compares as referred to by @Coincoin, and can even account for locale - for example (and this a sorting example, not strictly equality), traditionally in Spanish (in Spain), the letter combination "ll" sorts between "l" and "m", so "lz" < "ll" < "ma".Short and nice. No other dependencies, than extended std C lib.returns true if str1 and str2 are equal.\nstrcasecmp may not exist, there could be analogs stricmp, strcmpi, etc.Example code:Output:Doing this without using Boost can be done by getting the C string pointer with c_str() and using strcasecmp:You can use the above code in C++14 if you are not in a position to use boost. You have to use std::towlower for wide chars.Just a note on whatever method you finally choose, if that method happens to include the use of strcmp that some answers suggest:strcmp doesn\'t work with Unicode data in general. In general, it doesn\'t even work with byte-based Unicode encodings, such as utf-8, since strcmp only makes byte-per-byte comparisons and Unicode code points encoded in utf-8 can take more than 1 byte. The only specific Unicode case strcmp properly handle is when a string encoded with a byte-based encoding contains only code points below U+00FF - then the byte-per-byte comparison is enough.As of early 2013, the ICU project, maintained by IBM, is a pretty good answer to this.http://site.icu-project.org/ICU is a "complete, portable Unicode library that closely tracks industry standards."  For the specific problem of string comparison, the Collation object does what you want.The Mozilla Project adopted ICU for internationalization in Firefox in mid-2012; you can track the engineering discussion, including issues of build systems and data file size, here:Just use strcmp() for case sensitive and strcmpi() or stricmp() for case insensitive comparison. Which are both in the header file <string.h>format:Usage:Outputapple and ApPlE are the samea comes before b, so apple comes before ballIf you have a vector of strings, for example:http://ideone.com/N6sq6XLate to the party, but here is a variant that uses std::locale, and thus correctly handles Turkish:gives you a functor that uses the active locale to convert characters to lowercase, which you can then use via std::transform to generate lower-case strings:This also works for wchar_t based strings.Looks like above solutions aren\'t using compare method and implementing total again so here is my solution and hope it works for you (It\'s working fine).this could probably be made much more efficient, but here is a bulky version with all its bits bare.not all that portable, but works well with whatever is on my computer (no idea, I am of pictures not words)If you have to compare a source string more often with other strings one elegant solution is to use regex.An easy way to compare strings that are only different by lowercase and capitalized characters is to do an ascii comparison. All capital and lowercase letters differ by 32 bits in the ascii table, using this information we have the following...