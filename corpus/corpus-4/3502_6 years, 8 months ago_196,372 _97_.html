Today I was browsing through some questions on this site and I found a mention of an enum being used in singleton pattern about purported thread safety benefits to such solution.I have never used enums and I have been programing in Java for more than couple a years now. And apparently they changed a lot. Now they even do full blown support of OOP within themselves.You should always use enums when a variable (especially a method parameter) can only take one out of a small set of possible values. Examples would be things like type constants (contract status: "permanent", "temp", "apprentice"), or flags ("execute now", "defer execution").If you use enums instead of integers (or String codes), you increase compile-time checking and avoid errors from passing in invalid constants, and you document which values are legal to use.BTW, overuse of enums might mean that your methods do too much (it\'s often better to have several separate methods, rather than one method that takes several flags which modify what it does), but if you have to use flags or type codes, enums are the way to go.As an example, which is better?versusA method call like:then becomes:In the second example, it\'s immediately clear which types are allowed, docs and implementation cannot go out of sync, and the compiler can enforce this.\nAlso, an invalid call likeis no longer possible.Why use any programming language feature?  The reason we have languages at all is forEnums improve both likelihood of correctness and readability without writing a lot of boilerplate.  If you are willing to write boilerplate, then you can "simulate" enums:Now you can write:The boilerplate above has much the same effect asBoth provide the same level of checking help from the compiler.  Boilerplate is just more typing.  But saving a lot of typing makes the programmer more efficient (see 1), so it\'s a worthwhile feature.It\'s worthwhile for at least one more reason, too:Switch statementsOne thing that the static final enum simulation above does not give you is nice switch cases.  For enum types, the Java switch uses the type of its variable to infer the scope of enum cases, so for the enum Color above you merely need to say:Note it\'s not Color.RED in the cases.  If you don\'t use enum, the only way to use named quantities with switch is something like:But now a variable to hold a color must have type int.  The nice compiler checking of the enum and the static final simulation is gone.  Not happy.A compromise is to use a scalar-valued member in the simulation:Now:But note, even more boilerplate!Using an enum as a singletonFrom the boilerplate above you can see why an enum provides a way to implement a singleton.  Instead of writing:and then accessing it withwe can just saywhich gives us the same thing.  We can get away with this because Java enums are implemented as full classes with only a little syntactic sugar sprinkled over the top.  This is again less boilerplate, but it\'s non-obvious unless the idiom is familiar to you.  I also dislike the fact that you get the various enum functions even though they don\'t make much sense for the singleton: ord and values, etc.  (There\'s actually a trickier simulation where Color extends Integer that will work with switch, but it\'s so tricky that it even more clearly shows why enum is a better idea.)Thread safetyThread safety is a potential problem only when singletons are created lazily with no locking.If many threads call getInstance simultaneously while INSTANCE is still null, any number of instances can be created.  This is bad.  The only solution is to add synchronized access to protect the variable INSTANCE.However, the static final code above does not have this problem.  It creates the instance eagerly at class load time.  Class loading is synchronized.  The enum singleton is effectively lazy because it\'s not initialized until first use. Java initialization is also synchronized, so multiple threads can\'t initialize more than one instance of INSTANCE. You\'re getting a lazily initialized singleton with very little code. The only negative is the the rather obscure syntax. You need to know the idiom or thoroughly understand how class loading and initialization work to know what\'s happening.  Besides the already mentioned use-cases, I often find enums useful for implementing the strategy pattern, following some basic OOP guidelines:The simplest example would be a set of Comparator implementations:This "pattern" can be used in far more complex scenarios, making extensive use of all the goodies that come with the enum: iterating over the instances, relying on their implicit order, retrieving an instance by its name, static methods providing the right instance for specific contexts etc. And still you have this all hidden behind the interface so your code will work with custom implementations without modification in case you want something that\'s not available among the "default options".I\'ve seen this successfully applied for modeling the concept of time granularity (daily, weekly, etc.) where all the logic was encapsulated in an enum (choosing the right granularity for a given time range, specific behavior bound to each granularity as constant methods etc.). And still, the Granularity as seen by the service layer was simply an interface.Something none of the other answers have covered that make enums particularly powerful are the ability to have template methods. Methods can be part of the base enum and overridden by each type. And, with the behavior attached to the enum, it often eliminates the need for if-else constructs or switch statements as this blog post demonstrates - where enum.method() does what originally would be executed inside the conditional. The same example also shows the use of static imports with enums as well producing much cleaner DSL like code. Some other interesting qualities include the fact that enums provide implementation for equals(), toString() and hashCode() and implement Serializable and Comparable. For a complete rundown of all that enums have to offer I highly recommend Bruce Eckel\'s Thinking in Java 4th edition which devotes an entire chapter to the topic. Particularly illuminating are the examples involving a Rock, Paper, Scissors (i.e. RoShamBo) game as enums. From Java documents -You should use enum types any time you\n  need to represent a fixed set of\n  constants. That includes natural enum\n  types such as the planets in our solar\n  system and data sets where you know\n  all possible values at compile\n  time\xe2\x80\x94for example, the choices on a\n  menu, command line flags, and so on.A common example is to replace a class with a set of private static final int constants (within reasonable number of constants) with an enum type. Basically if you think you know all possible values of "something" at compile time you can represent that as an enum type. Enums provide readability and flexibility over a class with constants.Few other advantages that I can think of enum types. They is always one instance of a particular enum class (hence the concept of using enums as singleton arrives). Another advantage is you can use enums as a type in switch-case statement. Also you can use toString() on the enum to print them as readable strings.Now why and what for should I used\n  enum in day to day programing?You can use an Enum to represent a smallish fixed set of constants or an internal class mode while increasing readability. Also, Enums can enforce a certain rigidity when used in method parameters. They offer the interesting possibility of passing information to a constructor like in the Planets example on Oracle\'s site and, as you\'ve discovered, also allow a simple way to create a singleton pattern.ex: Locale.setDefault(Locale.US) reads better than Locale.setDefault(1) and enforces the use of fixed set of values shown in an IDE when you add the . separator instead of all integers.Enums enumerate a fixed set of values, in a self-documenting way.\nThey make your code more explicit, and also less error-prone.Why not using String, or int, instead of Enum, for constants?Moreover, each of the Enum\'s instances is a class, for which you can define its individual behaviour. Plus, they assure thread safety upon creation of the instances (when the enum is loaded), which has seen great application in simplifying the Singleton Pattern.This blog illustrates some of its applications, such as a State Machine for a parser.Apart from all said by others.. In an older project that I used to work for, a lot of communication between entities(independent applications) was using integers which represented a small set. It was useful to declare the set as enum with static methods to get enum object from value and viceversa. The code looked cleaner, switch case usability and easier writing to logs.Create enum object from received values (e.g. 1,2) using ProtocolType.fromInt(2)\nWrite to logs using myEnumObj.nameHope this helps.What is a enum:Why to use enums:Note:In addition to good answers here, it is useful to know that enums are just like the other classes with Constant fields and a private constructor.For example,The compiler compiles it as follows;Enum inherits all the methods of Object class and abstract class Enum. So you can use it\'s methods for reflection, multithreading, serilization, comparable, etc. If you just declare a static constant instead of Enum, you can\'t. Besides that, the value of Enum can be passed to DAO layer as well.Here\'s an example program to demonstrate.ENum stands for "Enumerated Type". It is a data type having a fixed set of constants which you define yourself.enum means enumeration i.e. mention (a number of things) one by one.An enum is a data type that contains fixed set of constants.ORAn enum is just like a class, with a fixed set of instances known at compile time. For example:Advantages of enum: for moreIn my opinion, all the answers you got up to now are valid, but in my experience, I would express it in a few words:Use enums if you want the compiler to check the validity of the value of an identifier. Otherwise, you can use strings as you always did (probably you defined some "conventions" for your application) and you will be very flexible... but you will not get 100% security against typos on your strings and you will realize them only in runtime.  Enum ? Why should be used . I think its more understood  when you will use it .\nI have the same experience .Say you have Create,delete, Edit and Read DB operation now if you create an enum as Operation now , you may declare something like So you can use it in many ways .\nIt\'s always good to have enum for specific things as the Db operation in above example can be controlled by checking  the currentOperation. Perhaps one can say this can be accomplished with variables and integer Values too .But I believe Enum is a safer and a programmer\'s  way.Another thing : I think every Programmer loves boolean don\'t we ?, because it can store only two values , two specific values . So Enum can be thought of having the same type of facilities where user will define how many and what type of value it will store , just in a slightly differently way. :)Java lets you restrict variable to having one of only a few predefined values - in other words, one value from an enumerated list.\nUsing enums can help to reduce bug\'s in your code.\nHere is an example of enums outside a class:This restricts coffeesize to having either: BIG , HUGE , or OVERWHELMING as a variable.So far, I have never needed to use enums. I have been reading about them since they were introduced in 1.5 or version tiger as it was called back in the day. They never really solved a \'problem\' for me. For those who use it (and I see a lot of them do), am sure it definitely serves some purpose. Just my 2 quid.There are many answers here, just want to point two specific ones:1) Using as constants in Switch-case statement.\nSwitch case won\'t allow you to use String objects for case. Enums come in handy. More: http://www.javabeat.net/2009/02/how-to-use-enum-in-switch/2) Implementing Singleton Design Pattern - Enum again, comes to rescue. Usage, here: What is the best approach for using an Enum as a singleton in Java?Use enums for TYPE SAFETY, this is a language feature so you will usually get:Enums can have methods, constructors, you can even use enums inside enums and combine enums with interfaces.Think of enums as types to replace a well defined set of int constants (which Java \'inherited\' from C/C++).The book  Effective Java 2nd Edition has a whole chapter about them and goes into more details.\nAlso see this stackoverflow post.What gave me the Ah-Ha moment was this realization: that Enum has a private constructor only accessible via the public enumeration:As for me to make the code readable in future the most useful aplyable case  of enumeration is represented in  next snippet: In my experience I have seen Enum usage sometimes cause systems to be very difficult to change. If you are using an Enum for a set of domain-specific values that change frequently, and it has a lot of other classes and components that depend on it, you might want to consider not using an Enum.For example, a trading system that uses an Enum for markets/exchanges. There are a lot of markets out there and it\'s almost certain that there will be a lot of sub-systems that need to access this list of markets. Every time you want a new market to be added to your system, or if you want to remove a market, it\'s possible that everything under the sun will have to be rebuilt and released.A better example would be something like a product category type. Let\'s say your software manages inventory for a department store. There are a lot of product categories, and many reasons why this list of categories could change. Managers may want to stock a new product line, get rid of other product lines, and possibly reorganize the categories from time to time. If you have to rebuild and redeploy all of your systems simply because users want to add a product category, then you\'ve taken something that should be simple and fast (adding a category) and made it very difficult and slow.Bottom line, Enums are good if the data you are representing is very static over time and has a limited number of dependencies. But if the data changes a lot and has a lot of dependencies, then you need something dynamic that isn\'t checked at compile time (like a database table).