I want to write a query like this:But this isn\'t how the MAX function works, right?  It is an aggregate function so it expects a single parameter and then returns the MAX of all rows.   Does anyone know how to do it my way?You\'d need to make a User-Defined Function if you wanted to have syntax similar to your example, but could you do what you want to do, inline, fairly easily with a CASE statement, as the others have said.The UDF could be something like this:... and you would call it like so ...If you\'re using SQL Server 2008 (or above), then this is the better solution:All credit and votes should go to Sven\'s answer to a related question, "SQL MAX of multiple columns?"\nI say it\'s the "best answer" because:Can be done in one line:Edit: If you\'re dealing with very large numbers you\'ll have to convert the value variables into bigint in order to avoid an integer overflow. I don\'t think so. I wanted this the other day. The closest I got was:Why not try IIF function (requires SQL Server 2012 and later)That\'s it.The other answers are good, but if you have to worry about having NULL values, you may want this variant:Sub Queries can access the columns from the Outer query so you can use this approach to use aggregates such as MAX across columns. (Probably more useful when there is a greater number of columns involved though)SQL Server 2012 introduced IIF:Handling NULLs is recommended when using IIF, because a NULL on either side of your boolean_expression will cause IIF to return the false_value (as opposed to NULL). I would go with the solution provided by kcrumley\nJust modify it slightly to handle NULLsEDIT\nModified after comment from Mark. As he correctly pointed out in 3 valued logic x > NULL or x < NULL should always return NULL. In other words unknown result.Its as simple as this: Oops, I just posted a dupe of this question... The answer is, there is no built in function like Oracle\'s Greatest, but you can achieve a similar result for 2 columns with a UDF, note, the use of sql_variant is quite important here.kristofPosted this answer: I probably wouldn\'t do it this way, as it\'s less efficient than the already mentioned CASE constructs - unless, perhaps, you had covering indexes for both queries. Either way, it\'s a useful technique for similar problems:You can do something like this:For the answer above regarding large numbers, you could do the multiplication before the addition/subtraction. It\'s a bit bulkier but requires no cast. (I can\'t speak for speed but I assume it\'s still pretty quick)  SELECT 0.5 * ((@val1 + @val2) +\n  ABS(@val1 - @val2))Changes toSELECT @val1*0.5+@val2*0.5 +\n  ABS(@val1*0.5 - @val2*0.5)at least an alternative if you want to avoid casting. In its simplest form...For SQL Server 2012:Here\'s a case example that should handle nulls and will work with older versions of MSSQL.  This is based on the inline function in one one of the popular examples:Here is @Scott Langham\'s answer with simple NULL handling:Here is an IIF version with NULL handling (based on of Xin\'s answer):The logic is as follows, if either of the values is NULL, return the one that isn\'t NULL (if both are NULL, a NULL is returned). Otherwise return the greater one.Same can be done for MIN.