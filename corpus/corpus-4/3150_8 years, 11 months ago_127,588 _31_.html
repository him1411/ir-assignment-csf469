Many C++ books contain example code like this......so I\'ve always done that too. But I\'ve seen a lot of code from working developers like this instead:Is there a technical reason to prefer one over the other, or is it just a matter of coding style?The varying line-ending characters don\'t matter, assuming the file is open in text mode, which is what you get unless you ask for binary.  The compiled program will write out the correct thing for the system compiled for.The only difference is that std::endl flushes the output buffer, and \'\\n\' doesn\'t.  If you don\'t want the buffer flushed frequently, use \'\\n\'.  If you do (for example, if you want to get all the output, and the program is unstable), use std::endl.The difference can be illustrated by the following:is equivalent toSo,I use \\n on most lines.\nThen use std::endl at the end of a paragraph (but that is just a habit and not usually necessary).Contrary to other claims, the \\n character is mapped to the correct platform end of line sequence only if the stream is going to a file (std::cin and std::cout being special but still files (or file-like)).There might be performance issues, std::endl forces a flush of the output stream.They will both write the appropriate end-of-line character(s). In addition to that endl will cause the buffer to be committed. You usually don\'t want to use endl when doing file I/O because the unnecessary commits can impact performance.I recalled reading about this in the standard, so here goes:See C11 standard which defines how the standard streams behave, as C++ programs interface the CRT, the C11 standard should govern the flushing policy here.ISO/IEC 9899:201x7.21.3 \xc2\xa77At program startup, three text streams are predefined and need not be opened explicitly\n  \xe2\x80\x94 standard input (for reading conventional input), standard output (for writing\n  conventional output), and standard error (for writing diagnostic output). As initially\n  opened, the standard error stream is not fully buffered; the standard input and standard\n  output streams are fully buffered if and only if the stream can be determined not to refer\n  to an interactive device.7.21.3 \xc2\xa73When a stream is unbuffered, characters are intended to appear from the source or at the\n  destination as soon as possible. Otherwise characters may be accumulated and\n  transmitted to or from the host environment as a block. When a stream is fully buffered,\n  characters are intended to be transmitted to or from the host environment as a block when\n  a buffer is filled. When a stream is line buffered, characters are intended to be\n  transmitted to or from the host environment as a block when a new-line character is\n  encountered. Furthermore, characters are intended to be transmitted as a block to the host\n  environment when a buffer is filled, when input is requested on an unbuffered stream, or\n  when input is requested on a line buffered stream that requires the transmission of\n  characters from the host environment. Support for these characteristics is\n  implementation-defined, and may be affected via the setbuf and setvbuf functions.This means that std::cout and std::cin are fully buffered if and only if they are referring to a non-interactive device. In other words, if stdout is attached to a terminal then there is no difference in behavior. However, if std::cout.sync_with_stdio(false) is called, then \'\\n\' will not cause a flush even to interactive devices. Otherwise \'\\n\' is equivalent to std::endl unless piping to files: c++ ref on std::endl.There\'s another function call implied in there if you\'re going to use std::endla) calls operator << once. \nb) calls operator << twice.Not a big deal, but endl won\'t work in boost::lambda.If you use Qt and endl, you could accidentally use the wrong endl, happened to me today and i was like ..WTF ??Of course that was my mistake, since i should have written std::endl, but if you use endl, qt and using namespace std; it depends on the order of the include files if the correct endl will be used.*Of course you could recompile Qt to use a namespace, so you get a compilation error for the example above.EDIT: Forgot to mention, Qt\'s endl is declared in "qtextstream.h" which is part of QtCore*EDIT2: C++ will pick the correct endl if you have a using for std::cout or the namespace std, since std::endl is in the same namespace as std::cout, C++\'s ADL mechanism will pick std::endl.I\'ve always had a habit of just using std::endl because it is easy for me to see.If you didn\'t notice, endl is like pressing the ENTER KEY while "\\n" is like pressing ENTER KEY + SPACE BAR.