Let\'s say you don\'t want other sites to "frame" your site in an <iframe>:So you insert anti-framing, frame busting JavaScript into all your pages:Excellent! Now you "bust" or break out of any containing iframe automatically. Except for one small problem.As it turns out, your frame-busting code can be busted, as shown here:This code does the following:My question is -- and this is more of a JavaScript puzzle than an actual problem -- how can you defeat the frame-busting buster? I had a few thoughts, but nothing worked in my testing:I\'m not much of a JavaScript programmer, so here\'s my challenge to you: hey buster, can you bust the frame-busting buster?I\'m not sure if this is viable or not - but if you can\'t break the frame, why not just display a warning. For example, If your page isn\'t the "top page" create a setInterval method that tries to break the frame. If after 3 or 4 tries your page still isn\'t the top page - create a div element that covers the whole page (modal box) with a message and a link like...You are viewing this page in a unauthorized frame window - (Blah blah... potential security issue)click this link to fix this problemNot the best, but I don\'t see any way they could script their way out of that.FWIW, most current browsers support the X-Frame-Options: deny directive, which works even when script is disabled.IE8:\nhttp://blogs.msdn.com/ie/archive/2009/01/27/ie8-security-part-vii-clickjacking-defenses.aspxFirefox (3.6.9)\nhttps://bugzilla.mozilla.org/show_bug.cgi?id=475530\nhttps://developer.mozilla.org/en/The_X-FRAME-OPTIONS_response_headerChrome/Webkit\nhttp://blog.chromium.org/2010/01/security-in-depth-new-security-features.html\nhttp://trac.webkit.org/changeset/42333Came up with this, and it seems to work at least in Firefox.We have used the following approach in one of our websites from http://seclab.stanford.edu/websec/framebusting/framebust.pdfAfter pondering this for a little while, I believe this will show them who\'s boss...Using _top as the target parameter for window.open() will launch it in the same window.Considering current HTML5 standard that introduced sandbox for iframe, all frame busting codes that provided in this page can be disabled when attacker uses sandbox because it restricts the iframe from following:Please see: http://www.whatwg.org/specs/web-apps/current-work/multipage/the-iframe-element.html#attr-iframe-sandboxNow, consider attacker used the following code to host your site in iframe:Then, all JavaScript frame busting code will fail. After checking all frame busing code, only this defense works in all cases:that originally proposed by Gustav Rydstedt, Elie Bursztein, Dan Boneh, and Collin Jackson (2010)Ok, so we know that were in a frame. So we location.href to another special page with the path as a GET variable.  We now explain to the user what is going on and provide a link with a target="_TOP" option. It\'s simple and would probably work (haven\'t tested it), but it requires some user interaction. Maybe you could point out the offending site to the user and make a hall of shame of click jackers to your site somewhere.. Just an idea, but it night work..All the proposed solutions directly force a change in the location of the top window. What if a user wants the frame to be there? For example the top frame in the image results of search engines.I wrote a prototype where by default all inputs (links, forms and input elements) are disabled and/or do nothing when activated.If a containing frame is detected, the inputs are left disabled and a warning message is shown at the top of the page. The warning message contains a link that will open a safe version of the page in a new window. This prevents the page from being used for clickjacking, while still allowing the user to view the contents in other situations.If no containing frame is detected, the inputs are enabled.Here is the code. You need to set the standard HTML attributes to safe values and add additonal attributes that contain the actual values. It probably is incomplete and for full safety additional attributes (I am thinking about event handlers) will probably have to be treated in the same way:I\'m going to be brave and throw my hat into the ring on this one (ancient as it is), see how many downvotes I can collect.Here is my attempt, which does seem to work everywhere I have tested it (Chrome20, IE8 and FF14):I placed this code in the <head> and called it from the end of the <body> to ensure my page is rendered before it starts arguing with the malicious code, don\'t know if this is the best approach, YMMV.How does it work?...I hear you ask - well the honest answer is, I don\'t really know. It took a lot of fudging about to make it work everywhere I was testing, and the exact effect that it has varies slightly depending on where you run it.Here is the thinking behind it:For my http://mysite.tld/page-that-takes-a-while-to-load (the target of the XHR) I used a PHP script that looks like this:What happens?Can\'t you avoid the wait time in Chrome and Firefox?Apparently not. At first I pointed the XHR to a URL that would return a 404 - this didn\'t work in Firefox. Then I tried the sleep(5); approach that I eventually landed on for this answer, then I started playing around with the sleep length in various ways. I could find no real pattern to the behaviour, but I did find that if it is too short, specifically Firefox will not play ball (Chrome and IE seem to be fairly well behaved). I don\'t know what the definition of "too short" is in real terms, but 5 seconds seems to work every time.If any passing Javascript ninjas want to explain a little better what\'s going on, why this is (probably) wrong, unreliable, the worst code they\'ve ever seen etc I\'ll happily listen.Well, you can modify the value of the counter, but that is obviously a brittle solution. You can load your content via AJAX after you have determined the site is not within a frame - also not a great solution, but it hopefully avoids firing the on beforeunload event (I am assuming).Edit: Another idea. If you detect you are in a frame, ask the user to disable javascript, before clicking on a link that takes you to the desired URL (passing a querystring that lets your page know to tell the user that they can re-enable javascript once they are there).Edit 2: Go nuclear - if you detect you are in a frame, just delete your document body content and print some nasty message.Edit 3: Can you enumerate the top document and set all functions to null (even anonymous ones)?As of 2015, you should use CSP2\'s frame-ancestors directive for this. This is implemented via an HTTP response header.e.g.Of course, not many browsers support CSP2 yet so it is wise to include the old X-Frame-Options header:I would advise to include both anyway, otherwise your site would continue to be vulnerable to Clickjacking attacks in old browsers, and of course you would get undesirable framing even without malicious intent. Most browsers do update automatically these days, however you still tend to get corporate users being stuck on old versions of Internet Explorer for legacy application compatibility reasons.I think you were almost there.  Have you tried:or, alternatively:Note: I didn\'t actually test this.If you add an alert right after the buster code, then the alert will stall the javascript thread, and it will let the page load. This is what StackOverflow does, and it busts out of my iframes, even when I use the frame busting buster. It also worked with my simple test page. This has only been tested in Firefox 3.5 and IE7 on windows.Code:What about calling the buster repeatedly as well? This\'ll create a race condition, but one may hope that the buster comes out on top:If you look at the values returned by setInterval() they are usually single digits, so you can usually disable all such interrupts with a single line of code:I might just have just gotten a way to bust the frame buster buster javascript. Using the getElementsByName in my javascript function, i\'ve set a loop between the frame buster and the actual frame buster buster script.\ncheck this post out. http://www.phcityonweb.com/frame-buster-buster-buster-2426setInterval and setTimeout create an automatically incrementing interval.  Each time setTimeout or setInterval is called, this number goes up by one, so that if you call setTimeout, you\'ll get the current, highest value.Since it is almost unheard of for there to be 10000 simultaneous setIntervals and setTimeouts working, and since setTimeout returns "last interval or timeout created + 1", and since top.clearInterval is still accessible, this will defeat the black-hat attacks to frame websites which are described above.Use htaccess to avoid high-jacking frameset, iframe and any content like images.This will show a copyright page instead of the expected.