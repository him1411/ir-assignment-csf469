I\'ve just come across someone\'s C code that I\'m confused as to why it is compiling. There are two points I don\'t understand.First, the function prototype has no parameters compared to the actual function definition. Second, the parameter in the function definition does not have a type.Why does this work? I have tested it in a couple of compilers, and it works fine.All the other answers are correct, but just for completionA function is declared in the following manner:return-type is the variable type that the function returns. This can not be an array type or a function type. If not given, then int\n  is assumed.function-name is the name of the function.parameter-list is the list of parameters that the function takes separated by commas. If no parameters are given, then the function\n  does not take any and should be defined with an empty set of\n  parenthesis or with the keyword void. If no variable type is in front\n  of a variable in the paramater list, then int is assumed. Arrays and\n  functions are not passed to functions, but are automatically converted\n  to pointers. If the list is terminated with an ellipsis (,...), then\n  there is no set number of parameters. Note: the header stdarg.h can be\n  used to access arguments when using an ellipsis.And again for the sake of completeness. From C11 specification 6:11:6 (page: 179)The use of function declarators with empty parentheses (not\n  prototype-format parameter type declarators) is an obsolescent\n  feature.In C func() means that you can pass any number of arguments.  If you want no arguments then you have to declare as func(void). The type you\'re passing to your function, if not specified defaults to int.int func(); is an obsolescent function declaration from the days when there was no C standard, i.e. the days of K&R C (before 1989, the year the first "ANSI C" standard was published).Remember that there were no prototypes in K&R C and the keyword void was not yet invented. All you could do was to tell the compiler about the return type of a function. The empty parameter list in K&R C means "an unspecified but fixed" number of arguments. Fixed means that you must call the function with the same number of args each time (as opposed to a variadic function like printf, where the number and type can vary for each call).Many compilers will diagnose this construct; in particular gcc -Wstrict-prototypes will tell you "function declaration isn\'t a prototype", which is spot on, because it looks like a prototype (especially if you are poisoned by C++!), but isn\'t. It\'s an old style K&R C return type declaration. Rule of thumb: Never leave an empty parameter list declaration empty, use int func(void) to be specific.\nThis turns the K&R return type declaration into a proper C89 prototype. Compilers are happy, developers are happy, static checkers are happy. Those mislead by^W^Wfond of C++ may cringe, though, because they need to type extra characters when they try to exercise their foreign language skills :-)I would consider any build that passes this to be lacking in configured warning/error level though, there\'s no point in being this allowing for actual code.It\'s K&R style function declaration and definition. From C99 Standard (ISO/IEC 9899:TC3)Section 6.7.5.3 Function Declarators (including prototypes)An identifier list declares only the identifiers of the parameters of the function. An empty\n  list in a function declarator that is part of a definition of that function specifies that the\n  function has no parameters. The empty list in a function declarator that is not part of a\n  definition of that function specifies that no information about the number or types of the\n  parameters is supplied. (If both function types are "old style", parameter types are not compared.) Section 6.11.6 Function declaratorsThe use of function declarators with empty parentheses (not prototype-format parameter\n  type declarators) is an obsolescent feature.Section 6.11.7 Function definitionsThe use of function definitions with separate parameter identifier and declaration lists\n  (not prototype-format parameter type and identifier declarators) is an obsolescent feature.Which the old style means K&R styleExample:Declaration: int old_style();Definition: C assumes int if no type is given on function return type and parameter list. Only for this rule following weird things are possible. A function definition looks like this.If its a prototype you writeIn prototype you can only specify the type of parameters. Parameters\' name is not mandatory. SoAlso if you dont specify parameter type but name int is assumed as type.If you go farther, following works too. Compiler assumes int func() when you write func(). But dont put func() inside a function body. That\'ll be a function callAs stated @Krishnabhadra, all previous responses from other users, have a correct interpretation, and I just want to make a more detailed analysis of some points.In the Old-C as in ANSI-C the "untyped formal parameter", take the dimencion of your work register or instruction depth  capability  (shadow registers or instruction cumulative cycle), in an 8bit MPU, will be an int16, in a 16bit MPU and so will be an int16 an so on, in the case 64bit architectures may choose to compile options like: -m32.Although it seems simpler implementation at high level,\nFor pass multiple parameters, the work of the programmer in the control dimencion  data type step, becomes more demanding.In other cases, for some  microprocessors architectures, the ANSI compilers customized, leveraged some of this old features to optimize the use of the code, forcing the location of these "untyped formal parameters" to work within or outside the work register, today you get almost the same with the use of "volatile" and "register".But it should be noted that the most modern compilers,\nnot make any distinction between the two types of parameters declaration.Examples of a compilation with gcc under linux:\n\xc2\xa0\n\nIn any case the statement of the prototype locally is of no use, because there is no call without parameters reference to this prototype will be remiss.\nIf you use the system with "untyped formal parameter", for an external call, proceed to generate a declarative prototype data type.Like this:Regarding parameter type, there are already correct answers here but if you want to hear it from the compiler you can try adding some flags (flags are almost always a good idea anyways).compiling your program using gcc foo.c -Wextra I get:strangely -Wextra doesn\'t catch this for clang (it doesn\'t recognize -Wmissing-parameter-type for some reason, maybe for historical ones mentioned above) but -pedantic does:And for prototype issue as said again above int func() refers to arbitrary parameters unless you exclicitly define it as int func(void) which would then give you the errors as expected:or in clang as:If the function declaration has no parameters i.e. empty then it is taking unspecified number of arguments. If you want to make it take no arguments then change it to:This is why I typically advise people to compile their code with:These flags enforce a couple of things:These flags are also used by default in a lot of Open Source projects. For example, FreeBSD has these flags enabled when building with WARNS=6 in your Makefile.Sir, in C++ (and C++ ONLY) you are allowed to define multiple functions of the same name with different parameters.  For example:Should compile.  To choose which function to use, simply pass that variable type into the parenthesis when you compile.For example:will call func(int test).Whereaswill call func(char).You do NOT need variable names in the function header, although as long as the function prototype (y\'know, the line at top that has just a function with no code in it) matches the names in actual function below you\'ll be A OKay (for example, instead of int func(int) you could just as well have int func(int avariable).As to the variable in the prototype compiling without a type, it probably defaults to type, likely int (although I\'m not sure if which type it defaults to varies by compiler or not.)