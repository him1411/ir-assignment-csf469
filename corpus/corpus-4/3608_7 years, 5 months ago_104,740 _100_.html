If I have a reference to an object - that will potentially (but not immediately) have nested objects, something like - what is the best way to test for the existence of keys in the most deeply nested objects?This - returns \'undefined\', but this - fails.I\'m currently doing something like this - but I was wondering if there\'s a better way.You have to do it step by step if you don\'t want a TypeError, because if one of the members is null or undefined, and you try to access a member an exception will be thrown.You can either simply catch the exception, or make a function to test the existence of multiple levels, something like this:Here is a pattern I picked up from Oliver Steele:In fact that whole article is a discussion of how you can do this in javascript. He settles on using the above syntax (which isn\'t that hard to read once you get used to it) as an idiom.Looks like lodash has added _.get for all your nested property getting needs.https://lodash.com/docs#getlodash users may enjoy lodash.contrib which has a couple methods that mitigate this problem.Signature: _.getPath(obj:Object, ks:String|Array)Gets the value at any depth in a nested object based on the path described by\nthe keys given. Keys may be given as an array or as a dot-separated string.\nReturns undefined if the path cannot be reached.I have done performance tests (thank you cdMinix for adding lodash) on some of the suggestions proposed to this question with the results listed below.Disclaimer #1 Turning strings in to references is unnecessary meta-programming and probably best avoided. Don\'t loose track of your references to begin with. Read more from this answer to a similar question.Disclaimer #2 We are talking about million of operations per millisecond here. It is very unlikely any of these would make much difference in most use cases. Choose which ever makes the most sense knowing the limitations of each. For me I would go with something like reduce out of convenience. Object Wrap (by Oliver Steele) \xe2\x80\x93 34 % \xe2\x80\x93 fastest Original solution (suggested in question) \xe2\x80\x93 45%checkNested \xe2\x80\x93 50%get_if_exist \xe2\x80\x93 52%validChain \xe2\x80\x93 54%objHasKeys \xe2\x80\x93 63%nestedPropertyExists \xe2\x80\x93 69%_.get \xe2\x80\x93 72%deeptest \xe2\x80\x93 86%sad clowns \xe2\x80\x93 100% \xe2\x80\x93 slowestYou can read an object property at any depth, if you handle the name like a string: \'t.level1.level2.level3\'.It returns undefined if any of the segments is undefined.If you are coding in ES6 environment (or using 6to5) then you can take advantage of the arrow function syntax:Regarding the performance, there is no performance penalty for using try..catch block if the property is set. There is a performance impact if the property is unset.Consider simply using _.has:how aboutI tried a recursive approach:The ! keys.length || kicks out of the recursion so it doesn\'t run the function with no keys left to test.  Tests:I am using it to print a friendly html view of a bunch of objects with unknown key/values, e.g.:One simple way is this:The try/catch catches the cases for when any of the higher level objects such as test, test.level1, test.level1.level2 are not defined.A shorter, ES5 version of @CMS\'s excellent answer:With a similar test:I think the following script gives more readable representation.declare a function:then use it like this:I call it "sad clown technique" because it is using sign o(EDIT:here is a version for TypeScript it gives type checks at compile time (as well as the intellisense if you use a tool like Visual Studio)the usage is the same:but this time intellisense works! plus, you can set a default value:I didn\'t see any example of someone using ProxiesSo I came up with my own.\nThe grate thing about it is that you don\'t have to interpolate strings. You can actually return a chain-able object function and do some magical things with it. You can even call functions and get array indexes to check for deep objectsThe above code works fine for synchronous stuff. But how would you test something that is asynchronous like this ajax call?\nHow do you test that? what if the response isn\'t json when it returns a 500 http error?sure you could use async/await to get rid of some callbacks. But what if you could do it even more magically? something that looks like this:You probably wonder where all the promise & .then chains are... this could be blocking for all that you know... but using the same Proxy technic with promise you can actually test deeply nested complex path for it existens without ever writing a single functionThe answer given by CMS works fine with the following modification for null checks as wellI know this question is old, but I wanted to offer an extension by adding this to all objects. I know people tend to frown on using the Object prototype for extended object functionality, but I don\'t find anything easier than doing this. Plus, it\'s now allowed for with the Object.defineProperty method.Now, in order to test for any property in any object you can simply do:Here\'s a jsfiddle to test it out, and in particular it includes some jQuery that breaks if you modify the Object.prototype directly because of the property becoming enumerable. This should work fine with 3rd party libraries.This works with all objects and arrays :)ex: this is my improved version of Brian\'s answer I used _has as the property name because it can conflict with existing has property (ex: maps)Here\'s the fiddleBased on this answer, I came up with this generic function using ES2015 which would solve the problemHere\'s my take on it - most of these solutions ignore the case of a nested array as in:I may want to check for obj.l2[0].kWith the function below, you can do deeptest(\'l2[0].k\',obj)The function will return true if the object exists, false otherwiseI thought I\'d add another one that I came up with today. The reason I am proud of this solution is that it avoids nested brackets that are used in many solutions such as Object Wrap (by Oliver Steele):(in this example I use an underscore as a placeholder variable, but any variable name will work)theres a function here on thecodeabode (safeRead) which will do this in a safe manner... i.e.if any property is null or undefined, an empty string is returnedBased on a previous comment, here is another version where the main object could not be defined either:Following options were elaborated starting from this answer. Same tree for both : I think this is a slight improvement (becomes a 1-liner):This works because the && operator returns the final operand it evaluated (and it short-circuits).I was looking for the value to be returned if the property exists, so I modified the answer by CMS above. Here\'s what I came up with:I was having the same issue and and wanted to see if I could come up with a my own solution. This accepts the path you want to check as a string.Here is a snippet with some logging and test cases:Now we can also use reduce to loop through nested keys: Slight edit to this answer to allow nested arrays in the pathCheck linked answer for usages :)I automated the processAnother ES5 solution:My solution that I use since long time (using string unfortunaly, couldn\'t find better)edit: this work only if object "test" have global scope/range.\nelse you have to do something like : edit final version to allow 2 method of call :