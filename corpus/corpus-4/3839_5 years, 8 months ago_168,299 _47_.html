There are two new memory management attributes for properties introduced by ARC, strong and weak.Apart from copy, which is obviously something completely different, are there any differences between strong vs retain and weak vs assign?From my understanding, the only difference here is that weak will assign nil to the pointer, while assign won\'t, which means the program will crash when I send a message to the pointer once it\'s been released. But if I use weak, this won\'t ever happen, because message send to nil won\'t do anything.I don\'t know about any differences between strong and retain.Is there any reason why should I use assign and retain in new projects, or are the kind of being deprecated?From the Transitioning to ARC Release Notes (the example in the section on property attributes).So strong is the same as retain in a property declaration.For ARC projects I would use strong instead of retain, I would use assign for C primitive properties and weak for weak references to Objective-C objects. After reading so many articles Stackoverflow posts and demo applications to check variable property attributes, I decided to put all the attributes information together:Below is the detailed article link where you can find above mentioned all attributes, that will definitely help you.\nMany thanks to all the people who give best answers here!!Variable property attributes or Modifiers in iOS1.strong (iOS4 = retain )Example:2.weak\n    - Example :Strong & Weak Explanation, Thanks to BJ Homer:Imagine our object is a dog, and that the dog wants to run away (be\n  deallocated).Strong pointers are like a leash on the dog. As long as you have the\n  leash attached to the dog, the dog will not run away. If five people\n  attach their leash to one dog, (five strong pointers to one object),\n  then the dog will not run away until all five leashes are detached.Weak pointers, on the other hand, are like little kids pointing at the\n  dog and saying "Look! A dog!" As long as the dog is still on the\n  leash, the little kids can still see the dog, and they\'ll still point\n  to it. As soon as all the leashes are detached, though, the dog runs\n  away no matter how many little kids are pointing to it.As soon as the last strong pointer (leash) no longer points to an\n  object, the object will be deallocated, and all weak pointers will be\n  zeroed out.When we use weak?The only time you would want to use weak, is if you wanted to avoid retain cycles \n(e.g. the parent retains the child and the child retains the parent so neither is ever released).3.retain = strongExample:4.assign Example:As far as I know, strong and retain are synonyms, so they do exactly the same.Then the weak is almost like assign, but automatically set to nil after the object, it is pointing to, is deallocated.That means, you can simply replace them.However, there is one special case I\'ve encountered, where I had to use assign, rather than weak. Let\'s say we have two properties delegateAssign and delegateWeak. In both is stored our delegate, that is owning us by having the only strong reference. The delegate is deallocating, so our -dealloc method is called too.The delegate is already in deallocation process, but still not fully deallocated. The problem is that weak references to him are already nullified! Property delegateWeak contains nil, but delegateAssign contains valid object (with all properties already released and nullified, but still valid).It is quite special case, but it reveal us how those weak variables work and when they are nullified.Clang\'s document on Objective-C Automatic Reference Counting (ARC) explains the ownership qualifiers and modifiers clearly:There are four ownership qualifiers:A type is nontrivially ownership-qualified if it is qualified with\n  __autoreleasing, __strong, or __weak.Then there are six ownership modifiers for declared property:With the exception of weak, these modifiers are available in non-ARC modes.Semantics wise, the ownership qualifiers have different meaning in the five managed operations: Reading, Assignment, Initialization, Destruction and Moving, in which most of times we only care about the difference in Assignment operation.  Assignment occurs when evaluating an assignment operator. The\n  semantics vary based on the qualification:The other difference in Reading, Init, Destruction and Moving, please refer to Section 4.2 Semantics in the document.Example:\n@property (strong, nonatomic) ViewController *viewController;@synthesize viewController;By Default automatically get and set to nilExample :\n@property (weak, nonatomic) IBOutlet UIButton *myButton;@synthesize myButton;The differences between strong and retain:The differences between weak and assign: