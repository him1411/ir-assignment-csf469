My singleton accessor method is usually some variant of:What could I be doing to improve this?Another option is to use the +(void)initialize method.  From the documentation:The runtime sends initialize to each class in a program exactly one time just before the class, or any class that inherits from it, is sent its first message from within the program. (Thus the method may never be invoked if the class is not used.) The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses.So you could do something akin to this:[Source]Per my other answer below, I think you should be doing:Since Kendall posted a threadsafe singleton that attempts to avoid locking costs, I thought I would toss one up as well:Okay, let me explain how this works:Fast case: In normal execution sharedInstance has already been set, so the while loop is never executed and the function returns after simply testing for the variable\'s existence;Slow case: If sharedInstance doesn\'t exist, then an instance is allocated and copied into it using a Compare And Swap (\'CAS\');Contended case: If two threads both attempt to call sharedInstance at the same time AND sharedInstance doesn\'t exist at the same time then they will both initialize new instances of the singleton and attempt to CAS it into position. Whichever one wins the CAS returns immediately, whichever one loses releases the instance it just allocated and returns the (now set) sharedInstance. The single OSAtomicCompareAndSwapPtrBarrier acts as both a write barrier for the setting thread and a read barrier from the testing thread.Edit: This implementation obsoleted with ARC. Please have a look at How do I implement an Objective-C singleton that is compatible with ARC? for correct implementation.All the implementations of initialize I\'ve read in other answers share a common error.The Apple documentation recommend you check the class type in your initialize block. Because subclasses call the initialize by default. There exists a non-obvious case where subclasses may be created indirectly through KVO. For if you add the following line in another class:Objective-C will implicitly create a subclass of MySingletonClass resulting in a second triggering of +initialize.You may think that you should implicitly check for duplicate initialization in your init block as such:But you will shoot yourself in the foot; or worse give another developer the opportunity to shoot themselves in the foot.TL;DR, here\'s my implementation(Replace ZAssert with our own assertion macro; or just NSAssert.)A thorough explanation of the Singleton macro code is on the blog Cocoa With Lovehttp://cocoawithlove.com/2008/11/singletons-appdelegates-and-top-level.html.I have an interesting variation on sharedInstance that is thread safe, but does not lock after the initialization.  I am not yet sure enough of it to modify the top answer as requested, but I present it for further discussion:Short answer: Fabulous.Long answer: Something like....Be sure to read the dispatch/once.h header to understand what\'s going on. In this case the header comments are more applicable than the docs or man page.I\'ve rolled singleton into a class, so other classes can inherit singleton properties.Singleton.h :Singleton.m :And here is an example of some class, that you want to become singleton.The only limitation about Singleton class, is that it is NSObject subclass. But most time I use singletons in my code they are in fact NSObject subclasses, so this class really ease my life and make code cleaner.This works in a non-garbage collected environment also.Shouln\'t this be threadsafe and avoid the expensive locking after the first call?Here\'s a macro that I put together:http://github.com/cjhanson/Objective-C-Optimized-SingletonIt is based on the work here by Matt Gallagher\nBut changing the implementation to use method swizzling as described here by Dave MacLachlan of Google.I welcome comments / contributions.How about So you avoid the synchronization cost after initialization?For an in-depth discussion of the singleton pattern in Objective-C, look here:Using the Singleton Pattern in Objective-CKLSingleton is:KLSingletonYou don\'t want to synchronize on self... Since the self object doesn\'t exist yet! You end up locking on a temporary id value. You want to ensure that no one else can run class methods ( sharedInstance, alloc, allocWithZone:, etc ), so you need to synchronize on the class object instead:Just wanted to leave this here so I don\'t lose it. The advantage to this one is that it\'s usable in InterfaceBuilder, which is a HUGE advantage. This is taken from another question that I asked:I know there are a lot of comments on this "question", but I don\'t see many people suggesting using a macro to define the singleton.  It\'s such a common pattern and a macro greatly simplifies the singleton.Here are the macros I wrote based on several Objc implementations I\'ve seen.Singeton.hExample of use:MyManager.hMyManager.mWhy a interface macro when it\'s nearly empty?  Code consistency between the header and code files; maintainability in case you want to add more automatic methods or change it around.I\'m using the initialize method to create the singleton as is used in the most popular answer here (at time of writing).With Objective C class methods, we can just avoid using the singleton pattern the usual way, from:to:by wrapping the class inside another class that just has Class Methods, that way there is no chance of accidentally creating duplicate instances, as we\'re not creating any instance!I wrote a more detailed blog here :)To extend the example from @robbie-hanson ...My way is simple like this:If the singleton is initialized already, the LOCK block will not be entered. The second check if(!initialized) is to make sure it is not initialized yet when the current thread acquires the LOCK.I\'ve not read through all the solutions, so forgive if this code is redundant. This is the most thread safe implementation in my opinion. I usually use code roughly similar to that in Ben Hoffstein\'s answer (which I also got out of Wikipedia). I use it for the reasons stated by Chris Hanson in his comment.However, sometimes I have a need to place a singleton into a NIB, and in that case I use the following:I leave the implementation of -retain (etc.) to the reader, although the above code is all you need in a garbage collected environment.The accepted answer, although it compiles, is incorrect.Per Apple documentation:... You can take a similar approach to synchronize the class methods of the associated class, using the Class object instead of self.Even if using self works, it shouldn\'t and this looks like a copy and paste mistake to me.\nThe correct implementation for a class factory method would be: