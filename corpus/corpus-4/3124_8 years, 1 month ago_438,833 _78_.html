Does anyone know how can I check whether a variable is a number or a string in JavaScript?If you\'re dealing with literal notation, and not constructors, you can use typeof:.If you\'re creating numbers and strings via a constructor, such as var foo = new String("foo"), you should keep in mind that typeof may return object for foo. Perhaps a more foolproof method of checking the type would be to utilize the method found in underscore.js (annotated source can be found here),This returns a boolean true for the following:Best way to do that is using isNaN + type casting:Updated all-in method:The same using regex:EDIT:In case you need to handle null values:EDIT2 (updated) :\nIn case you need to handle null and the empty string:The best way I have found is to either check for a method on the string, i.e.:or if you want to do something with the number check for a number property,This is sort of like "duck typing", it\'s up to you which way makes the most sense. I don\'t have enough karma to comment, but typeof fails for boxed strings and numbers, i.e.:will alert "object".Check if the value is a string literal or String object:Unit test:Checking for a number is similar:You\'re looking for isNaN():See JavaScript isNaN() Function at MDN.Try this,Or adapt it to return an unknown type:May 12, 2012 Update:\nFull example at Javascript: A Better typeof.Best way to do this:This satisfies the following test cases:Here\'s an approach based on the idea of coercing the input to a number or string by adding zero or the null string, and then do a typed equality comparison.For some unfathomable reason, x===x+0 seems to perform better than x===+x.Are there any cases where this fails?In the same vein:This appears to be mildly faster than either x===true || x===false or typeof x==="boolean" (and much faster than x===Boolean(x)).Then there\'s also All these depend on the existence of an "identity" operation particular to each type which can be applied to any value and reliably produce a value of the type in question. I cannot think of such an operation for dates.For NaN, there isThis is basically underscore\'s version, and as it stands is about four times faster than isNaN(), but the comments in the underscore source mention that "NaN is the only number that does not equal itself" and adds a check for _.isNumber. Why? What other objects would not equal themselves? Also, underscore uses x !== +x--but what difference could the + here make?Then for the paranoid:Since ES2015 the correct way to check if a variable\nholds a valid number is:Examples:Can you just divide it by 1?I assume the issue would be a string input like: "123ABG"Just a way I did it recently.uh, how about just:After further review many months later, this only guarantees obj is an object that has the method or property name toLowerCase defined.  I am ashamed of my answer.  Please see top-voted typeof one.I think converting the var to a string decreases the performance, at least this test performed in the latest browsers shows so.So if you care about performance, I would, I\'d use this:for checking if the variable is a string (even if you use var str = new String("foo"), str instanceof String would return true).As for checking if it\'s a number I would go for the native: isNaN; function.This solution resolves many of the issues raised here!This is by far the most reliable method I have used by far. I did not invent this, and cannot recall where I originally found it.  But it works where other techniques fail:Example of correctnessor just use the invert of isNaNif(!isNaN(data))\n do something with the number\nelse\n it is a stringand yes - using jQuery - $.isNumeric() is more fun for the buck.the best way i found which also thinks of positive and negative numbers is from : \nO\'Reilly Javascript and DHTML Cookbook :}Errr? Just use regular expressions! :)since a string as \'1234\' with typeof will show \'string\', and the inverse cannot ever happen (typeof 123 will always be number), the best is to use a simple regex /^\\-?\\d+$/.test(var). Or a more advanced to match floats, integers and negative numbers, /^[\\-\\+]?[\\d]+\\.?(\\d+)?$/\nThe important side of .test is that it WON\'T throw an exception if the var isn\'t an string, the value can be anything. If you are looking for the real type, then typeof alone will do. @BitOfUniverse\'s answer is good, and I come up with a new way:I know 0 can\'t be dividend, but here the function works perfectly.typeof works very well for me in most case. You can try using an if statementwhere x is any variable name of your choiceJsut an FYI, if you\'re using jQuery you haveto handle this. More details on http://api.jquery.com/jQuery.isNumeric/jQuery uses this:Simply use orif you want to handle strings defined as objects or literals and saves you don\'t want to use a  helper function.Very late to the party; however, the following has always worked well for me when I want to check whether some input is either a string or a number in one shot.Created a jsperf on the checking if a variable is a number. Quite interesting! typeof actually has a performance use. Using typeof for anything other than numbers, generally goes a 1/3rd the speed as a variable.constructor since the majority of data types in javascript are Objects; numbers are not!http://jsperf.com/jemiloii-fastest-method-to-check-if-type-is-a-numbertypeof variable === \'number\'| fastest | if you want a number, such as 5, and not \'5\'\ntypeof parseFloat(variable) === \'number\'| fastest | if you want a number, such as 5, and \'5\'isNaN() is slower, but not that much slower. I had high hopes for parseInt and parseFloat, however they were horribly slower.For detecting numbers, the following passage from JavaScript: The Good Parts by Douglas Crockford is relevant:The isFinite function is the best way of determining whether a value can be used as a number because it rejects NaN and Infinity . Unfortunately, isFinite will attempt to convert its operand to a number, so it is not a good test if a value is not actually a number. You may want to define your own isNumber function:Here is how isString was implemented in AngularJS:You can also use these 2 is-string and is-number open source components to get the job done without duplicating.Examples:And: