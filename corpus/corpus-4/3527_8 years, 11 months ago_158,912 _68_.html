I ran into the problem that my primary key sequence is not in sync with my table rows. That is, when I insert a new row I get a duplicate key error because the sequence implied in the serial datatype returns a number that already exists.It seems to be caused by import/restores not maintaining the sequence properly.Source - Ruby Forumpg_get_serial_sequence can be used to avoid any incorrect assumptions about the sequence name. This resets the sequence in one shot:Or more concisely:However this form can\'t handle empty tables correctly, since max(id) is null, and neither can you setval 0 because it would be out of range of the sequence. One workaround for this is to resort to the ALTER SEQUENCE syntax i.e.But ALTER SEQUENCE is of limited use because the sequence name and restart value cannot be expressions.It seems the best all-purpose solution is to call setval with false as the 3rd parameter, allowing us to specify the "next value to use":This ticks all my boxes:Finally, note that pg_get_serial_sequence only works if the sequence is owned by the column. This will be the case if the incrementing column was defined as a serial type, however if the sequence was added manually it is necessary to ensure ALTER SEQUENCE .. OWNED BY is also performed. i.e. if serial type was used for table creation, this should all work:But if sequences were added manually:This will reset all sequences from public making no assumptions about table or column names. Tested on version 8.4ALTER SEQUENCE sequence_name RESTART WITH (SELECT max(id) FROM table_name);\nDoesn\'t work.Copied from @tardate answer:The shortest and fastest way:tbl_id being the serial column of table tbl, drawing from the sequence tbl_tbl_id_seq (which is the default automatic name).If you don\'t know the name of the attached sequence (which doesn\'t have to be in default form), use pg_get_serial_sequence():There is no off-by-one error here. Per documentation:The two-parameter form sets the sequence\'s last_value field to the\n  specified value and sets its is_called field to true, meaning that the\n  next nextval will advance the sequence before returning a value.Bold emphasis mine.Reset all sequences, no assumptions about names except that the primary key of each table is "id":This command for only change auto generated key sequence value in postgresql In place of zero you can put any number from which you want to restart sequence.default sequence name will "TableName_FieldName_seq". For example, if your table name is "MyTable" and your field name is "MyID", then your sequence name will be "MyTable_MyID_seq".This is answer is same as @murugesanponappan\'s answer, but there is a syntax error in his solution. you can not use sub query (select max()...) in alter command. So that either you have to use fixed numeric value or you need to use a variable in place of sub query.These functions are fraught with perils when sequence names, column names, table names or schema names have funny characters such as spaces, punctuation marks, and the like.  I have written this:You can call it for a single sequence by passing it the OID and it will return the highest number used by any table that has the sequence as default; or you can run it with a query like this, to reset all the sequences in your database:Using a different qual you can reset only the sequence in a certain schema, and so on.  For example, if you want to adjust sequences in the "public" schema:Note that due to how setval() works, you don\'t need to add 1 to the result.As a closing note, I have to warn that some databases seem to have defaults linking to sequences in ways that do not let the system catalogs have full information of them.  This happens when you see things like this in psql\'s \\d:Note that the nextval() call in that default clause has a ::text cast in addition to the ::regclass cast.  I think this is due to databases being pg_dump\'ed from old PostgreSQL versions.  What will happen is that the function sequence_max_value() above will ignore such a table.  To fix the problem, you can redefine the DEFAULT clause to refer to the sequence directly without the cast:Then psql displays it properly:As soon as you\'ve fixed that, the function works correctly for this table as well as all others that might use the same sequence.Reset all sequence from publicMy version use the first one, with some error checking...before I had not tried yet the code : in the following I post\nthe version for the sql-code for both Klaus and user457226 solutions\nwhich worked on my pc [Postgres 8.3], with just some little adjustements\nfor the Klaus one and of my version for the user457226 one.Klaus solution :user457226 solution :Putting it all togetherwill fix \'id\' sequence of the given table (as usually necessary with django for instance).I suggest this solution found on postgres wiki. It updates all sequences of your tables.How to use(from postgres wiki):Example:Original article(also with fix for sequence ownership) hereSome really hardcore answers here, I\'m assuming it used to be really bad at around the time when this has been asked, since a lot of answers from here don\'t works for version 9.3. The documentation since version 8.0 provides an answer to this very question:Also, if you need to take care of case-sensitive sequence names, that\'s how you do it:Recheck all sequence in public schema functionTo restart all sequence to 1 use:The Klaus answer is the most useful, execpt for a little miss : you\nhave to add DISTINCT in select statement.However, if you are sure that no table+column names can be equivalent\nfor two different tables, you can also use :which is an extension of user457226 solution for the case when\nsome interested column name is not \'ID\'.Ugly hack to fix it using some shell magic, not a great solution but might inspire others with similar problems :)If you see this error when you are loading custom SQL data for initialization, another way to avoid this is:Instead of writing:Remove the id (primary key) from initial dataThis keeps the Postgres sequence in sync !Try reindex.UPDATE: As pointed out in the comments, this was in reply to the original question.SELECT setval... makes JDBC bork, so here\'s a Java-compatible way of doing this:This answer is a copy from mauro.Yet another plpgsql - resets only if max(att) > then lastvalalso commenting the line --execute format(\'alter sequence will give the list, not actually resetting the valueI spent an hour trying to get djsnowsill\'s answer to work with a database using Mixed Case tables and columns, then finally stumbled upon the solution thanks to a comment from Manuel Darveau, but I thought I could make it a bit clearer for everyone:This has the benefit of:To explain, the problem was that pg_get_serial_sequence takes strings to work out what you\'re referring to, so if you do:This is achieved using \'\'%1$I\'\' in the format string, \'\' makes an apostrophe 1$ means first arg, and I means in quotes