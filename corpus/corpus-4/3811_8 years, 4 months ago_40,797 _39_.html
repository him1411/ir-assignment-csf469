What are the reasons behind the decision to not have a fully generic get method \nin the interface of java.util.Map<K, V>.To clarify the question, the signature of the method is V get(Object key)instead of V get(K key)and I\'m wondering why (same thing for remove, containsKey, containsValue).As mentioned by others, the reason why get(), etc. is not generic because the key of the entry you are retrieving does not have to be the same type as the object that you pass in to get(); the specification of the method only requires that they be equal. This follows from how the equals() method takes in an Object as parameter, not just the same type as the object.Although it may be commonly true that many classes have equals() defined so that its objects can only be equal to objects of its own class, there are many places in Java where this is not the case. For example, the specification for List.equals() says that two List objects are equal if they are both Lists and have the same contents, even if they are different implementations of List. So coming back to the example in this question, according to the specification of the method is possible to have a Map<ArrayList, Something> and for me to call get() with a LinkedList as argument, and it should retrieve the key which is a list with the same contents. This would not be possible if get() were generic and restricted its argument type.An awesome Java coder at Google, Kevin Bourrillion, wrote about exactly this issue in a blog post a while ago (admittedly in the context of Set instead of Map). The most relevant sentence:Uniformly, methods of the Java\n  Collections Framework (and the Google\n  Collections Library too) never\n  restrict the types of their parameters\n  except when it\'s necessary to prevent\n  the collection from getting broken.I\'m not entirely sure I agree with it as a principle - .NET seems to be fine requiring the right key type, for example - but it\'s worth following the reasoning in the blog post. (Having mentioned .NET, it\'s worth explaining that part of the reason why it\'s not a problem in .NET is that there\'s the bigger problem in .NET of more limited variance...)The contract is expressed thus:More formally, if this map contains a\n  mapping from a key k to a value v such\n  that (key==null ? k==null :\n  key.equals(k)), then this method\n  returns v; otherwise it returns null.\n  (There can be at most one such\n  mapping.)(my emphasis)and as such, a successful key lookup depends on the input key\'s implementation of the equality method. That is not necessarily dependent on the class of k.It\'s an application of Postel\'s Law, "be  conservative in what you do, be liberal in what you accept from others."Equality checks can be performed regardless of type; the equals method is defined on the Object class and accepts any Object as a parameter. So, it makes sense for key equivalence, and operations based on key equivalence, to accept any Object type.When a map returns key values, it conserves as much type information as it can, by using the type parameter.I think this section of Generics Tutorial explains the situation (my emphasis):"You need to make certain that the generic API is not unduly restrictive; it must\ncontinue to support the original contract of the API. Consider again some examples\nfrom java.util.Collection. The pre-generic API looks like:A naive attempt to generify it is:While this is certainly type safe, it doesn\xe2\x80\x99t live up to the API\xe2\x80\x99s original contract.\nThe containsAll() method works with any kind of incoming collection. It will only\nsucceed if the incoming collection really contains only instances of E, but:The reason is that containment is determined by equals and hashCode which are methods on Object and both take an Object parameter. This was an early design flaw in Java\'s standard libraries. Coupled with limitations in Java\'s type system, it forces anything that relies on equals and hashCode to take Object.The only way to have type-safe hash tables and equality in Java is to eschew Object.equals and Object.hashCode and use a generic substitute. Functional Java comes with type classes for just this purpose: Hash<A> and Equal<A>. A wrapper for HashMap<K, V> is provided that takes Hash<K> and Equal<K> in its constructor. This class\'s get and contains methods therefore take a generic argument of type K.Example:There is one more weighty reason, it can not be done technically, because it brokes Map.Java has polymorphic generic construction like <? extends SomeClass>. Marked such reference can point to type signed with <AnySubclassOfSomeClass>. But polymorphic generic makes that reference readonly. The compiler allows you to use generic types only as returning type of method (like simple getters), but blocks using of methods where generic type is argument (like ordinary setters).\nIt means if you write Map<? extends KeyType, ValueType>, the compiler does not allow you to call method get(<? extends KeyType>), and the map will be useless. The only solution is to make this method not generic: get(Object).Backwards compatibility, I guess. Map (or HashMap) still needs to support get(Object).I was looking at this and thinking why they did it this way. I don\'t think any of the existing answers explains why they couldn\'t just make the new generic interface accept only the proper type for the key. The actual reason is that even though they introduced generics they did NOT create a new interface. The Map interface is the same old non-generic Map it just serves as both generic and non-generic version. This way if you have a method that accepts non-generic Map you can pass it a Map<String, Customer> and it would still work. At the same time the contract for get accepts Object so the new interface should support this contract too.In my opinion they should have added a new interface and implemented both on existing collection but they decided in favor of compatible interfaces even if it means worse design for the get method. Note that the collections themselves would be compatible with existing methods only the interfaces wouldn\'t.Compatibility.Before generics were available, there was just get(Object o).Had they changed this method to get(<K> o) it would have potentially forced massive code maintenance onto java users just to make working code compile again.They could have introduced an additional method, say get_checked(<K> o) and deprecate the old get() method so there was a gentler transition path.  But for some reason, this was not done.  (The situation we are in now is that you need to install tools like findBugs to check for type compatibility between the get() argument and the declared key type <K> of the map.)The arguments relating to the semantics of .equals() are bogus, I think.  (Technically they\'re correct, but I still think they\'re bogus.  No designer in his right mind is ever going to make o1.equals(o2) true if o1 and o2 do not have any common superclass.)We are doing big refactoring just now and we were missing this strongly typed get() to check that we did not missed some get() with old type.But I found workaround/ugly trick for compilation time check: create Map interface with strongly typed get, containsKey, remove... and put it to java.util package of your project.You will get compilation errors just for calling get(), ... with wrong types,  everything others seems ok for compiler (at least inside eclipse kepler).Do not forget to delete this interface after check of your build as this is not what you want in runtime.