An 64-bit double can represent integer +/- 253 exactlyGiven this fact I choose to use a double type as a single type for all my types, since my largest integer is unsigned 32-bit.But now I have to print these pseudo integers, but the problem is they are also mixed in with actual doubles.So how do I print these doubles nicely in Java?I have tried String.format("%f", value), which is close, except I get a lot of trailing zeros for small values.Here\'s an example output of of %fWhat I want is:Sure I can write a function to trim those zeros, but that\'s lot of performance loss due to String manipulation.  Can I do better with another format code?EDITThe answers by Tom E. and Jeremy S. are unacceptable as they both arbitrarily rounds to 2 decimal places.  Please understand the problem before answering.EDIT 2Please note that String.format(format, args...) is locale-dependent (see answers below).If the idea is to print integers stored as doubles as if they are integers, and otherwise print the doubles with the minimum necessary precision:Produces:And does not rely on string manipulation.As pointed in the comments, this is not the right answer to the original question.\nThat said, it is a very useful way to format numbers without unnecessary trailing zeros.In short:If you want to get rid of trailing zeros and Locale problems, then you should use :Explanation:Why other answers did not suit me :Double.toString() or System.out.println or FloatingDecimal.toJavaFormatString uses scientific notations if double is less than 10^-3 or greater than or equal to 10^7by using %f, the default decimal precision is 6, otherwise you can hardcode it but it results in extra zeros added if you have less decimals. Example :by using setMaximumFractionDigits(0); or %.0f you remove any decimal precision, which is fine for integers/longs but not for doubleby using DecimalFormat, you are local dependent. In French locale, the decimal separator is a comma, not a point :Using the ENGLISH locale makes sure you get a point for decimal separator, wherever your program will runWhy using 340 then for setMaximumFractionDigits ?Two reasons :On my machine, the following function is roughly 7 times faster than the function provided by JasonD\'s answer, since it avoids String.format:Why not:This should work with the extreme values supported by Double. Yields:My 2 cents:Naw, never mind.Performance loss due to String manipulation is zero.And here\'s the code to trim the end after %fI made a DoubleFormatter to efficiently convert a great numbers of double values to a nice/presentable String:Here the code:Note: I used 2 functions from GUAVA library. If you don\'t use GUAVA, code it yourself: Please note that String.format(format, args...) is locale-dependent because it formats using the user\'s default locale, that is, probably with commas and even spaces inside like 123 456,789 or 123,456.789, which may be not exactly what you expect.You may prefer to use String.format((Locale)null, format, args...).For example,printsand this is what will String.format(format, args...) do in different countries.EDIT Ok, since there has been a discussion about formalities:This one will get the job done nicely, I know the topic is old, but I was struggling with the same issue till I came to this. I hope someone find it useful.Late answer but...You said you choose to store your numbers with the double type. I think this could be the root of the problem because it forces you to store integers into doubles (and therefore losing the initial information about the value\'s nature). What about storing your numbers in instances of the Number class (superclass of both Double and Integer) and rely on polymorphism to determine the correct format of each number ?I know it may not be acceptable to refactor a whole part of your code due to that but it could produce the desired output without extra code/casting/parsing.Example:Will produce the following output:Here is an answer that actually works (combination of different answers here)Here are two ways to achieve it. First, the shorter (and probably better) way:And here\'s the longer and probably worse way:I had to use this cause d == (long)d was giving me violation in sonar reportI know this is a really old thread.. But I think the best way to do this is as below:Output:The only issue is the last one where .0 doesn\'t get removed. But if you are able to live with that then this works best. %.2f will round it to the last 2 decimal digits. So will DecimalFormat. If you need all the decimal places but not the trailing zeros then this works best.This will make the string to drop the tailing 0-s.