Pre-Honeycomb (AndroidÂ 3), each Activity was registered to handle button clicks via the onClick tag in a Layout\'s XML:Within that method you can use view.getId() and a switch statement to do the button logic.With the introduction of Honeycomb I\'m breaking these Activities into Fragments which can be reused inside many different Activities. Most of the behavior of the buttons is Activity independent, and I would like the code to reside inside the Fragments file without using the old (pre 1.6) method of registering the OnClickListener for each button.The problem is that when my layout\'s are inflated it is still the hosting Activity that is receiving the button clicks, not the individual Fragments. Is there a good approach to eitherYou could just do this:Activity:Fragment:In response to @Ameen who wanted less coupling so Fragments are reuseableInterface:Activity:Fragment:I prefer using the following solution for handling onClick events. This works for Activity and Fragments as well.The problem I think is that the view is still the activity, not the fragment. The fragments doesn\'t have any independent view of its own and is attached to the parent activities view. Thats why the event ends up in the Activity, not the fragment. Its unfortunate, but I think you will need some code to make this work.What I\'ve been doing during conversions is simply adding a click listener that calls the old event handler.for instance:I\'ve recently solved this issue without having to add a method to the context Activity or having to implement OnClickListener. I\'m not sure if it is a "valid" solution neither, but it works.Based on: https://developer.android.com/tools/data-binding/guide.html#binding_eventsIt can be done with data bindings: Just add your fragment instance as a variable, then you can link any method with onClick.And the fragment linking code would be...ButterKnife is probably the best solution for the clutter problem. It uses annotation processors to generate the so called "old method" boilerplate code.But the onClick method can still be used, with a custom inflator.This is another way\xef\xbc\x9a1.Create a BaseFragment like this:2.Use instead of 3.In your activity:and Hope it helps.I would rather go for the click handling in code than using the onClick attribute in XML when working with fragments.This becomes even easier when migrating your activities to fragments. You can just call the click handler (previously set to android:onClick in XML) directly from each case block.When it comes to handling clicks in fragments, this looks simpler to me than android:onClick.You can define a callback as an attribute of your XML layout. The article Custom XML Attributes For Your Custom Android Widgets will show you how to do it for a custom widget. Credit goes to Kevin Dion :) I\'m investigating whether I can add styleable attributes to the base Fragment class.The basic idea is to have the same functionality that View implements when dealing with the onClick callback.In my use case, I have 50 odd ImageViews I needed to hook into a single onClick method.  My solution is to loop over the views inside the fragment and set the same onclick listener on each:Adding to Blundell\'s answer,\nIf you have more fragments, with plenty of onClicks:Activity:In Your Fragment:If you register in xml using android:Onclick="", callback will be given to the respected Activity under whose context your fragment belongs to (getActivity() ). If such method not found in the Activity, then system will throw an exception.You might want to consider using EventBus for decoupled events ..\nYou can listen for events very easily. You can also make sure the event is being received on the ui thread (instead of calling runOnUiThread.. for yourself for every event subscription)https://github.com/greenrobot/EventBusfrom Github:Android optimized event bus that simplifies communication between\n  Activities, Fragments, Threads, Services, etc. Less code, better\n  qualityAs I see answers they\'re somehow old. Recently Google introduce DataBinding which is much easier to handle onClick or assigning in your xml.Here is good example which you can see how to handle this : There is also very nice tutorial about DataBinding you can find it Here.I\'d like to add to Adjorn Linkz\'s answer.If you need multiple handlers, you could just use lambda referencesThe trick here is that handler method\'s signature matches View.OnClickListener.onClick signature. This way, you won\'t need the View.OnClickListener interface.Also, you won\'t need any switch statements.Sadly, this method is only limited to interfaces that require a single method, or a lambda.This has been working for me:(Android studio)Best solution IMHO:in fragment:then in Fragment\'s onViewStateRestored: Your Activity is receiving the callback as must have used:If you want your fragment to receive callback then do this:and implement onClickListener interface on Fragment