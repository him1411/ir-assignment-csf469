To my understanding, all of your javascript gets merged into 1 file. Rails does this by default when it adds //= require_tree . to the bottom of your application.js manifest file. This sounds like a real life-saver, but I am a little concerned about page-specific javascript code. Does this code get executed on every page? The last thing I want is for all of my objects to be instantiated for every page when they are only needed on 1 page. Also, isn\'t there potential for code that clashes too?Or do you put a small script tag at the bottom of the page that just calls into a method that executes the javascript code for the page?Do you no longer need require.js then?ThanksEDIT: I appreciate all the answers... and I don\'t think they are really getting at the problem. Some of them are about styling and don\'t seem to relate... and others just mention javascript_include_tag... which I know exists (obviously...) but it would appear that the Rails 3.1 way going forward is to wrap up all of your Javascript into 1 file rather than loading individual Javascript at the bottom of each page.The best solution I can come up with is to wrap certain features in div tags with ids or classes. In the javascript code, you just check if the id or class is on the page, and if it is, you run the javascript code that is associated with it. This way if the dynamic element is not on the page, the javascript code doesn\'t run - even though it\'s been included in the massive application.js file packaged by Sprockets.My above solution has the benefit that if a search box is included on 8 of the 100 pages, it will run on only those 8 pages. You also won\'t have to include the same code on 8 of the pages on the site. In fact, you\'ll never have to include manual script tags on your site anywhere ever again.I think this is the actual answer to my question.The Asset Pipeline docs suggest how to do controller-specific JS:For example, if a ProjectsController is generated, there will be a new file at app/assets/javascripts/projects.js.coffee and another at app/assets/stylesheets/projects.css.scss. You should put any JavaScript or CSS unique to a controller inside their respective asset files, as these files can then be loaded just for these controllers with lines such as <%= javascript_include_tag params[:controller] %> or <%= stylesheet_link_tag params[:controller] %>.Link to: asset_pipelineFor the page-specific js you can use Garber-Irish solution.So your Rails javascripts folder might look like this for two controllers - cars and users:And javascripts will look like this:and markup_based_js_execution will contain code for UTIL object, and on DOM-ready UTIL.init execution.And don\'t forget to put this to your layout file:I also think that it is better to use classes instead of data-* attributes, for the better page-specific css. As Jason Garber have mentioned: page-specific CSS selectors can get really awkward (when you use data-*attributes)I hope this will help you.I see that you\'ve answered your own question, but here\'s another option:Basically, you\'re making the assumption that is required. It\'s not. Feel free to remove it. In my current application, the first I\'m doing with 3.1.x honestly, I\'ve made three different top level JS files. My application.js file only has This way, I can create subdirectories, with their own top level JS files, that only include what I need.The keys are:Hope that helps and adds some details to ClosureCowboy\'s answer.SujalAnother option: to create page- or model-specific files, you could create directories inside your assets/javascripts/ folder.Your main application.js manifest file could be configured to load its files from global/. Specific pages or groups of pages could have their own manifests which load files from their own specific directories. Sprockets will automatically combine the files loaded by application.js with your page-specific files, which allows this solution to work.  This technique can be used for style_sheets/ as well.I appreciate all the answers... and I don\'t think they are really getting at the problem. Some of them are about styling and don\'t seem to relate... and others just mention javascript_include_tag... which I know exists (obviously...) but it would appear that the Rails 3.1 way going forward is to wrap up all of your Javascript into 1 file rather than loading individual Javascript at the bottom of each page.The best solution I can come up with is to wrap certain features in div tags with ids or classes. In the javascript code. Then you just check if the id or class is on the page, and if it is, you run the javascript code that is associated with it. This way if the dynamic element is not on the page, the javascript code doesn\'t run - even though it\'s been included in the massive application.js file packaged by Sprockets.My above solution has the benefit that if a search box is included on 8 of the 100 pages, it will run on only those 8 pages. You also won\'t have to include the same code on 8 of the pages on the site. In fact, you\'ll never have to include manual script tags on your site anywhere ever again - except to maybe preload data.I think this is the actual answer to my question.I realize I\'m coming to this party a bit late, but I wanted to throw in a solution that I\'ve been using lately.  However, let me first mention...The Rails 3.1/3.2 Way (No, sir.  I don\'t like it.)See: http://guides.rubyonrails.org/asset_pipeline.html#how-to-use-the-asset-pipelineI\'m including the following for the sake of completeness in this answer, and because it\'s not an unviable solution... though I don\'t care much for it.The "Rails Way" is a controller-oriented solution, rather than being view-oriented as the original author of this question requested.  There are controller-specific JS files named after their respective controllers.  All of these files are placed in a folder tree that is NOT included by default in any of the application.js require directives.To include controller-specific code, the following is added to a view.I loathe this solution, but it\'s there and it\'s quick.  Presumably, you could instead call these files something like "people-index.js" and "people-show.js" and then use something like "#{params[:controller]}-index" to get a view-oriented solution.  Again, quick fix, but it doesn\'t sit well with me.My Data Attribute WayCall me crazy, but I want ALL of my JS compiled and minified into application.js when I deploy.  I don\'t want to have to remember to include these little straggler files all over the place.I load all of my JS in one compact, soon-to-be browser cached, file.  If a certain piece of my application.js needs to be fired on a page, I let the HTML tell me, not Rails.Rather than locking my JS to specific element IDs or littering my HTML with marker classes, I use a custom data attribute called data-jstags.On each page, I use - insert preferred JS library method here - to run code when the DOM has finished loading.  This bootstrapping code performs the following actions:So say I have the following defined somewhere in my application.js:The bootstrapping event is going to apply the my_autosuggest_init and my_hint_init functions against the search input, turning it into an input that displays a list of suggestions while the user types, as well as providing some kind of input hint when the input is left blank and unfocused.Unless some element is tagged with data-jstag="auto-suggest", the auto-suggest code never fires.  However, it\'s always there, minified and eventually cached in my application.js for those times that I need it on a page.If you need to pass additional parameters to your tagged JS functions, you\'ll have to apply some creativity.  Either add data-paramter attributes, come up with some kind of parameter syntax, or even use a hybrid approach.Even if I have some complicated workflow that seems controller-specific, I will just create a file for it in my lib folder, pack it into application.js, and tag it with something like \'new-thing-wizard\'.  When my bootstrap hits that tag, my nice, fancy wizard will be instantiated and run.  It runs for that controller\'s view(s) when needed, but is not otherwise coupled to the controller.  In fact, if I code my wizard right, I might be able to provide all configuration data in the views and therefore be able to re-use my wizard later for any other controller that needs it.Anyway, this is how I\'ve been implementing page specific JS for a while now, and it has served me well both for simple site designs and for more complex/rich applications.  Hopefully one of the two solutions I\'ve presented here, my way or the Rails way, is helpful to anyone who comes across this question in the future.This has been answered and accepted long ago, but I came up with my own solution based on some of these answers and my experience with Rails 3+.The asset pipeline is sweet. Use it.First, in your application.js file, remove //= require_tree.Then in your application_controller.rb create a helper method:Then in your application.html.erb layout file, add your new helper among the existing javascript includes, prefixed with the raw helper:Voila, now you can easily create view-specific javascript using the same file structure you use everywhere else in rails. Simply stick your files in app/assets/:namespace/:controller/action.js.erb!Hope that helps someone else!You can add this line in your layout file (e.g. application.html.erb) to automatically load the controller specific javascript file (the one that was created when you generated the controller):You also could add a line to automatically load a script file in a per-action basis.Just put your page scripts into a subdirectoriy named after the controller name. In these files you could include other scripts using =require.\nIt would be nice to create a helper to include the file only if it exists, to avoid a 404 fail in the browser.Maybe you will find pluggable_js gem as suitable solution.The LoadJS gem is another option:LoadJS provides a way to load page-specific Javascript code in a Rails app without loosing the magic provided by Sprockets. All your Javascript code will continue by minified in one Javascript file but some portions of it will only be executed for certain pages.https://github.com/guidomb/loadjsPhilip\'s answer is quite good. Here is the code to make it work:In application.html.erb:\n<body class="<%=params[:controller].parameterize%>">\nAssuming your controller is called Projects, that will generate:\n<body class="projects">\nThen in projects.js.coffee:JavaScripts are only merged when you tell Rails (Sprockets, rather) to merge them.This is how i solved the styling issue: (excuse the Haml)This way i start all the page specific .css.sass files with:This way you can easily avoid any clashes.\nWhen it comes to .js.coffee files you could just initialize elements like;Hope this helped some.You can also group the js in folders and continue to use the asset pipeline to load your javascript selectively depending on the page. I agree with your answer, to check if that selector is there, use:(didn\'t see anyone add the actual solution)I don\'t see an answer that really puts it all together and lays it out for you.  Thus, I\'ll try to put meleyal, sujal (a la ClosureCowboy), the first part of Ryan\'s answer, and even Gal\'s bold statement about Backbone.js... all together in a way that is short and clear.  And, who knows, I might even meet Marnen Laibow-Koser\'s requirements.assets/javascripts/application.js\nviews/layouts/application.html.erb\nviews/foo/index.html.erb\nassets/javascripts/foo.js\nassets/javascripts/foostuff/foothis.js.coffeeRemove //= require_tree . from application.js and list only the JS that each page shares.The two lines shown above in application.html.erb tell the page where to include application.js and your page-specific JS.The three lines shown above in index.html.erb tells your view to look for some page-specific JS and include it at a named yield region called ":javascript" (or whatever you want to name it).  In this example, the controller is "foo" so Rails will attempt to include "foo.js" at the :javascript yield region in the application layout.List your page-specific JS in foo.js (or whatever the controller is named).  List common libraries, a tree, directories, whatever.Keep your custom page-specific JS someplace where you can easily reference it apart from your other custom JS.  In this example, foo.js requires the foostuff tree so put your custom JS there, such as foothis.js.coffee.There are no hard rules here.  Feel free to move things around and perhaps even create multiple yield regions of various names in various layouts if needed.  This just shows one possible first step forward.  (I don\'t do it exactly like this given our use of Backbone.js.  I might also choose to drop foo.js down into a folder called foo instead of foostuff but haven\'t decided that yet.)You can do similar things with CSS and <%= stylesheet_link_tag params[:controller] %> but this is beyond scope of the question.If I missed a glaring best practice here, send me a note and I\'ll conisder adapting.  Rails is fairly new to me and, honestly, I\'m not terribly impressed so far with the chaos it brings by default to enterprise development and all the traffic the average Rails program generates.I have another solution, which although primitive works fine for me and doesn\'t need any fancy selective loading strategies.  Put in your nornal document ready function, but then test the current windows location to see if it is the page your javascript is intended for:This still allows all the js to be loaded by rails 3.x in one small package, but does not generate much overhead or any conflicts with pages for which the js isn\'t intended.  ryguy\'s answer is a good answer, even though its been downvoted into negative points land.Especially if you\'re using something like Backbone JS - each page has its own Backbone view. Then the erb file just has a single line of inline javascript that fires up the right backbone view class. I consider it a single line of \'glue code\' and therefore the fact that its inline is OK. The advantage is that you can keep your "require_tree" which lets the browser cache all the javascript. in show.html.erb, you\'ll have something like:and in your layout file, you\'ll need:Move all your commom JS files to a sub-folder like \'app/assets/javascript/global\' then in the application.js, modify the //= require_tree . line to //= require_tree ./global.Now you are free to put your controller-specific JS on the \'app/assets/javascript/\' root and they will not be included in compiled JS, being used just when you call them via = javascript_include_tag on your controller/view.Though you have several answers here, I think your edit is probably the best bet. A design pattern that we use in our team that we got from Gitlab is the Dispatcher pattern. It does something similar to what you\'re talking about, however the page name is set in the body tag by rails. For example, in your layout file, just include something like (in HAML):Then only have one closure and a switch statement in your dispatcher.js.coffee file in your javascripts folder like so:All you need to do in the individual files (say products.js.coffee or login.js.coffee for example) is enclose them in a class and then globalize that class symbol so you can access it in the dispatcher:Gitlab has several examples of this that you might want to poke around with in case you\'re curious :)Paloma project offers interesting approach to manage page specific javascript code.Usage example from their docs:Step1. remove require_tree . in your application.js and application.css.Step2. Edit your application.html.erb(by rails default) in layout folder. Add "params[:controller]" in the following tags.Step3. Add a file in config/initializers/assets.rbreferences:\nhttp://theflyingdeveloper.com/controller-specific-assets-with-rails-4/I haven\'t tried this out, but it looks like the following is true:if you have a content_for that is javascript (e.g. with real javascript within it), sprockets would not know about it and thus this would work the same way as it does now.if you want to exclude a file from the big bundle of javascript, you would go into config/sprockets.yml file and modify the source_files accordingly.  Then, you would just include any of the files that you excluded where needed.I did it previously using this method: http://theflyingdeveloper.com/controller-specific-assets-with-rails-4/ . Super-easy, relies on controllers to select the proper js to load. I combined some answers into:Application helper:layouts/application.html.haml:Following the lead from Ryan, here\'s what I have done-application.js.coffeeusers.js.coffee (controller specific coffeescript,e.g controller:users, action:dashboard)application.html.hamlHere\'s how to do it especially if you don\'t have to execute tons of libraries for your specific page, but only to run a few hundreds lines of JS more or less.Since it\'s perfectly fine to embed Javascript code into HTML, just create under app/views shared.js directory and place there your page/pages specific code inside my_cool_partial.html.erbSo now from wherever you want you simply do:And that\'s it, k?