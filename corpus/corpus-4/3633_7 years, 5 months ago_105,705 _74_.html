I\'ve thought of some less than elegant ways to solve this, but I know I must be missing something.My onItemSelected fires off immediately without any interaction with the user, and this is undesired behavior.  I wish for the UI to wait until the user selects something before it does anything.I even tried setting up the listener in the onResume(), hoping that would help, but it doesn\'t.How can I stop this from firing off before the user can touch the control?I would have expected your solution to work -- I though the selection event would not fire if you set the adapter before setting up the listener.That being said, a simple boolean flag would allow you to detect the rogue first selection event and ignore it.The use of Runnables is completely incorrect. Use setSelection(position, false); in the initial selection before setOnItemSelectedListener(listener) This way you set your selection with no animation which causes the on item selected listener to be called. But the listener is null so nothing is run. Then your listener is assigned. So follow this exact sequence: Referring to the answer of Dan Dyer, try to register the OnSelectListener in a post(Runnable) method:By doing that for me the wished behavior finally occurred.In this case it also means that the listener only fires on a changed item.I created a small utility method for changing Spinner selection without notifying the user:It disables the listener, changes the selection, and re-enables the listener after that.The trick is that calls are asynchronous to the UI thread, so you have to do it in consecutive handler posts.I was in similar situation, and I have a simple solution working for me.It seems like methods setSelection(int position) and setSelected(int position, boolean animate) have different internal implementation.When you use the second method setSelected(int position, boolean animate) with false animate flag, you get the selection without firing onItemSelected listener.Unfortunately it seems that the two most commonly suggested solutions to this issue, namely counting callback occurrences and posting a Runnable to set the callback at a later time can both fail when for example accessibility options are enabled. Here\'s a helper class that works around these issues. Further explenation is in the comment block.I have had LOTS of issues with the spinner firing of when I didn\'t want to, and all the answers here are unreliable. They work - but only sometimes. You will eventually run into scenarios where they will fail and introduce bugs into your code. What worked for me was to store the last selected index in a variable and evaluate it in the listener. If it is the same as the new selected index do nothing and return, else continue with the listener. Do this:Trust me when I say this, this is by far the most reliable solution. A hack, but it works!Just to flesh out hints at using the onTouchListener to distinguish between automatic calls to the setOnItemSelectedListener (which are part of Activity initialization, etc.) vs. calls to it triggered by actual user interaction, I did the following after trying some other suggestions here and found that it worked well with the fewest lines of code.Just set an Boolean field for your Activity/Fragment like:Then just before you set your spinner\'s setOnItemSelectedListener, set an onTouchListener:After pulling my hair out for a long time now I\'ve created my own Spinner class. I\'ve added a method to it which disconnects and connects the listener appropriately.Use it in your XML like this:All you have to do is retrieve the instance of SaneSpinner after inflation and call set selection like this: With this, no event is fired and user interaction is not interrupted. This reduced my code complexity a lot. This should be included in stock Android since it really is a PITA.No unwanted events from the layout phase if you defer adding the listener till the layout is finished:I got a very simple answer , 100% sure it works:I\'ve found much more elegant solution to this. It involves counting how many times the ArrayAdapter (in your case "adapter")has been invoked. Let\'s say you have 1 spinner and you call:Declare an int counter after the onCreate and then inside onItemSelected() method put an "if" condition to check how many times the atapter has been called. In your case you have it called just once so:This will happen if you are making selection in code as;Instead of above statement use Edit: This method doesn\'t work for Mi Android Version Mi UI.My small contribution is a variation on some of the above that has suited me a few times.Declare an integer variable as a default value (or last used value saved in preferences).\nUse spinner.setSelection(myDefault) to set that value before the listener is registered.\nIn the\xc2\xa0onItemSelected check whether the new spinner value equals the value you assigned before running any further code.This has the added advantage of not running code if the user selects the same value again.After having had the same problem, I came to this solutions using tags.\nThe idea behind it is simple: Whenever the spinner is changed programatically, make sure the tag reflects the selected position. In the listener then you check if the selected position equals the tag. If it does, the spinner selection was changed programatically.Below is my new "spinner proxy" class: You will also need an XML file with the tag setup in your Values directory.\nI named my file spinner_tag.xml, but that\'s up to you.\nIt looks like this:Now replacein your code withAnd make your handler somewhat look like this:The function isUiTriggered() will return true if and only if the spinner has been changed by the user. Note that this function has a side effect - it will set the tag, so a second call in the same listener call will always return false.This wrapper will also handle the problem with the listener being called during layout creation.Have fun,\nJens.Since nothing worked for me, and I have more than 1 spinner in my view (and IMHO holding a bool map is an overkill) I use the tag to count the clicks :I would try to callafter you call setAdapter(). Also try out calling before the adapter.You always have the solution to go with subclassing, where you can wrap a boolean flag to your overriden setAdapter method to skip the event.The solution with a boolean flag or a counter didn\'t help me, \'cause during orientation change onItemSelected() calls "overflew" the flag or the counter.I subclassed android.widget.Spinner and made tiny additions. The relevant parts are below. This solution worked for me.This is not an elegant solution either.  In fact it\'s rather Rube-Goldberg but it seems to work.  I make sure the spinner has been used at least once by extending the array adapter and overriding its getDropDownView.  In the new getDropDownView method I have a boolean flag that is set to show the dropdown menu has been used at least once.  I ignore calls to the listener until the flag is set.MainActivity.onCreate():overriden array adapter:modified listener:if you need to recreate activity on the fly eg: changing themes , a simple flag/counter wont workuse onUserInteraction() function to detect user activity,reference : https://stackoverflow.com/a/25070696/4772917I have done with simplest way:onCreate();DoneDesign a spinner for common use, just data input and get user\'s choosen, advantages :\n1. Keep spinner style the same for app.\n2. Start spinner anywhere.\n3. Easy to handle linked spinner(start ReuseSpinner again with different data).\nMy demo example : ReuseSpinner\n\npass data to ReuseSpinner :get user\'s choosen :That\'s my final and easy to use solution :Use the default setSelection(...) for default behaviour or use setSelectionWithoutInformListener(...) for selecting an item in the spinner without triggering OnItemSelectedListener callback.I need to use mSpinner in ViewHolder, so the flag mOldPosition is set in the anonymous inner class.I would store the initial index during creation of the onClickListener object.My solution uses onTouchListener but doesn\'t restricts from its use. It creates a wrapper for onTouchListener if necessary where setup onItemSelectedListener.Not a prefect solution but if your happy with having the starting string as just a place holder you can add place holder spring value ("Day_of_Work_Out")