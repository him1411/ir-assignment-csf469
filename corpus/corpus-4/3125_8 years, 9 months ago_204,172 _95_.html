I have two websites, let\'s say they\'re example.com and anotherexample.net.\nOn anotherexample.net/page.html, I have an IFRAME SRC="http://example.com/someform.asp". That IFRAME displays a form for the user to fill out and submit to http://example.com/process.asp. When I open the form ("someform.asp") in its own browser window, all works well.\nHowever, when I load someform.asp as an IFRAME in IE 6 or IE 7, the cookies for example.com are not saved. In Firefox this problem doesn\'t appear.For testing purposes, I\'ve created a similar setup on http://newmoon.wz.cz/test/page.php .example.com uses cookie-based sessions (and there\'s nothing I can do about that), so without cookies, process.asp won\'t execute. How do I force IE to save those cookies?Results of sniffing the HTTP traffic: on GET /someform.asp response, there\'s a valid per-session Set-Cookie header (e.g. Set-Cookie: ASPKSJIUIUGF=JKHJUHVGFYTTYFY), but on POST /process.asp request, there is no Cookie header at all.Edit3: some AJAX+serverside scripting is apparently capable to sidestep the problem, but that looks very much like a bug, plus it opens a whole new set of security holes. I don\'t want my applications to use a combination of bug+security hole just because it\'s easy.Edit: the P3P policy was the root cause, full explanation below.I got it to work, but the solution is a bit complex, so bear with me.As it is, Internet Explorer gives lower level of trust to IFRAME pages (IE calls this "third-party" content). If the page inside the IFRAME doesn\'t have a Privacy Policy, its cookies are blocked (which is indicated by the eye icon in status bar, when you click on it, it shows you a list of blocked URLs).the evil eye http://stuff.piskvor.org/cookies_blocked_MSIE_eye.pngIn this case, when cookies are blocked, session identifier is not sent, and the target script throws a \'session not found\' error.(I\'ve tried setting the session identifier into the form and loading it from POST variables. This would have worked, but for political reasons I couldn\'t do that.)It is possible to make the page inside the IFRAME more trusted: if the inner page sends a P3P header with a privacy policy that is acceptable to IE, the cookies will be accepted. A good starting point is the W3C tutorial. I\'ve gone through it, downloaded the IBM Privacy Policy Editor and there I created a representation of the privacy policy and gave it a name to reference it by (here it was policy1). NOTE: at this point, you actually need to find out if your site has a privacy policy, and if not, create it - whether it collects user data, what kind of data, what it does with it, who has access to it, etc. You need to find this information and think about it. Just slapping together a few tags will not cut it. This step cannot be done purely in software, and may be highly political (e.g. "should we sell our click statistics?").(e.g. "the site is operated by ACME Ltd., it uses anonymous per-session identifiers for its operation, collects user data only if explicitly permitted and only for the following purposes, the data is stored only as long as necessary, only our company has access to it, etc. etc."). (When editing with this tool, it\'s possible to view errors/omissions in the policy. Also very useful is the tab "HTML Policy": at the bottom, it has a "Policy Evaluation" - a quick check if the policy will be blocked by IE\'s default settings)The Editor exports to a .p3p file, which is an XML representation of the above policy. Also, it can export a "compact version" of this policy.Then a Policy Reference file (http://example.com/w3c/p3p.xml) was needed (an index of privacy policies the site uses):The <INCLUDE> shows all URIs that will use this policy (in my case, the whole site). The policy file I\'ve exported from the Editor was uploaded to http://example.com/w3c/example-com.p3p I\'ve set the webserver at example.com to send the compact header with responses, like this:policyref is a relative URI to the Policy Reference file (which in turn references the privacy policies), CP is the compact policy representation. Note that the combination of P3P headers in the example may not be applicable on your specific website; your P3P headers MUST truthfully represent your own privacy policy!In this configuration, the Evil Eye does not appear, the cookies are saved even in the IFRAME, and the application works.Several people have suggested "just slap some tags into your P3P header, until the Evil Eye gives up".The tags are not only a bunch of bits, they have real world meanings, and their use gives you real world responsibilities! For example, pretending that you never collect user data might make the browser happy, but if you actually collect user data, the P3P is conflicting with reality. Plain and simple, you are purposefully lying to your users, and that might be criminal behavior in some countries. As in, "go to jail, do not collect $200".A few examples (see p3pwriter for the full set of tags):I\'m not a lawyer, but I\'m not willing to go to court to see if the P3P header is really legally binding or if you can promise your users anything without actually willing to honor your promises.I\'ve spend a large part of my day looking into this P3P thing and I feel the need to share what I\'ve found out.I\'ve noticed that the P3P concept is very outdated and seems only to be really used/enforced by Internet Explorer (IE).The simplest explanation is: IE wants you to define a P3P header if you are using cookies.This is a nice idea, and luckily most of the time not providing this header won\'t cause any issues (read browser warnings). Unless your website/web application is loaded into an other website using an (i)Frame. This is where IE becomes a massive pain in the ***. It will not allow you to set a cookie unless the P3P header is set. Knowing this I wanted to find an answer to the following two questions:My findings are:The concept was born in 2002 and it baffles me that this outdated and legally unimplemented concept is still forced upon developers within IE.\nIf this header doesn\'t have have any legal ramifications this header should be ignored (or alternatively, generate a warning or notification in the console). Not enforced! I\'m now forced to put a line in my code (and send a header to the client) that does absolutely nothing.In short - to keep IE happy - add the following line to your PHP code (Other languages should look similar)Problem solved, and IE is happy with this potato.I was able to make the evil eye go away by simply adding this small header to the site in the IFrame (PHP solution):Remember to press ctrl+F5 to reload your site or Explorer may still show the evil eye, despite the fact that it\'s working fine. This is probably the main reason why I had so many problems getting it to work.No policy file was neccesary at all.Edit:\nI found a nice blog entry that explains the problem with cookies in IFrames. It also has a quick fix in C# code:\nFrames, ASPX Pages and Rejected CookiesI had this issue as well, thought I\'d post the code that I used in my MVC2 project. Be careful when in the page life cycle you add in the header or you\'ll get an HttpException "Server cannot append header after HTTP headers have been sent." I used a custom ActionFilterAttribute on the OnActionExecuting method (called before the action is executed).Example use:This is buried in the comments of other answers, but I almost missed it, so it seems like it deserves its own answer.To review: in order for IE to accept 3rd party cookies, you need serve your files with an http header called p3p in the format:BUT, p3p is pretty much dead as a standard at this point and you can easily get IE to work without investing the time and legal resources in creating a real p3p policy.  This is because if your compact p3p policy header is invalid, IE actually treats it as a good policy and accepts 3rd party cookies.  So you can use a p3p header such as thisYou can optionally include a link to a page that explains why you don\'t have a p3p policy, as Google and Facebook do (they point here: https://support.google.com/accounts/answer/151657 and  here: https://www.facebook.com/help/327993273962160/).Finally, it\'s important to note that all files served from the 3rd party site need to have the p3p header, not just the one that sets the cookie, so you may not be able to just do this in your PHP, asp.net, etc code.  You are probably better off setting in up on the web server level (i.e. in IIS or Apache).This is a great topic on the issue, however I found that one important detail (which was essential at least in my case) that was not posted here or anywhere else (I apologize if I just missed it) was that the P3P line must be passed in header of EVERY file sent from the 3rd party server, even files not setting or using the cookies such as Javascript files or images. Otherwise the cookies will be blocked. I have more on this in a post here: http://posheika.net/?p=110One possible thing to do is to add the domain to allowed sites in tools -> internet options -> privacy -> sites: somedomain.com -> allow -> OK.Anyone having this problem in node.js.Then add this p3p module, and enable this module at middleware.I am using express so I add it in app.jsFirst require that module in app.jsthen use it as middlewareIt will add p3p headers at res object. No need to do any extra things.You will get more info at:https://github.com/troygoode/node-p3pIf anybody is looking for Apache line; we used this one. Header set P3P "CP=\\"Thanks IE8\\""It really didn\'t matter what we set CP value to, as long as there is the P3P header.This post provides some commentary on P3P and a short-cut solution that reduces the problems with IE7 and IE8.One solution that I haven\'t seen mentioned here, is using session storage instead of cookies.\nOf course this might not fit everyone\'s requirements, but for some cases it\'s an easy fix.Got similar problem, also went to investigate how to generate the P3P policy this morning, here is my post about how to generate your own policy and use in the web site :)\nhttp://everydayopenslikeaflower.blogspot.com/2009/08/how-to-create-p3p-policy-and-implement.html I\'ve implemented a full P3P policy before but didn\'t want go through the hassle again for a new project I was working on. I found this link useful for a simple solution to the problem, only having to specify a minimal compact P3P policy of "CAO PSA OUR": http://blog.sweetxml.org/2007/10/minimal-p3p-compact-policy-suggestion.htmlThe article quotes a (now broken) link to a Microsoft kb article. The policy did the trick for me!You can also combine the p3p.xml and policy.xml files as such:/home/ubuntu/sites/shared/w3c/p3p.xmlI found the easiest way to add a header is proxy through Apache and use mod_headers, as such:So we proxy all requests except those to /w3c/p3p.xml to our application server.You can test it all with the W3C validatorIf you own the domain that needs to be embedded, then you could, before calling the page that includes the IFrame, redirect to that domain, which will create the cookie and redirect back,\nas explained here: http://www.mendoweb.be/blog/internet-explorer-safari-third-party-cookie-problem/This will work for Internet Explorer but for Safari as well (because Safari also blocks the third-party cookies).I know it\'s a bit late to put my contribution on this subject but I lost so many hours that maybe this answer will help somebody.I was trying to call a third party cookie on my site and of course it was not working on Internet Explorer 10, even at a low security level... don\'t ask me why. In the iframe I was calling a read_cookie.php (echo $_COOKIE) with ajax.And I don\'t know why I was incapable of setting the P3P policy to solve the problem...During my search I saw something about getting the cookie in JSON working. I don\'t even try because I thought that if the cookie won\'t pass through an iframe, it will not pass any more through an array...Guess what, it does! So if you json_encode your cookie then decode after your ajax request, you\'ll get it!Maybe there is something I missed and if I did, all my apologies, but i never saw something so stupid. Block third party cookies for security, why not, but let it pass if encoded? Where is the security now?I hope this post will help somebody and again, if I missed something and I\'m dumb, please educate me!This finally worked for me (after a lot of hastle and generating some policies using IBMs policy generator). You can downlod the policy generator here: http://www.softpedia.com/get/Security/Security-Related/P3P-Policy-Editor.shtmlI was not able to download the generator from the official IBM website any more.I created these files in the root folder of my Web-AppI was investigating this problem with regard to login-off via Azure Access Control Services, and wasn\'t able to connect head and tails of anything.Then, stumbled over this post https://blogs.msdn.microsoft.com/ieinternals/2011/03/10/beware-cookie-sharing-in-cross-zone-scenarios/ In short, IE doesn\'t share cookies across zones (eg. Internet vs. Trusted sites).So, if your IFrame target and html page are in different zone\'s P3P won\'t help with anything.In Rails I am using this gem : https://github.com/merchii/rack-iframe\nBawically it sets a set of abbreviations without a reference file: https://github.com/merchii/rack-iframe/blob/master/lib/rack/iframe.rb#L8It is easy to install when you dont care at all about the meaning of the p3p stuff.It is only possible if you are able to send custom server-side response headers with the static content.For a more detailed explanation see my answer here: Set P3P code in HTMLIn Rails 3.2 I am using:I got this from: http://dot-net-web-developer-bristol.blogspot.com/2012/04/setting-p3p-header-in-rails-session.htmlA better solution would be to make an Ajax call inside the iframe to the page that would get/set cookies...