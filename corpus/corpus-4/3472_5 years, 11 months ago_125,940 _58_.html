I am new to Android. I want to know what the Looper class does and also how to use it. I have read the Android Looper class documentation but I am unable to completely understand it.\nI have seen it in a lot of places but unable to understand its purpose. Can anyone help me by defining the purpose of Looper and also by giving a simple example if possible?What is Looper?Looper is a class which is used to execute the Messages(Runnables) in a queue. Normal threads have no such queue, e.g. simple thread does not have any queue. It executes once and after method execution finishes, the thread will not run another Message(Runnable).Where we can use Looper class?If someone wants to execute multiple messages(Runnables) then he should use the Looper class which is responsible for creating a queue in the thread.\nFor example, while writing an application that downloads files from the internet, we can use Looper class to put files to be downloaded in the queue.How it works?There is prepare() method to prepare the Looper. Then you can use loop() method to create a message loop in the current thread and now your Looper is ready to execute the requests in the queue until you quit the loop.Here is the code by which you can prepare the Looper.You can better understand what Looper is in the context of GUI framework. Looper is made to do 2 things.1) Looper transforms a normal thread, which terminates when its run() method return, into something run continuously until Android app is running, which is needed in GUI framework (Technically, it still terminates when run() method return. But let me clarify what I mean in below).2) Looper provides a queue where jobs to be done are enqueued, which is also needed in GUI framework.As you may know, when an application is launched, the system creates a thread of execution for the application, called \xe2\x80\x9cmain\xe2\x80\x9d, and Android applications normally run entirely on a single thread by default the \xe2\x80\x9cmain thread\xe2\x80\x9d. But main thread is not some secret, special thread. It\'s just a normal thread similar to threads you create with new Thread() code, which means it terminates when its run() method return! Think of below example. Now, let\'s apply this simple principle to Android app. What would happen if an Android app runs on normal thread? A thread called "main" or "UI" or whatever starts your application, and draws all UI. So, the first screen is displayed to users. So what now? The main thread terminates? No, it shouldn\xe2\x80\x99t. It should wait until users do something, right? But how can we achieve this behavior? Well, we can try with Object.wait() or Thread.sleep(). For example, main thread finishes its initial job to display first screen, and sleeps. It awakes, which means interrupted, when a new job to do is fetched. So far so good, but at this moment we need a queue-like data structure to hold multiple jobs. Think about a case when a user touches screen serially, and a task takes longer time to finish. So, we need to have a data structure to hold jobs to be done in first-in-first-out manner. Also, you may imagine, implementing ever-running-and-process-job-when-arrived thread using interrupt is not easy, and leads to complex and often unmaintainable code. We\'d rather create a new mechanism for such purpose, and that is what Looper is all about. The official document of Looper class says, "Threads by default do not have a message loop associated with them", and Looper is a class "used to run a message loop for a thread". Now you can understand what it means. To make things more clear, let\'s check the code where main thread is transformed. It all happens in ActivityThread class. In its main() method, you can find below code, which turns a normal main thread into something what we need.and Looper.loop() method loop infinitely and dequeue a message and process one at a time:So, basically Looper is a class that is made to address a problem that occurs in GUI framework. But this kind of needs also can happen in other situation as well. Actually it is a pretty famous pattern for multi threads application, and you can learn more about it in "Concurrent Programming in Java" by Doug Lea(Especially, chapter 4.1.4 "Worker Threads" would be helpful). Also, you can imagine this kind of mechanism is not unique in Android framework, but all GUI framework may need somewhat similar to this. You can find almost same mechanism in Java Swing framework.Looper allows tasks to be executed sequentially on a single thread. And handler defines those tasks that we need to be executed. It is a typical scenario that I am trying to illustrate in this example:Now we can use the handler in some other threads(say ui thread) to post the task on Looper to execute.On UI thread we have an implicit Looper that allow us to handle the messages on ui thread.Android Looper is a wrapper to attach MessageQueue to Threads and it manages Queue processing. It looks very cryptic in Android documentation and many times we may face Looper related UI access issues. If we don\'t understand the basics it becomes very tough to handle. Here is an Article which explains Looper life cycle, how to use it and usage of Looper in Handler-\nhttp://prasanta-paul.blogspot.kr/2013/09/android-looper-and-toast-from.html\nHope it helps.Looper is a class that turns a thread into a Pipeline Thread and Handler gives you a mechanism to push tasks into it from any other threads. So a PipeLine Thread is a thread which can accept more tasks from other threads through a Handler.The Looper is named so because it implements the loop \xe2\x80\x93 takes the next task, executes it, then takes the next one and so on. The Handler is called a handler because it is used to handle or accept that next task each time from any other thread and pass to Looper (Thread or PipeLine Thread).A Looper and Handler or PipeLine Thread\'s very perfect example is to download more than one images or upload them to a server (Http) one by one in a single thread instead of starting a new Thread for each network call in the background.Read more here about Looper and Handler and the definition of Pipeline Thread:Android Guts: Intro to Loopers and HandlersA Looper has a synchronized MessageQueue that\'s used to process Messages placed on the queue.It implements a Thread Specific Storage Pattern.Only one Looper per Thread. Key methods include prepare(),loop() and quit().prepare() initializes the current Thread as a Looper. prepare() is static method that uses the ThreadLocal class as shown below.Looper can be programmed in a Thread via several stepsExtend ThreadCall Looper.prepare() to initialize Thread as a LooperCreate one or more Handler(s) to process the incoming messagesHandling multiple down or upload items in a Service is a better example.Handlers and AsnycTasks are often used to propagate events/Messages between the UI (thread) and a worker thread or to delay actions. So they are more related  to the UI.More specific a Looper handles tasks (runnables, futures) in a thread related queue in the background - even with no user interaction or a displayed UI (app downloads a file in the background during a call).Life span of java Thread is over after completion of run() method. Same thread can\'t be started again. Looper transforms normal Thread into a message loop. Key methods of Looper are :Initialize the current thread as a looper. This gives you a chance to create handlers that then reference this looper, before actually starting the loop. Be sure to call loop() after calling this method, and end it by calling quit().Run the message queue in this thread. Be sure to call quit() to end the loop.Quits the looper.Causes the loop() method to terminate without processing any more messages in the message queue.This mindorks article by Janishar explains the core concepts in nice way.Looper is associated with a Thread. If you need Looper on UI thread, Looper.getMainLooper() will return associated thread. You need Looper to be associated with a Handler.Looper, Handler, and HandlerThread are the Android\xe2\x80\x99s way of solving the problems of asynchronous programming.Once you have Handler, you can call below APIs.Causes the Runnable r to be added to the message queue. The runnable will be run on the thread to which this handler is attached.Pushes a message onto the end of the message queue after all pending messages before the current time. It will be received in handleMessage(Message), in the thread attached to this handler.HandlerThread is handy class for starting a new thread that has a looper. The looper can then be used to create handler classesIn some scenarios, you can\'t run Runnable tasks on UI Thread. \ne.g. Network operations : Send message on a socket, open an URL and get content by reading InputStreamIn these cases, HandlerThread is useful. You can get Looper object from HandlerThread and create a Handler on HandlerThread instead of main thread.The HandlerThread code will be like this:Refer to below post for example code:Android: Toast in a thread