This question already has an answer here:I was trying to generate a new tag with class name test in the <h2> by clicking the button. I also defined a click event associated with test. But the event doesn\'t work.Can anyone help?The click() binding you\'re using is called a "direct" binding which will only attach the handler to elements that already exist. It won\'t get bound to elements created in the future. To do that, you\'ll have to create a "delegated" binding by using on(). Delegated events have the advantage that they can process events from descendant elements that are added to the document at a later time.SourceHere\'s what you\'re looking for:The above works for those using jQuery version 1.7+. If you\'re using an older version, refer to the previous answer below.Previous Answer:Try using live():Worked for me. Tried it with jsFiddle.Or there\'s a new-fangled way of doing it with delegate():An updated jsFiddle.Use the .on() method with delegated eventsThe .on() method allows you to delegate any desired event handler to:\n current elements or  future elements added to the DOM at a later time.P.S: Don\'t use .live()! From jQuery 1.7+ the .live() method is deprecated.Reason: The Click()-binding attaches the event handler only if the element already exist in the html code.It won\'t consider the new element which is created dynamically(Future element) after the page loaded.Dynamic elements are created with the help of javascript or jquery(not in html). So the click event doesn\'t fire.  Solution :To overcome this we should use on()  function. delegate(),live() and on() functions have the advantages over the DOM elements.on can trigger both existing elements as well as future elements.on can consider the elements which are all present in the whole page.delegate(),live() functions are deprecated(Don\'t use these).You should use on function to trigger the event on dynamically created (future) elements.Remove the code from $(document).ready:Change into:Change To jQuery .live()You need to use .live for this to work:or if you\'re using jquery 1.7+ use .on:Try .live() or .delegate()http://api.jquery.com/live/http://api.jquery.com/delegate/Your .test element was added after the .click() method, so it didn\'t have the event attached to it. Live and Delegate give that event trigger to parent elements which check their children, so anything added afterwards still works. I think Live will check the entire document body, while Delegate can be given to an element, so Delegate is more efficient.More info:http://www.alfajango.com/blog/the-difference-between-jquerys-bind-live-and-delegate/Add this function in your js file.\n   It will work on every browserI found two solutions at the jQuery\'s documentation:First: Use delegate on Body or DocumentE.g:     Why?Answer: Attach a handler to one or more events for all elements that match the selector, now or in the future, based on a specific set of root elements.\nlink: http://api.jquery.com/delegate/Second: Put the your function at the "$( document )", using "on" and attach it to the element that you want to trigger this.\nThe first parameter is the "event handler", the second: the element and the third: the function. \nE.g:       Why?Answer:  Event handlers are bound only to the currently selected elements; they must exist on the page at the time your code makes the call to .on(). To ensure the elements are present and can be selected, perform event binding inside a document ready handler for elements that are in the HTML markup on the page. If new HTML is being injected into the page, select the elements and attach event handlers after the new HTML is placed into the page. Or, use delegated events to attach an event handler, as described next ...\nlink: https://api.jquery.com/on/Best way to apply event on dynamically generated content by using delegation.so your code is like this nowThe problem you have is that you\'re attempting to bind the "test" class to the event before there is anything with a "test" class in the DOM. Although it may seem like this is all dynamic, what is really happening is JQuery makes a pass over the DOM and wires up the click event when the ready() function fired, which happens before you created the "Click Me" in your button event. By adding the "test" Click event to the "button" click handler it will wire it up after the correct element exists in the DOM.Using live() (as others have pointed out) is another way to do this but I felt it was also a good idea to point out the minor error in your JS code. What you wrote wasn\'t wrong, it just needed to be correctly scoped. Grasping how the DOM and JS works is one of the tricky things for many traditional developers to wrap their head around. live() is a cleaner way to handle this and in most cases is the correct way to go. It essentially is watching the DOM and re-wiring things whenever the elements within it change. .live function works great.It is for Dynamically added elements to the stage.Cheers,\nAnkit.The Jquery .on works ok but I had some problems with the rendering implementing some of the solutions above. My problem using the .on is that somehow it was rendering the events differently than the .hover method.Just fyi for anyone else that may also have the problem. I solved my problem by re-registering the hover event for the dynamically added item:re-register the hover event because hover doesn\'t work for dynamically created items.\nso every time i create the new/dynamic item i add the hover code again. works perfectlyI couldn\'t get live or delegate to work on a div in a lightbox (tinybox).I used setTimeout successfullly, in the following simple way:Also you can use onclick="do_something(this)"inside element\nAn alternate and more succinct alternative (IMHO) is to use a raw javascript function that responds to an on click event, then pass the target element back to jQuery if you like. The advantage of this approach is that you can dynamically add your element anywhere, and the click handler will \'just work\', and you need not concern yourself with delegating control to parent elements, and so on.  \n\n Step 1:  Update the dynamic html to fire an onclick event. Be sure to pass the \'event\' object as an argument\n\n Step 2:  Create the test function to respond to the click event \n\n Optional Step 3:  Given you are using jQuery I\'m assuming it will be useful to get a reference back to the source button \nI\'m working with tables adding new elements dynamically to them, and when using on(), the only way of making it works for me is using a non-dynamic parent as:This is really useful because, to remove events bound with on(), you can use off(), and to use events once, you can use one().Will only work if the DIV with the class .surrounding_div_class is the immediate parent to the object .testIf there is another object in the div that will be filled it wont work.You CAN add on click to dynamically created elements.  Example below.  Using a When to make sure its done.  In my example, i\'m grabbing a div with the class expand, adding a "click to see more" span, then using that span to hide/show the original div.If you have a dinamically added link to some container or the body:you can take its raw javascript element and add an event listener to it, like the click:No matter how many times you add this new link instance you can use it as if you where using a jquery click function.So you will receive a message saying Its okIt has better performance than other alternatives. Extra: You could gain better performance avoiding jquery and using plain javascript. If you are using IE up to version 8 you should use this polyfill to use the method addEventListenerUse \'on\' as click gets bind to the elements already present.For e.gThis will help.