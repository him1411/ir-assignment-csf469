I\'m trying to set the Content-Type header of an HttpClient object as required by an API I am calling.I tried setting the Content-Type like below:It allows me to add the Accept header but when I try to add Content-Type it throws the following exception:Misused header name. Make sure request headers are used with\n  HttpRequestMessage, response headers with HttpResponseMessage, and\n  content headers with HttpContent objects.How can I set the Content-Type header in a HttpClient request?The content type is a header of the content, not of the request, which is why this is failing. AddWithoutValidation as suggested by Robert Levy may work, but you can also use set the content type when creating the request content itself (note that code snippet adds "application/json" in two places-for Accept and Content-Type headers):For those who didn\'t see Johns comment to carlos solution ...If you don\'t mind a small library dependency, Flurl.Http [disclosure: I\'m the author] makes this uber-simple. Its PostJsonAsync method takes care of both serializing the content and setting the content-type header, and ReceiveJson deserializes the response. If the accept header is required you\'ll need to set that yourself, but Flurl provides a pretty clean way to do that too:Flurl uses HttpClient and Json.NET under the hood, and it\'s a PCL so it\'ll work on a variety of platforms.try to use TryAddWithoutValidation Call AddWithoutValidation instead of Add (see this MSDN link).Alternatively, I\'m guessing the API you are using really only requires this for POST or PUT requests (not ordinary GET requests).  In that case, when you call HttpClient.PostAsync and pass in an HttpContent, set this on the Headers property of that HttpContent object..Net tries to force you to obey certain standards, namely that the Content-Type header can only be specified on requests that have content (e.g. POST, PUT, etc.).  Therefore, as others have indicated, the preferred way to set the Content-Type header is through the HttpContent.Headers.ContentType property.With that said, certain APIs (such as the LiquidFiles Api, as of 2016-12-19) requires setting the Content-Type header for a GET request.  .Net will not allow setting this header on the request itself -- even using TryAddWithoutValidation.  Furthermore, you cannot specify a Content for the request -- even if it is of zero-length.  The only way I could seem to get around this was to resort to reflection.  The code (in case some else needs it) is Edit:As noted in the comments, this field has different names in different versions of the dll.  In the source code on GitHub, the field is currently named s_invalidHeaders.  The example has been modified to account for this per the suggestion of @David Thompson.Some extra information about .NET Core (after reading erdomke\'s post about setting a private field to supply the content-type on a request that doesn\'t have content)...After debugging my code, I can\'t see the private field to set via reflection - so I thought I\'d try to recreate the problem.I have tried the following code using .Net 4.6:  And, as expected, I get an aggregate exception with the content "Cannot send a content-body with this verb-type." However, if i do the same thing with .NET Core (1.1) - I don\'t get an exception. My request was quite happily answered by my server application, and the content-type was picked up.I was pleasantly surprised about that, and I hope it helps someone!