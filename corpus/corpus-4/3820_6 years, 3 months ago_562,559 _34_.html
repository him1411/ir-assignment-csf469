I have this bash script and I had a problem in line 16.\nHow can I take the previous result of line 15 and add\nit to the variable in line 16?For integers:Use arithmetic expansion: $((EXPR))Using the external expr utility. Note that this is only needed for really old systems.For floating point:Bash doesn\'t directly support this, but there\'s a couple of external tools you can use:You can also use scientific notation (e.g.: 2.5e+2)Common pitfalls:When setting a variable, you cannot have whitespace on either side of =, otherwise it will force the shell to interpret the first word as the name of the application to run (eg: num= or num)num= 1 num =2bc and expr expect each number and operator as a separate argument, so whitespace is important. They cannot process arguments like 3+ +4.num=`expr $num1+ $num2`Use the $(( )) arithmetic expansion.See http://tldp.org/LDP/abs/html/arithexp.html for more information.There are a thousand and one ways to do it. Here\'s one using dc:But if that\'s too bash-y for you (or portability matters) you could sayBut maybe you\'re one of those people who thinks RPN is icky and weird; don\'t worry! bc is here for you:That said, there are a some unrelated improvements you could be making to your scriptEDIT:As described in BASH FAQ 022, bash does not natively support floating point numbers. If you need to sum floating point numbers the use of an external tool (like bc or dc) is required.In this case the solution would beTo add accumulate possibly-floating-point numbers into num.In bash,Note that bash can only handle integer arithmetic, so if your awk command returns a fraction, then you\'ll want to redesign: here\'s your code rewritten a bit to do all math in awk.I really like this method as well, less clutter:I always forget the syntax so I come to google, but then I never find the one I\'m familiar with :P. This is the cleanest to me and more true to what I\'d expect in other languages.You should declare metab as integer and then use arithmetic evaluationFor more information see https://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html#Shell-ArithmeticAnother portable POSIX compliant way to do in bash, which can be defined as a function in .bashrc for all the arithmetic operators of convenience.and just call it in command-line as,The idea is to use the Input-Field-Separator(IFS), a special variable in bash used for word splitting after expansion and to split lines into words. The function changes the value locally to use word-splitting character as the sum operator +.Remember the IFS is changed locally and does NOT take effect on the default IFS behaviour outside the function scope. An excerpt from the man bash page,The shell treats each character of IFS as a delimiter, and splits the results of the other expansions into words on these characters. If IFS is unset, or its value is exactly , the default, then sequences of , , and  at the beginning and end of the results of the previous expansions are ignored, and any sequence of IFS characters not at the beginning or end serves to delimit words. The "$(( $* ))" represents the list of arguments passed to be split by + and later the sum value is output using the printf function. The function can be extended to add scope for other arithmetic operations also.