Does anyone have a regular expression handy that will match any legal DNS hostname or IP address?It\'s easy to write one that works 95% of the time, but I\'m hoping to get something that\'s well tested to exactly match the latest RFC specs for DNS hostnames.You can use the following regular expressions separately or by combining them in a joint OR expression.ValidIpAddressRegex matches valid IP addresses and ValidHostnameRegex valid host names. Depending on the language you use \\ could have to be escaped with \\.ValidHostnameRegex is valid as per RFC 1123. Originally, RFC 952 specified that hostname segments could not start with a digit.http://en.wikipedia.org/wiki/HostnameThe original specification of\n  hostnames in RFC\n  952,\n  mandated that labels could not start\n  with a digit or with a hyphen, and\n  must not end with a hyphen. However, a\n  subsequent specification (RFC\n  1123)\n  permitted hostname labels to start\n  with digits.The hostname regex of smink does not observe the limitation on the length of individual labels within a hostname. Each label within a valid hostname may be no more than 63 octets long.Note that the backslash at the end of the first line (above) is Unix shell syntax for splitting the long line. It\'s not a part of the regular expression itself.Here\'s just the regular expression alone on a single line:You should also check separately that the total length of the hostname must not exceed 255 characters. For more information, please consult RFC-952 and RFC-1123.To match a valid IP address use the following regex:instead of:Many regex engine match the first possibility in the OR sequence. For instance, try the following regex: Test the difference between good vs badI don\'t seem to be able to edit the top post, so I\'ll add my answer here.For hostname - easy answer, on egrep example here -- http: //www.linuxinsight.com/how_to_grep_for_ip_addresses_using_the_gnu_egrep_utility.htmlThough the case doesn\'t account for values like 0 in the fist octet, and values greater than 254 (ip addres) or 255 (netmask). Maybe an additional if statement would help.As for legal dns hostname, provided that you are checking for internet hostnames only (and not intranet), I wrote the following snipped, a mix of shell/php but it should be applicable as any regular expression.first go to ietf website, download and parse a list of legal level 1 domain names:That should give you a nice piece of re code that checks for legality of top domain name, like .com .org or .caThen add first part of the expression according to guidelines found here -- http: //www.domainit.com/support/faq.mhtml?category=Domain_FAQ&question=9 (any alphanumeric combination and \'-\' symbol, dash should not be in the beginning or end of an octet.Then put it all together (PHP preg_match example):You may also want to add an if statement to check that string that you checking is shorter than 256 characters -- http://www.ops.ietf.org/lists/namedroppers/namedroppers.2003/msg00964.htmlI think this is the best Ip validation regex. please check it once!!!  localhost \xd0\xb6\xd0\xb5 \xd0\xb5\xd1\x81\xd1\x82\xd1\x8ctry this:it works in my case.Here is a regex that I used in Ant to obtain a proxy host IP or hostname out of ANT_OPTS. This was used to obtain the proxy IP so that I could run an Ant "isreachable" test before configuring a proxy for a forked JVM. I found this works pretty well for IP addresses. It validates like the top answer but it also makes sure the ip is isolated so no text or more numbers/decimals are after or before the ip. (?<!\\S)(?:(?:\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\b|.\\b){7}(?!\\S)this re are used only for for this type validationwork only if\nhttp://www.kk.com\nhttp://www.kk.co.innot works forhttp://www.kk.com/\nhttp://www.kk.co.in.kkhttp://www.kk.com/dfas\nhttp://www.kk.co.in/This works for valid IP addresses:Regarding IP addresses, it appears that there is some debate on whether to include leading zeros.  It was once the common practice and is generally accepted, so I would argue that they should be flagged as valid regardless of the current preference.  There is also some ambiguity over whether text before and after the string should be validated and, again, I think it should.  1.2.3.4 is a valid IP but 1.2.3.4.5 is not and neither the 1.2.3.4 portion nor the 2.3.4.5 portion should result in a match.  Some of the concerns can be handled with this expression:The unfortunate part here is the fact that the regex portion that validates an octet is repeated as is true in many offered solutions.  Although this is better than for instances of the pattern, the repetition can be eliminated entirely if subroutines are supported in the regex being used.  The next example enables those functions with the -P switch of grep and also takes advantage of lookahead and lookbehind functionality. (The function name I selected is \'o\' for octet.  I could have used \'octet\' as the name but wanted to be terse.)The handling of the dot might actually create a false negatives if IP addresses are in a file with text in the form of sentences since the a period could follow without it being part of the dotted notation.  A variant of the above would fix that:how about this?on php: filter_var(gethostbyname($dns), FILTER_VALIDATE_IP) == true ? \'ip\' : \'not ip\'Check ipv4 solution here. Seems there is no need in ipv6 nowadays.Checking for host names like... mywebsite.co.in, thangaraj.name, 18thangaraj.in, thangaraj106.in etc.,I thought about this simple regex matching pattern for IP address matching\n\\d+[.]\\d+[.]\\d+[.]\\d+