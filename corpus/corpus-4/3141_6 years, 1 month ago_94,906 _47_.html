I know it is used to make arguments a real array, but I don\'t understand what happens when using Array.prototype.slice.call(arguments)What happens under the hood is that when .slice() is called normally, this is an Array, and then it just iterates over that Array, and does its work.How is this in the .slice() function an Array? Because when you do:...the object automatically becomes the value of this in the method(). So with:...the [1,2,3] Array is set as the value of this in .slice().But what if you could substitute something else as the this value? As long as whatever you substitute has a numeric .length property, and a bunch of properties that are numeric indices, it should work. This type of object is often called an array-like object.The .call() and .apply() methods let you manually set the value of this in a function. So if we set the value of this in .slice() to an array-like object, .slice() will just assume it\'s working with an Array, and will do its thing.Take this plain object as an example.This is obviously not an Array, but if you can set it as the this value of .slice(), then it will just work, because it looks enough like an Array for .slice() to work properly.Example: http://jsfiddle.net/wSvkv/As you can see in the console, the result is what we expect:So this is what happens when you set an arguments object as the this value of .slice(). Because arguments has a .length property and a bunch of numeric indices, .slice() just goes about its work as if it were working on a real Array.The arguments object is not actually an instance of an Array, and does not have any of the Array methods. So, arguments.slice(...) will not work because the arguments object does not have the slice method.Arrays do have this method, and because the arguments object is very similar to an array, the two are compatible. This means that we can use array methods with the arguments object. And since array methods were built with arrays in mind, they will return arrays rather than other argument objects.So why use Array.prototype? The Array is the object which we create new arrays from (new Array()), and these new arrays are passed methods and properties, like slice. These methods are stored in the [Class].prototype object. So, for efficiency sake, instead of accessing the slice method by (new Array()).slice.call() or [].slice.call(), we just get it straight from the prototype. This is so we don\'t have to initialise a new array.But why do we have to do this in the first place? Well, as you said, it converts an arguments object into an Array instance. The reason why we use slice, however, is more of a "hack" than anything. The slice method will take a, you guessed it, slice of an array and return that slice as a new array. Passing no arguments to it (besides the arguments object as its context) causes the slice method to take a complete chunk of the passed "array" (in this case, the arguments object) and return it as a new array.Normally, callingwill copy the array a into b. However, we can\'t dobecause arguments isn\'t a real array, and doesn\'t have slice as a method. Array.prototype.slice is the slice function for arrays, and call runs the function with this set to arguments.Its because, as MDN notesThe arguments object is not an array. It is similar to an array, but\n  does not have any array properties except length. For example, it does\n  not have the pop method. However it can be converted to a real array:Here we are calling slice on the native object Array and not on its implementation and thats why the extra .prototypeFirst, you should read how function invocation works in JavaScript. I suspect that alone is enough to answer your question. But here\'s a summary of what is happening:Array.prototype.slice extracts the slice method from Array\'s prototype. But calling it directly won\'t work, as it\'s a method (not a function) and therefore requires a context (a calling object, this), otherwise it would throw Uncaught TypeError: Array.prototype.slice called on null or undefined.The call() method allows you to specify a method\'s context, basically making these two calls equivalent:Except the former requires the slice method to exist in someObject\'s prototype chain (as it does for Array), whereas the latter allows the context (someObject) to be manually passed to the method.Also, the latter is short for:Which is the same as:Dont forget, that a low-level basics of this behaviour is the type-casting that integrated in JS-engine entirely.Slice just takes object (thanks to existing arguments.length property) and returns array-object casted after doing all operations on that.The same logics you can test if you try to treat String-method with an INT-value:And that explains statement above.It uses the slice method arrays have and calls it with its this being the arguments object. This means it calls it as if you did arguments.slice() assuming arguments had such a method.Creating a slice without any arguments will simply take all elements - so it simply copies the elements from arguments to an array.Let\'s assume you have: function.apply(thisArg, argArray )The apply method invokes a function, passing in the object that will be bound to this\n  and an optional array of arguments.The slice() method selects a part of an array, and returns the new array.So when you call Array.prototype.slice.apply(arguments, [0]) the array slice method is invoked (bind) on arguments.Maybe a bit late, but the answer to all of this mess is that call() is used in JS for inheritance.\nIf we compare this to Python or PHP, for example, call is used respectively as super().init() or parent::_construct().This is an example of its usage that clarifies all:Reference: https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritancewhen .slice() is called normally, this is an Array, and then it just iterates over that Array, and does its work.Array.prototype.slice.call(arguments) is the old-fashioned way to convert an arguments into an array.In ECMAScript 2015, you can use Array.from or the spread operator:I\'m just writing this to remind myself...Or just use this handy function $A to turn most things into an array.example usage...