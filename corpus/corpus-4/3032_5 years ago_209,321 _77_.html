I am using ng-view to include AngularJS partial views, and I want to update the page title and h1 header tags based on the included view. These are out of scope of the partial view controllers though, and so I can\'t figure out how to bind them to data set in the controllers.If it was ASP.NET MVC you could use @ViewBag to do this, but I don\'t know the equivalent in AngularJS. I\'ve searched about shared services, events etc but still can\'t get it working. Any way to modify my example so it works would be much appreciated. My HTML:My JavaScript:You could define controller at the <html> level.You create service: Page and modify from controllers.Inject Page and Call \'Page.setTitle()\' from controllers.Here is the concrete example:  http://plnkr.co/edit/0e7T6lI just discovered a nice way to set your page title if you\'re using routing:JavaScript:HTML:Edit: using the ng-bind attribute instead of curlies {{}} so they don\'t show on loadNote that you can also set the title directly with javascript, i.e.,This does not have data binding, but it suffices when putting ng-app in the <html> tag is problematic. (For example, using JSP templates where <head> is defined in exactly one place, yet you have more than one app.)Declaring ng-app on the html element provides root scope for both the head and body.Therefore in your controller inject $rootScope and set a header property on this:and in your page:The module angularjs-viewhead shows a mechanism to set the title on a per-view basis using only a custom directive.It can either be applied to an existing view element whose content is already the view title:...or it can be used as a standalone element, in which case the element will be invisible in the rendered document and will only be used to set the view title:The content of this directive is made available in the root scope as viewTitle, so it can be used on the title element just like any other variable:It can also be used in any other spot that can "see" the root scope. For example:This solution allows the title to be set via the same mechanism that is used to control the rest of the presentation: AngularJS templates. This avoids the need to clutter controllers with this presentational logic. The controller needs to make available any data that will be used to inform the title, but the template makes the final determination on how to present it, and can use expression interpolation and filters to bind to scope data as normal.(Disclaimer: I am the author of this module, but I\'m referencing it here only in the hope that it will help someone else to solve this problem.)Here is an adapted solution that works for me which doesn\'t require injection of $rootScope into controllers for setting resource specific page titles.In the master template:In the routing config:And in the run block:Finally in the controller:jkoreska\'s solution is perfect if you know the titles before hand, but you may need to set the title based on data you get from a resource etc.My solution requires a single service. Since the rootScope is the base of all DOM elements, we don\'t need to put a controller on the html element like someone mentionedA clean way that allow dynamically setting title or meta description. In example I use ui-router but you can use ngRoute in same way.HTML:Alternatively, if you are using ui-router:index.htmlRoutingIf you don\'t have control over title element (like asp.net web form) here is some thing you can useHere is another approach that hasn\'t been mentioned by the others here  (as of this writing).You can use custom events like so:This approach has the advantage of not requiring extra services to be written and then injected into every controller that needs to set the title, and also doesn\'t (ab)use the $rootScope. It also allows you to set a dynamic title (as in the code example), which is not possible using custom data attributes on the router\'s config object (as far as I know at least).None of these answers seemed intuitive enough, so I created a small directive to do this. This way allows you to declare the title in the page, where one would normally do it, and allows it to be dynamic as well.You\'ll need to of course change the module name to match yours.To use it, just throw this in your view, much as you would do for a regular <title> tag:You can also just include plain text if you don\'t need it to by dynamic:Alternatively, you can use an attribute, to make it more IE-friendly:You can put whatever text you want in the tag of course, including Angular code. In this example, it will look for $scope.titleText in whichever controller the custom-title tag is currently in. Just make sure you don\'t have multiple page-title tags on your page, or they\'ll clobber each other.Plunker example here http://plnkr.co/edit/nK63te7BSbCxLeZ2ADHV. You\'ll have to download the zip and run it locally in order to see the title change.Here\'s a different way to do title changes. Maybe not as scalable as a factory function (which could conceivably handle unlimited pages) but it was easier for me to understand:In my index.html I started like this:Then I made a partial called "nav.html":Then I went back to "index.html" and added the nav.html using ng-include and the ng-view for my partials:Notice that ng-cloak? It doesn\'t have anything to do with this answer but it hides the page until it\'s done loading, a nice touch :) Learn how here: Angularjs - ng-cloak/ng-show elements blinkHere\'s the basic module.  I put it in a file called "app.js":If you look toward the end of the module, you\'ll see that I have a critter-detail page based on :id.  It\'s a partial that is used from the Crispy Critters page.  [Corny, I know - maybe it\'s a site that celebrates all kinds of chicken nuggets ;)  Anyway, you could update the title when a user clicks on any link, so in my main Crispy Critters page that leads to the critter-detail page, that\'s where the $root.title update would go, just like you saw in the nav.html above:Sorry so windy but I prefer a post that gives enough detail to get it up and running.  Note that the example page in the AngularJS docs is out of date and shows a 0.9 version of ng-bind-template.  You can see that it\'s not that much different.Afterthought: you know this but it\'s here for anyone else; at the bottom of the index.html, one must include the app.js with the module:For scenarios that you don\'t have an ngApp that contains the title tag, just inject a service to controllers that need to set the window title.Working example...\nhttp://jsfiddle.net/8m379/1/Simple and dirty way using $rootScope:In your controllers, when you have the data necessary to create the title, do:When I had to solve this, I couldn\'t place the ng-app on the page\'s html tag, so I solved it with a service:While others may have better methods, I was able to use $rootScope in my controllers, as each of my views/templates has a distinct controller. You will need to inject the $rootScope in each controller. While this may not be ideal, it is functioning for me, so I thought I should pass it along. If you inspect the page, it adds the ng-binding to the title tag.Example Controller:Example Index.html header:You can also set the pageTitle and pageDescription to dynamic values, such as returning data from a REST call:Again, others may have better ideas on how to approach this, but since I am using a pre-rendering, my needs are being met.Thanks to tosh shimayama for his solution.\nI thought it was not so clean to put a service straight into the $scope, so here\'s my slight variation on that:  http://plnkr.co/edit/QJbuZZnZEDOBcYrJXWWsThe controller (that in original answer seemed to me a little bit too dumb) creates an ActionBar object, and this one is stuffed into $scope.\nThe object is responsible for actually querying the service. It also hides from the $scope the call to set the template URL, which instead is available to other controllers to set the URL.Mr Hash had the best answer so far, but the solution below makes it ideal (for me) by adding the following benefits:In the router:In the run block:Simplistic solution for angular-ui-router :HTML :App.js > myApp.config blockApp.js>myApp.run The better and dynamic solution I have found is to use $watch to trace the variable changes and then update the title.