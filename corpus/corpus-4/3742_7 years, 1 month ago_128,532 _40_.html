Good links are appreciated.http://en.wikipedia.org/wiki/C%2B%2B11#Rvalue_references_and_move_constructors\nhttp://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html#Move_SemanticsIt\'s a new C++ way to avoid copies. For example, using a move constructor, a std::vector could just copy its internal pointer to data to the new object, leaving the moved object in an incorrect state, avoiding to copy all data. This would be C++-valid.Try googling for move semantics, rvalue, perfect forwarding.You can use move when you need to "transfer" the content of an object somewhere else, without doing a copy (e.g the content is not duplicated, that\'s why it could be use on some non-copyable objects, like an unique_ptr). It\'s also possible for an object to take the content of a temporary object without doing a copy (and save a lot of time), with std::move.This link really helped me out : http://thbecker.net/articles/rvalue_references/section_01.htmlI\'m sorry if my answer is coming to late, but I was also looking for a good link for the std::move, and I found the links above a little bit "austere". This put the emphasis on r-value reference, in which context you should use them, and I think it\'s more detailed, that\'s why I wanted to share this link here.While std::move()  "looks like" a function - I would say it isn\'t really a function. It\'s sort of a converter between ways the compiler considers an expression\'s value.The first thing to note is that std::move() doesn\'t actually move anything.If you\'ve ever watched the animation series Bleach - it does the equivalent of Quincy Seele Schneider\'s  Reishi softening (see also its use in this scene).Seriously, though, it converts an expression from being an lvalue or pure rvalue (such as a variable you might be using for a long time yet, or a temporary you\'re passing around for a while, respectively) to being an xvalue. An xvalue tells the compiler:You can plunder me, move anything I\'m holding and use it elsewhere (since I\'m going to be destroyed soon anyway)".in other words, when you use std::move(x), you\'re allowing yourself (or the compiler) to cannibalize x. So if x has, say, its own buffer in memory - after std::move()ing you can use that buffer for whatever else you like.Another way to ask this question is "What would I use/cannibalize an object\'s resources for?" well, if you\'re writing application code, you would probably not be messing around a lot with temporary objects created by the compiler. So mainly you would do this in places like constructors, operator methods, STL-algorithm-like functions etc. where objects get created and destroyed automagically alot. Of course, that\'s just a rule of thumb.A typical use is \'moving\' resources from one object to another instead of copying.  @Guillaume links to this page which has a straightforward short example: swapping two objects with less copying.using move allows you to swap the resources instead of copying them around:Think of what happens when T is, say, vector<int> of size n. In the first version you read and write 3*n elements, in the second version you basically read and write just the 3 pointers to the vectors\' buffers. Of course, class T needs to know how to do the moving; you should have a move-assignment operator and a move-constructor for class T for this to work.std::move itself doesn\'t really do much. I thought that it called the moved constructor for an object, but it really just performs a type cast (casting an lvalue variable to an rvalue so that the said variable can be passed as an argument to a move constructor or assignment operator).So std::move is just used as a precursor to using move semantics. Move semantics is essentially an efficient way for dealing with temporary objects.Consider Object A = B + C + D + E + F;This is nice looking code, but E + F produces a temporary object. Then D + temp produces another temporary object and so on. In each normal "+" operator of a class, deep copies occur.For exampleThe creation of the temporary object in this function is useless - these temporary objects will be deleted at the end of the line anyway as they go out of scope.We can rather use move semantics to "plunder" the temporary objects and do something likeThis avoid needless deep copies being made. With reference to the example, the only part where deep copying occurs is now E + F. The rest uses move semantics. The move constructor or assignment operator also needs to be implemented to assign the result to A.1.) What is it? std::move() is a function from the C++ Standard Library for casting to a rvalue reference. Simplisticly std::move(t) is equivalent to:An rvalue is a temporary that does not persist beyond the expression that defines it, such as a intermediate function result which is never stored in a variable.An implementation for std::move() is given in N2027: "A Brief Introduction to Rvalue References" as follows:As you can see, std::move returns T&& no matter if called with a value (T), reference type (T&) or rvalue reference (T&&).2.) What does it do? As a cast, it does not do anything during runtime. It is only relevant at compile time to tell the compiler that you would like to continue considering the reference as an rvalue.What it does not do:3.) When should it be used? You should use std::move if you want to call functions which support move semantics with an argument which is not an rvalue (temporary expression).This begs the following follow-up questions for me:What are move semantics? Move semantics in contrast to copy semantics is a programming technique in which the members of a object are initialized by \'taking over\' instead of copying another object\'s members. Such \'take over\' makes only sense with pointers and resource handles, which can be cheaply transferred by copying the pointer or integer handle rather than the underlying data.What kind of classes and objects support move semantics? It is up to you as a developer to implement move semantics in your own classes if these would benefit from transferring their members instead of copying them. Once you implement move semantics, you will directly benefit from work from many library programmers who have added support for handling classes with move semantics efficiently.Why can\'t the compiler figure it out on its own? The compiler cannot just call another overload of a function unless you say so. You must help the compiler choose whether the regular or move version of function should be called.In which situations would I want to tell the compiler that it should treat a variable as an rvalue? This will most likely happen in template or library functions, where you know that an intermediate result could be salvaged.