Say you have a linked list structure in Java.  It\'s made up of Nodes:and each Node points to the next node, except for the last Node, which has null for next.  Say there is a possibility that the list can contain a loop - i.e. the final Node, instead of having a null, has a reference to one of the nodes in the list which came before it.What\'s the best way of writingwhich would return true if the given Node is the first of a list with a loop, and false otherwise?  How could you write so that it takes a constant amount of space and a reasonable amount of time?Here\'s a picture of what a list with a loop looks like:You can make use of Floyd\'s cycle-finding algorithm, also known as tortoise and hare algorithm.\n The idea is to have two references to the list and move them at different speeds. Move one forward by 1 node and the other by 2 nodes. Java function implementing the algorithm:Here\'s a refinement of the Fast/Slow solution, which correctly handles odd length lists and improves clarity.An alternative solution to the Turtle and Rabbit, not quite as nice, as I temporarily change the list:The idea is to walk the list, and reverse it as you go. Then, when you first reach a node that has already been visited, its next pointer will point "backwards", causing the iteration to proceed towards first again, where it terminates.Test code:Better than Floyd\'s algorithmRichard Brent described an alternative cycle detection algorithm, which is pretty much like the hare and the tortoise [Floyd\'s cycle] except that, the slow node here doesn\'t move, but is later "teleported" to the position of the fast node at fixed intervals. The description is available here : http://www.siafoo.net/algorithm/11\nBrent claims that his algorithm is 24 to 36 % faster than the Floyd\'s cycle algorithm. \nO(n) time complexity, O(1) space complexity.Tortoise and hareTake a look at Pollard\'s rho algorithm.  It\'s not quite the same problem, but maybe you\'ll understand the logic from it, and apply it for linked lists.(if you\'re lazy, you can just check out cycle detection -- check the part about the tortoise and hare.)This only requires linear time, and 2 extra pointers.In Java:(Most of the solution do not check for both next and next.next for nulls.  Also, since the turtle is always behind, you don\'t have to check it for null -- the hare did that already.)The user unicornaddict has a nice algorithm above, but unfortunately it contains a bug for non-loopy lists of odd length >= 3. The problem is that fast can get "stuck" just before the end of the list, slow catches up to it, and a loop is (wrongly) detected.Here\'s the corrected algorithm.The following may not be the best method--it is O(n^2).  However, it should serve to get the job done (eventually).AlgorithmComplexityYou can also look the Nivasch\'s algorithm here: Nivasch\'s algorithm.Or you can check Gabriel Nivasch\'s personal homepage at The stack algorithm for cycle detection which also contains a C implementation of the algorithm.Forgive me my ignorance (I\'m still fairly new to Java and programming), but why wouldn\'t the above work? I guess this doesn\'t solve the constant space issue... but it does at least get there in a reasonable time, correct? It will only take the space of the linked list plus the space of a set with n elements (where n is the number of elements in the linked list, or the number of elements until it reaches a loop). And for time, worst-case analysis, I think, would suggest O(nlog(n)). SortedSet look-ups for contains() are log(n) (check the javadoc, but I\'m pretty sure TreeSet\'s underlying structure is TreeMap, whose in turn is a red-black tree), and in the worst case (no loops, or loop at very end), it will have to do n look-ups.If we\'re allowed to embed the class Node, I would solve the problem as I\'ve implemented it below. hasLoop() runs in O(n) time, and takes only the space of counter. Does this seem like an appropriate solution? Or is there a way to do it without embedding Node? (Obviously, in a real implementation there would be more methods, like RemoveNode(Node n), etc.)You could even do it in constant O(1) time (although it would not be very fast or efficient): There is a limited amount of nodes your computer\'s memory can hold, say N records. If you traverse more than N records, then you have a loop.I cannot see any way of making this take a fixed amount of time or space, both will increase with the size of the list.I would make use of an IdentityHashMap (given that there is not yet an IdentityHashSet) and store each Node into the map.  Before a node is stored you would call containsKey on it.  If the Node already exists you have a cycle.ItentityHashMap uses == instead of .equals so that you are checking where the object is in memory rather than if it has the same contents.i think it can be done in one of the simplest way by O(n) complexity.as you traverse the list starting from head, create a sorted list of adresses. when you insert a new adress, just check it is already there in the sorted list. the sorting is of O(logN) complexity only :-)I might be terribly late and new to handle this thread. But still..Why cant the address of the node and the "next" node pointed be stored in a tableIf we could tabulate this wayHence there is a cycle formed.Here is my runnable code. What I have done is to reveres the linked list by using three temporary nodes (space complexity O(1)) that keep track of the links. The interesting fact about doing it is to help detect the cycle in the linked list because as you go forward, you don\'t expect to go back to the starting point (root node) and one of the temporary nodes should go to null unless you have a cycle which means it points to the root node. The time complexity of this algorithm is O(n) and space complexity is O(1).Here is the class node for the linked list:Here is the main code with a simple test case of three nodes that the last node pointing to the second node:Here is the a simple test case of three nodes that the last node pointing to the second node:This code is optimized and will produce result faster than with the one chosen as the best answer.This code saves from going into a very long process of chasing the forward and backward node pointer which will occur in the following case if we follow the \'best answer\' method.Look through the dry run of the following and you will realize what I am trying to say.Then look at the problem through the given method below and measure the no. of steps taken to find the answer.1->2->9->3\n^--------^ Here is the code:Use above function to detect a loop in linkedlist in java.This approach has space overhead, but a simpler implementation:Loop can be identified by storing nodes in a Map. And before putting the node; check if node already exists. If node already exists in the map then it means that Linked List has loop.