Recently posted a question regarding the HttpClient over Https (found here).  I\'ve made some headway, but I\'ve run into new issues. As with my last problem, I can\'t seem to find an example anywhere that works for me. Basically, I want my client to accept any certificate (because I\'m only ever pointing to one server) but I keep getting a javax.net.ssl.SSLException: Not trusted server certificate exception.So this is what I have:And here\'s the error I\'m getting:Note: Do not implement this in production code you are ever going to use on a network you do not entirely trust. Especially anything going over the public internet. Your question is just what I want to know. After I did some searches, the conclusion is as follows.In HttpClient way, you should create a custom class from org.apache.http.conn.ssl.SSLSocketFactory, not the one org.apache.http.conn.ssl.SSLSocketFactory\n itself. Some clues can be found in this post Custom SSL handling stopped working on Android 2.2 FroYo.An example is like  ...and use this class while creating instance of HttpClient.BTW, the link below is for someone who is looking for HttpURLConnection solution.\nHttps Connection AndroidI have tested the above two kinds of solutions on froyo, and they all work like a charm in my cases. Finally, using HttpURLConnection may face the redirect problems, but this is beyond the topic.Note: Before you decide to trust all certificates, you probably should know the site full well and won\'t be harmful of it to end-user.Indeed, the risk you take should be considered carefully, including the effect of hacker\'s mock site mentioned in the following comments that I deeply appreciated. In some situation, although it might be hard to take care of all certificates, you\'d better know the implicit drawbacks to trust all of them.You basically have four potential solutions to fix a "Not Trusted" exception on Android using httpclient:This answer uses solution #4, which seems to me to be the most robust.The solution is to use an SSLSocketFactory that can accept multiple KeyStores, allowing you to supply your own KeyStore with your own certificates.  This allows you to load additional top-level certificates such as Thawte that might be missing on some Android devices.  It also allows you to load your own self-signed certificates as well.  It will use the built-in default device certificates first, and fall back on your additional certificates only as necessary.First, you\'ll want to determine which cert you are missing in your KeyStore.  Run the following command:And you\'ll see output like the following:As you can see, our root certificate is from Thawte.  Go to your provider\'s website and find the corresponding certificate.  For us, it was here, and you can see that the one we needed was the one Copyright 2006.If you\'re using a self-signed certificate, you didn\'t need to do the previous step since you already have your signing certificate. Then, create a keystore file containing the missing signing certificate.  Crazybob has details how to do this on Android, but the idea is to do the following:If you don\'t have it already, download the bouncy castle provider library from: http://www.bouncycastle.org/latest_releases.html. This will go on your classpath below.Run a command to extract the certificate from the server and create a pem file. In this case, mycert.pem.Then run the following commands to create the keystore.You\'ll notice that the above script places the result in res/raw/mystore.bks.  Now you have a file that you\'ll load into your Android app that provides the missing certificate(s).  To do this, register your SSLSocketFactory for the SSL scheme:To create your SSLSocketFactory:And finally, the AdditionalKeyStoresSSLSocketFactory code, which accepts your new KeyStore and checks if the built-in KeyStore fails to validate an SSL certificate:Add this code before the HttpsURLConnection and it will be done.  I got it.I hope this helps you.This is a bad idea.  Trusting any certificate is only (very) slightly better than using no SSL at all.  When you say "I want my client to accept any certificate (because I\'m only ever pointing to one server)" you are assuming this means that somehow pointing to "one server" is safe, which it\'s not on a public network.  You are completely open to a man-in-the-middle attack by trusting any certificate.  Anyone can proxy your connection by establishing a separate SSL connection with you and with the end server.  The MITM then has access to your entire request and response.  Unless you didn\'t really need SSL in the first place (your message has nothing sensitive, and doesn\'t do authentication) you shouldn\'t trust all certificates blindly.  You should consider adding the public cert to a jks using keytool, and using that to build your socket factory, such as this:This has one caveat to watch out for.  The certificate will expire eventually, and the code will stop working at that time.  You can easily determine when this will happen by looking at the cert.You can disable HttpURLConnection SSL checking for testing purposes this way since API 8:The API of HttpComponents has got changed. It works with the code below.The code above in https://stackoverflow.com/a/6378872/1553004 is correct, except it MUST also call the hostname verifier:I signed up to stackoverflow expressly to add this fix.  Heed my warning!For those who would like to allow all certificates to work (for testing purposes) over OAuth, follow these steps:1) Download the source code of the Android OAuth API here: https://github.com/kaeppler/signpost2) Find the file "CommonsHttpOAuthProvider" class3) Change it as below:The "MySSLSocketFactory" above is based on the accepted answer. To make it even easier, here goes the complete class:}Hope this helps someone.Trusting all certificates was no real alternative for me, so I did the following to get HttpsURLConnection to trust a new certificate (see also http://nelenkov.blogspot.jp/2011/12/using-custom-certificate-trust-store-on.html).Get the certificate; I got this done by exporting the certificate in Firefox (click on the little lock icon, get certificate details, click export), then used portecle to export a truststore (BKS).Load the Truststore from /res/raw/geotrust_cert.bks with the following code:Here is a much simple version using 4.1.2 httpclient code.  This can then be modified to any trust algorithm you see fit.I\'m looked response from "emmby" (answered Jun 16 \'11 at 21:29), item #4: "Create a custom SSLSocketFactory that uses the built-in certificate KeyStore, but falls back on an alternate KeyStore for anything that fails to verify with the default."This is a simplified implementation. Load the system keystore & merge with application keystore.A simple mode to convert from JKS to BKS:*Note: In Android 4.0 (ICS) the Trust Store has changed, more info: http://nelenkov.blogspot.com.es/2011/12/ics-trust-store-implementation.htmlI\'m adding a response for those that use the httpclient-4.5, and probably works for 4.4 as well.Any body still struggling with StartCom SSL Certificates on Android 2.1 visit https://www.startssl.com/certs/ and download the ca.pem, now in the answer provided by @emmby replace with Should work out of the box. I was struggling it for over a day even after a perfect answer by @emmby.. Hope this helps someone...I used this and It works for me on all OS./**\n     * Disables the SSL certificate checking for new instances of {@link HttpsURLConnection} This has been created to\n     * aid testing on a local box, not for use on production.\n     */Just adding -Dtrust_all_cert=true to VM arguments should do. This argument tells java to ignore certificate checks.work with all httpsThere a many answers above but I wasn\'t able to get any of them working correctly (with my limited time), so for anyone else in the same situation you can try the code below which worked perfectly for my java testing purposes:and call like:Reference: http://tech.chitgoks.com/2011/04/24/how-to-avoid-javax-net-ssl-sslpeerunverifiedexception-peer-not-authenticated-problem-using-apache-httpclient/Simply use this - Daniel\'s answer was good except I had to change this code...to this code...to get it to work.