I have a condition in a silverlight application that compares 2 strings, for some reason when I use == it returns false while .Equals() returns true.Here is the code:Any reason as to why this is happening?When == is used on an expression of type object, it\'ll resolve to System.Object.ReferenceEquals.Equals is just a virtual method and behaves as such, so the overridden version will be used (which, for string type compares the contents).When comparing an object reference to a string (even if the object reference refers to a string), the special behavior of the == operator specific to the string class is ignored.Normally (when not dealing with strings, that is), Equals compares values, while == compares object references.\nIf two objects you are comparing are referring to the same exact instance of an object, then both will return true, but if one has the same content and came from a different source (is a separate instance with the same data), only Equals will return true. However, as noted in the comments, string is a special case because it overrides the == operator so that when dealing purely with string references (and not object references), only the values are compared even if they are separate instances. The following code illustrates the subtle differences in behaviors:The output is:== and .Equals are both dependent upon the behavior defined in the actual type and the actual type at the call site.  Both are just methods / operators which can be overridden on any type and given any behavior the author so desires.  In my experience, I find it\'s common for people to implement .Equals on an object but neglect to implement operator ==.  This means that .Equals will actually measure the equality of the values while == will measure whether or not they are the same reference.  When I\'m working with a new type whose definition is in flux or writing generic algorithms, I find the best practice is the followingIn some cases when I feel the usage of == is ambiguous I will explicitly use Object.Reference equals in the code to remove the ambiguity.Eric Lippert recently did a blog post on the subject of why there are 2 methods of equality in the CLR.  It\'s worth the readI would add that if you cast your object to a string then it will work correctly. This is why the compiler will give you a warning saying "Possible unintended reference comparison; to get a value comparison, cast the left hand side to type \'string\'"Firstly, there is a difference. For numbersAnd for stringsIn both cases, == behaves more usefully than .Equals== Operator\n1. If operands are Value Types and their values are equal, it returns true else false.\n2. If operands are Reference Types with exception of string and both refer to same object, it returns true else false.\n3. If operands are string type and their values are equal, it returns true else false..Equals\n1. If operands are Reference Types, it performs Reference Equality that is if both refer to same object, it returns true else false.\n2. If Operands are Value Types then unlike == operator it checks for their type first and If their types are same it performs == operator else it returns false.As far as I understand it the answer is simple:I hope i\'m correct and that it answered your question.I am a bit confused here. If the runtime type of Content is of type string, then both == and Equals should return true. However, since this does not appear to be the case, then runtime type of Content is not string and calling Equals on it is doing a referential equality and this explains why Equals("Energy Attack") fails. However, in the second case, the decision as to which overloaded == static operator should be called is made at compile time and this decision appears to be ==(string,string). this suggests to me that Content provides an implicit conversion to string.There is another dimension to an earlier answer by @BlueMonkMN.  The additional dimension is that the answer to the @Drahcir\'s title question as it is stated also depends on how we arrived at the string value.  To illustrate:The output is:Adding one more point to the answer..EqualsTo() method gives you provision to compare against culture and case sensitive.The == token in C# is used for two different equality-check operators.  When the compiler encounters that token, it will check whether either of the types being compared has implemented an equality-operator overload for either the specific combination types being compared(*), or for a combination of types to which both types can be converted.  If the compiler finds such an overload it will use it.  Otherwise, if the two types are both reference types and they are not unrelated classes (either may be an interface, or they may be related classes), the compiler will regard == as a reference-comparison operator.  If neither condition applies, compilation will fail.Note that some other languages use separate tokens for the two equality-check operators.  In VB.NET, for example, the = token is used within expressions solely for the overloadable equality-check operator, and Is is used as a reference-test or null-test operator.  An to use = on a type which does not override the equality-check operator will fail, as will attempting to use Is for any purpose other than testing reference equality or nullity.(*)Types generally only overload equality for comparison with themselves, but it may be useful for types to overload the equality operator for comparison with other particular types; for example, int could have (and IMHO should have but didn\'t) defined an equality operators for comparison with float, so that 16777217 would not report itself equal to 16777216f.  As it is, since no such operator is defined, C# will promote the int to float, rounding it to 16777216f before the equality-check operator sees it; that operator then sees two equal floating-point numbers and reports them as equal, unaware of the rounding that took place.Really great answers and examples!I would just like to add the fundamental difference between the two, Operators such as == are not polymorphic, while Equals isWith that concept in mind, if you work out any example (by looking at left hand and right hand reference type, and checking/knowing if the type actually has == operator overloaded and Equals being overriden) you are certain to get the right answer.When we create any object there are two parts to the object one is the content and the other is reference to that content.\n== compares both content and reference;\nequals() compares only contenthttp://www.codeproject.com/Articles/584128/What-is-the-difference-between-equalsequals-and-EqThe only difference between Equal and == is on object type comparison. in other cases, such as reference types and value types, they are almost the same(either both are bit-wise equality or both are reference equality). object:\nEquals: bit-wise equality \n==:  reference equalitystring: (equals and == are the same for string, but if one of string changed to object, then comparison result will be different)\nEquals: bit-wise equality\n== : bit-wise equalitySee here for more explanation.==The == operator can be used to compare two variables of any kind, and it simply compares the bits.Note : there are more zeroes on the left side of the int but we don\'t care about that here.int a (00000011) == byte b (00000011)Remember == operator cares only about the pattern of the bits in the variable.Use == If two references (primitives) refers to the same object on the heap.Rules are same whether the variable is a reference or primitive.a == c is true \na == b is falsethe bit pattern are the same for a and c, so they are equal using ==.Equal():Use the equals() method to see if two different objects are equal.Such as two different String objects that both represent the characters in "Jane"