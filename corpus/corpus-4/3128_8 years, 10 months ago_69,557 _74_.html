I\'ve been developing an internal website for a portfolio management tool.  There is a lot of text data, company names etc.  I\'ve been really impressed with some search engines ability to very quickly respond to queries with "Did you mean: xxxx".I need to be able to intelligently take a user query and respond with not only raw search results but also with a "Did you mean?" response when there is a highly likely alternative answer etc[I\'m developing in ASP.NET (VB - don\'t hold it against me! )]UPDATE:\nOK, how can I mimic this without the millions of \'unpaid users\'?Here\'s the explanation directly from the source ( almost ) at min 22:03Worth watching!Basically and according  to Douglas Merrill former CTO of Google it is like this:1) You write a  ( misspelled )  word  in google 2) You don\'t find what you wanted ( don\'t click on any results )3) You realize you misspelled the word  so you rewrite the word in the search box.4) You find what you want ( you click in the first links ) This pattern multiplied millions of times, shows what are the most common misspells and what are the most "common" corrections. This way Google can almost instantaneously, offer spell correction in every language.Also this means if overnight everyone start to spell night as "nigth" google would suggest that word instead.  EDIT@ThomasRutter: Douglas describe it as "statistical machine learning". They know who correct the query, because they know which query comes from which user ( using cookies ) If the users perform a query, and only 10% of the users click on a result and 90% goes back and type another query ( with the corrected word ) and this time that 90% clicks on a result, then they know they have found a correction. They can also know if those are "related" queries of two different, because they have information of all the links they show. Furthermore, they are now including the context into the spell check, so they can even suggest different word depending on the context. See this demo of google wave ( @ 44m 06s )  that shows how the context is taken into account to automatically correct the spelling.Here it is explained how that natural language processing works.And finally here is an awesome demo of what can be done adding automatic machine translation ( @ 1h 12m 47s )  to the mix. \n  I\'ve added anchors of minute and seconds to the videos to skip directly to the content, if they don\'t work, try reloading the page or scrolling by hand to the mark. \nI found this article some time ago: http://www.norvig.com/spell-correct.html.It\'s an interesting read about the "spelling correction" topic. The examples are in Python but it\'s clear and simple to understand, and I think that the algorithm can be easily \ntranslated to other languages.Below follows a short description of the algorithm.\nThe algorithm consists of two steps, preparation and word checking.Step 1: Preparation - setting up the word databaseBest is if you can use actual search words and their occurence.\nIf you don\'t have that a large set of text can be used instead.\nCount the occurrence (popularity) of each word.Step 2. Word checking - finding words that are similar to the one checkedSimilar means that the edit distance is low (typically 0-1 or 0-2). The edit distance is the minimum number of inserts/deletes/changes/swaps needed to transform one word to another.Choose the most popular word from the previous step and suggest it as a correction (if other than the word itself).For the theory of "did you mean" algorithm you can refer to Chapter 3 of Introduction to Information Retrieval. It is available online for free. Section 3.3 (page 52) exactly answers your question. And to specifically answer your update you only need a dictionary of words and nothing else (including millions of users).Hmm... I thought that google used their vast corpus of data (the internet) to do some serious NLP (Natural Language Processing). For example, they have so much data from the entire internet that they can count the number of times a three-word sequence occurs (known as a trigram). So if they see a sentence like: "pink frugr concert", they could see it has few hits, then find the most likely "pink * concert" in their corpus.They apparently just do a variation of what Davide Gualano was saying, though, so definitely read that link. Google does of course use all web-pages it knows as a corpus, so that makes its algorithm particularly effective.My guess is that they use a combination of a Levenshtein distance algorithm and the masses of data they collect regarding the searches that are run. They could pull a set of searches that have the shortest Levenshtein distance from the entered search string, then pick the one with the most results.Normally a production spelling corrector utilizes several methodologies to provide a spelling suggestion. Some are:Decide on a way to determine whether spelling correction is required. These may include insufficient results, results which are not specific or accurate enough (according to some measure), etc. Then:Use a large body of text or a dictionary, where all, or most are known to be correctly spelled. These are easily found online, in places such as LingPipe. Then to determine  the best suggestion you look for a word which is the closest match based on several measures. The most intuitive one is similar characters. What has been shown through research and experimentation is that two or three character sequence matches work better. (bigrams and trigrams). To further improve results, weigh a higher score upon a match at the beginning, or end of the word. For performance reasons, index all these words as trigrams or bigrams, so that when you are performing a lookup, you convert to n-gram, and lookup via hashtable or trie.Use heuristics related to potential keyboard mistakes based on character location. So that "hwllo" should be "hello" because \'w\' is close to \'e\'.Use a phonetic key (Soundex, Metaphone) to index the words and lookup possible corrections. In practice this normally returns worse results than using n-gram indexing, as described above.In each case you must select the best correction from a list. This may be a distance metric such as levenshtein, the keyboard metric, etc.For a multi-word phrase, only one word may be misspelled, in which case you can use the remaining words as context in determining a best match.Use Levenshtein distance, then create a Metric Tree (or Slim tree) to index words.\nThen run a 1-Nearest Neighbour query, and you got the result.Google apparently suggests queries with best results, not with those which are spelled correctly. But in this case, probably a spell-corrector would be more feasible, Of course you could store some value for every query, based on some metric of how good results it returns.So,You need a dictionary (english or based on your data)Generate a word trellis and calculate probabilities for the transitions using your dictionary.Add a decoder to calculate minimum error distance using your trellis. Of course you should take care of insertions and deletions when calculating distances. Fun thing is that QWERTY keyboard maximizes the distance if you hit keys close to each other.(cae would turn car, cay would turn cat)Return the word which has the minimum distance. Then you could compare that to your query database and check if there is better results for other close matches.Here is the best answer I found, Spelling corrector implemented and described by Google\'s Director of Research Peter Norvig.If you want to read more about the theory behind this, you can read his book chapter.The idea of this algorithm is based on statistical machine learning. As a guess...it could \n1) search for words \n2) if it is not found use some algorithm to try to "guess" the word. Could be something from AI like Hopfield network or back propagation network, or something else "identifying fingerprints", restoring broken data, or spelling corrections as Davide mentioned already...regarding your question how to mimic the behavior without having tons of data - why not use tons of data collected by google? Download the google sarch results for the misspelled word and search for "Did you mean:" in the HTML.I guess that\'s called mashup nowadays :-)I saw something on this a few years back, so may have changed since, but apparently they started it by analysing their logs for the same users submitting very similar queries in a short space of time, and used machine learning based on how users had corrected themselves.Simple. They have tons of data. They have statistics for every possible term, based on how often it is queried, and what variations of it usually yield results the users click... so, when they see you typed a frequent misspelling for a search term, they go ahead and propose the more usual answer.Actually, if the misspelling is in effect the most frequent searched term, the algorythm will take it for the right one.You mean to say spell checker? If it is a spell checker rather than a whole phrase then I\'ve got a link about the spell checking where the algorithm is developed in python. Check this link Meanwhile, I am also working on project that includes searching databases using text. I guess this would solve your problemEasiest way to figure it out is to Google dynamic programming.It\'s an algorithm that\'s been borrowed from Information Retrieval and is used heavily in modern day bioinformatics to see how similiar two gene sequences are.Optimal solution uses dynamic programming and recursion.This is a very solved problem with lots of solutions.  Just google around until you find some open source code.There is a specific data structure - ternary search tree - that naturally supports partial matches and near-neighbor matches.This is an old question, and I\'m surprised that nobody suggested the OP using Apache Solr.Apache Solr is a full text search engine that besides many other functionality also provides spellchecking or query suggestions. From the documentation:By default, the Lucene Spell checkers sort suggestions first by the\n  score from the string distance calculation and second by the frequency\n  (if available) of the suggestion in the index.Apart from the above answers, in case you want to implement something by yourself quickly, here is a suggestion - You can find the implementation and detailed documentation of this algorithm on my GitHub project.