Is a GUID unique 100% of the time?Will it stay unique over multiple threads?While each generated GUID is not\n  guaranteed to be unique, the total\n  number of unique keys (2^128 or\n  3.4\xc3\x9710^38) is so large that the probability of the same number being\n  generated twice is very small. For\n  example, consider the observable\n  universe, which contains about 5\xc3\x9710^22\n  stars; every star could then have\n  6.8\xc3\x9710^15 universally unique GUIDs.From Wikipedia.These are some good articles on how a GUID is made (for .NET) and how you could get the same guid in the right situation.http://ericlippert.com/2012/04/24/guid-guide-part-one/http://ericlippert.com/2012/04/30/guid-guide-part-two/http://ericlippert.com/2012/05/07/guid-guide-part-three/The simple answer is yes.Raymond Chen wrote a great article on GUIDs and why substrings of GUIDs are not guaranteed unique. The article goes in to some depth as to the way GUIDs are generated and the data they use to ensure uniqueness, which should go to some length in explaining why they are :-)As a side note, I was playing around with Volume GUIDs in Windows XP. This is a very obscure partition layout with three disks and fourteen volumes.It\'s not that the GUIDs are very similar but the fact that all GUIDs have the string "mario" in them. Is that a coincidence or is there an explanation behind this?Now, when googling for part 4 in the GUID I found approx 125.000 hits with volume GUIDs.Conclusion: When it comes to Volume GUIDs they aren\'t as unique as other GUIDs.If you are scared of the same GUID values then put two of them next to each other. If you are too paranoid then put three.Yes, a GUID should always be unique.  It is based on both hardware and time, plus a few extra bits to make sure it\'s unique.  I\'m sure it\'s theoretically possible to end up with two identical ones, but extremely unlikely in a real-world scenario.  Here\'s a great article by Raymond Chen on Guids: http://blogs.msdn.com/oldnewthing/archive/2008/06/27/8659071.aspxIt should not happen.  However, when .NET is under a heavy load, it is possible to get duplicate guids.  I have two different web servers using two different sql servers. I went to merge the data and found I had 15 million guids and 7 duplicates.Guids are statistically unique.  The odds of two different clients generating the same Guid are infinitesimally small (assuming no bugs in the Guid generating code).  You may as well worry about your processor glitching due to a cosmic ray and deciding that 2+2=5 today.Multiple threads allocating new guids will get unique values, but you should get that the function you are calling is thread safe.  Which environment is this in?Eric Lippert has written a very interesting series of articles about GUIDs.There are on the order 230 personal computers in the world (and of\n  course lots of hand-held devices or non-PC computing devices that have\n  more or less the same levels of computing power, but lets ignore\n  those). Let\'s assume that we put all those PCs in the world to the\n  task of generating GUIDs; if each one can generate, say, 220 GUIDs per\n  second then after only about 272 seconds -- one hundred and fifty\n  trillion years -- you\'ll have a very high chance of generating a\n  collision with your specific GUID. And the odds of collision get\n  pretty good after only thirty trillion years.Theoretically, no, they are not unique. It\'s possible to generate an identical guid over and over. However, the chances of it happening are so low that you can assume they are unique.I\'ve read before that the chances are so low that you really should stress about something else--like your server spontaneously combusting or other bugs in your code. That is, assume it\'s unique and don\'t build in any code to "catch" duplicates--spend your time on something more likely to happen (i.e. anything else).I made an attempt to describe the usefulness of GUIDs to my blog audience (non-technical family memebers). From there (via Wikipedia), the odds of generating a duplicate GUID:From http://www.guidgenerator.com/online-guid-generator.aspxWhat is a GUID?GUID (or UUID) is an acronym for \'Globally Unique Identifier\' (or \'Universally Unique Identifier\'). It is a 128-bit integer number used to identify resources. The term GUID is generally used by developers working with Microsoft technologies, while UUID is used everywhere else.How unique is a GUID?128-bits is big enough and the generation algorithm is unique enough that if 1,000,000,000 GUIDs per second were generated for 1 year the probability of a duplicate would be only 50%. Or if every human on Earth generated 600,000,000 GUIDs there would only be a 50% probability of a duplicate.If your system clock is set properly and hasn\'t wrapped around, and if your NIC has its own MAC (i.e. you haven\'t set a custom MAC) and your NIC vendor has not been recycling MACs (which they are not supposed to do but which has been known to occur), and if your system\'s GUID generation function is properly implemented, then your system will never generate duplicate GUIDs.If everyone on earth who is generating GUIDs follows those rules then your GUIDs will be globally unique.In practice, the number of people who break the rules is low, and their GUIDs are unlikely to "escape".  Conflicts are statistically improbable.MSDN: There is a very low probability that the value of the new Guid is all zeroes or equal to any other Guid. Is a GUID unique 100% of the time?Not guaranteed, since there are several ways of generating one. However, you can try to calculate the chance of creating two GUIDs that are identical and you get the idea: a GUID has 128 bits, hence, there are 2128 distinct GUIDs \xe2\x80\x93 much more than there are stars in the known universe. Read the wikipedia article for more details.I experienced a duplicate GUID.I use the Neat Receipts desktop scanner and it comes with proprietary database software. The software has a sync to cloud feature, and I kept getting an error upon syncing. A gander at the logs revealed the awesome line:"errors":[{"code":1,"message":"creator_guid: is already\n  taken","guid":"C83E5734-D77A-4B09-B8C1-9623CAC7B167"}]}I was a bit in disbelief, but surely enough, when I found a way into my local neatworks database and deleted the record containing that GUID, the error stopped occurring.So to answer your question with anecdotal evidence, no. A duplicate is possible. But it is likely that the reason it happened wasn\'t due to chance, but due to standard practice not being adhered to in some way. (I am just not that lucky) However, I cannot say for sure. It isn\'t my software.Their customer support was EXTREMELY courteous and helpful, but they must have never encountered this issue before because after 3+ hours on the phone with them, they didn\'t find the solution. (FWIW, I am very impressed by Neat, and this glitch, however frustrating, didn\'t change my opinion of their product.)None seems to mention the actual math of the probability of it occurring.First, let\'s assume we can use the entire 128 bit space (Guid v4 only uses 122 bits).We know that the general probability of NOT getting a duplicate in n picks is:(1-1/2128)(1-2/2128)...(1-(n-1)/2128)Because 2128 is much much larger than n, we can approximate this to:(1-1/2128)n(n-1)/2And because we can assume n is much much larger than 0, we can approximate that to:(1-1/2128)n^2/2Now we can equate this to the "acceptable" probability, let\'s say 1%:(1-1/2128)n^2/2 = 0.01Which we solve for n and get:n = sqrt(2* log 0.01 / log (1-1/2128))Which Wolfram Alpha gets to be 5.598318 \xc3\x97 1019To put that number into perspective, lets take 10000 machines, each having a 4 core CPU, doing 4Ghz and spending 10000 cycles to generate a Guid and doing nothing else. It would then take ~111 years before they generate a duplicate.GUID algorithms are usually implemented according to the v4 GUID specification, which is essentially a pseudo-random string. Sadly, these fall into the category of "likely non-unique", from Wikipedia (I don\'t know why so many people ignore this bit): "... other GUID versions have different uniqueness properties and probabilities, ranging from guaranteed uniqueness to likely non-uniqueness."The pseudo-random properties of V8\'s JavaScript Math.random() are TERRIBLE at uniqueness, with collisions often coming after only a few thousand iterations, but V8 isn\'t the only culprit. I\'ve seen real-world GUID collisions using both PHP and Ruby implementations of v4 GUIDs.Because it\'s becoming more and more common to scale ID generation across multiple clients, and clusters of servers, entropy takes a big hit -- the chances of the same random seed being used to generate an ID escalate (time is often used as a random seed in pseudo-random generators), and GUID collisions escalate from "likely non-unique" to "very likely to cause lots of trouble".To solve this problem, I set out to create an ID algorithm that could scale safely, and make better guarantees against collision. It does so by using the timestamp, an in-memory client counter, client fingerprint, and random characters. The combination of factors creates an additive complexity that is particularly resistant to collision, even if you scale it across a number of hosts:http://usecuid.org/I have experienced the GUIDs not being unique during multi-threaded/multi-process unit-testing (too?).  I guess that has to do with, all other tings being equal, the identical seeding (or lack of seeding) of pseudo random generators.  I was using it for generating unique file names.  I found the OS is much better at doing that :)You ask if GUIDs are 100% unique.  That depends on the number of GUIDs it must be unique among.  As the number of GUIDs approach infinity, the probability for duplicate GUIDs approach 100%.In a more general sense, this is known as the "birthday problem" or "birthday paradox". Wikipedia has a pretty good overview at: \nWikipedia - Birthday ProblemIn very rough terms, the square root of the size of the pool is a rough approximation of when you can expect a 50% chance of a duplicate. The article includes a probability table of pool size and various probabilities, including a row for 2^128. So for a 1% probability of collision you would expect to randomly pick 2.6*10^18 128-bit numbers. A 50% chance requires 2.2*10^19 picks, while SQRT(2^128) is 1.8*10^19.Of course, that is just the ideal case of a truly random process. As others mentioned, a lot is riding on the that random aspect - just how good is the generator and seed? It would be nice if there was some hardware support to assist with this process which would be more bullet-proof except that anything can be spoofed or virtualized. I suspect that might be the reason why MAC addresses/time-stamps are no longer incorporated.