I searched in Google to find the differences between a case class and a class. Everyone mentions that when you want to do pattern matching on the class, use case class. Otherwise use classes and also mentioning some extra perks like equals and hash code overriding. But are these the only reasons why one should use a case class instead of class? I guess there should be some very important reason for this feature in Scala. What is the explanation or is there a resource to learn more about the Scala case classes from?Case classes can be seen as plain and immutable data-holding objects that should exclusively depend on their constructor arguments.This functional concept allows us toIn combination with inheritance, case classes are used to mimic algebraic datatypes.If an object performs stateful computations on the inside or exhibits other kinds of complex behaviour, it should be an ordinary class.Technically, there is no difference between a class and a case class -- even if the compiler does optimize some stuff when using case classes. However, a case class is used to do away with boiler plate for a specific pattern, which is implementing algebraic data types.A very simple example of such types are trees. A binary tree, for instance, can be implemented like this:That enable us to do the following:Note that trees construct and deconstruct (through pattern match) with the same syntax, which is also exactly how they are printed (minus spaces).And they can also be used with hash maps or sets, since they have a valid, stable hashCode.(You already mentioned all but the last one).Those are the only differences to regular classes.No one mentioned that case classes have val constructor parameters yet this is also the default for regular classes (which I think is an inconsistency in the design of Scala). Dario implied such where he noted they are "immutable".Note you can override the default by prepending the each constructor argument with var for case classes. However, making case classes mutable causes their equals and hashCode methods to be time variant.[1]sepp2k already mentioned that case classes automatically generate equals and hashCode methods.Also no one mentioned that case classes automatically create a companion object with the same name as the class, which contains apply and unapply methods. The apply method enables constructing instances without prepending with new. The unapply extractor method enables the pattern matching that others mentioned.Also the compiler optimizes the speed of match-case pattern matching for case classes[2].[1] Case Classes Are Cool[2] Case Classes and Extractors, pg 15.No one mentioned that case classes are also instances of Product and thus inherit these methods:where the productArity returns the number of class parameters, productElement(i) returns the ith parameter, and productIterator allows iterating through them.The case class construct in Scala can also be seen as a convenience to remove some boilerplate.When constructing a case class Scala gives you the following.Because the class is immutable you get accessors, which are just the variables (or properties) of the class but no mutators (so no ability to change the variables). The constructor parameters are automatically available to you as public read only fields. Much nicer to use than Java bean construct. The biggest advantage as has been mentioned previously is the fact that you can pattern match on case classes. The reason for this is because you get the unapply method which lets you deconstruct a case class to extract its fields.     In essence what you are getting from Scala when creating a case class (or a case object if your class takes no arguments) is a  singleton object which serves the purpose as a factory and as an extractor .Class:But if we use same code but use case class:Person class:Pattern Matching:object: singleton:According to Scala\'s documentation: Case classes are just regular classes that are:Another feature of the case keyword is the compiler automatically generates several methods for us, including the familiar toString, equals, and hashCode methods in Java.A case class is a class that may be used with the match/case statement.You see that case is followed by an instance of class Fun whose 2nd parameter is a Var. This is a very nice and powerful syntax, but it cannot work with instances of any class, therefore there are some restrictions for case classes. And if these restrictions are obeyed, it is possible to automatically define hashcode and equals.The vague phrase "a recursive decomposition mechanism via pattern matching" means just "it works with case". (Indeed, the instance followed by match is compared to (matched against) the instance that follows case, Scala has to decompose them both, and has to recursively decompose what they are made of.)What case classes are useful for? The Wikipedia article about Algebraic Data Types gives two good classical examples, lists and trees. Support for algebraic data types (including knowing how to compare them) is a must for any modern functional language.What case classes are not useful for? Some objects have state, the code like connection.setConnectTimeout(connectTimeout) is not for case classes.And now you can read A Tour of Scala: Case ClassesNobody mentioned that case class companion object has tupled defention, which has a type:The only use case I can find is when you need to construct case class from tuple, example:You can do the same, without tupled, by creating object directly, but if your datasets expressed as list of tuple with arity 20(tuple with 20 elements), may be using tupled is your choise.Unlike classes, case classes are just used to hold data.Case classes are flexible for data-centric applications, which means you can define data fields in case class and define business logic in a companion object. In this way, you are separating the data from the business logic.With the copy method, you can inherit any or all required properties from the source and can change them as you like.