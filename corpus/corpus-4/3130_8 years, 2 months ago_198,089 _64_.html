I have a page that allows the user to download a dynamically-generated file. It takes a long time to generate, so I\'d like to show a "waiting" indicator. The problem is, I can\'t figure out how to detect when the browser has received the file, so I can hide the indicator.I\'m making the request in a hidden form, which POSTs to the server, and targets a hidden iframe for its results. This is so I don\'t replace the entire browser window with the result. I listen for a "load" event on the iframe, in the hope that it will fire when the download is complete.I return a "Content-Disposition: attachment" header with the file, which causes the browser to show the "Save" dialog. But the browser doesn\'t fire a "load" event in the iframe.One approach I tried is using a multi-part response. So it would send an empty HTML file, as well as the attached downloadable file. For example:This works in Firefox; it receives the empty HTML file, fires the "load" event, then shows the "Save" dialog for the downloadable file. But it fails on IE and Safari; IE fires the "load" event but doesn\'t download the file, and Safari downloads the file (with the wrong name and content-type), and doesn\'t fire the "load" event.A different approach might be to make a call to start the file creation, then poll the server until it\'s ready, then download the already-created file. But I\'d rather avoid creating temporary files on the server.Does anyone have a better idea?One possible solution uses JavaScript on the client.The client algorithm:The server algorithm:Client source code (JavaScript):Example server code (PHP):Where:A very simple (and lame) one line solution is to use the window.onblur() event to close the loading dialog. Of course, if it takes too long and the user decides to do something else (like reading emails) the loading dialog will close.old thread, i know...but those, that are lead here by google might be interested in my solution.\nit is very simple, yet reliable. and it makes it possible to display real progress messages (and can be easily plugged in to existing processes):the script that processes (my problem was: retrieving files via http and deliver them as zip) writes the status to the session.the status is polled and displayed every second. thats all (ok, its not. you have to take care of a lot of details [eg concurrent downloads], but its a good place to start ;-)).the downloadpage:getstatus.phpdownload.phpi use the following to download blobs and revoke the object-url after the download. it works in chrome and firefox!after the file download dialog is closed, the window gets her focus back so the focus event is triggered.I wrote a simple JavaScript class that implements a technique similar to the one described in bulltorious answer. I hope it can be useful to someone here.\nThe GitHub project is called response-monitor.jsBy default it uses spin.js as the waiting indicator but it also provides a set of callbacks for implementation of a custom indicator.JQuery is supported but not required.Notable featuresExample usageHTMLClient (plain JavaScript)Client (JQuery)Client with callbacks (JQuery)Server (PHP)For more examples check the examples folder on the repository.When the user triggers the generation of the file, you could simply assign a unique ID to that "download", and send the user to a page which refreshes (or checks with AJAX) every few seconds.  Once the file is finished, save it under that same unique ID and...Then you can skip the whole iframe/waiting/browserwindow mess, yet have a really elegant solution.Based on Elmer\'s example I\'ve prepared my own solution. After elements click with defined download class it lets to show custom message on the screen. I\'ve used focus trigger to hide the message.JavaScriptHTMLNow you should implement any element to download:orAfter each download click you will see message your report is creating, please wait...I just had this exact same problem. My solution was to use temporary files since I was generating a bunch of temporary files already. The form is submitted with:At the end of the script that generates the file I have:This will cause the load event on the iframe to be fired. Then the wait message is closed and the file download will then start. Tested on IE7 and Firefox.If you don\'t want to generate and store the file on the server, are you willing to store the status, e.g. file-in-progress, file-complete?  Your "waiting" page could poll the server to know when the file generation is complete. You wouldn\'t know for sure that the browser started the download but you\'d have some confidence.I\'m very late to the party but I\'ll put this up here if anyone else would like to know my solution:I had a real struggle with this exact problem but I found a viable solution using iframes (I know, I know. It\'s terrible but it works for a simple problem that I had)I had an html page that launched a separate php script that generated the file and then downloaded it. On the html page, i used the following jquery in the html header (you\'ll need to include a jquery library as well):On your_download_script.php, have the following:To break this down, jquery first launches your php script in an iframe. The iframe is loaded once the file is generated. Then jquery launches the script again with a request variable telling the script to download the file.The reason that you can\'t do the download and file generation all in one go is due to the php header() function. If you use header(), you\'re changing the script to something other than a web page and jquery will never recognize the download script as being \'loaded\'. I know this may not necessarily be detecting when a browser receives a file but your issue sounded similar to mine. If you\'re streaming a file that you\'re generating dynamically, and also have a realtime server-to-client messaging library implemented, you can alert your client pretty easily.  The server-to-client messaging library I like and recommend is Socket.io (via Node.js).  After your server script is done generating the file that is being streamed for download your last line in that script can emit a message to Socket.io which sends a notification to the client.  On the client, Socket.io listens for incoming messages emitted from the server and allows you to act on them.  The benefit of using this method over others is that you are able to detect a "true" finish event after the streaming is done.For example, you could show your busy indicator after a download link is clicked, stream your file, emit a message to Socket.io from the server in the last line of your streaming script, listen on the client for a notification, receive the notification and update your UI by hiding the busy indicator.I realize most people reading answers to this question might not have this type of a setup, but I\'ve used this exact solution to great effect in my own projects and it works wonderfully.Socket.io is incredibly easy to install and use. See more: http://socket.io/The question is to have a \xe2\x80\x98waiting\xe2\x80\x99 indicator while a file is generated and then return to normal once the file is downloading.  The way I like todo this is using a hidden iFrame and hook the frame\xe2\x80\x99s onload event to let my page know when download starts. BUT onload does not fire in IE for file downloads (like with the attachment header token). Polling the server works, but I dislike the extra complexity. So here is what I do:Disclaimer, don\xe2\x80\x99t do this on a busy site, because of the caching could add up. But really, if your sites that busy the long running process will starve you of threads anyways.Here is what the codebehind looks like, which is all you really need.A quick solution if you only want to display a message or a loader gif until the download dialog is displayed is to put the message in a hidden container and when you click on the button that generate the file to be downloaded you make the container visible. Then use jquery or javascript to catch the focusout event of the button to hide the container that contain the messageIf you have download a file, which is saved, as opposed to being in the document, there\'s no way to determine when the download is complete, since it is not in the scope of the current document, but a separate process in the browser.Create an iframe when button/link is clicked and append this to body.Create an iframe with delay and delete it after download.