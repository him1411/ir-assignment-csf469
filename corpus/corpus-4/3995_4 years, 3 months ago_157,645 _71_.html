I want to import a function from another file in the same directory.Sometimes it works for me with from .mymodule import myfunction but sometimes I get a:Sometimes it works with from mymodule import myfunction, but sometimes I also get a:I don\'t understand the logic here, and I couldn\'t find any explanation. This looks completely random.Could someone explain to me what\'s the logic behind all this?unfortunately, this module needs to be inside the package, and it also\n  needs to be runnable as a script, sometimes. Any idea how I could\n  achieve that?It\'s quite common to have a layout like this......with a mymodule.py like this......a myothermodule.py like this......and a main.py like this......which works fine when you run main.py or mypackage/mymodule.py, but fails with mypackage/myothermodule.py, due to the relative import...The way you\'re supposed to run it is......but it\'s somewhat verbose, and doesn\'t mix well with a shebang line like #!/usr/bin/env python3.The simplest fix for this case, assuming the name mymodule is globally unique, would be to avoid using relative imports, and just use......although, if it\'s not unique, or your package structure is more complex, you\'ll need to include the directory containing your package directory in PYTHONPATH, and do it like this......or if you want it to work "out of the box", you can frob the PYTHONPATH in code first with this...It\'s kind of a pain, but there\'s a clue as to why in an email written by a certain Guido van Rossum...I\'m -1 on this and on any other proposed twiddlings of the __main__\n  machinery. The only use case seems to be running scripts that happen\n  to be living inside a module\'s directory, which I\'ve always seen as an\n  antipattern. To make me change my mind you\'d have to convince me that\n  it isn\'t.Whether running scripts inside a package is an antipattern or not is subjective, but personally I find it really useful in a package I have which contains some custom wxPython widgets, so I can run the script for any of the source files to display a wx.Frame containing only that widget for testing purposes.At some point PEP 338 conflicted with PEP 328:... relative imports rely on __name__ to determine the current\n  module\'s position in the package hierarchy. In a main module, the\n  value of __name__ is always \'__main__\', so explicit relative imports\n  will always fail (as they only work for a module inside a package)and to address the issue, PEP 366 introduced the top level variable __package__:By adding a new module level attribute, this PEP allows relative\n  imports to work automatically if the module is executed using the -m\n  switch. A small amount of boilerplate in the module itself will allow\n  the relative imports to work when the file is executed by name. [...] When it [the attribute] is present, relative imports will be based on this attribute\n  rather than the module __name__ attribute. [...] When the main module is specified by its filename, then the __package__ attribute will be set to None. [...] When the import system encounters an explicit relative import in a\n  module without __package__ set (or with it set to None), it will\n  calculate and store the correct value (__name__.rpartition(\'.\')[0]\n  for normal modules and __name__ for package initialisation modules)(emphasis mine)If the __name__ is \'__main__\', __name__.rpartition(\'.\')[0] returns empty string. This is why there\'s empty string literal in the error description:The relevant part of the CPython\'s PyImport_ImportModuleLevelObject function:CPython raises this exception if it was unable to find package (the name of the package) in interp->modules (accessible as sys.modules). Since sys.modules is "a dictionary that maps module names to modules which have already been loaded", it\'s now clear that the parent module must be explicitly absolute-imported before performing relative import.Note:  The patch from the issue 18018 has added another if block, which will be executed before the code above:If package (same as above) is empty string, the error message will beHowever, you will only see this in Python 3.6 or newer.Consider a directory (which is a Python package):All of the files in package begin with the same 2 lines of code:I\'m including these two lines only to make the order of operations obvious. We can ignore them completely, since they don\'t affect the execution.__init__.py and module.py contain only those two lines (i.e., they are effectively empty).standalone.py additionally attempts to import module.py via relative import:We\'re well aware that /path/to/python/interpreter package/standalone.py will fail. However, we can run the module with the -m command line option that will "search sys.path for the named module and execute its contents as the __main__ module":-m does all the importing stuff for you and automatically sets __package__, but you can do that yourself in thePlease treat it as a proof of concept rather than an actual solution. It isn\'t well-suited for use in real-world code.Unfortunately, setting __package__ alone is not enough. You\'re going to need to import at least N preceding packages in the module hierarchy, where N is the number of parent directories (relative to the directory of the script) that will be searched for the module being imported.Thus,Add the parent directory of the Nth predecessor of the current module to sys.pathRemove the current file\'s directory from sys.pathImport the parent module of the current module using its fully-qualified nameSet __package__ to the fully-qualified name from 2Perform the relative importI\'ll borrow files from the Solution #1 and add some more subpackages:This time standalone.py will import module.py from the package package using the following relative importWe\'ll need to precede that line with the boilerplate code, to make it work.It allows us to execute standalone.py by filename:A more general solution wrapped in a function can be found here. Example usage:The steps are -Replace explicit relative imports with equivalent absolute importsInstall package to make it importableFor instance, the directory structure may be as followswhere setup.py isThe rest of the files were borrowed from the Solution #1.Installation will allow you to import the package regardless of your working directory (assuming there\'ll be no naming issues).We can modify standalone.py to use this advantage (step 1):Change your working directory to project and run /path/to/python/interpreter setup.py install --user (--user installs the package in your site-packages directory) (step 2):Let\'s verify that it\'s now possible to run standalone.py as a script:Note: If you decide to go down this route, you\'d be better off using virtual environments to install packages in isolation.Frankly, the installation is not necessary - you could add some boilerplate code to your script to make absolute imports work.I\'m going to borrow files from Solution #1 and change standalone.py:Add the parent directory of package to sys.path before attempting to import anything from package using absolute imports:Replace the relative import by the absolute import:standalone.py runs without problems:I feel that I should warn you: try not to do this, especially if your project has a complex structure.As a side note, PEP 8 recommends the use of absolute imports, but states that in some scenarios explicit relative imports are acceptable:Absolute imports are recommended, as they are usually more readable\n  and tend to be better behaved (or at least give better error\n  messages). [...] However, explicit relative imports are an acceptable\n  alternative to absolute imports, especially when dealing with complex\n  package layouts where using absolute imports would be unnecessarily\n  verbose.I ran into this issue.  A Hack work around is using a try/except block like this:if both packages are in your import path (sys.path), and the module/class you want is in example/example.py, then to access the class without relative import try: