I\'ve searched around for solutions to this problem, and the only answer I can find seems to be "don\'t put a ListView into a ScrollView".  I have yet to see any real explanation for why though.  The only reason I can seem to find is that Google doesn\'t think you should want to do that.  Well I do, so I did.So the question is, how can you place a ListView into a ScrollView without it collapsing to its minimum height?Using a ListView to make it not scroll is extremely expensive and goes against the whole purpose of ListView. You should NOT do this. Just use a LinearLayout instead.Here\'s my solution.  I\'m fairly new to the Android platform, and I\'m sure this is a bit hackish, especially in the part about calling .measure directly, and setting the LayoutParams.height property directly, but it works.All you have to do is call Utility.setListViewHeightBasedOnChildren(yourListView) and it will be resized to exactly accommodate the height of its items.This will definitely work............\nYou have to just replace your <ScrollView ></ScrollView> in layout XML file with this Custom ScrollView like     <com.tmd.utils.VerticalScrollview > </com.tmd.utils.VerticalScrollview > Insted of putting ListView inside a ScrollView , we can use ListView as a ScrollView. Things which has to be in ListView can be put inside the ListView. Other layouts on top and bottom of ListView can be put by adding layouts to header and footer of ListView. So the entire ListView will give you an experience of scrolling .There are plenty of situations where it makes a lot of sense to have ListView\'s in a ScrollView.Here\'s code based on DougW\'s suggestion... works in a fragment, takes less memory.call setListViewHeightBasedOnChildren(listview) on each embedded listview.There\'s a built-in setting for it. On the ScrollView:In Java,Romain Guy explains it in depth here: http://www.curious-creature.org/2010/08/15/scrollviews-handy-trick/ListView is actually already capable of measuring itself to be tall enough to display all items, but it doesn\'t do this when you simply specify wrap_content (MeasureSpec.UNSPECIFIED). It will do this when given a height with MeasureSpec.AT_MOST. With this knowledge, you can create a very simple subclass to solve this problem which works far better than any of the solutions posted above. You should still use wrap_content with this subclass.Manipulating the heightMeasureSpec to be AT_MOST with a very large size (Integer.MAX_VALUE >> 4) causes the ListView to measure all of its children up to the given (very large) height and set its height accordingly.This works better than the other solutions for a few reasons:On the downside, you could argue that doing this is relying on undocumented behavior in the SDK which could change. On the other hand, you could argue that this is how wrap_content should really work with ListView and that the current wrap_content behavior is just broken.If you\'re worried that the behavior could change in the future, you should simply copy the onMeasure function and related functions out of ListView.java and into your own subclass, then make the AT_MOST path through onMeasure run for UNSPECIFIED as well.By the way, I believe that this is a perfectly valid approach when you are working with small numbers of list items. It may be inefficient when compared to LinearLayout, but when the number of items is small, using LinearLayout is unnecessary optimization and therefore unnecessary complexity.We could not use two scrolling simulteniuosly.We will have get total length of ListView and expand listview with the total height .Then we can add ListView in ScrollView directly or using LinearLayout because ScrollView have directly one child .\ncopy  setListViewHeightBasedOnChildren(lv) method in your code and expand listview then you can use listview inside scrollview.\n\\layout xml fileonCreate method in Activity class:This is a combination of the answers by DougW, Good Guy Greg, and Paul. I found it was all needed when trying to use this with a custom listview adapter and non-standard list items otherwise the listview crashed the application (also crashed with the answer by Nex):You should not put a ListView in a ScrollView because a ListView already is a ScrollView.  So that would be like putting a ScrollView in a ScrollView.What are you trying to accomplish?hey I had a similar issue. I wanted to display a list view that didn\'t scroll and I found that manipulating the parameters worked but was inefficient and would behave differently on different devices.. as a result, this is a piece of my schedule code which actually does this very efficiently.Note: if you use this, notifyDataSetChanged(); will not work as intended as the views will not be redrawn.\nDo this if you need a work aroundThere are two issue when using a ListView inside a ScrollView.1- ListView must fully expand to its children height. this ListView resolve this:Divider height must be 0, use padding in rows instead.2- The ListView consumes touch events so ScrollView can\'t be scrolled as usual. This ScrollView resolve this issue:This is the best way I found to do the trick!I converted @DougW\'s Utility into C# (used in Xamarin). The following works fine for fixed-height items in the list, and is going to be mostly fine, or at least a good start, if only some of the items are a bit bigger than the standard item.Thanks @DougW, this got me out of a tight spot when I had to work with OtherPeople\'sCode. :-)thanks to Vinay\'s code here is my code for when you can\'t have a listview inside a scrollview yet you need something like thatthe relativeLayout stays inside a ScrollView so it all becomes scrollable :)Here is small modification on @djunod\'s answer that I need to make it work perfectly:try this, this works for me, I forgot where I found it, somewhere in stack overflow, \ni\'m not here to explained it why it doesn\'t work, but this is the answer :).EDIT !, I finally found out where I got the code. here ! : ListView inside ScrollView is not scrolling on AndroidAlthough the suggested setListViewHeightBasedOnChildren() methods work in most of the cases, in some cases, specially with a lot of items, I noticed that the last elements are not displayed. So I decided to mimic a simple version of the ListView behavior in order to reuse any Adapter code, here it\'s the ListView alternative:A solution I use is, to add all Content of the ScrollView (what should be above and under the listView) as headerView and footerView in the ListView.So it works like, also the convertview is resued how it should be.All these answers are wrong!!!\nIf you are trying to put a listview in a scroll view you should re-think your design. You are trying to put a ScrollView in a ScrollView. Interfering with the list will hurt list performance. It was designed to be like this by Android.If you really want the list to be in the same scroll as the other elements, all you have to do is add the other items into the top of the list using a simple switch statement in your adapter:The list adapter can handle everything since it only renders what is visible. You Create Custom ListView Which is non ScrollableIn Your Layout Resources File\n\nIn Java FileCreate a object of your customListview instead of ListView like : \nNonScrollListView non_scroll_list = (NonScrollListView) findViewById(R.id.lv_nonscroll_list);This whole problem would just go away if LinearLayout had a setAdapter method, because then when you told someone to use it instead the alternative would be trivial.If you actually want a scrolling ListView inside another scrolling view this won\'t help, but otherwise this will at least give you an idea. You need to create a custom adapter to combine all the content you want to scroll over and set the ListView\'s adapter to that.I don\'t have sample code handy, but if you want something like.Then you need to create an adapter that represents all of that content.  The ListView/Adapters are smart enough to handle different types as well, but you need to write the adapter yourself.The android UI API just isn\'t as mature as pretty much everything else out there, so it doesn\'t have the same niceties as other platforms.  Also, when doing something on android you need to be in an android (unix) mindset where you expect that to do anything you\'re probably going to have to assemble functionality of smaller parts and write a bunch of your own code to get it to work.When we place ListView inside ScrollView two problems arise. One is ScrollView measures its children in UNSPECIFIED mode, so ListView sets its own height to accommodate only one item(I don\'t know why), another is ScrollView intercepts the touch event so ListView does not scrolls.But we can place ListView inside ScrollView with some workaround. This post, by me, explains the workaround. By this workaround we can also retain ListView\'s recycling feature as well.This is the only thing that worked for me:on Lollipop onwards you can useThis enable or disable nested scrolling for this view\nif you need backwards compatibility with older version of the OS you\'ll have to use the RecyclerView.This library is the easiest and quickest solution to the problem.Here is my version of the code that calculates total height of the list view. This one works for me:Instead of putting the listview inside Scrollview, put the rest of the content between listview and the opening of the Scrollview as a separate view and set that view as the header of the listview. So you will finally end up only list view taking charge of Scroll.