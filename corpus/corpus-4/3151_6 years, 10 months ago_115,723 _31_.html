The diamond operator in java 7 allows code like the following:However in Java 5/6, I can simply write:My understanding of type erasure is that these are exactly the same. (The generic gets removed at runtime anyway). Why bother with the diamond at all? What new functionality / type safety does it allow? If it doesn\'t yield any new functionality why do they mention it as a feature? Is my understanding of this concept flawed?The issue withis that on the left hand side, you are using the generic type List<String> where on the right side you are using the raw type LinkedList. Raw types in Java effectively only exist for compatibility with pre-generics code and should never be used in new code unless \nyou absolutely have to.Now, if Java had generics from the beginning and didn\'t have types, such as LinkedList, that were originally created before it had generics, it probably could have made it so that the constructor for a generic type automatically infers its type parameters from the left-hand side of the assignment if possible. But it didn\'t, and it must treat raw types and generic types differently for backwards compatibility. That leaves them needing to make a slightly different, but equally convenient, way of declaring a new instance of a generic object without having to repeat its type parameters... the diamond operator.As far as your original example of List<String> list = new LinkedList(), the compiler generates a warning for that assignment because it must. Consider this:Generics exist to provide compile-time protection against doing the wrong thing. In the above example, using the raw type means you don\'t get this protection and will get an error at runtime. This is why you should not use raw types.The diamond operator, however, allows the right hand side of the assignment to be defined as a true generic instance with the same type parameters as the left side... without having to type those parameters again. It allows you to keep the safety of generics with almost the same effort as using the raw type.I think the key thing to understand is that raw types (with no <>) cannot be treated the same as generic types. When you declare a raw type, you get none of the benefits and type checking of generics. You also have to keep in mind that generics are a general purpose part of the Java language... they don\'t just apply to the no-arg constructors of Collections!Your understanding is slightly flawed. The diamond operator is a nice feature as you don\'t have to repeat yourself. It makes sense to define the type once when you declare the type but just doesn\'t make sense to define it again on the right side. The DRY principle.Now to explain all the fuzz about defining types. You are right that the type is removed at runtime but once you want to retrieve something out of a List with type definition you get it back as the type you\'ve defined when declaring the list otherwise it would lose all specific features and have only the Object features except when you\'d cast the retrieved object to it\'s original type which can sometimes be very tricky and result in a ClassCastException.Using List<String> list = new LinkedList() will get you rawtype warnings.This line causes the [unchecked] warning:So, the question transforms: why [unchecked] warning is not suppressed automatically only for the case when new collection is created?I think, it would be much more difficult task then adding <> feature. UPD: I also think that there would be a mess if it were legally to use raw types \'just for a few things\'.In theory, the diamond operator allows you to write more compact (and readable) code by saving repeated type arguments. In practice, it\'s just two confusing chars more giving you nothing. Why?IMHO, having a clear and simple way to mark a source as Java 7 would be more useful than inventing such strange things. In so marked code raw types could be forbidden without losing anything.Btw., I don\'t think that it should be done using a compile switch. The Java version of a program file is an attribute of the file, no option at all. Using something as trivial ascould make it clear (you may prefer something more sophisticated including one or more fancy keywords). It would even allow to compile sources written for different Java versions together without any problems. It would allow introducing new keywords (e.g., "module") or dropping some obsolete features (multiple non-public non-nested classes in a single file or whatsoever) without losing any compatibility.When you write List<String> list = new LinkedList();, compiler produces an "unchecked" warning. You may ignore it, but if you used to ignore these warnings you may also miss a warning that notifies you about a real type safety problem.So, it\'s better to write a code that doesn\'t generate extra warnings, and diamond operator allows you to do it in convenient way without unnecessary repetition.The point for diamond operator is simply to reduce typing of code when declaring generic types. It doesn\'t have any effect on runtime whatsoever.The only difference if you specify in Java 5 and 6,  is that you have to specify @SuppressWarnings("unchecked") to the list (otherwise you will get an unchecked cast warning). My understanding is that diamond operator is trying to make development easier. It\'s got nothing to do on runtime execution of generics at all.All said in the other responses are valid but the use cases are not completely valid IMHO. If one checks out Guava  and especially the collections related stuff, the same has been done with static methods. E.g. Lists.newArrayList() which allows you to writeor with static importGuava has other very powerful features like this and I actually can\'t think of much uses for the <>.It would have been more useful if they went for making the diamond operator behavior the default, that is, the type is inferenced from the left side of the expression or if the type of the left side was inferenced from the right side. The latter is what happens in Scala.