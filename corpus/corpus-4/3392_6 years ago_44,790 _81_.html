On my Lion app, I have this data model:The relationship subitems inside Item is ordered.Xcode 4.1 (build 4B110) has created for me the file Item.h, Item.m, SubItem.h and SubItem.h.Here is the content (autogenerated) of Item.h:And here is the content (autogenerated) of Item.m:As you can see, the class Item offers a method called addSubitemsObject:. Unfortunately, when trying to use it in this way:this error appear:Can you help me?Update:After just 1,787 days from my bug report, today (August 1, 2016) Apple wrote me this: "Please verify this issue with the latest iOS 10 beta build and update your bug report at bugreport.apple.com with your results.". Let\'s hope this is the right time :)I reproduced your setup both with your data model and one of my own with different names. I got the same error in both cases. Looks like a bug in Apple\'s autogenerated code. I agree that there may be a bug here. I\'ve modified the implementation of the add object setter to append correctly to a NSMutableOrderedSet.Reassigning the set to self.subitems will ensure that the Will/DidChangeValue notifications are sent.I\'ve decided to improve the solution by implementing all the required methods:Yes, this is definitely a Core Data bug. I wrote up an ObjC-Runtime-based fix a while back, but at the time I figured it would be fixed soon. Anyway, no such luck, so I posted it up on GitHub as KCOrderedAccessorFix. Work around the problem on all your entities:One entity in particular:Or just for one relationship:Instead to making a copy I suggest to use the accessor in NSObject to get access to the NSMutableOrderedSet of the relationships.e.g. the Core Data Release Notes for iOS v5.0 refer to this.In a short test it worked in my application.I\'ve tracked the bug. It occurs in willChangeValueForKey:withSetMutation:usingObjects:.This call sets off a chain of notifications which may be difficult to track, and of course changes to one responder may have implications for another, which I suspect is why Apple have done nothing. However, it is okay in Set and its only the Set operations on an OrderedSet that malfunction. That means there are only four methods that need to be altered. Therefore, all I did was convert the Set operations to their equivalent Array operations. These work perfectly and minimal (but necessary) overheads.On a critical level, this solution does suffer from one critical flaw; if you are adding objects and one of the objects already exists, then it is either not added or moved to the back of the ordered list (I don\'t know which). In either case, the expected ordered index of the object by the time we arrive at didChange is different from what was anticipated. This may break some people\'s apps, but it doesn\'t affect mine, since I am only ever adding new objects or I confirm their final locations before I add them.Of course, there is an easier solution. it is as follows;The Apple docs To Many Relations says: you should access the proxy mutable set or ordered set usingModifying this set will add or remove relations to your managed object. Accessing the mutable ordered set using the accessor whether with [ ] or . notation is wrong and will fail.Received the same error, @LeeIII solution worked for me (thanks!). I suggest slightly modify it:Content of Item+category.m:If you are using mogenerator, then instead ofsimply use:Personally I have just replaced the calls to the CoreData generated methods with direct calls to the method as outlined in another solution by @Stephan:This removes the need for categories that might later conflict with a solution from Apple to the generated code when the bug is fixed.This has the added plus of being the official way to do it!It seems that if you link the parent with the child by setting the parent to the child and not the other way around it works without crashing.So if you do:instead ofIt should work, at least it works on iOS 7 and didn\'t had any problems with the relationship.I have had the same problem, but only when I tried something different to what I had been doing. I can\'t see the code for subItem, but I will assume that it has a reverse link to item. Lets call this reveres link, "parentItem", then the easiest solution is this:The effect is that it makes use of apple\'s own code and it is simple and clean. In addition, the set is automatically added to, and all observers are updated. No problem.I just fell foul of this issue, and resolved it using a much simpler implementation than the others outlined here. I simply make use of the methods available on NSManagedObject for dealing with relationships when not using subclasses.An example implementation for inserting an entity into an NSOrderedSet relationship would look like this:This works perfectly, and is what I was using before I moved to NSManagedObject subclasses.I agree that there maybe a bug here. I\'ve modified the implementation of the add object >setter to append correctly to a NSMutableOrderedSet.Reassigning the set to self.subitems will ensure that the Will/DidChangeValue notifications >are sent.Leelll, are you sure that after such custom setup of NSMutableOrderedSet values stored in that set will be saved to the database correctly by CoreData? I didn\'t check that, but it looks like CoreData knows nothing about NSOrderedSet and expects NSSet as to-many relationship container.I think everybody is missing the real problem. It is not in the accessor methods but rather in the fact that NSOrderedSet is not a subclass of NSSet. So when -interSectsSet: is called with an ordered set as argument it fails.fails with *** -[NSSet intersectsSet:]: set argument is not an NSSetLooks like the fix is to change the implementation of the set operators so they handle the types transparently. No reason why a -intersectsSet: should work with either an ordered or unordered set. The exception happens in the change notification. Presumably in the code that handles the inverse relationship. Since it only happens if I set an inverse relationship. The following did the trick for meI just got the problem in Swift (Xcode 6.1.1).The answer was DO NOT CODE ANY METHOD OR ADDITIONAL THINGS in your NSManagedObject subclasses. I think it is a compilator mistake. Very strange bug ..Hope it helps ..This issue occurred to me while migrating a project from Objective-C to Swift 2 with XCode 7. That project used to work, and for a good reason: I was using MOGenerator which had replacement methods to fix this bug. But not all methods require a replacement.So here\'s the complete solution with an example class, relying on default accessors as much as possible.Let\'s say we have a List with ordered ItemsFirst a quick win if you have a one/to-many relationship, the easiest is to just do:instead ofNow, if that\'s not an option, here\'s what you can do:Of course, if you\'re using Objective-C, you can do the exact same thing since this is where I got the idea in the first place :)I solved this problem by set the inverse to No Inverse, I don\'t know why, Maybe there is Apple Bug.I have the same situation with an item called "signals" instead of "subitems". The solution with tempset works in my testing. Further, I had a problem with the removeSignals: method. This override seems to work:If there is a better way to do this, please let me know. My values input is never more than 10 -20 items so performance isn\'t much of a concern - nonetheless please point out anything relevant.Thanks,DamienI found this question by googling for the error message, and just wanted to point out that I ran into this error in a slightly different way (not using ordered sets). This isn\'t quite an answer to the given question, but I\'m posting it here just in case it is helpful to anyone else who stumbles across this question while searching.I was adding a new model version, and added some relationships to existing models, and defined the add*Object methods in the header file myself. When I tried to call them, I got the error above.After reviewing my models, I realized I had stupidly forgotten to check the "To-Many Relationship" checkbox.So if you\'re running into this and you\'re not using ordered sets, double check your model. I found a fix for this bug that works for me. I just replace this:with this:I found using the method by LeeIII worked, but on profiling found it was drastically slow.  It took 15 seconds to parse 1000 items.  Commenting out the code to add the relationship turned 15 seconds into 2 seconds.  My workaround (which is faster but much more ugly) involves creating a temporary mutable array then copying into the ordered set when all the parsing is done.  (this is only a performance win if you are going to add many relationships).I hope this help someone else!Robert,I agree your answer will work for this, but keep in mind that there is an automatically created method for adding a whole set of values to a relationship already. Apple\'s Documentation (as seen here under the "To-many Relationships" section or here under the "Custom To-Many Relationship Accessor Methods" section) implements them this way:You could easily compile your set of relationships outside of core data and then add them all at once using this method. It might be less ugly than the method you suggested ;)I\'m quite sure it is finally fixed in iOS 10 beta 6!