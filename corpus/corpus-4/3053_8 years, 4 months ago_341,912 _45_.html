What is the difference between the following declarations:What is the general rule for understanding more complex declarations?The third one is same as the first.The general rule is operator precedence. It can get even much more complex as function pointers come into the picture.Use the cdecl program, as suggested by K&R.It works the other way too.I don\'t know if it has an official name, but I call it the Right-Left Thingy(TM).Start at the variable, then go right, and left, and right...and so on.arr1 is an array of 8 pointers to integers.arr2 is a pointer (the parenthesis block the right-left) to an array of 8 integers.arr3 is an array of 8 pointers to integers.This should help you out with complex declarations.The answer for the last two can also be deducted from the golden rule in C:Declaration follows use.int (*arr2)[8];What happens if you dereference arr2? You get an array of 8 integers.int *(arr3[8]);What happens if you take an element from arr3? You get a pointer to an integer.This also helps when dealing with pointers to functions. To take sigjuice\'s example:float *(*x)(void )What happens when you dereference x? You get a function that you can call with no arguments. What happens when you call it? It will return a pointer to a float.Operator precedence is always tricky, though. However, using parentheses can actually also be confusing because declaration follows use. At least, to me, intuitively arr2 looks like an array of 8 pointers to ints, but it is actually the other way around. Just takes some getting used to. Reason enough to always add a comment to these declarations, if you ask me :)edit: exampleBy the way, I just stumbled across the following situation: a function that has a static matrix and that uses pointer arithmetic to see if the row pointer is out of bounds. Example:Output:Note that the value of border never changes, so the compiler can optimize that away. This is different from what you might initially want to use: const int (*border)[3]: that declares border as a pointer to an array of 3 integers that will not change value as long as the variable exists. However, that pointer may be pointed to any other such array at any time. We want that kind of behaviour for the argument, instead (because this function does not change any of those integers). Declaration follows use.(p.s.: feel free to improve this sample!)As a rule of thumb, right unary operators (like [], (), etc) take preference over left ones.  So, int *(*ptr)()[]; would be a pointer that points to a function that returns an array of pointers to int (get the right operators as soon as you can as you get out of the parenthesis)Here\'s how i interpret it:note on precedence: array subscript operator (\'[ ]\') has higher priority than\n  dereference operator (\'*\').So, here we will apply the \'[ ]\' before \'*\', making the statement equivalent to:note on how a declaration makes sense: int num means (num) is an (int), int *ptr or int (*ptr) means, (value at ptr) is\n  an (int), which makes ptr a pointer to int.This can be read as, (value of the (value at ith index of the something)) is an integer. So, (value at the ith index of something) is an (integer pointer), which makes the something an array of integer pointers.In the second one,To make sense out of this statement, you must be familiar with this fact:note on pointer representation of array: somethingElse[i] is equivalent to *(somethingElse + i)So, replacing somethingElse with (*something), we get *(*something + i), which is an integer as per declaration. So, (*something) given us an array, which makes something equivalent to (pointer to an array).I think we can use the simple rule .." ptr is a pointer to " \ngo towards right ..its ")" now go left its a "("\ncome out go right  "()" so\n" to a function which takes no arguments " go left "and returns a pointer " go right "to \nan array" go left " of integers "I guess the second declaration is confusing to many. Here\'s an easy way to understand it.Lets have an array of integers, i.e. int B[8].Let\'s also have a variable A which points to B. Now, value at A is B, i.e. (*A) == B. Hence A points to an array of integers. In your question, arr is similar to A.Similarly, in int* (*C) [8], C is a pointer to an array of pointers to integer.In pointer to an integer if pointer is incremented then it goes next integer.in array of pointer if pointer is incremented it jumps to next array