Can I pass variables to a GNU Makefile as command line arguments? In other words, I want to pass some arguments which will eventually become variables in the Makefile.You have several options to set up variables from outside your makefile:From environment - each environment variable is transformed into a makefile variable with the same name and value.You may also want to set -e option (aka --environments-override) on, and your environment variables will override assignments made into makefile (unless these assignments themselves use the override directive .  However, it\'s not recommended, and it\'s much better and flexible to use ?= assignment (the conditional variable assignment operator, it only has an effect if the variable is not yet defined):Note that certain variables are not inherited from environment:From command line - make can take variable assignments as part of his command line, mingled with targets:But then all assignments to FOO variable within the makefile will be ignored unless you use the override directive in assignment. (The effect is the same as with -e option for environment variables).Exporting from the parent Make - if you call Make from a Makefile, you usually shouldn\'t explicitly write variable assignments like this:Instead, better solution might be to export these variables.  Exporting a variable makes it into the environment of every shell invocation, and Make calls from these commands pick these environment variable as specified above.You can also export all variables by using export without arguments.The simplest way is:Then in your makefile you can refer to $(foo). Note that this won\'t propagate to sub-makes automatically.If you are using sub-makes, see this article: Communicating Variables to a Sub-makeSay you have a makefile like this:You would then call it make action argument=somethingFrom the manual:Variables in make can come from the environment in which make is run. Every environment variable that make  sees when it starts up is transformed into a make variable with the same name and value. However, an explicit assignment in the makefile, or with a command argument, overrides the environment.So you can do (from bash):resulting in a variable FOOBAR in your Makefile.If you make a file called Makefile and add a variable like this $(unittest)\nthen you will be able to use this variable inside the Makefile even with wildcardsexample :I use BOOST_TEST and by giving a wildcard to parameter --run_test=$(unittest) \nthen I will be able to use regular expression to filter out the test I want my Makefile\nto runThen use the variable, $(ROOT_DIR) in the Makefile.There\'s another option not cited here which is included in the GNU Make book by Stallman and McGrath (see http://www.chemie.fu-berlin.de/chemnet/use/info/make/make_7.html). It provides the example:It involves verifying if a given parameter appears in MAKEFLAGS. For example .. suppose that you\'re studying about threads in c++11 and you\'ve divided your study across multiple files (class01, ... , classNM) and you want to: compile then all and run individually or compile one at a time and run it if a flag is specified (-r, for instance). So, you could come up with the following Makefile:Having that, you\'d: