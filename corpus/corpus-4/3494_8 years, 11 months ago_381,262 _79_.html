How can I find local IP addresses (i.e. 192.168.x.x or 10.0.x.x) in Python platform independently and using only the standard library?This won\'t work always (returns 127.0.0.1 on machines having the hostname in /etc/hosts as 127.0.0.1), a paliative would be what gimel shows, use socket.getfqdn() instead. Of course your machine needs a resolvable hostname.I just found this but it seems a bit hackish, however they say tried it on *nix and I did on windows and it worked.This assumes you have an internet access, and that there is no local proxy.I\'m using this, because one of the computers I was on had an /etc/hosts with duplicate entries and references to itself. socket.gethostbyname() only returns the last entry in /etc/hosts. This solution weeds out the ones starting with "127.". \nWorks with Python 3 and 2.5, possibly other versions too. Does not deal with several network devices or IPv6. Works on Linux and Windows.Update: The above technique stopped working on recent Linux distros. This can be used instead:Update: Created a long one-liner that combines the two one-liners above. Should work everywhere (Linux, Windows, OS X, Python 2.x and Python 3):Note that this may throw an exception if no IP is configured.Finally, as an alias called myip:You can use the netifaces module. Just type:in your command shell and it will install itself on default Python installation.Then you can use it like this:On my computer it printed:Author of this module claims it should work on Windows, UNIX and Mac OS X.This function returns the "primary" IP on the local box (the one with a default route).Python 2 or 3:This returns a single IP which is the primary (the one with a default route). If you need instead all IP\'s attached to all interfaces (including localhost, etc), see this answer.If you are behind a NAT firewall like your wifi box at home, then this will not show your public NAT IP, but instead your private NAT IP on the local network which has a default route to your local WIFI router; getting your wifi router\'s external IP would either require running this on THAT box, or connecting to an external service such as whatismyip.com/whatismyipaddress.com that could reflect back the IP... but that is completely different from the original question. :)Updated connect() call per Pedro\'s suggestion in comments. (If you need a specific license statement, this is public domain/free for any use, or MIT/CC2-BY-SA per Stack Overflow\'s code/content license at your option.)Socket API methodDownsides:Reflector method(Do note that this does not answer the OP\'s question of the local IP address, e.g. 192.168...; it gives you your public IP address, which might be more desirable depending on use case.)You can query some site like whatismyip.com (but with an API), such as:or if using python2:Advantages:Disadvantages (and workarounds):edit: Though initially I thought these methods were really bad (unless you use many fallbacks, the code may be irrelevant many years from now), it does pose the question "what is the internet?". A computer may have many interfaces pointing to many different networks. For a more thorough description of the topic, google for gateways and routes. A computer may be able to access an internal network via an internal gateway, or access the world-wide web via a gateway on for example a router (usually the case). The local IP address that the OP asks about is only well-defined with respect to a single link layer, so you have to specify that ("is it the network card, or the ethernet cable, which we\'re talking about?"). There may be multiple non-unique answers to this question as posed. However the global IP address on the world-wide web is probably well-defined (in the absence of massive network fragmentation): probably the return path via the gateway which can access the TLDs.On Linux:If the computer has a route to the Internet, this will always work to get the preferred local ip address, even if /etc/hosts is not set correctly.I use this on my ubuntu machines:im using following module:Tested with windows and linux (and doesnt require additional modules for those)\nintended for use on systems which are in a single IPv4 based LAN.The fixed list of interface names does not work for recent linux versions, which have adopted the systemd v197 change regarding predictable interface names as pointed out by Alexander.\nIn such cases, you need to manually replace the list with the interface names on your system, or use another solution like netifaces.If you don\'t want to use external packages and don\'t want to rely on outside Internet servers, this might help. It\'s a code sample that I found on Google Code Search and modified to return required information:Usage:As it relies on windll, this will work only on Windows.On Debian (tested) and I suspect most Linux\'s..On MS Windows (tested) A version I do not believe that has been posted yet. \nI tested with python 2.7 on Ubuntu 12.04.Found this solution at : http://code.activestate.com/recipes/439094-get-the-ip-address-associated-with-a-network-inter/Example Result:get_ip_address(\'eth0\')\n          \'38.113.228.130\'One simple way to produce "clean" output via command line utils:It will show all IPv4 addresses on the system.FYI I can verify that the method:Works in OS X (10.6,10.5), Windows XP, and on a well administered RHEL department server.  It did not work on a very minimal CentOS VM that I just do some kernel hacking on.  So for that instance you can just check for a 127.0.0.1 address and in that case do the following:And then parse the ip address from the output.  It should be noted that ifconfig is not in a normal user\'s PATH by default and that is why I give the full path in the command.  I hope this helps.I\'m afraid there aren\'t any good platform independent ways to do this other than connecting to another computer and having it send you your IP address.  For example:  findmyipaddress.  Note that this won\'t work if you need an IP address that\'s behind NAT unless the computer you\'re connecting to is behind NAT as well.Here\'s one solution that works in Linux:  get the IP address associated with a network interface.This will work on most linux boxes:This is a variant of UnkwnTech\'s answer -- it provides a get_local_addr() function, which returns the primary LAN ip address of the host. I\'m posting it because this adds a number of things: ipv6 support, error handling, ignoring localhost/linklocal addrs, and uses a TESTNET addr (rfc5737) to connect to.Variation on ninjagecko\'s answer. This should work on any LAN that allows UDP broadcast and doesn\'t require access to an address on the LAN or internet.127.0.1.1 is your real IP address. More generally speaking, a computer can have any number of IP addresses. You can filter them for private networks - 127.0.0.0/8, 10.0.0.0/8, 172.16.0.0/12 and 192.168.0.0/16.However, there is no cross-platform way to get all IP addresses. On Linux, you can use the SIOCGIFCONF ioctl.A slight refinement of the commands version that uses the IP command, and returns IPv4 and IPv6 addresses:This answer is my personal attempt to solve the problem of getting the LAN IP, since socket.gethostbyname(socket.gethostname()) also returned 127.0.0.1. This method does not require Internet just a LAN connection. Code is for Python 3.x but could easily be converted for 2.x. Using UDP Broadcast:Well you can use the command "ip route" on GNU/Linux to know your current IP address.This shows the IP given to the interface by the DHCP server running on the router/modem. Usually "192.168.1.1/24" is the IP for local network where "24" means the range of posible IP addresses given by the DHCP server within the mask range.Here\'s an example: Note that PyNotify is just an addition to get my point straight and is not required at allThe advantage of this is that you don\'t need to specify the network interface. That\'s pretty useful when running a socket serverYou can install PyNotify using easy_install or even Pip:oror within python script/interpreternetifaces is available via pip and easy_install.  (I know, it\'s not in base, but it could be worth the install.)netifaces does have some oddities across platforms:Here\'s some netifaces code to play with:The above code doesn\'t map an address back to its interface name (useful for generating ebtables/iptables rules on the fly).  So here\'s a version that keeps the above information with the interface name in a tuple:And, no, I\'m not in love with list comprehensions.  It\'s just the way my brain works these days.The following snippet will print it all out:Enjoy!To get the ip address you can use a shell command directly in python:I had to solve the problem "Figure out if an IP address is local or not", and my first thought was to build a list of IPs that were local and then match against it. This is what led me to this question. However, I later realized there is a more straightfoward way to do it: Try to bind on that IP and see if it works.I know this doesn\'t answer the question directly, but this should be helpful to anyone trying to solve the related question and who was following the same train of thought. This has the advantage of being a cross-platform solution (I think).For a list of IP addresses on *nix systems,Though it\'s a bit late for this answer, I thought someone else may find it useful :-)PS : It\'ll return Broadcast addresses and Netmask as well.Note: This is not using the standard library, but quite simple.$ pip install pif