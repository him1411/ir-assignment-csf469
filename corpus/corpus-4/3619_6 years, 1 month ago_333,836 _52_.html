I\'m fairly new to Node.js and I am having some issues.I am using Node.js 4.10 and Express 2.4.3.When I try to access http://127.0.0.1:8888/auth/facebook, i\'ll be redirected to http://127.0.0.1:8888/auth/facebook_callback.I then received the following error:The following is my code:May I know what is wrong with my code?I\'m really new to this, so sorry for just putting up the code here.Thank you all in advance.The res object in Express is a subclass of Node.js\'s http.ServerResponse (read the http.js source). You are allowed to call res.setHeader(name, value) as often as you want until you call res.writeHead(statusCode). After writeHead, the headers are baked in and you can only call res.write(data), and finally res.end(data).The error "Error: Can\'t set headers after they are sent." means that you\'re already in the Body or Finished state, but some function tried to set a header or statusCode. When you see this error, try to look for anything that tries to send a header after some of the body has already been written. For example, look for callbacks that are accidentally called twice, or any error that happens after the body is sent.In your case, you called res.redirect(), which caused the response to become Finished. Then your code threw an error (res.req is null). and since the error happened within your actual function(req, res, next) (not within a callback), Connect was able to catch it and then tried to send a 500 error page. But since the headers were already sent, Node.js\'s setHeader threw the error that you saw.Response must be in Head and remains in Head:Response must be in Head and becomes Body:Response can be in either Head/Body and remains in Body:Response can be in either Head/Body and becomes Finished:Response can be in either Head/Body and remains in its current state:Response must be in Head and becomes Finished:I ran into this error as well for a while.  I think (hope) I\'ve wrapped my head around it, wanted to write it here for reference.When you add middleware to connect or express (which is built on connect) using the app.use method, you\'re appending items to Server.prototype.stack in connect (At least with the current npm install connect, which looks quite different from the one github as of this post).  When the server gets a request, it iterates over the stack, calling the (request, response, next) method.The problem is, if in one of the middleware items writes to the response body or headers (it looks like it\'s either/or for some reason), but doesn\'t call response.end() and you call next() then as the core Server.prototype.handle method completes, it\'s going to notice that:So, it throws an error.  But the error it throws is just this basic response (from the connect http.js source code:Right there, it\'s calling res.setHeader(\'Content-Type\', \'text/plain\');, which you are likely to have set in your render method, without calling response.end(), something like:The way everything needs to be structured is like this:The problematic middleware sets the response header without calling response.end() and calls next(), which confuses connect\'s server.I had this same issue and realised it was because I was calling res.redirect without a return statement, so the next function was also being called immediately afterwards:Which should have been:Lots of people hit this error.  It\'s a confusing this with async processing.  Most likely some of your code is setting headers in the first tick and then you are running an async callback in a future tick. In between, the response header gets sent, but then further headers (like a 30X redirect) try to add extra headers, but it\'s too late since the response header has already been transmitted.I\'m not sure exactly what\'s causing your error, but look at any callbacks as potential areas to investigate.One easy tip to simplify your code. Get rid of app.configure() and just call app.use directly in your top level scope.See also the everyauth module, which does Facebook and a dozen or so other 3rd party authentication providers.I boiled my head over this issue and it has happened due to a careless mistake on handling the callbacks. non returned callbacks cause the response to be set twice.!My program had a code which validate request and query the DB. after validating if error is there,  I was calling back the index.js with the validation errors . \nAnd if validation passes it goes ahead and hit the db with success/failure. What was happening is : Incase validation fails the callback get called and response get set. But not returned. So it still continues the method goes to db and hit success/failure . It  calls the same callback again causing the response to be set twice now. So solution is simple, you need to \'return\' the callback so that the method don\'t continue executing, once the error has occurred and hence set the response object once This type of error you will get when you pass statements after sending a response.For example:       Will result in the error you are seeing, because once the response has been sent, the following res.send will not be executed.If you want do anything, you should do it before sending the response.In my case it was a 304 response (caching) that was causing the issue.  Easiest solution:Alternate solution here if you want more control:http://vlasenko.org/2011/10/12/expressconnect-static-set-last-modified-to-now-to-avoid-304-not-modified/For anyone that\'s coming to this and none of the other solutions helped, in my case this manifested on a route that handled image uploading but didn\'t handle timeouts, and thus if the upload took too long and timed out, when the callback was fired after the timeout response had been sent, calling res.send() resulted in the crash as the headers were already set to account for the timeout.This was easily reproduced by setting a very short timeout and hitting the route with a decently-large image, the crash was reproduced every time.In my case this happened with React and postal.js when I didn\'t unsubscribe from a channel in the componentWillUnmount callback of my React component.Just leaned this. You can pass the responses through this function:This happens when response was delivered to client and again you are trying to give response. You have to check in your code that somewhere you are returning response to client again which causes this error. Check and return response once when you want to return.Sometimes you may get this error when you try to call next() function after res.end or res.send , try to delete if you have next() after res.send or res.end in your function.\nNote: here next() means after responding to the client with your response(i.e res.send or res.end) you are still trying to execute some code to respond again so it is not legal.Example : remove next() from above function and it will work.simple answer from visionmedia: https://github.com/visionmedia/express/issues/634Add this middlware and it will work