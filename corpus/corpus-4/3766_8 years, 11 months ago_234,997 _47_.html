What would be the quickest way to construct a python binding to a C or C++ library?(using windows if this matters)You should have a look at Boost.Python, here is the short introdution taken from their website:The Boost Python Library is a framework for interfacing Python and\n  C++. It allows you to quickly and seamlessly expose C++ classes\n  functions and objects to Python, and vice-versa, using no special\n  tools -- just your C++ compiler. It is designed to wrap C++ interfaces\n  non-intrusively, so that you should not have to change the C++ code at\n  all in order to wrap it, making Boost.Python ideal for exposing\n  3rd-party libraries to Python. The library\'s use of advanced\n  metaprogramming techniques simplifies its syntax for users, so that\n  wrapping code takes on the look of a kind of declarative interface\n  definition language (IDL).I like ctypes a lot, swig always tended to give me problems. Also ctypes has the advantage that you don\'t need to satisfy any compile time dependency on python, and your binding will work on any python that has ctypes, not just the one it was compiled against.Suppose you have a simple C++ example class you want to talk to in a file called foo.cpp:Since ctypes can only talk to C functions, you need to provide those declaring them as extern "C"Next you have to compile this to a shared libraryAnd finally you have to write your python wrapper (e.g. in fooWrapper.py)Once you have that you can call it likeThe quickest way to do this is using SWIG.Example from SWIG tutorial:Interface file:Building a Python module on Unix:Usage:Note that you have to have python-dev. Also in some systems python header files will be in /usr/include/python2.7 based on the way you have installed it.From the tutorial:SWIG is a fairly complete C++ compiler with support for nearly every language feature. This includes preprocessing, pointers, classes, inheritance, and even C++ templates. SWIG can also be used to package structures and classes into proxy classes in the target language \xe2\x80\x94 exposing the underlying functionality in a very natural manner.I started my journey in the python <-> C++ binding from this page, with the objective of linking high level data types (multidimensional STL vectors with python lists) :-)Having tried the solutions based on both ctypes and boost.python (and not being a software engineer) I have found them complex when high level datatypes binding is required, while I have found swig much more simple for such cases.\nThis example uses therefore SWIG and it has been tested in Linux (but swig is available and is widely used in Windows too).The objective is to make available to python a C++ function that takes a matrix in form of a 2D STL vector and returns an average of each row (as a 1D STL vector).The code in C++ ("code.cpp") is as follow:The equivalent header ("code.h") is:We first compile the C++ code to create an object file:We then define a swig interface definition file ("code.i") for our C++ functions.Using swig, we generate a C++ interface source code from the swig interface definition file..We finally compile the generated C++ interface source file and link everything together to generate a shared library that is directly importable by python (the "_" matters):We can now use the function in python scripts:Check out pyrex or cython.  They\'re python-like languages for interfacing between C/C++ and python.I\xe2\x80\x99ve never used it but I\xe2\x80\x99ve heard good things about ctypes. If you\xe2\x80\x99re trying to use it with C++, be sure to evade name mangling via extern "C". Thanks for the comment, Florian B\xc3\xb6sch.This paper, claiming python to be all a scientist needs, basically says: first prototype everything in Python. Then when you need to speed a part up, use SWIG and translate this part to C.I think cffi for python can be an option.The goal is to call C code from Python. You should be able to do so\n  without learning a 3rd language: every alternative requires you to\n  learn their own language (Cython, SWIG) or API (ctypes). So we tried\n  to assume that you know Python and C and minimize the extra bits of\n  API that you need to learn.http://cffi.readthedocs.org/en/release-0.7/There is also pybind11, which is like a lightweight version of Boost and compatible with all modern C++ compilers : https://pybind11.readthedocs.io/en/latest/ The question is how to call a C function from Python, if I understood correctly. Then the best bet are Ctypes (BTW portable across all variants of Python).For a detailed guide you may want to refer to my blog article.Cython is definitely the way to go, unless you anticipate writing Java wrappers, in which case SWIG may be preferable.  I recommend using the runcython command line utility, it makes the process of using Cython extremely easy.  If you need to pass structured data to C++, take a look at Google\'s protobuf library, it\'s very convenient.  Here is a minimal examples I made that uses both tools: https://github.com/nicodjimenez/python2cppHope it can be a useful starting point.  First you should decide what is your particular purpose. The official Python documentation on extending and embedding the Python interpreter was mentioned above, I can add a good overview of binary extensions. The use cases can be divided into 3 categories:In order to give some broader perspective for other interested and since your initial question is a bit vague ("to a C or C++ library") I think this information might be interesting to you. On the link above you can read on disadvantages of using binary extensions and its alternatives. Apart from the other answers suggested, if you want an accelerator module, you can try Numba. It works "by generating optimized machine code using the LLVM compiler infrastructure at import time, runtime, or statically (using the included pycc tool)". One of the official Python documents contains details on extending Python using C/C++.\nEven without the use of SWIG, it\xe2\x80\x99s quite straightforward and works perfectly well on Windows.