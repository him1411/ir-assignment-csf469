I\'ve tried several things already,both of which don\'t work.For all the standard library types the member function empty() is a query, not a command, i.e. it means "are you empty?" not "please throw away your contents".The clear() member function is inherited from ios and is used to clear the error state of the stream, e.g. if a file stream has the error state set to eofbit (end-of-file), then calling clear() will set the error state back to goodbit (no error).For clearing the contents of a stringstream, using:is correct, although using:is technically more efficient, because you avoid invoking the std::string constructor that takes const char*. But any compiler these days should be able to generate the same code in both cases - so I would just go with whatever is more readable.seems to work.This should be the most reliable way regardless of the compiler:You can clear the error state and empty the strignstream all in one lineThis effectively resets m to a default constructed stateI am always scoping it:my 2 cents:this seemed to work for me in xcode and dev-c++, I had a program in the form of a menu that if executed iteratively as per the request of a user will fill up a streamstring variable which would work ok the first time the code would run but would not clear the stringstream the next time the user will run the same code. but the two lines of code below finally cleared up the stringstream variable everytime before filling up the string variable. (2 hours of trial and error and google searches), btw, using each line on their own would not do the trick.It\'s a conceptual problem.Stringstream is a stream, so its iterators are forward, cannot return. In an output stringstream, you need a flush() to reinitialize it, as in any other output stream.These do not discard the data in the stringstream in gnu c++The following does empty the stringstream for me: