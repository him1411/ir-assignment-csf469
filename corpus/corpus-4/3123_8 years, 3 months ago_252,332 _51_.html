This is similar to this question:\nHow to convert int[] to Integer[] in Java?I\'m new to Java. How can i convert a List<Integer> to int[] in Java? I\'m confused because List.toArray() actually returns an Object[], which can be cast to nether Integer[] or int[].Right now I\'m using a loop to do so:I\'m sure there\'s a better way to do this.Unfortunately, I don\'t believe there really is a better way of doing this due to the nature of Java\'s handling of primitive types, boxing, arrays and generics. In particular:I believe there are libraries which have autogenerated versions of this kind of method for all the primitive types (i.e. there\'s a template which is copied for each type). It\'s ugly, but that\'s the way it is I\'m afraid :(Even though the Arrays class came out before generics arrived in Java, it would still have to include all the horrible overloads if it were introduced today (assuming you want to use primitive arrays).No one mentioned yet streams added in Java 8 so here it goes:Thought process: so now only thing we need to figure out is how to convert our Stream<Integer> (which will be returned from list.stream()) to that shiny IntStream. Here mapToInt method comes to rescue. All we need to do is provide some mapping from Integer to int. We could use something like Integer#getValue which returns int:mapToInt( (Integer i) -> i.intValue()) (or if someone prefers   mapToInt(Integer::intValue) )but similar code can be generated using unboxing, since compiler knows that result of this lambda must be int (lambda in mapToInt is implementation of ToIntFunction interface which expects body for int applyAsInt(T value) method which is expected to return int).  So we can simply writemapToInt((Integer i)->i)or simpler (since Integer i type can be inferred by compiler because List<Integer>#stream() returns Stream<Integer>)mapToInt(i -> i) In addition to Commons Lang, you can do this with Guava\'s method Ints.toArray(Collection<Integer> collection):This saves you having to do the intermediate array conversion that the Commons Lang equivalent requires yourself.The easiest way to do this is to make use of Apache Commons Lang.  It has a handy ArrayUtils class that can do what you want.  Use the toPrimitive method with the overload for an array of Integers.This way you don\'t reinvent the wheel.  Commons Lang has a great many useful things that Java left out.  Above, I chose to create an Integer list of the right size.  You can also use a 0-length static Integer array and let Java allocate an array of the right size:Slight change to your code to avoid expensive list indexing (since a List is not necessarily an ArrayList, but could be a linked list, for which random access is expensive)Here is Java 8 single line code for thisJava 8 has given us a easy way to do this via streams...Using the collections stream() function and then mapping to ints, you\'ll get an IntStream. With the IntStream we can call toArray() which gives us int []to int []to IntStreamI\'ll throw one more in here. I\'ve noticed several uses of for loops, but you don\'t even need anything inside the loop. I mention this only because the original question was trying to find less verbose code.If Java allowed multiple declarations in a for loop the way C++ does, we could go a step further and do for(int i = 0, Iterator it...In the end though (this part is just my opinion), if you are going to have a helping function or method to do something for you, just set it up and forget about it. It can be a one-liner or ten; if you\'ll never look at it again you won\'t know the difference.If you are simply mapping an Integer to an int then you should consider using parallelism, since your mapping logic does not rely on any variables outside its scope.Just be aware of this Note that parallelism is not automatically faster than performing operations serially, although it can be if you have enough data and processor cores. While aggregate operations enable you to more easily implement parallelism, it is still your responsibility to determine if your application is suitable for parallelism.There are two ways to map Integers to their primitive form:Via a ToIntFunction.Via explicit unboxing with lambda expression.Via implicit (auto-) unboxing with lambda expression.Given a list with a null valueHere are three options to handle null:Filter out the null values before mapping.Map the null values to a default value.Handle null inside the lambda expression.This simple loop is always correct! no bugsThere is really no way of "one-lining" what you are trying to do because toArray returns an Object[] and you cannot cast from Object[] to int[] or Integer[] to int[]try also Dollar (check this revision):Using a lambda you could do this (compiles in jdk lambda):I would recommend you to use List<?> skeletal implementation from the java collections API, it appears to be quite helpful in this particular case:Beware of boxing/unboxing drawbacksWith Eclipse Collections, you can do the following if you have a list of type  java.util.List<Integer>:If you already have an Eclipse Collections type like MutableList, you can do the following:Note: I am a committer for Eclipse Collections