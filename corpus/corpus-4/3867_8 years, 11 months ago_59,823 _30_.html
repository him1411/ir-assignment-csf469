Just getting my head around Ruby metaprogramming. The mixin/modules always manage to confuse me. So is the major difference just this or is a bigger dragon lurking?\ne.g.What you have said is correct. However there is more to it than that.If you have a class Klazz and module Mod, including Mod in Klazz gives instances of Klazz access to Mod\'s methods. Or you can extend Klazz with Mod giving the class Klazz access to Mod\'s methods. But also you can extend an arbitrary object with o.extend Mod. In this case the individual object gets Mod\'s methods even though all other objects with the same class as o do not.extend - adds the specified module\'s methods and constants to the target\'s metaclass (i.e. the singleton class) \n  e.g. include - By default, it mixes in the specified module\'s methods as instance methods in the target module/class. \n  e.g.However, modules very often override include\'s behavior by monkey-patching the included method. This is very prominent in legacy Rails code. more details from Yehuda Katz. Further details about include, with its default behavior, assuming you\'ve run the following codeOf course, the ruby core documentation is always the best place to go for these things. The RubySpec project was also a fantastic resource, because they documented the functionality precisely.That\'s correct.Behind the scenes, include is actually an alias for append_features, which (from the docs):Ruby\'s default implementation is to\n  add the constants, methods, and module\n  variables of this module to aModule if\n  this module has not already been added\n  to aModule or one of its ancestors.All the other answers are good, including the tip to dig through RubySpecs:https://github.com/rubyspec/rubyspec/blob/master/core/module/include_spec.rbhttps://github.com/rubyspec/rubyspec/blob/master/core/module/extend_object_spec.rbAs for use cases:If you include module ReusableModule in class ClassThatIncludes, the methods, constants, classes, submodules, and other declarations gets referenced. If you extend class ClassThatExtends with module ReusableModule, then the methods and constants gets copied. Obviously, if you are not careful, you can waste a lot of memory by dynamically duplicating definitions.If you use ActiveSupport::Concern, the .included() functionality lets you rewrite the including class directly. module ClassMethods inside a Concern gets extended (copied) into the including class.I learned it before but appreciate it when I use it. Here is the difference:This doesn\'t work but would work if I\'ve defined it as def page_views(campaign):This works:I would also like to explain the mechanism as it works. If I am not right please correct.When we use include we are adding a linkage from our class to a module which contains some methods.Objects don\'t have methods, only clases and modules do.\nSo when a receives mesage some_method it begin search method some_method in a\'s eigen class, then in A class and then in linked to A class modules if there are some (in reverse order, last included wins).When we use extend we are adding linkage to a module in object\'s eigen class.\nSo if we use A.new.extend(MyMod) we are adding linkage to our module to A\'s instance eigen class or a\' class.\nAnd if we use A.extend(MyMod) we are adding linkage to A(object\'s, classes are also objects) eigenclass A\'.so method lookup path for a is as follows:\na => a\' => linked modules to a\' class => A.also there is a prepend method which changes lookup path:a => a\' => prepended modulesto A => A => included module to Asorry for my bad english.