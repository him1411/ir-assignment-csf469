This question already has an answer here:Is there a simple way to flatten a list of iterables with a list comprehension, or failing that, what would you all consider to be the best way to flatten a shallow list like this, balancing performance and readability?I tried to flatten such a list with a nested list comprehension, like this:But I get in trouble of the NameError variety there, because the name \'menuitem\' is not defined.  After googling and looking around on Stack Overflow, I got the desired results with a reduce statement:But this method is fairly unreadable because I need that list(x) call there because x is a Django QuerySet object.Conclusion: Thanks to everyone who contributed to this question.  Here is a summary of what I learned.  I\'m also making this a community wiki in case others want to add to or correct these observations.My original reduce statement is redundant and is better written this way:This is the correct syntax for a nested list comprehension (Brilliant summary dF!):But neither of these methods are as efficient as using itertools.chain:And as @cdleary notes, it\'s probably better style to avoid * operator magic by using chain.from_iterable like so:If you\'re just looking to iterate over a flattened version of the data structure and don\'t need an indexable sequence, consider itertools.chain and company.It will work on anything that\'s iterable, which should include Django\'s iterable QuerySets, which it appears that you\'re using in the question.Edit: This is probably as good as a reduce anyway, because reduce will have the same overhead copying the items into the list that\'s being extended. chain will only incur this (same) overhead if you run list(chain) at the end.Meta-Edit: Actually, it\'s less overhead than the question\'s proposed solution, because you throw away the temporary lists you create when you extend the original with the temporary.Edit: As J.F. Sebastian says itertools.chain.from_iterable avoids the unpacking and you should use that to avoid * magic, but the timeit app shows negligible performance difference.You almost have it! The way to do nested list comprehensions is to put the for statements in the same order as they would go in regular nested for statements.Thus, thiscorresponds toSo you want@S.Lott: You inspired me to write a timeit app.I figured it would also vary based on the number of partitions (number of iterators within the container list) -- your comment didn\'t mention how many partitions there were of the thirty items. This plot is flattening a thousand items in every run, with varying number of partitions. The items are evenly distributed among the partitions.Code (Python 2.6):Edit: Decided to make it community wiki.Note: METHODS should probably be accumulated with a decorator, but I figure it\'d be easier for people to read this way.sum(list of lists, []) would flatten it.This solution works for arbitrary nesting depths - not just the "list of lists" depth that some (all?) of the other solutions are limited to:It\'s the recursion which allows for arbitrary depth nesting - until you hit the maximum recursion depth, of course...Performance Results.  Revised.I flattened a 2-level list of 30 items 1000 timesReduce is always a poor choice.In Python 2.6, using chain.from_iterable():It avoids creating of intermediate list.There seems to be a confusion with operator.add! When you add two lists together, the correct term for that is concat, not add. operator.concat is what you need to use.If you\'re thinking functional, it is as easy as this::You see reduce respects the sequence type, so when you supply a tuple, you get back a tuple. let\'s try with a list::Aha, you get back a list.How about performance::from_iterable is pretty fast! But it\'s no comparison to reduce with concat.Off the top of my head, you can eliminate the lambda:Or even eliminate the map, since you\'ve already got a list-comp:You can also just express this as a sum of lists:Here is the correct solution using list comprehensions (they\'re backward in the question):In your case it would beor you could use join and sayIn either case, the gotcha was the nesting of the for loops.have you tried flatten?\nFrom matplotlib.cbook.flatten(seq, scalarp=) ?UPDATE\nWhich gave me another idea:So to test how effective it is when recursive gets deeper: How much deeper?I will bet "flattenlist" I am going to use this rather than matploblib for a long long time unless I want a yield generator and fast result as "flatten" uses in matploblib.cbookThis, is fast. :This version is a generator.Tweak it if you want a list.You can add a predicate ,if want to flatten those which satisfy a conditionTaken from python cookbookFrom my experience, the most efficient way to flatten a list of lists is:Some timeit comparisons with the other proposed methods:Now, the efficiency gain appears better when processing longer sublists:And this methods also works with any iterative object:What about:But, Guido is recommending against performing too much in a single line of code since it reduces readability. There is minimal, if any, performance gain by performing what you want in a single line vs. multiple lines.pylab provides a flatten:\n link to numpy flattenHere is a version working for multiple levels of list using collectons.Iterable:If each item in the list is a string (and any strings inside those strings use " " rather than \' \'), you can use regular expressions (re module)The above code converts in_list into a string, uses the regex to find all the substrings within quotes (i.e. each item of the list) and spits them out as a list.If you have to flat more complicated list with not iterable elements or with depth more than 2 you can use following function:It will return generator object which you can convert to list with list() function. Notice that yield from syntax available from python3.3 but you can use explicit iteration instead.\nExample:If you\'re looking for a built-in, simple, one-liner you can use:returnsA simple alternative is to use numpy\'s concatenate but it converts the contents to float:Test:In Python 3.4 you will be able to do:The easiest way to achieve this in either Python 2 or 3 is to use the morph library using pip install morph.The code is: