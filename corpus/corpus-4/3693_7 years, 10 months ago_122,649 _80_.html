I have been searching the web looking for a definition for declarative and imperative programming that would shed some light for me. However the language used at some of the resources that I have found is daunting - for instance at Wikipedia.\nDoes any one have a real world example that they could show me that might bring some perspective to this subject... perhaps in C#.A great C# example of declarative vs. imperative programming is LINQ.With imperative programming, you tell the compiler what you want to happen, step by step.For example, let\'s start with this collection, and choose the odd numbers:With imperative programming, we\'d step through this, and decide what we want:Here, we\'re saying:With declarative programming, on the other hand, you write code that describes what you want, but not necessarily how to get it (declare your desired results, but not the step-by-step):Here, we\'re saying "Give us everything where it\'s odd", not "Step through the collection.  Check this item, if it\'s odd, add it to a result collection."In many cases, code will be a mixture of both designs, too, so it\'s not always black-and-white.Declarative programming is when you say what you want, and imperative language is when you say how to get what you want.A simple example in Python:The first example is declarative because we do not specify any "implementation details" of building the list.To tie in a C# example, generally, using LINQ results in a declarative style, because you aren\'t saying how to obtain what you want; you are only saying what you want.  You could say the same about SQL.One benefit of declarative programming is that it allows the compiler to make decisions that might result in better code than what you might make by hand.  Running with the SQL example, if you had a query like the SQL "compiler" can "optimize" this query because it knows that id is an indexed field -- or maybe it isn\'t indexed, in which case it will have to iterate over the entire data set anyway.  Or maybe the SQL engine knows that this is the perfect time to utilize all 8 cores for a speedy parallel search.   You, as a programmer, aren\'t concerned with any of those conditions, and you don\'t have to write your code to handle any special case in that way.Declarative vs. ImperativeA programming paradigm is a fundamental style of computer programming.\nThere are four main paradigms: imperative, declarative, functional (which is considered a subset of the declarative paradigm) and object-oriented.Declarative programming : is a programming paradigm that expresses the logic of a computation(What do) without describing its control flow(How do).\nSome well-known examples of declarative domain specific languages (DSLs) include CSS, regular expressions, and a subset of SQL (SELECT queries, for example)\nMany markup languages such as HTML, MXML, XAML, XSLT... are often declarative.\nThe declarative programming try to blur the distinction between a program as a set of instructions and a program as an assertion about the desired answer.Imperative programming : is a programming paradigm that describes computation in terms of statements that change a program state. The declarative programs can be dually viewed as programming commands or mathematical assertions.Functional programming : is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids state and mutable data. It emphasizes the application of functions, in contrast to the imperative programming style, which emphasizes changes in state.\nIn a pure functional language, such as Haskell, all functions are without side effects, and state changes are only represented as functions that transform the state.The following example of imperative programming in MSDN, loops through the numbers 1 through 10, and finds the even numbers.Both examples yield the same result, and one is neither better nor worse than the other. The first example requires more code, but the code is testable, and the imperative approach gives you full control over the implementation details. In the second example, the code is arguably more readable; however, LINQ does not give you control over what happens behind the scenes. You must trust that LINQ will provide the requested result.I\'ll add another example that rarely pops up in declarative/imperative programming discussion: the User Interface!In C#, you can build an UI using various technologies.On the imperative end, you could use DirectX or OpenGL to very imperatively draw your buttons, checkboxes, etc... line-by-line (or really, triangle by triangle).  It is up to you to say how to draw the user interface.At the declarative end, you have WPF.  You basically write some XML (yeah, yeah, "XAML" technically) and the framework does the work for you.  You say what the user interface looks like.  It is up to the system to figure out how to do it.Anyway, just another thing to think about.  Just because one language is declarative or imperative does not mean that it doesn\'t have certain features of the other.Also, one benefit of declarative programming is that purpose is usually more easily understood from reading the code whereas imperative gives you finer control over execution.The gist of it all:Declarative -> what you want doneImperative -> how you want it doneImperative programming requires developers to define step by step how\n  code should be executed. To give directions in an imperative fashion,\n  you say, \xe2\x80\x9cGo to 1st Street, turn left onto Main, drive two blocks,\n  turn right onto Maple, and stop at the third house on the left.\xe2\x80\x9d The\n  declarative version might sound something like this: \xe2\x80\x9cDrive to Sue\xe2\x80\x99s\n  house.\xe2\x80\x9d One says how to do something; the other says what needs to be\n  done.The declarative style has two advantages over the imperative style:Calvert,C Kulkarni,D (2009). Essential LINQ. Addison Wesley. 48.All above answers and other online posts mention following: What they have not told us is how to achieve it. For part of the program to be more declarative, other parts must provide the abstraction to hide the implementation details (which are the imperative codes). In fact, the reason functional programming and functional libraries are more declarative is because they have abstracted away loops and list creations, hiding all the implementation details (most likely imperative codes with loops) behind the scene.In any program, you will always have both imperative and declarative codes, what we should aim for is to hide all imperative codes behind the abstractions, so that other parts of the program can use them declaratively. Finally, although functional programming and LINQ can make your program more declarative, you can always make it even more declarative by providing more abstractions. For example:I liked an explanation from a Cambridge course + their examples:In computer science, declarative programming is a programming paradigm that expresses the logic of a computation without describing its control flow.From http://en.wikipedia.org/wiki/Declarative_programmingin a nutshell the declarative language is simpler because it lacks the complexity of control flow ( loops, if statements, etc. )A good comparison is the ASP.Net \'code-behind\' model.  You have declarative \'.ASPX\' files and then the imperative \'ASPX.CS\' code files.  I often find that if I can do all I need in the declarative half of the script a lot more people can follow what\'s being done.Imperative programming is telling the computer explicitly what to do, and how to do it, like specifying order and suchC#:Declarative is when you tell the computer what to do, but not really how to do it. Datalog / Prolog is the first language that comes to mind in this regard. Basically everything is declarative. You can\'t really guarantee order.C# is a much more imperative programming language, but certain C# features are more declarative, like LinqThe same thing could be written imperatively:(example from wikipedia Linq)Stealing from Philip Roberts here:Two examples:1. Doubling all numbers in an arrayImperatively:Declaratively:2. Summing all items in a listImperativelyDeclarativelyNote how the imperative examples involve creating a new variable, mutating it, and returning that new value (i.e., how to make something happen), whereas the declarative examples execute on a given input and return the new value based on the initial input (i.e., what we want to happen).I would say that the difference, like Drazen stated, has mostly to do with the overall level of abstraction.  With declarative, at some point, you\'re so far away from the individual steps that the program has a lot of latitude regarding how to get your result.Declarative Real World Example:Imperative Real World Example:Just to add another example in terms of mobile app development. In iOS and Android we have Interface Builders, where we can define UI of the apps.The UI drawn using these Builders are declarative in nature, where we drag and drop the components. The actual draeing happens underneath and performed by the framework and system.But we can also draw the whole components in code, and that is imperative in nature.Also, some new languages like Angular JS is focussing on designing UIs declaratively and we may see a lot of other languages offering the same support. Like JAVA doesnot have any good declarative way to draw native desktop apps in JAVA swing or JAVA FX but in near future they just might.Imperative programming\nA programming language that requires programming discipline such as C/C++, Java, COBOL, FORTRAN, Perl and JavaScript. Programmers writing in such languages must develop a proper order of actions in order to solve the problem, based on a knowledge of data processing and programming.Declarative programming\nA computer language that does not require writing traditional programming logic;\nUsers concentrate on defining the input and output rather than the program steps required in a procedural programming language such as C++ or Java.  Declarative programming examples are CSS, HTML, XML, XSLT, RegX.declarative program is just a data for its some more-or-less "universal" imperative implementation/vm.pluses:\nspecifying just a data, in some hardcoded (and checked) format, is simpler and less error-prone than specifying variant of some imperative algorithm directly. some complex specifications just cant be written directly, only in some DSL form.\nbest and freq used in DSLs data structures is sets and tables. because you not have dependencies between elements/rows. and when you havent dependencies you have freedom to modify and ease of support. (compare for example modules with classes - with modules you happy and with classes you have fragile base class problem)\nall goods of declarativeness and DSL follows immediately from benefits of that data structures (tables and sets).\nanother plus - you can change implementation of declarative language vm, if DSL is more-or-less abstract (well designed). make parallel implementation, for example. or port it to other os etc. all good specifed modular isolating interfaces or protocols gives you such freedom and easyness of support.minuses:\nyou guess right. generic (and parameterized by DSL) imperative algorithm/vm implementation may be slower and/or memory hungry than specific one. in some cases.\nif that cases is rare - just forget about it, let it be slow. if it\'s frequient - you always can extend your DSL/vm for that case. somewhere slowing down all other cases, sure...P.S. Frameworks is half-way between DSL and imperative. and as all halfway solutions ... they combines deficiences, not benefits. they not so safe AND not so fast :) look at jack-of-all-trades haskell - it\'s halfway between strong simple ML and flexible metaprog Prolog and... what a monster it is. you can look at Prolog as a Haskell with boolean-only functions/predicates. and how simple its flexibility is against Haskell...I just wonder why no one has mentioned Attribute classes as a declarative programming tool in C#. The popular answer of this page has just talked about LINQ as a declarative programming tool.According to Wikipedia Common declarative languages include those of database query languages\n  (e.g., SQL, XQuery), regular expressions, logic programming,\n  functional programming, and configuration management systems.So LINQ, as a functional syntax, is definitely a declarative method, but Attribute classes in C#, as a configuration tool, are declarative too. Here is a good starting point to read more about it: Quick Overview of C# Attribute ProgrammingFrom my understanding, both terms have roots in philosophy, there are declarative and imperative kinds of knowledge. Declarative knowledge are assertions of truth, statements of fact like math axioms. It tells\nyou something. Imperative, or procedural knowledge, tells you step by step how to arrive at something. That\'s what the definition of an algorithm essentially is. If you would, compare a computer programming language with the English language. Declarative sentences state something. A boring example, but here\'s a declarative way of displaying whether two numbers are equal to each other, in Java:Imperative sentences in English, on the other hand, give a command or make some sort of request. Imperative programming, then, is just a list of commands (do this, do that). Here\'s an imperative way of displaying whether two numbers are equal to each other or not while accepting user input, in Java:Essentially, declarative knowledge skips over certain elements to form a layer of abstraction over those elements. Declarative programming does the same.