I have scripts calling other script files but I need to get the filepath of the file that is currently running within the process. For example, let\'s say I have three files. Using execfile:How can I get the file name and path of script_3.py, from code within script_3.py, without having to pass that information as arguments from script_2.py?(Executing os.getcwd() returns the original starting script\'s filepath not the current file\'s.)p1.py:p2.py:as others have said. You may also want to use:I think this is cleaner:and gets the same information as:Where [0] is the current frame in the stack (top of stack) and [1] is for the file name, increase to go backwards in the stack i.e.would be the file name of the script that called the current frame. Also, using [-1] will get you to the bottom of the stack, the original calling script.Here is an experiment based on the answers in this thread - with Python 2.7.10 on Windows.The stack-based ones are the only ones that seem to give reliable results. The last two have the shortest syntax, ie -Here\'s to these being added to sys as functions! Credit to @Usagi and @pablogBased on the following three files, and running script1.py from its folder with python script1.py (also tried execfiles with absolute paths and calling from a separate folder). C:\\testpath\\script1.py: execfile(\'script2.py\')\nC:\\testpath\\script2.py: execfile(\'lib/script3.py\')\nC:\\testpath\\lib\\script3.py:The suggestions marked as best are all true if your script consists of only one file. If you want to find out the name of the executable (i.e. the root file passed to the python interpreter for the current program) from a file that may be imported as a module, you need to do this (let\'s assume this is in a file named foo.py):import inspectprint inspect.stack()[-1][1]Because the last thing ([-1]) on the stack is the first thing that went into it (stacks are LIFO/FILO data structures).Then in file bar.py if you import foo it\'ll print bar.py, rather than foo.py, which would be the value of all of these:this will give us the filename only. i.e. if abspath of file is c:\\abcd\\abc.py then 2nd line will print abc.pyIt\'s not entirely clear what you mean by "the filepath of the file that is currently running within the process".\nsys.argv[0] usually contains the location of the script that was invoked by the Python interpreter.\nCheck the sys documentation for more details.As @Tim and @Pat Notz have pointed out, the __file__ attribute provides access tothe file from which the module was\n  loaded, if it was loaded from a fileI have a script that must work under windows environment.\nThis code snipped is what I\'ve finished with:it\'s quite a hacky decision. But it requires no external libraries and it\'s the most important thing in my case.The __file__ attribute works for both the file containing the main execution code as well as imported modules.See https://web.archive.org/web/20090918095828/http://pyref.infogami.com/__file__this would print the path of the currently executing scriptI think it\'s just __file__   Sounds like you may also want to checkout the inspect module.No need for inspect or any other library.This worked for me when I had to import a script (from a different directory then the executed script), that used a configuration file residing in the same folder as the imported script.You can use inspect.stack()This should work:I used the approach with __file__\nos.path.abspath(__file__)\nbut there is a little trick, it returns the .py file \nwhen the code is run the first time, \nnext runs give the name of *.pyc file\nso I stayed with:\ninspect.getfile(inspect.currentframe())\nor\nsys._getframe().f_code.co_filename if you want just the filename without ./ or .py you can try thisfile_name will print testscript\nyou can generate whatever you want by changing the index inside []I wrote a function which take into account eclipse debugger and unittest.\nIt return the folder of the first script you launch. You can optionally specify the __file__ var, but the main thing is that you don\'t have to share this variable across all your calling hierarchy.Maybe you can handle others stack particular cases I didn\'t see, but for me it\'s ok.To get directory of executing script  