I was recently working with a DateTime object, and wrote something like this:The intellisense documentation for AddDays() says it adds a day to the date, which it doesn\'t - it actually returns a date with a day added to it, so you have to write it like:This one has bitten me a number of times before, so I thought it would be useful to catalog the worst C# gotchas.Blammo.  Your app crashes with no stack trace. Happens all the time.(Notice capital MyVar instead of lowercase myVar in the getter.)Type.GetTypeThe one which I\'ve seen bite lots of people is Type.GetType(string). They wonder why it works for types in their own assembly, and some types like System.String, but not System.Windows.Forms.Form. The answer is that it only looks in the current assembly and in mscorlib.Anonymous methodsC# 2.0 introduced anonymous methods, leading to nasty situations like this:What will that print out? Well, it entirely depends on the scheduling. It will print 10 numbers, but it probably won\'t print 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 which is what you might expect. The problem is that it\'s the i variable which has been captured, not its value at the point of the creation of the delegate. This can be solved easily with an extra local variable of the right scope:Deferred execution of iterator blocksThis "poor man\'s unit test" doesn\'t pass - why not?The answer is that the code within the source of the CapitalLetters code doesn\'t get executed until the iterator\'s MoveNext() method is first called.I\'ve got some other oddities on my brainteasers page.A gotcha that gets lots of new developers, is the re-throw exception semantics. Lots of time I see code like the followingThe problem is that it wipes the stack trace and makes diagnosing issues much harder, cause you can not track where the exception originated. The correct code is either the throw statement with no args:Or wrapping the exception in another one, and using inner exception to get the original stack trace:The Heisenberg Watch WindowThis can bite you badly if you\'re doing load-on-demand stuff, like this:Now let\'s say you have some code elsewhere using this:Now you want to debug your CreateMyObj() method.  So you put a breakpoint on Line 3 above, with intention to step into the code.  Just for good measure, you also put a breakpoint on the line above that says _myObj = CreateMyObj();, and even a breakpoint inside CreateMyObj() itself.The code hits your breakpoint on Line 3.  You step into the code.  You expect to enter the conditional code, because _myObj is obviously null, right?  Uh... so... why did it skip the condition and go straight to return _myObj?!  You hover your mouse over _myObj... and indeed, it does have a value!  How did THAT happen?!The answer is that your IDE caused it to get a value, because you have a "watch" window open - especially the "Autos" watch window, which displays the values of all variables/properties relevant to the current or previous line of execution.  When you hit your breakpoint on Line 3, the watch window decided that you would be interested to know the value of MyObj - so behind the scenes, ignoring any of your breakpoints, it went and calculated the value of MyObj for you - including the call to CreateMyObj() that sets the value of _myObj!That\'s why I call this the Heisenberg Watch Window - you cannot observe the value without affecting it... :)GOTCHA!Edit - I feel @ChristianHayter\'s comment deserves inclusion in the main answer, because it looks like an effective workaround for this issue.  So anytime you have a lazy-loaded property...Decorate your property with [DebuggerBrowsable(DebuggerBrowsableState.Never)] or [DebuggerDisplay("")]. \xe2\x80\x93 Christian HayterHere\'s another time one that gets me:TimeSpan.Seconds is the seconds portion of the timespan (2 minutes and 0 seconds has a seconds value of 0). TimeSpan.TotalSeconds is the entire timespan measured in seconds (2 minutes has a total seconds value of 120).Leaking memory because you didn\'t un-hook events.This even caught out some senior developers I know.Imagine a WPF form with lots of things in it, and somewhere in there you subscribe to an event. If you don\'t unsubscribe then the entire form is kept around in memory after being closed and de-referenced.I believe the issue I saw was creating a DispatchTimer in the WPF form and subscribing to the Tick event, if you don\'t do a -= on the timer your form leaks memory!In this example your teardown code should have This one is especially tricky since you created the instance of the DispatchTimer inside the WPF form, so you would think that it would be an internal reference handled by the Garbage Collection process... unfortunately the DispatchTimer uses a static internal list of subscriptions and services requests on the UI thread, so the reference is \'owned\' by the static class.Maybe not really a gotcha because the behavior is written clearly in MSDN, but has broken my neck once because I found it rather counter-intuitive:This guy leaves the "nice.pic" file locked until the image is disposed. At the time I faced it I though it would be nice to load icons on the fly and didn\'t realize (at first) that I ended up with dozens of open and locked files! Image keeps track of where it had loaded the file from...How to solve this? I thought a one liner would do the job. I expected an extra parameter for FromFile(), but had none, so I wrote this...If you count ASP.NET, I\'d say the webforms lifecycle is a pretty big gotcha to me. I\'ve spent countless hours debugging poorly written webforms code, just because a lot of developers just don\'t really understand when to use which event handler (me included, sadly).overloaded == operators and untyped containers (arraylists, datasets, etc.):Solutions? always use string.Equals(a, b) when you are comparing string types using generics like List<string> to ensure that both operands are strings.DateTime.ToString("dd/MM/yyyy");  This will actually not always give you dd/MM/yyyy but instead it will take into account the regional settings and replace your date separator depending on where you are.  So you might get dd-MM-yyyy or something alike.The right way to do this is to use DateTime.ToString("dd\'/\'MM\'/\'yyyy");DateTime.ToString("r") is supposed to convert to RFC1123, which uses GMT. GMT is within a fraction of a second from UTC, and yet the "r" format specifier does not convert to UTC, even if the DateTime in question is specified as Local.This results in the following gotcha (varies depending on how far your local time is from UTC):Whoops!Moral of the story : Field initialisers are not run when deserializing an objectI saw this one posted the other day, and I think it is pretty obscure, and painful for those that don\'t knowAs that will return 0 and not 1 as most would expectWhen you start a process (using System.Diagnostics) that writes to the console, but you never read the Console.Out stream, after a certain amount of output your app will appear to hang.I\'m a bit late to this party, but I have two gotchas that have both bitten me recently:The Ticks property measures time in 10-millionths of a second (100 nanosecond blocks), however the resolution is not 100 nanoseconds, it\'s about 15ms.This code:will give you an output of (for example):Similarly, if you look at DateTime.Now.Millisecond, you\'ll get values in rounded chunks of 15.625ms:  15, 31, 46, etc.This particular behaviour varies from system to system, but there are other resolution-related gotchas in this date/time API.A great way to combine file paths, but it doesn\'t always behave the way you\'d expect.If the second parameter starts with a \\ character, it won\'t give you a complete path:This code:Gives you this output:No operator shortcuts in Linq-To-SqlSee here.In short, inside the conditional clause of a Linq-To-Sql query, you cannot use conditional shortcuts like || and && to avoid null reference exceptions; Linq-To-Sql evaluates both sides of the OR or AND operator even if the first condition obviates the need to evaluate the second condition!Using default parameters with virtual methodsOutput:\n  derived basehas no effect. mypoints[i] returns a copy of a Point value object. C# happily lets you modify a field of the copy. Silently doing nothing.Update:\nThis appears to be fixed in C# 3.0:Perhaps not the worst, but some parts of the .net framework use degrees while others use radians (and the documentation that appears with Intellisense never tells you which, you have to visit MSDN to find out)All of this could have been avoided by having an Angle class instead...For C/C++ programmers, the transition to C# is a natural one.  However, the biggest gotcha I\'ve run into personally (and have seen with others making the same transition) is not fully understanding the difference between classes and structs in C#.In C++, classes and structs are identical; they only differ in the default visibility, where classes default to private visibility and structs default to public visibility.  In C++, this class definitionis functionally equivalent to this struct definition.In C#, however, classes are reference types while structs are value types.  This makes a BIG difference in (1) deciding when to use one over the other, (2) testing object equality, (3) performance (e.g., boxing/unboxing), etc.There is all kinds of information on the web related to the differences between the two (e.g., here).  I would highly encourage anyone making the transition to C# to at least have a working knowledge of the differences and their implications.Garbage collection and Dispose(). Although you don\'t have to do anything to free up memory, you still have to free up resources via Dispose(). This is an immensely easy thing to forget when you are using WinForms, or tracking objects in any way.foreach loops variables scope!prints five "amet", while the following example works fineMS SQL Server can\'t handle dates before 1753.  Significantly, that is out of synch with the .NET DateTime.MinDate constant, which is 1/1/1.  So if you try to save a mindate, a malformed date (as recently happened to me in a data import) or simply the birth date of William the Conqueror, you\'re gonna be in trouble.  There is no built-in workaround for this; if you\'re likely to need to work with dates before 1753, you need to write your own workaround.The Nasty Linq Caching GotchaSee my question that led to this discovery, and the blogger who discovered the problem.In short, the DataContext keeps a cache of all Linq-to-Sql objects that you have ever loaded.  If anyone else makes any changes to a record that you have previously loaded, you will not be able to get the latest data, even if you explicitly reload the record!This is because of a property called ObjectTrackingEnabled on the DataContext, which by default is true.  If you set that property to false, the record will be loaded anew every time... BUT... you can\'t persist any changes to that record with SubmitChanges().GOTCHA!Arrays implement IListBut don\'t implement it. When you call Add, it tells you that it doesn\'t work. So why does a class implement an interface when it can\'t support it?Compiles, but doesn\'t work:We have this issue a lot, because the serializer (WCF) turns all the ILists into arrays and we get runtime errors.The contract on Stream.Read is something that I\'ve seen trip up a lot of people:The reason this is wrong is that Stream.Read will read at most the specified number of bytes, but is entirely free to read just 1 byte, even if another 7 bytes are available before end of stream.It doesn\'t help that this looks so similar to Stream.Write, which is guaranteed to have written all the bytes if it returns with no exception. It also doesn\'t help that the above code works almost all the time. And of course it doesn\'t help that there is no ready-made, convenient method for reading exactly N bytes correctly.So, to plug the hole, and increase awareness of this, here is an example of a correct way to do this:EventsI never understood why events are a language feature. They are complicated to use: you need to check for null before calling, you need to unregister (yourself), you can\'t find out who is registered (eg: did I register?). Why isn\'t an event just a class in the library? Basically a specialized List<delegate>?Enumerables can be evaluated more than onceIt\'ll bite you when you have a lazily-enumerated enumerable and you iterate over it twice and get different results. (or you get the same results but it executes twice unnecessarily)For example, while writing a certain test, I needed a few temp files to test the logic:Imagine my surprise when File.Delete(file) throws FileNotFound!!What\'s happening here is that the files enumerable got iterated twice (the results from the first iteration are simply not remembered) and on each new iteration you\'d be re-calling Path.GetTempFilename() so you\'ll get a different set of temp filenames.The solution is, of course, to eager-enumerate the value by using ToArray() or ToList():This is even scarier when you\'re doing something multi-threaded, like:and you find out content.Length is still 0 after all the writes!! You then begin to rigorously checks that you don\'t have a race condition when.... after one wasted hour... you figured out it\'s just that tiny little Enumerable gotcha thing you forgot....Today I fixed a bug that eluded for long time. The bug was in a generic class that was used in multi threaded scenario and a static int field was used to provide lock free synchronisation using Interlocked. The bug was caused because each instantiation of the generic class for a type has its own static. So each thread got its own static field and it wasn\'t used a lock as intended.This prints\n5\n10\n5Just found a weird one that had me stuck in debug for a while:You can increment null for a nullable int without throwing an excecption and the value stays null.Yes, this behavior is documented, but that certainly doesn\'t make it right.