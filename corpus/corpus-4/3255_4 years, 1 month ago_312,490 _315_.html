Everyone runs into syntax errors. Even experienced programmers make typos. For newcomers it\'s just part of the learning process. However, it\'s often easy to interpret error messages such as:   PHP Parse error: syntax error, unexpected \'{\' in index.php on line 20The unexpected symbol isn\'t always the real culprit. But the line number gives a rough idea where to start looking.Always look at the code context. The syntax mistake often hides in the mentioned or in previous code lines. Compare your code against syntax examples from the manual.While not every case matches the other. Yet there are some general steps to solve syntax mistakes.\nThis references summarized the common pitfalls:Unexpected T_STRINGUnexpected T_VARIABLE  Unexpected \'$varname\' (T_VARIABLE)Unexpected T_CONSTANT_ENCAPSED_STRING  Unexpected T_ENCAPSED_AND_WHITESPACEUnexpected $endUnexpected T_FUNCTION\xe2\x80\xa6Unexpected {Unexpected }Unexpected (Unexpected )Unexpected [Unexpected ]Unexpected T_IF  Unexpected T_FOREACH  Unexpected T_FOR  Unexpected T_WHILE  Unexpected T_DO  Unexpected T_PRINT  Unexpected T_ECHOUnexpected T_INLINE_HTML\xe2\x80\xa6Unexpected T_PAAMAYIM_NEKUDOTAYIM\xe2\x80\xa6Unexpected T_OBJECT_OPERATOR\xe2\x80\xa6 Unexpected T_DOUBLE_ARROW\xe2\x80\xa6\nUnexpected T_SL\xe2\x80\xa6\nUnexpected T_BOOLEAN_OR\xe2\x80\xa6\n\nUnexpected T_BOOLEAN_AND\xe2\x80\xa6\nUnexpected T_IS_EQUAL \nUnexpected T_IS_GREATER_OR_EQUAL \nUnexpected T_IS_IDENTICAL \nUnexpected T_IS_NOT_EQUAL \nUnexpected T_IS_NOT_IDENTICAL \nUnexpected T_IS_SMALLER_OR_EQUAL \nUnexpected < \nUnexpected >Unexpected T_NS_SEPARATOR\xe2\x80\xa6\nUnexpected character in input: \'\\\' (ASCII=92) state=1Unexpected \'public\' (T_PUBLIC)  Unexpected \'private\' (T_PRIVATE)  Unexpected \'protected\' (T_PROTECTED)  Unexpected \'final\' (T_FINAL)\xe2\x80\xa6Unexpected T_STATIC\xe2\x80\xa6\nUnexpected T_CLASS\xe2\x80\xa6Unexpected T_DNUMBERUnexpected , (comma)\nUnpexected . (period)\nUnexpected ; (semicolon)Unexpected * (asterisk)Unexpected : (colon)Closely related references:And:While Stackoverflow is also welcoming rookie coders, it\'s mostly targetted at professional programming questions.If your browser displays error messages such as "SyntaxError: illegal character", then it\'s not actually php-related, but a javascript-syntax error.PHP belongs to the C-style and imperative programming languages. It has rigid grammar rules, which it cannot recover from when encountering misplaced symbols or identifiers. It can\'t guess your coding intentions.There are a few basic precautions you can always take:Use proper code indentation, or adopt any lofty coding style.\nReadability prevents irregularities.Use an IDE or editor for PHP with syntax highlighting.\nWhich also help with parens/bracket balancing.Read the language reference and examples in the manual.\nTwice, to become somewhat proficient.A typical syntax error message reads:Parse error: syntax error, unexpected T_STRING, expecting \';\' in file.php on line 217Which lists the possible location of a syntax mistake. See the mentioned file name and line number.A moniker such as T_STRING explains which symbol the parser/tokenizer couldn\'t process finally. This isn\'t necessarily the cause of the syntax mistake however.It\'s important to look into previous code lines as well. Often syntax errors are just mishaps that happened earlier. The error line number is just where the parser conclusively gave up to process it all.There are many approaches to narrow down and fix syntax hiccups.Open the mentioned source file. Look at the mentioned code line.For runaway strings and misplaced operators this is usually where you find the culprit.Read the line left to right and imagine what each symbol does.More regularily you need to look at preceding lines as well.In particular missing ; semicolons are missing at the previous line end / statement. (At least from the stylistic viewpoint. )   If { code blocks } are incorrectly closed or nested, you may need to investigate even further up the source code. Use proper code indendation to simplify that.Look at the syntax colorization !Strings and variables and constants should all have different colors.Operators +-*/. should be be tinted distinct as well. Else they might be in the wrong context.If you see string colorization extend too far or too short, then you have found an unescaped or missing closing " or \' string marker.Having two same-colored punctuation characters next to each other can also mean trouble. Usually operators are lone, if it\'s not ++ or -- or parentheses following an operator. Two strings/identifiers directly following each other are incorrect in most contexts.Whitespace is your friend.\n Follow any coding style.\n   Break up long lines temporarily.You can freely add newlines between operators or constants and strings. The parser will then concretise the line number for parsing errors. Instead of looking at very lengthy code, you can isolate the missing or misplaced syntax symbol.Split up complex if statements into distinct or nested if conditions.Instead of lengthy math formulas or logic chains, use temporary variables to simplify the code. (More readable = less errors.)Add newlines between:Partitioning up long code blocks really helps locating the origin of syntax errors.Comment out offending code.If you can\'t isolate the problem source, start to comment out (and thus temporarily remove) blocks of code.As soon as you got rid of the parsing error, you have found the problem source. Look more closely there.Sometimes you want to temporarily remove complete function/method blocks. (In case of unmatched curly braces and wrongly indented code.)When you can\'t resolve the syntax issue, try to rewrite the commented out sections from scratch.As newcomer avoid some of the confusing syntax constructs.The ternary ? : condition operator can compact code and is useful indeed. But it doesn\'t aid readability in all cases. Prefer plain if statements while unversed.PHPs alternative syntax (if:/elseif:/endif;) is common for templates, but arguably less easy to follow than normal { code } blocks.The most prevalent newcomer mistakes are:Missing semicolons ; for terminating statements / lines.Mismatched string quotes for " or \' and unescaped quotes within.Forgotten operators, in particular for string . concatenation.Unbalanced ( parentheses ). Count them in the reported line. Are there an equal number of them?Don\'t forget that solving one syntax problem can uncover the next.If you make one issue go away, but another crops up in some code below, you\'re mostly on the right path.If after editing a new syntax error crops up in the same line, then your attempted change was possibly a failure. (Not always though.)Restore a backup of previously working code, if you can\'t fix it.Invisible stray unicode characters: In some cases you need to use a hexeditor or different editor/viewer on your source. Some problems cannot be found just from looking at your code.Try grep --color -P -n "[\\x80-\\xFF]" file.php as first measure to find non-ASCII symbols.In particular BOMs, zero-width spaces, or non-breaking spaces, and smart quotes regularily can find their way into source code.Take care of which type of linebreaks are saved in files. PHP just honors \\n newlines, not \\r carriage returns.Which is occasionally an issue for MacOS users (even on OS X for misconfigured editors).It often only surfaces as issue when single-line // or # comments are used. Multiline /*...*/ comments do seldomly disturb the parser when linebreaks get ignored.If your syntax error does not transmit over the web:\n It happens that you have a syntax error on your machine. But posting the very same file online does not exhibit it anymore. Which can only mean one of two things:You are looking at the wrong file!Or your code contained invisible stray Unicode. (See above)\nYou can easily find out: Just copy your code back from the web form into your text editor.Check your PHP version. Not all syntax constructs are available on every server.Don\'t use PHPs reserved keywords as identifiers for functions / methods, classes or constants.Trial-and-error is your last resort.If all else fails, you can always google your error message. Syntax symbols aren\'t as easy to search for (Stack Overflow itself is indexed by SymbolHound though). Therefore it may take looking through a few more pages before you find something relevant.Further guides:If your website is just blank, then typically a syntax error is the cause.\nEnable their display with:In your php.ini generally,\nor via .htaccess for mod_php,\nor even .user.ini with FastCGI setups.Enabling it within the broken script is too late, because PHP can\'t even interpret/run the first line. A quick workaround is crafting a wrapper script, say test.php:Then invoke the failing code by accessing this wrapper script.It also helps to enable PHPs error_log and look into your webservers error.log when a script crashes with HTTP 500 responses.I think this topic is totally overdiscussed/overcomplicated, using an IDE is THE way to go to completely avoid any syntax errors. I would even say that working without an IDE is kind of unprofessional. Why ? Because modern IDEs check your syntax after every character you type. When you code and your entire line turns red, and a big warning notice shows you the exact type and the exact position of the syntax error, then there\'s absolutely no need to search for another solution.You\'ll (effectively) never run into syntax errors again, simply because you see them right as you type. Seriously.Excellent IDEs with syntax check (all of them are available for Linux, Win and Mac):These days, the unexpected [ array bracket is commonly seen on outdated PHP versions.  The short array syntax is available since PHP >= 5.4. Older installations only support array().Array function result dereferencing is likewise not avaiable for older PHP versions:Reference - What does this error mean in PHP? - "Syntax error, unexpected [" shows the most common and practical workarounds.Though, you\'re always better off just upgrading your PHP installation. For shared webhosting plans, first research if e.g. SetHandler php56-fcgi can be used to enable a newer runtime.See also:Btw, there are also preprocessors and PHP 5.4 syntax down-converters if you\'re really clingy with older + slower PHP versions.Other causes for Unexpected [ syntax errorsIf it\'s not the PHP version mismatch, then it\'s oftentimes a plain typo or newcomer syntax mistake:You can\'t use array property declarations/expressions in classes, not even in PHP7.Confusing [ with opening curly braces { or parens ( is a common oversight.Or even:Or trying to dereference constants (before PHP 5.6) as arrays:At least PHP interprets that const as constant name.If you meant to access an array variable (which is the typical cause here), then add the leading $ sigil - so it becomes a $varname.This is somewhat rarer, but there are also syntax accidents with the terminating array ] bracket.Again mismatches with ) parentheses or } curly braces are common:Or trying to end an array where there isn\'t one:Which often occurs in multi-line and nested array declarations.If so, use your IDE for bracket matching to find any premature ] array closure. At the very least use more spacing and newlines to narrow it down.An "unexpected T_VARIABLE" means that there\'s a literal $variable name, which doesn\'t fit into the current expression/statement structure.It most commonly indicates a missing semicolon in the previous line. Variable assignments following a statement are a good indicator where to look:A frequent mishap are string concatenations with forgotten . operator:Btw, you should prefer string interpolation (basic variables in double quotes) whenever that helps readability. Which avoids these syntax issues.String interpolation is a scripting language core feature. No shame in utilizing it. Ignore any micro-optimization advise about variable . concatenation being faster. It\'s not.Of course the same issue can arise in other expressions, for instance arithmetic operations:PHP can\'t guess here if the variable should have been added, subtracted or compared etc.Same for syntax lists, like in array populations, where the parser also indicates an expected comma , for example:Or functions parameter lists:Equivalently do you see this with list or global statements, or when lacking a ; semicolon in a for loop.This parser error also occurs in class declarations. You can only assign static constants, not expressions. Thus the parser complains about variables as assigned data:Unmatched } closing curly braces can in particular lead here. If a method is terminated too early (use proper indentation!), then a stray variable is commonly misplaced into the class declaration body.You can also never have a variable follow an identifier directly:Btw, this is a common example where the intention was to use variable variables perhaps. In this case a variable property lookup with $this->{"myFunc$VAR"}(); for example.Take in mind that using variable variables should be the exception. Newcomers often try to use them too casually, even when arrays would be simpler and more appropriate.Hasty typing may lead to forgotten opening parenthesis\nfor if and for and foreach statements:Solution: add the missing opening ( between statement and variable.Solution: Remove the conditions from else or use elseif.Solution: Add brackets around $var.As mentioned in the reference answer on "Invisible stray Unicode" (such as a non-breaking space), you might also see this error for unsuspecting code like:It\'s rather prevalent in the start of files and for copy-and-pasted code. Check with a hexeditor, if your code does not visually appear to contain a syntax issue.The unwieldy names T_CONSTANT_ENCAPSED_STRING and T_ENCAPSED_AND_WHITESPACE refer to quoted "string" literals.They\'re used in different contexts, but the syntax issue are quite similar. T_ENCAPSED\xe2\x80\xa6 warnings occur in double quoted string context, while T_CONSTANT\xe2\x80\xa6 strings are often astray in plain PHP expressions or statements.And it comes up most frequently for incorrect PHP variable interpolation:Quoting arrays keys is a must in PHP context. But in double quoted strings (or HEREDOCs) this is a mistake. The parser complains about the contained single quoted \'string\', because it usually expects a literal identifier / key there.More precisely it\'s valid to use PHP2-style simple syntax within double quotes for array references:Nested arrays or deeper object references however require the complex curly string expression syntax:If unsure, this is commonly safer to use. It\'s often even considered more readable. And better IDEs actually use distinct syntax colorization for that.If a string follows an expression, but lacks a concatenation or other operator, then you\'ll see PHP complain about the string literal:While it\'s obvious to you and me, PHP just can\'t guess that the string was meant to be appended there.The same syntax error occurs when confounding string delimiters. A string started by a single \' or double " quote also ends with the same.That example started with double quotes. But double quotes were also destined for the HTML attributes. The intended concatenation operator within however became interpreted as part of a second string in single quotes.Tip: Set your editor/IDE to use slightly distinct colorization for single and double quoted strings. (It also helps with application logic to prefer e.g. double quoted strings for textual output, and single quoted strings only for constant-like values.)This is a good example where you shouldn\'t break out of double quotes in the first place. Instead just use proper \\" escapes for the HTML attributes\xc2\xb4 quotes:While this can also lead to syntax confusion, all better IDEs/editors again help by colorizing the escaped quotes differently.Equivalently are forgotten opening "/\' quotes a recipe for parser errors:Here the \', \' would become a string literal after a bareword, when obviously login was meant to be a string parameter.If you miss a , comma in an array creation block, the parser will see two consecutive strings:Note that the last line may always contain an extra comma, but overlooking one in between is unforgivable. Which is hard to discover without syntax highlighting.Same thing for function calls:A common variation are quite simply forgotten string terminators:Here PHP complains about two string literals directly following each other. But the real cause is the unclosed previous string of course.See alsoWhen PHP talks about an "unexpected $end", it means that your code ended prematurely. (The message is a bit misleading when taken literally. It\'s not about a variable named "$end", as sometimes assumed by newcomers. It refers to the "end of file", EOF.)Cause: Unbalanced { and } for code blocks / and function or class declarations.It\'s pretty much always about a missing } curly brace to close preceding code blocks.Again, use proper indentation to avoid such issues.Use an IDE with bracket matching, to find out where the } is amiss.\n There are keyboard shortcuts in most IDEs and text editors:Most IDEs also highlight matching braces, brackets and parens.\nWhich makes it pretty easy to inspect their correlation:And Unexpected $end syntax/parser error can also occur for unterminated expressions or statements:So, look at the end of scripts first. A trailing ; is often redundant for the last statement in any PHP script. But you should have one. Precisely because it narrows such syntax issues down.Another common occurence appears with HEREDOC or NOWDOC strings. The terminating marker goes ignored with leading spaces/tabs/etc.:Therefore the parser assumes the HEREDOC string to continue untill the end of the file (hence "Unexpected $end"). Pretty much all IDEs and syntax-highlighting editors will make this obvious or warn about it.Somewhat rarer you can see this syntax error when using the alternative syntax for statement/code blocks in templates. Using if: and else: and a missing endif; for example.Opening parentheses typically follow language constructs such as if/foreach/for/array/list or start an arithmetic expression. They\'re syntactically incorrect after "strings", a previous (), a lone $, and in some typical declaration contexts.A rarer occurence for this error is trying to use expressions as default function parameters. This is not supported, even in PHP7: Parameters in a function declaration can only be literal values or constant expressions. Unlike for function invocations, where you can freely use whatever(1+something()*2) etc.Same thing for class member declarations, where only literal/constant values are allowed, not expressions:Put such things in the constructor.\nSee also Why don\'t PHP attributes allow functions?Again note that PHP 7 only allows var $xy = 1 + 2 +3; constant expressions there.Utilizing Javascript or jQuery syntax won\'t work in PHP for obvious reasons:When this happens, it usually indicates an unterminated preceding string; and literal <script> sections leaking into PHP code context.Both isset() and empty() are language built-ins, not functions. They need to access a variable directly. If you inadvertently add a pair of parentheses too much, then you\'d create an expression however:Same applies to any language construct that requires implicit variable name access. These built-ins are part of the language grammer, therefore don\'t permit decorative extra parens.User-level functions that require a variable reference -but get an expression result passed- lead to runtime errors instead. You cannot have stray commas last in a function call. PHP expects a value there and thusly complains about an early closing ) parenthesis.A trailing comma is only allowed in array() or list() constructs.If you forget something in an arithmetic expression, then the parser gives up. Because how should it possibly interpret that:And if you forgot the closing ) even, then you\'d get a complaint about the unexpected semicolon instead.For forgotten variable $ prefixes in control statements you will see:PHP here sometimes tells you it expected a :: instead. Because a class::$variable could have satisfied the expected $variable expression..Curly braces { and } enclose code blocks. And syntax errors about them usually indicate some incorrec nesting.Most commonly unbalanced ( and ) are the cause if the parser complains about the opening curly { appearing too early. A simple example:Count your parens or use an IDE which helps with that. Also don\'t write code without any spaces. Readability counts.You can\'t use curly braces in expressions. If you confuse parentheses and curlys, it won\'t comply to the language grammer:There are a few exceptions for identifier construction, such as local scope variable ${references}.This is pretty rare. But you might also get { and } parser complaints for complex variable expressions:Though there\'s a higher likelihood for an unexpected } in such contexts.When getting an "unexpected }" error, you\'ve mostly closed a code block too early.It can happen for any unterminated expression.And if the last line in a function/code block lacks a trailing ; semicolon:Here the parser can\'t tell if you perhaps still wanted to add + 25; to the function result or something else.You\'ll sometimes see this parser error when a code block was } closed too early, or you forgot an opening { even:In above snippet the if didn\'t have an opening { curly brace. Thus the closing } one below became redundant. And therefore the next closing }, which was intended for the function, was not associatable to the original opening { curly brace.Such errors are even harder to find without proper code indentation. Use an IDE and bracket matching.Language constructs which require a condition/declaration header and a code block will trigger this error.For example misdeclared functions without parameter list are not permitted:And you can\'t likewise have an if without condition.Which doesn\'t make sense, obviously.  Same thing for the usual suspects, for/foreach and while/do etc.If you\'ve got this particular error, you definitely should look up some manual examples.T_STRING is a bit of a misnomer. It does not refer to a quoted "string". It means a raw identifier was encountered. This can range from bare words to leftover CONSTANT or function names, forgotten unquoted strings, or any plain text.This syntax error is most common for misquoted string values however. Any unescaped and stray " or \' quote will form an invalid expression:Syntax highlighting will make such mistakes super obvious. It\'s important to remember to use backslashes for escaping \\" double quotes, or \\\' single quotes - depending on which was used as string enclosure.See also What is the difference between single-quoted and double-quoted strings in PHP?If you miss a closing " then a syntax error typically materializes later. An unterminated string will often consume a bit of code until the next intended string value:It\'s not just literal T_STRINGs which the parser may protest then. Another frequent variation is an Unexpected \'>\' for unquoted literal HTML.If you copy and paste code from a blog or website, you sometimes end up with invalid code. Typographic quotes aren\'t what PHP expects:Typographic/smart quotes are Unicode symbols. PHP treats them as part of adjoining alphanumeric text. For example \xe2\x80\x9dthese is interpreted as constant identifier. But any following text literal is then seen as bareword/T_STRING by the parser.If you have an unterminated expression in previous lines, then any following statement or language construct gets seen as raw identifier:PHP just can\'t know if you meant to run two functions after another, or if you meant to multiply their results, add them, compare them, or only run one || or the other.This is rather uncommon. But if short_open_tags are enabled, then you can\'t begin your PHP scripts with an XML declaration:PHP will see the <? and reclaim it for itself. It won\'t understand what the stray xml was meant for. It\'ll get interpreted as constant. But the version will be seen as another literal/constant. And since the parser can\'t make sense of two subsequent literals/values without an expression operator in between, that\'ll be a parser failure.A most hideous cause for syntax errors are Unicode symbols, such as the non-breaking space. PHP allows Unicode characters as identifier names. If you get a T_STRING parser complaint for wholly unsuspicious code like:You need to break out another text editor. Or an hexeditor even. What looks like plain spaces and newlines here, may contain invisible constants. Java-based IDEs are sometimes oblivious to an UTF-8 BOM mangled within, zero-width spaces, paragraph separators, etc. Try to reedit everything, remove whitespace and add normal spaces back in.You can narrow it down with with adding redundant ; statement separators at each line start:The extra ; semicolon here will convert the preceding invisible character into an undefined constant reference (expression as statement). Which in return makes PHP produce a helpful notice.Comparison operators such as ==, >=, ===, !=, <>, !== and <= or < and > mostly should be used just in expressions, such as if expressions. If the parser complains about them, then it often means incorrect paring or mismatched ( ) parens around them.In particular for if statements with multiple comparisons you must take care to correctly count opening and closing parenthesis:Here the if condition here was already terminated by the )Once your comparisons become sufficiently complex it often helps to split it up into multiple and nested if constructs rather.A common newcomer is pitfal is trying to combine isset() or empty() with comparisons:Or even:This doesn\'t make sense to PHP, because isset and empty are language constructs that only accept variable names. It doesn\'t make sense to compare the result either, because the output is only/already a boolean.Both operators look somewhat similar, so they sometimes get mixed up:You only need to remember that this comparison operator is called "greater than or equal" to get it right.See also: If statement structure in PHPYou also can\'t combine two comparisons if they pertain the same variable name:PHP can\'t deduce that you meant to compare the initial variable again. Expressions are usually paired according to operator precedence, so by the time the < is seen, there\'d be only a boolean result left from the original variable.See also: unexpected T_IS_SMALLER_OR_EQUALYou can\'t compare against a variable with a row of operators:This has to be broken up into two comparisons, each against $x.This is actually more a case of blacklisted expressions (due to equivalent operator associativity). It\'s syntactically valid in a few C-style languages, but PHP wouldn\'t interpret it as expected comparison chain either.The greater than > or less than < operators don\'t have a custom T_XXX tokenizer name. And while they can be misplaced like all they others, you more often see the parser complain about them for misquoted strings and mashed HTML:This amounts to a string "<a href=\'z" being compared > to a literal constant Hello and then another < comparison. Or that\'s at least how PHP sees it. The actual cause and syntax mistake was the premature string " termination.See also:Control constructs such as if, foreach, for, while, list, global, return, do, print, echo may only be used as statements. They usually reside on a line by themselves.Pretty universally have you missed a semicolon in the previous line if the parser complains about a control statement:Solution: look into the previous line; add semicolon.Another location where this occurs is in class declarations. In the class section you can only list property initializations and method sections. No code may reside there.Such syntax errors commonly materialize for incorrectly nested { and }. In particular when function code blocks got closed too early.Most language constructs can only be used as statements. They aren\'t meant to be placed inside other expressions:Likewise can\'t you use an if in strings, math expressions or elsewhere:For embedding if-like conditions in an expression specifically, you often want to use a ?: ternary evaluation.The same applies to for, while, global, echo and a lesser extend list.Whereas print() is a language builtin that may be used in expression context. (But rarely makes sense.)You also can\'t use do or if and other language constructs for user-defined functions or class names. (Perhaps in PHP7. But even then it wouldn\'t be advisable.)Conditional control blocks if, elseif and else follow a simple structure. When you encounter a syntax error, it\'s most likely just invalid block nesting \xe2\x86\x92 with missing { curly braces } - or one too many.Mismatched code braces are common to less well-formatted code such as:If your code looks like this, start afresh! Otherwise it\'s unfixable to you or anyone else. There\'s no point in showcasing this on the internet to inquire for help.You will only be able to fix it, if you can visually follow the nested structure and relation of if/else conditionals and their { code blocks }. Use your IDE to see if they\'re all paired.Any double } } will not just close a branch, but a previous condition structure. Therefore stick with one coding style; don\'t mix and match in nested if/else trees.Apart from consistency here, it turns out helpful to avoid lengthy conditions too. Use temporary variables or functions to avoid unreadable if-expressions.A surprisingly frequent newcomer mistake is trying to use an if statement in an expression, such as a print statement:Which is invalid of course. You can use a ternary conditional, but beware of readability impacts.Otherwise break such output constructs up: use multiple ifs and echos.\nBetter yet, use temporary variables, and place your conditionals before:Defining functions or methods for such cases often makes sense too.Now this is less common, but a few coders even try to treat if as if it could return a result:Which is structurally identical to using if within a string concatenation / expression.You\'ll have to use an assignment in the code block:Alternatively, resort to a ?: ternary comparison.You cannot nest an if within a condition either:Which is obviously redundant, because the and (or or) already allows chaining comparisons.Once more: Each control block needs to be a statement. If the previous code piece isn\'t terminated by a semicolon, then that\'s a guaranteed syntax error:Btw, the last line in a {\xe2\x80\xa6} code block needs a semicolon too.Now it\'s probably wrong to blame a particular coding style, as this pitfall is too easy to overlook:Which happens more often than you might imagine.Which also explains a likewise subtle variation of this syntax error:Where the ; after the code block {\xe2\x80\xa6} terminates the whole if\nconstruct, severing the else branch syntactically.It\'s syntactically allowed to omit curly braces {\xe2\x80\xa6} for code blocks in if/elseif/else branches. Which sadly is a syntax style very common to unversed coders. (Under the false assumption this was quicker to type or read).However that\'s highly likely to trip up the syntax. Sooner or later additional statements will find their way into the if/else branches:But to actually use code blocks, you do have to write {\xe2\x80\xa6} them as such!Even seasoned programmers avoid this braceless syntax, or at least\n  understand it as an exceptional exception to the rule.One thing to remind yourself is the conditional order, of course. You can have as many elseifs as you want, but else has to go last. That\'s just how it is.As mentioned above, you can\'t have control statements in a class declaration:You either forgot a function definition, or closed one } too early in such cases.This is more or less a variation of incorrect indentation - presumably often based on wrong coding intentions.\nYou cannot mash other statements inbetween if and elseif/else structural tokens:Either can only occur in {\xe2\x80\xa6} code blocks, not in between control structure tokens.Nor can you part an if/else between different control structures:There is no syntactic relation between the if and else. The foreach lexical scope ends at }, so there\'s no point for the if structure to continue.If an unexpected T_ENDIF is complained about, you\'re using the alternative syntax style if: \xe2\x8b\xaf elseif: \xe2\x8b\xaf else: \xe2\x8b\xaf endif;. Which you should really think twice about.A common pitfall is confusing the eerily similar : colon for a ; semicolon. (Covered in "Semicolon too early")As indentation is harder to track in template files, the more when using the alternative syntax - it\'s plausible your endif; does not match any if:.Using } endif;\n is a doubled if-terminator.\n While an "unexpected $end" is usually the price for a forgotten closing } curly brace.So, this is not a syntax error, but worth mentioning in this context:That\'s not a ==/=== comparison, but an = assignment. This is rather subtle, and will easily lead some users to helplessly edit whole condition blocks. Watch out for unintended assignments first - whenver you experience a logic fault / misbeheviour.