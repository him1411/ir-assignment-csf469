I\'ve seen examples like this: and supposed that I could have a Constants class to wrap constants in, declaring them static final. I know practically no Java at all and am wondering if this is the best way to create constants.  That is perfectly acceptable, probably even the standard.where TYPE is the type, NAME is the name in all caps with underscores for spaces, and VALUE is the constant value;I highly recommend NOT putting your constants in their own classes or interfaces. As a side note:  Variables that are declared final and are mutable can still be changed; however, the variable can never point at a different object.For example:That is legal and ORIGIN would then be a point at (3, 0).I would highly advise against having a single constants class.  It may seem a good idea at the time, but when developers refuse to document constants and the class grows to encompass upwards of 500 constants which are all not related to each other at all (being related to entirely different aspects of the application), this generally turns into the constants file being completely unreadable.  Instead:It is a BAD PRACTICE to use interfaces just to hold constants (named constant interface pattern by Josh Bloch). Here\'s what Josh advises:If the constants are strongly tied to\n  an existing class or interface, you\n  should add them to the class or\n  interface. For example, all of the\n  boxed numerical primitive classes,\n  such as Integer and Double, export\n  MIN_VALUE and MAX_VALUE constants. If\n  the constants are best viewed as\n  members of an enumerated type, you\n  should export them with an enum\n  type. Otherwise, you should export the\n  constants with a noninstantiable\n  utility class.Example:About the naming convention:By convention, such fields have names\n  consisting of capital letters, with\n  words separated by underscores. It is\n  critical that these fields contain\n  either primitive values or references\n  to immutable objects.In Effective Java (2nd edition), it\'s recommended that you use enums instead of static ints for constants.There\'s a good writeup on enums in Java here:\nhttp://java.sun.com/j2se/1.5.0/docs/guide/language/enums.htmlNote that at the end of that article the question posed is:So when should you use enums?With an answer of:Any time you need a fixed set of constantsJust avoid using an interface:It is tempting, but violates encapsulation and blurs the distinction of class definitions.I use following approach:Than, for example, I use Constants.DB.Connection.URL to get constant.\nIt looks more "object oriently" as for me.Creating static final constants in a separate class can get you into trouble.  The Java compiler will actually optimize this and place the actual value of the constant into any class that references it.If you later change the \'Constants\' class and you don\'t do a hard re-compile on other classes that reference that class, you will wind up with a combination of old and new values being used.Instead of thinking of these as constants, think of them as configuration parameters and create a class to manage them.  Have the values be non-final, and even consider using getters.  In the future, as you determine that some of these parameters actually should be configurable by the user or administrator, it will be much easier to do.The number one mistake you can make is creating a globally accessible class called with a generic name, like Constants. This simply gets littered with garbage and you lose all ability to figure out what portion of your system uses these constants.Instead, constants should go into the class which "owns" them. Do you have a constant called TIMEOUT? It should probably go into your Communications() or Connection() class. MAX_BAD_LOGINS_PER_HOUR? Goes into User().  And so on and so forth. The other possible use is Java .properties files when "constants" can be defined at run-time, but not easily user changeable. You can package these up in your .jars and reference them with the Class resourceLoader.That\'s the right way to go.Generally constants are not kept in separate "Constants" classes because they\'re not discoverable.  If the constant is relevant to the current class, keeping them there helps the next developer.What about an enumeration?I prefer to use getters rather than constants.  Those getters might return constant values, e.g. public int getMaxConnections() {return 10;}, but anything that needs the constant will go through a getter.One benefit is that if your program outgrows the constant--you find that it needs to be configurable--you can just change how the getter returns the constant.The other benefit is that in order to modify the constant you don\'t have to recompile everything that uses it.  When you reference a static final field, the value of that constant is compiled into any bytecode that references it.I agree that using an interface is not the way to go. Avoiding this pattern even has its own item (#18) in Bloch\'s Effective Java.An argument Bloch makes against the constant interface pattern is that use of constants is an implementation detail, but implementing an interface to use them exposes that implementation detail in your exported API.The public|private static final TYPE NAME = VALUE; pattern is a good way of declaring a constant. Personally, I think it\'s better to avoid making a separate class to house all of your constants, but I\'ve never seen a reason not to do this, other than personal preference and style.If your constants can be well-modeled as an enumeration, consider the enum structure available in 1.5 or later.If you\'re using a version earlier than 1.5, you can still pull off typesafe enumerations by using normal Java classes. (See this site for more on that).Based on the comments above I think this is a good approach to change the old-fashioned global constant class (having public static final variables) to its enum-like equivalent in a way like this:So then I can refer them to like:A good object oriented design should not need many publicly available constants.  Most constants should be encapsulated in the class that needs them to do its job.   There is a certain amount of opinion to answer this.  To start with, constants in java are generally declared to be public, static and final. Below are the reasons:I would never use an interface for a CONSTANTS accessor/object simply because interfaces are generally expected to be implemented.  Wouldn\'t this look funny:Instead I would choose between a few different ways, based on some small trade-offs, and so it depends on what you need:A Constant, of any type, can be declared by creating an immutable property that within a class (that is a member variable with the final modifier).  Typically the static and  public modifiers are also provided.There are numerous applications where a constant\'s value indicates a selection from an n-tuple (e.g. enumeration) of choices.  In our example, we can choose to define an Enumerated Type that will restrict the possible assigned values (i.e. improved type-safety):A single, generic constants class is a bad idea. Constants should be grouped together with the class they\'re most logically related to.Rather than using variables of any kind (especially enums), I would suggest that you use methods. Create a method with the same name as the variable and have it return the value you assigned to the variable. Now delete the variable and replace all references to it with calls to the method you just created. If you feel that the constant is generic enough that you shouldn\'t have to create an instance of the class just to use it, then make the constant method a class method.FWIW, a timeout in seconds value should probably be a configuration setting (read in from a properties file or through injection as in Spring) and not a constant.What is the difference1.2.and using \nMyGlobalConstants.TIMEOUT_IN_SECS wherever we need this constant. I think both are same.What is the best way to implement constants in Java?One approach that we should really avoid : using interfaces to define constants.Creating a interface specifically to declare constants is really the worst thing : it defeats the reason why interfaces were designed : defining method(s) contract.Even if an interface already exists to address a specific need, declaring the constants in them make really not sense as constants should not make part of the API and the contract provided to client classes.To simplify, we have broadly 4 valid approaches.With static final String/Integer field :With Java 5 enum :TLDR : Which is the best way and where locate the constants ?In most of cases, the enum way is probably finer than the static final String/Integer way and personally I think that the static final String/Integer way should be used only if we have good reasons to not use enums.\nAnd about where we should declare the constant values, the idea is to search if there exists a class that own a strong semantic and use relationship with constant values. If we find it, we should use it as the constants holder. Otherwise, the constant should be associated to no one particular class.static final String/ static final Integer versus enum Enums usage is really a way to strongly considered.\nEnums have a great advantage over String or Integer constant field. \nThey set a stronger compilation constraint. \nIf you define a method that takes the enum as parameter, you can only pass a enum value defined in the enum class(or null). \nWith String and Integer you can substitute them with any values of compatible type and the compilation will be fine even if the value is not a defined constant in the static final String/ static final Integer fields. For example, below two constants defined in a class as static final String fields :Here a method that expects to have one of these constants as parameter :You can invoke it in this way :or But no compilation constraint prevents you from invoking it in this way :You would have the error only at runtime and only if you do at a time a check on the transmitted value.With enum, checks are not required as the client could only pass a enum value in a enum parameter.For example, here two values defined in a enum class (so constant out of the box):Here a method that expects to have one of these enum values as parameter :You can invoke it in this way :or But the compilation will never allow you from invoking it in this way :Where should we declare the constants ?If your application contains an existing class that has a specific and strong functional cohesion with the constant values, the 1) and the 2) appear more intuitive.\nGenerally, it eases the use of the constants if these are declared in the main class that manipulates them or that has a name very natural to guess that we will find it inside.For example in the JDK library, the exponential and pi constant values are   declared in a class that declare not only constant declarations (java.lang.Math).The clients using mathematics functions rely often on the Math class.\nSo, they may find constants easily enough and can also remember where E and PI are defined in a very natural way. If your application doesn\'t contain an existing class that has a very specific and strong functional cohesion with the constant values, the 1 variant) and the 2 variant) ways appear more intuitive.\nGenerally, it doesn\'t ease the use of the constants if these are declared in one class that manipulates them while we have also 3 or 4 other classes that manipulate them as much as and no one of these classes seems be more natural than others to host constant values.\nHere, defining a custom class to hold only constant values makes sense.\nFor example in the JDK library, the java.util.concurrent.TimeUnit enum is not declared in a specific class as there is not really one and only one JDK specific class that appear as the most intuitive to hold it :Many classes declared in java.util.concurrent use them :\nBlockingQueue, ArrayBlockingQueue<E>, CompletableFuture, ExecutorService , ... and really no one of them seems more appropriate to hold the enum.I wouldn\'t call the class the same (aside from casing) as the constant ... I would have at a minimum one class of "Settings", or "Values", or "Constants", where all the constants would live.  If I have a large number of them, I\'d group them up in logical constant classes (UserSettings, AppSettings, etc.)To take it a step further, you can place globally used constants in an interface so they can be used system wide.  E.g.But don\'t then implement it.  Just refer to them directly in code via the fully qualified classname.For Constants, Enum is a better choice IMHO. Here is an examplepublic class myClass  {One of the way I do it is by creating a \'Global\' class with the constant values and do a static import in the classes that need access to the constant.static final is my preference, I\'d only use an enum if the item was indeed enumerable.I use static final to declare constants and go with the ALL_CAPS naming notation. I have seen quite a few real life instances where all constants are bunched together into an interface. A few posts have rightly called that a bad practice, primarily because that\'s not what an interface is for. An interface should enforce a contract and should not be a place to put unrelated constants in. Putting it together into a class that cannot be instantiated (through a private constructor) too is fine if the constant semantics don\'t belong to a specific class(es). I always put a constant in the class that it\'s most related to, because that makes sense and is also easily maintainable.Enums are a good choice to represent a range of values, but if you are storing standalone constants with an emphasis on the absolute value (eg. TIMEOUT = 100 ms) you can just go for the static final approach.I agree with what most are saying, it is best to use enums when dealing with a collection of constants. However, if you are programming in Android there is a better solution: IntDef Annotation.IntDef annotation is superior to enums in one simple way, it takes significantly less space as it is simply a compile-time marker. It is not a class, nor does it have the automatic string-conversion property.