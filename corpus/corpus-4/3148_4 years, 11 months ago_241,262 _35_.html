I am using Scanner methods nextInt() and nextLine() for reading input. Basically, it looks like this:The problem is that after entering the numerical value, the first input.nextLine() is skipped and the second input.nextLine() is executed, so that my output looks like this:I tested my application and it looks like the problem lies in using input.nextInt(). If I delete it, then both string1 = input.nextLine() and string2 = input.nextLine() are executed as I want them to be.That\'s because the Scanner.nextInt method does not consume the last newline character of your input, and thus that newline is consumed in the next call to Scanner.nextLine.Workaround:Either fire a blank Scanner.nextLine call after Scanner.nextInt to consume rest of that line including newline Or, it would be even better, if you read the input through Scanner.nextLine and convert your input to integer using Integer.parseInt(String) method.You will encounter the similar behaviour when you use Scanner.nextLine after Scanner.next() or any Scanner.nextFoo method (except nextLine itself).The problem is with the input.nextInt() command it only reads the int value. So when you continue reading with input.nextLine() you receive the "\\n" Enter key. So to skip this you have to add the input.nextLine(). Hope this should be clear now.Try it like that:It\'s because when you enter a number then press Enter, input.nextInt() consumes only the number, not the "end of line". When input.nextLine() executes, it consumes the "end of line" still in the buffer from the first input.Instead, use input.nextLine() immediately after input.nextInt()There seem to be many questions about this issue with java.util.Scanner. I think a more readable/idiomatic solution would be to call scanner.skip("[\\r\\n]+") to drop any newline characters after calling nextInt().EDIT: as @PatrickParker noted below, this will cause an infinite loop if user inputs any whitespace after the number. See their answer for a better pattern to use with skip: https://stackoverflow.com/a/42471816/143585It does that because input.nextInt(); doesn\'t capture the newline. you could do like the others proposed by adding an input.nextLine(); underneath.\nAlternatively you can do it C# style and parse a nextLine to an integer like so:  Doing this works just as well, and it saves you a line of code.Things you need to know:text which represents few lines also contains non-printable characters between lines (we call them line separators) like when you are reading data from console, it allows user to type his response and when he is done he needs to somehow confirm that fact. To do so, user is required to press "enter"/"return" key on keyboard.  What is important is that this key beside ensuring placing user data to standard input (represented by System.in which is read by Scanner) also sends OS dependant line separators (like for Windows \\r\\n) after it. So when you are asking user for value like age, and user types 42 and presses enter, standard input will contain "42\\r\\n".Scanner#nextInt (and other Scanner#nextType methods) doesn\'t allow Scanner to consume these line separators. It will read them from System.in (how else Scanner would know that there are no more digits from user which represent age value than facing whitespace?) which will remove them from standard input, but it will also cache those line separators internally. What we need to remember, is that all of Scanner methods are always scanning starting from cached text.  Now Scanner#nextLine() simply collects and returns all characters until it finds line separators (or end of stream). But since line separators after reading number from console are found immediately in Scanner\'s cache, it returns empty String, meaning that Scanner was not able to find any character before those line separators (or end of stream).\nBTW nextLine also consumes those line separators.  So when you want to ask for number and then for entire line and avoid that empty string as result of nextLine, either BTW: Scanner#nextType methods can skip delimiters (by default all whitespaces like tabs, line separators) including those cached by scanner, until they will find next non-delimiter value (token). Thanks to that for input like "42\\r\\n\\r\\n321\\r\\n\\r\\n\\r\\nfoobar" code will be able to properly assign num1=42 num2=321 name=foobar.Instead of input.nextLine() use input.next(), that should solve the problem.Modified code:In order to avoid the issue, use nextLine(); immediately after nextInt(); as it helps in clearing out the buffer. When you press ENTER the nextInt(); does not capture the new line and hence, skips the Scanner code later. If you want to scan input fast without getting confused into Scanner class nextLine() method , Use Custom Input Scanner for it . ScanReader sc = new ScanReader(System.in);\n\n3. Import necessary Classes : import java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n \n4. Throw IOException from your main method to handle Exception\n5. Use Provided Methods.\n6. EnjoyIf you want to read both strings and ints, a solution is to use two Scanners:Why not use a new Scanner for every reading? Like below. With this approach you will not confront your problem.sc.nextLine() is better as compared to parsing the input.\nBecause performance wise it will be good.