I need to repeatedly remove the first line from a huge text file using a bash script.Right now I am using sed -i -e "1d" $FILE - but it takes around a minute to do the deletion.Is there a more efficient way to accomplish this?Try GNU tail:-n x: Just print the last x lines. tail -n 5 would give you the last 5 lines of the input. The + sign kind of inverts the argument and make tail print anything but the first x-1 lines. tail -n +1 would print the whole file, tail -n +2 everything but the first line, etc.GNU tail is much faster than sed. tail is also available on BSD and the -n +2 flag is consistent across both tools. Check the FreeBSD or OS X man pages for more. The BSD version can be much slower than sed, though. I wonder how they managed that; tail should just read a file line by line while sed does pretty complex operations involving interpreting a script, applying regular expressions and the like.Note: You may be tempted to usebut this will give you an empty file. The reason is that the redirection (>) happens before tail is invoked by the shell:If you want to remove the first line inside the file, you should use:The && will make sure that the file doesn\'t get overwritten when there is a problem.For those who are on SunOS which is non-GNU, the following code will help:You can use -i to update the file without using \'>\' operator. The following command will delete the first line from the file and save it to the file.No, that\'s about as efficient as you\'re going to get. You could write a C program which could do the job a little faster (less startup time and processing arguments) but it will probably tend towards the same speed as sed as files get large (and I assume they\'re large if it\'s taking a minute).But your question suffers from the same problem as so many others in that it pre-supposes the solution. If you were to tell us in detail what you\'re trying to do rather then how, we may be able to suggest a better option.For example, if this is a file A that some other program B processes, one solution would be to not strip off the first line, but modify program B to process it differently.Let\'s say all your programs append to this file A and program B currently reads and processes the first line before deleting it.You could re-engineer program B so that it didn\'t try to delete the first line but maintains a persistent (probably file-based) offset into the file A so that, next time it runs, it could seek to that offset, process the line there, and update the offset.Then, at a quiet time (midnight?), it could do special processing of file A to delete all lines currently processed and set the offset back to 0.It will certainly be faster for a program to open and seek a file rather than open and rewrite. This discussion assumes you have control over program B, of course. I don\'t know if that\'s the case but there may be other possible solutions if you provide further information.You can edit the files in place: Just use perl\'s -i flag, like this:This makes the first line disappear, as you ask. Perl will need to read and copy the entire file, but it arranges for the output to be saved under the name of the original file.As Pax said, you probably aren\'t going to get any faster than this.  The reason is that there are almost no filesystems that support truncating from the beginning of the file so this is going to be an O(n) operation where n is the size of the file.  What you can do much faster though is overwrite the first line with the same number of bytes (maybe with spaces or a comment) which might work for you depending on exactly what you are trying to do (what is that by the way?).How about using csplit?should show the lines except the first line :Sponge avoids the need for juggling a temp file:Since it sounds like I can\'t speed up the deletion, I think a good approach might be to process the file in batches like this:The drawback of this is that if the program gets killed in the middle (or if there\'s some bad sql in there - causing the "process" part to die or lock-up), there will be lines that are either skipped, or processed twice.(file1 contains lines of sql code)If what you are looking to do is recover after failure, you could just build up a file that has what you\'ve done so far.Would using tail on N-1 lines and directing that into a file, followed by removing the old file, and renaming the new file to the old name do the job?If i were doing this programatically, i would read through the file, and remember the file offset, after reading each line, so i could seek back to that position to read the file with one less line in it.