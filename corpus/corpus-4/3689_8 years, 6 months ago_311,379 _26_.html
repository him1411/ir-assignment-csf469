In JavaScript, when converting from a float to a string, how can I get just 2 digits after the decimal point? For example, 0.34 instead of 0.3445434.The specifics, in case the code isn\'t self-explanatory.edit: ...or just use toFixed, as proposed by Tim B\xc3\xbcthe. Forgot that one, thanks (and an upvote) for reminder :)There are functions to round numbers. For example:will print 5.04.EDIT:\nFiddleBe careful when using toFixed():First, rounding the number is done using the binary representation of the number, which might lead to unexpected behaviour. For exampleinstead of \'0.6\'.Second, there\'s an IE bug with toFixed(). In IE (at least up to version 7, didn\'t check IE8), the following holds true:It might be a good idea to follow kkyy\'s suggestion or to use a custom toFixed() function, egOne more problem to be aware of, is that toFixed() can produce unnecessary zeros at the end of the number.\nFor example:The idea is to clean up the output using a RegExp:The RegExp matches the trailing zeros (and optionally the decimal point) to make sure it looks good for integers as well.This issue is probably worth one more answer\xc2\xa0: as mentioned by Dony and ArteQ, the rounding is affected by a loss of precision (that is, 0.5 may become 0.49999\xe2\x80\xa6).  The consequence is that the rounding is neither half up, nor half down, nor any other consistent rounding method, and will give inconsistent result whatever the method you use.Indeed toFixed is affected as well\xc2\xa0:So whichever method you use, if you need consistency in the rounding you better add (or remove) an epsilon.E.g. for half up rounding using toFixed\xc2\xa0:It\'s the same if you build your own function, add/remove an epsilon before computation.As pointed out by matias, this methods has a flaw\xc2\xa0: whichever the epsilon value, 0.334999999\xe2\x80\xa6 will allways be rounded at 0.34 instead of 0.35.  Therefore we have consistency, but not "standard rounding".There is a problem with all those solutions floating around using multipliers. Both kkyy and Christoph\'s solutions are wrong unfortunately.Please test your code for number 551.175 with 2 decimal places - it will round to 551.17 while it should be 551.18 ! But if you test for ex. 451.175 it will be ok - 451.18. So it\'s difficult to spot this error at a first glance.The problem is with multiplying: try 551.175 * 100 = 55117.49999999999 (ups!)So my idea is to treat it with toFixed() before using Math.round();Maybe you\'ll also want decimal separator? Here is a function I just made:There is no way to avoid inconsistent rounding for prices with x.xx5 as actual value using either multiplication or division. If you need to calculate correct prices client-side you should keep all amounts in cents. This is due to the nature of the internal representation of numeric values in JavaScript. Notice that Excel suffers from the same problems so most people wouldn\'t notice the small errors caused by this phenomen. However errors may accumulate whenever you add up a lot of calculated values, there is a whole theory around this involving the order of calculations and other methods to minimize the error in the final result. To emphasize on the problems with decimal values, please note that 0.1 + 0.2 is not exactly equal to 0.3 in JavaScript, while 1 + 2 is equal to 3.