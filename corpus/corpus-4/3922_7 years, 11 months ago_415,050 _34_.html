What\'s the most idiomatic way in Java to verify that a cast from long to int does not lose any information?This is my current implementation:A new method has been added with Java 8 to do just that. Will throw an ArithmeticException in case of overflow. See: Math.toIntExact(long) Several other overflow safe methods have been added to Java 8. They end with exact. Examples: I think I\'d do it as simply as:I think that expresses the intent more clearly than the repeated casting... but it\'s somewhat subjective.Note of potential interest - in C# it would just be:With Google Guava\'s Ints class, your method can be changed to:From the linked docs:public static int checkedCast(long value)Returns the int value that is equal to value, if possible.Parameters:\n  value - any value in the range of the int typeReturns:\n  the int value that equals valueThrows:\n  IllegalArgumentException - if value is greater than Integer.MAX_VALUE or less than Integer.MIN_VALUEIncidentally, you don\'t need the safeLongToInt wrapper, unless you want to leave it in place for changing out the functionality without extensive refactoring of course.With BigDecimal:here is a solution, in case you don\'t care about value in case it is bigger then needed ;)I claim that the obvious way to see whether casting a value changed the value would be to cast and check the result. I would, however, remove the unnecessary cast when comparing. I\'m also not too keen on one letter variable names (exception x and y, but not when they mean row and column (sometimes respectively)).However, really I would want to avoid this conversion if at all possible. Obviously sometimes it\'s not possible, but in those cases IllegalArgumentException is almost certainly the wrong exception to be throwing as far as client code is concerned.DONT: This is not a solution!My first approach was:But that merely just casts the long to an int, potentially creating new Long instances or retrieving them from the Long pool.The drawbacksLong.valueOf creates a new Long instance if the number is not within Long\'s pool range [-128, 127].The intValue implementation does nothing more than:So this can be considered even worse than just casting the long to int.Java integer types are represented as signed. With an input between 231 and 232 (or -231 and -232) the cast would succeed but your test would fail. What to check for is whether all of the high bits of the long are all the same:but Long can not exceed the maximum :)One other solution can be: I have tried this for cases where the client is doing a POST and the server DB understands only Integers while the client has a Long. 