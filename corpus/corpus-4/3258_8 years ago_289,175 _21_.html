I\'m writing a script in Bash to test some code. However, it seems silly to run the tests if compiling the code fails in the first place, in which case I\'ll just abort the tests.Is there a way I can do this without wrapping the entire script inside of a while loop and using breaks? Something like a dun dun dun goto?Try this statement:Replace 1 with appropriate error codes. See also Exit Codes With Special Meanings.Use set -eThe script will terminate after the first line that fails (returns nonzero exit code).  In this case, command-that-fails2 will not run.If you were to check the return status of every single command, your script would look like this:With set -e it would look like:Any command that fails will cause the entire script to fail and return an exit status you can check with $?.  If your script is very long or you\'re building a lot of stuff it\'s going to get pretty ugly if you add return status checks everywhere.A bad-arse SysOps guy once taught me the Three-Fingered Claw technique:These functions are *NIX OS and shell flavor-robust. Put them at the beginning of your script (bash or otherwise), try() your statement and code on.(based on  flying sheep comment).Hope that explains everything.I often include a function called run() to handle errors.  Every call I want to make is passed to this function so the entire script exits when a failure is hit.   The advantage of this over the set -e solution is that the script doesn\'t exit silently when a line fails, and can tell you what the problem is.  In the following example, the 3rd line is not executed because the script exits at the call to false.If you will invoke the script with source, you can use return <x> where <x> will be the script exit status (use a non-zero value for error or false). This will also work as expected, when you source the script. If you invoke an executable script (i.e., directly with its filename), the return statement will result in a complain (error message "return: can only `return\' from a function or sourced script").If exit <x> is used instead, when the script is invoked with source, it will result in exiting the shell that started the script, but an executable script will run directly fine.To handle either case in the same script, you can useThis will handle whichever invocation may be suitable.Note: <x> is supposed to be just a number.Instead of if construct, you can leverage the short-circuit evaluation:Note the pair of parentheses which is necessary because of priority of alternation operator. $? is a special variable set to exit code of most recently called command.