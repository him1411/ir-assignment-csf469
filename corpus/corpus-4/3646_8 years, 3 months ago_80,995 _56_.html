In various bits of Android code I\'ve seen:However I can\'t find any decent explanation of which is preferable, and under what circumstances which should be used.Pointers to documentation on this, and guidance about what might break if the wrong one is chosen, would be much appreciated.I agree that documentation is sparse when it comes to Contexts in Android, but you can piece together a few facts from various sources.This blog post on the official Google Android developers blog was written mostly to help address memory leaks, but provides some good information about contexts as well:In a regular Android application, you\n  usually have two kinds of Context,\n  Activity and Application.Reading the article a little bit further tells about the difference between the two and when you might want to consider using the application Context (Activity.getApplicationContext()) rather than using the Activity context this).  Basically the Application context is associated with the Application and will always be the same throughout the life cycle of your app, where as the Activity context is associated with the activity and could possibly be destroyed many times as the activity is destroyed during screen orientation changes and such.I couldn\'t find really anything about when to use getBaseContext() other than a post from Dianne Hackborn, one of the Google engineers working on the Android SDK:Don\'t use getBaseContext(), just use\n  the Context you have.That was from a post on the android-developers newsgroup, you may want to consider asking your question there as well, because a handful of the people working on Android actual monitor that newsgroup and answer questions.So overall it seems preferable to use the global application context when possible.Here\'s what I\'ve found regarding the use of context:1) . Within an Activity itself, use this for inflating layouts and menus, register context menus, instantiating widgets, start other activities, create new Intent within an Activity, instantiating preferences, or other methods available in an Activity.Inflate layout:Inflate menu:Register context menu:Instantiate widget:Start an Activity:Instantiate preferences:2) . For application-wide class, use getApplicationContext() as this context exist for the lifespan of the application.Retrieve the name of the current Android package:Bind an application-wide class:3) . For Listeners and other type of Android classes (e.g. ContentObserver), use a Context substitution like:where this or context is the context of a class (Activity, etc).Activity context substitution:Listener context substitution:ContentObserver context substitution:4) . For BroadcastReceiver (including inlined/embedded receiver), use the receiver\'s own context.External BroadcastReceiver:Inlined/Embedded BroadcastReceiver:5) . For Services, use the service\'s own context.6) . For Toasts, generally use getApplicationContext(), but where possible, use the context passed from an Activity, Service, etc.Use context of the application:Use context passed from a source:And last, don\'t use getBaseContext() as advised by Android\'s framework developers.UPDATE: Add examples of Context usage.I read this thread a few days ago, asking myself the same question. My decision after reading this was simple: always use applicationContext.However, I encountered a problem with this, I spent a few hours to find it, and a few seconds to solve it... (changing one word...)I am using a LayoutInflater to inflate a view containing a Spinner.So here are two possibilities:1)2)Then, I am doing something like this:What I noticed: If you instantiated your linearLayout with the applicationContext, then when you click on the spinner in your activity, you will have an uncaught exception, coming from the dalvik virtual machine (not from your code, that\'s why I have spent a lot of time to find where was my mistake...).If you use the baseContext, then that\'s all right, the context menu will open and you will be able to choose among your choices.So here is my conclusion: I suppose (I have not tested it further) than the baseContext is required when dealing with contextMenu in your Activity...The test has been done coding with API 8, and tested on an HTC Desire, android 2.3.3.I hope my comment have not bored you so far, and wish you all the best. Happy coding ;-)First, I agree that we should use appcontext whenever possible. then "this" in activity. i\'ve never had a need for basecontext.In my tests, in most cases they can be interchanged. In most cases, the reason you want to get a hold of a context is to access files, preferences, database etc. These data is eventually reflected as files in your app\'s private data folder (/data/data/). No matter which context you use, they\'ll be mapped to the same folder/files so you are OK.That\'s what I observed. Maybe there are cases you should distinguish them.In some cases you may use Activity context over application context when running something in a thread. When thread completes execution and you need to return the result back to the caller activity, you need that context with a handler.In simple wordsgetApplicationContext() as the method name suggest will make your app aware of application wide details which you can access from anywhere in the app. So you can make use of this in service binding, broadcast registration etc. Application context will be alive till the app exits.getActivity() or this will make your app aware of the current screen which is visible also the app level details provided by application context. So whatever you want to know about the current screen like Window ActionBar Fragementmanger and so are available with this context. Basically and Activity extend Context. This context will alive till the current component(activity) is aliveI\'ve only used this and getBaseContext when toasting from an onClick (very green noob to both Java and android).  I use this when my clicker is directly in the activity and have to use getBaseContext in an anonymous inner clicker.  I\'m guessing that is pretty much the trick with getBaseContext, it is perhaps returning the context of the activity in which the inner class is hiding.  