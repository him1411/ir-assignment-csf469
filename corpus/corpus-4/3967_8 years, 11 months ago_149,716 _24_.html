Just wondering what the difference between BeginInvoke() and Invoke() are? Mainly what each one would be used for.EDIT: What is the difference between creating a threading object and calling invoke on that and just calling BeginInvoke() on a delegate? or are they the same thing?Do you mean Delegate.Invoke/BeginInvoke or Control.Invoke/BeginInvoke?Tim\'s answer mentions when you might want to use BeginInvoke - although it was mostly geared towards Delegate.BeginInvoke, I suspect.For Windows Forms apps, I would suggest that you should usually use BeginInvoke. That way you don\'t need to worry about deadlock, for example - but you need to understand that the UI may not have been updated by the time you next look at it! In particular, you shouldn\'t modify data which the UI thread might be about to use for display purposes. For example, if you have a Person with FirstName and LastName properties, and you did:then the UI may well end up displaying "Keyser Spacey". (There\'s an outside chance it could display "Kevin Soze" but only through the weirdness of the memory model.)Unless you have this sort of issue, however, Control.BeginInvoke is easier to get right, and will avoid your background thread from having to wait for no good reason. Note that the Windows Forms team has guaranteed that you can use Control.BeginInvoke in a "fire and forget" manner - i.e. without ever calling EndInvoke. This is not true of async calls in general: normally every BeginXXX should have a corresponding EndXXX call, usually in the callback.Building on Jon Skeet\'s reply, there are times when you want to invoke a delegate and wait for its execution to complete before the current thread continues.  In those cases the Invoke call is what you want.In multi-threading applications, you may not want a thread to wait on a delegate to finish execution, especially if that delegate performs I/O (which could make the delegate and your thread block).In those cases the BeginInvoke would be useful.  By calling it, you\'re telling the delegate to start but then your thread is free to do other things in parallel with the delegate.Using BeginInvoke increases the complexity of your code but there are times when the improved performance is worth the complexity.The difference between Control.Invoke() and Control.BeginInvoke() is,A logical conclusion is that a delegate you pass to Invoke() can have out-parameters or a return-value, while a delegate you pass to BeginInvoke() cannot (you have to use EndInvoke to retrieve the results).Just to give a short, working example to see an effect of their differenceIf use BeginInvoke, MessageBox pops simultaneous to the text update. If use Invoke, MessageBox pops after the 3 second sleep. Hence, showing the effect of an asynchronous (BeginInvoke) and a synchronous (Invoke) call. Delegate.BeginInvoke() asynchronously queues the call of a delegate and returns control immediately.  When using Delegate.BeginInvoke(), you should call Delegate.EndInvoke() in the callback method to get the results.Delegate.Invoke() synchronously calls the delegate in the same thread.MSDN ArticleJust adding why and when to use Invoke().Both Invoke() and BeginInvoke() marshal the code you specify to the dispatcher thread.But unlike BeginInvoke(), Invoke() stalls your thread until the dispatcher executes your code. You might want to use Invoke() if you need to pause an asynchronous operation until the user has supplied some sort of feedback.For example, you could call Invoke() to run a snippet of code that shows an OK/Cancel dialog box. After the user clicks a button and your marshaled code completes, the invoke() method will return, and you can act upon the user\'s response. See Pro WPF in C# chapter 31