In SQL Server 2005, we can create temp tables one of two ways:orWhat are the differences between these two?  I have read conflicting opinions on whether @tmp still uses tempdb, or if everything happens in memory.  In which scenarios does one out-perform the other? There are a few differences between Temporary Tables (#tmp) and Table Variables (@tmp), although using tempdb isn\'t one of them, as spelt out in the MSDN link below.As a rule of thumb, for small to medium volumes of data and simple usage scenarios you should use table variables. (This is an overly broad guideline with of course lots of exceptions - see below and following articles.)Some points to consider when choosing between them: Temporary Tables are real tables so you can do things like CREATE INDEXes, etc. If you have large amounts of data for which accessing by index will be faster then temporary tables are a good option.Table variables can have indexes by using PRIMARY KEY or UNIQUE constraints. (If you want a non-unique index just include the primary key column as the last column in the unique constraint. If you don\'t have a unique column, you can use an identity column.) SQL 2014 has non-unique indexes too.Table variables don\'t participate in transactions and SELECTs are implicitly with NOLOCK. The transaction behaviour can be very helpful, for instance if you want to ROLLBACK midway through a procedure then table variables populated during that transaction will still be populated!Temp tables might result in stored procedures being recompiled, perhaps often. Table variables will not.You can create a temp table using SELECT INTO, which can be quicker to write (good for ad-hoc querying) and may allow you to deal with changing datatypes over time, since you don\'t need to define your temp table structure upfront. You can pass table variables back from functions, enabling you to encapsulate and reuse logic much easier (eg make a function to split a string into a table of values on some arbitrary delimiter).Using Table Variables within user-defined functions enables those functions to be used more widely (see CREATE FUNCTION documentation for details). If you\'re writing a function you should use table variables over temp tables unless there\'s a compelling need otherwise.Both table variables and temp tables are stored in tempdb. But table variables (since 2005) default to the collation of the current database versus temp tables which take the default collation of tempdb (ref). This means you should be aware of collation issues if using temp tables and your db collation is different to tempdb\'s, causing problems if you want to compare data in the temp table with data in your database.Global Temp Tables (##tmp) are another type of temp table available to all sessions and users. Some further reading:Martin Smith\'s great answer on dba.stackexchange.comMSDN FAQ on difference between the two: https://support.microsoft.com/en-gb/kb/305977MDSN blog article: http://blogs.msdn.com/sqlserverstorageengine/archive/2008/03/30/sql-server-table-variable-vs-local-temporary-table.aspxArticle: http://searchsqlserver.techtarget.com/tip/0,289483,sid87_gci1267047,00.html#Just looking at the claim in the accepted answer that table variables don\'t participate in logging. It seems generally untrue that there is any difference in quantity of logging (at least for insert/update/delete operations to the table itself though I have since found that there is some small difference in this respect for cached temporary objects in stored procedures due to additional system table updates).I looked at the logging behaviour against both a @table_variable and a #temp table for the following operations.The transaction log records were almost identical for all operations. The table variable version actually has a few extra log entries because it gets an entry added to  (and later removed from) the sys.syssingleobjrefs base table but overall had a few less bytes logged purely as the internal name for table variables consumes 236 less bytes than for #temp tables (118 fewer nvarchar characters).ResultsIn which scenarios does one out-perform the other?For smaller tables (less than 1000 rows) use a temp variable, otherwise use a temp table.@wcm - actually to nit pick the Table Variable isn\'t Ram only - it can be partially stored on disk.A temp table can have indexes, whereas a table variable can only have a primary index. If speed is an issue Table variables can be faster, but obviously if there are a lot of records, or the need to search the temp table of a clustered index, then a Temp Table would be better.Good background articleTemp table: A Temp table is easy to create and back up data.Table variable: But the table variable involves the effort when we usually create the normal tables.Temp table: Temp table result can be used by multiple users.Table variable: But the table variable can be used by the current user only.\xc2\xa0Temp table: Temp table will be stored in the tempdb. It will make network traffic. When we have large data in the temp table then it has to work across the database. A Performance issue will exist.Table variable: But a table variable will store in the physical memory for some of the data, then later when the size increases it will be moved to the tempdb.Temp table: Temp table can do all the DDL operations. It allows creating the indexes, dropping, altering, etc..,Table variable: Whereas table variable won\'t allow doing the DDL operations. But the table variable allows us to create the clustered index only.Temp table: Temp table can be used for the current session or global. So that a multiple user session can utilize the results in the table.Table variable: But the table variable can be used up to that program. (Stored procedure)Temp table: Temp variable cannot use the transactions. When we do the DML operations with the temp table then it can be rollback or commit the transactions.Table variable: But we cannot do it for table variable.Temp table: Functions cannot use the temp variable. More over we cannot do the DML operation in the functions .Table variable: But the function allows us to use the table variable. But using the table variable we can do that.Temp table: The stored procedure will do the recompilation (can\'t use same execution plan) when we use the temp variable for every sub sequent calls.Table variable: Whereas the table variable won\'t do like that.For all of you who believe the myth that temp variables are in memory only First, the table variable is NOT necessarily memory resident. Under memory pressure, the pages belonging to a table variable can be pushed out to tempdb.Read the article here: TempDB:: Table variable vs local temporary table The other main difference is that table variables don\'t have column statistics, where as temp tables do. This means that the query optimiser doesn\'t know how many rows are in the table variable (it guesses 1), which can lead to highly non-optimal plans been generated if the table variable actually has a large number of rows.Quote taken from; Professional SQL Server 2012 Internals and TroubleshootingStatistics\n  The major difference between temp tables and table variables is that\n  statistics are not created on table variables. This has two major\n  consequences, the fi rst of which is that the Query Optimizer uses a\n  fi xed estimation for the number of rows in a table variable\n  irrespective of the data it contains. Moreover, adding or removing\n  data doesn\xe2\x80\x99t change the estimation.Indexes You can\xe2\x80\x99t create indexes on table variables although you can\n  create constraints. This means that by creating primary keys or unique\n  constraints, you can have indexes (as these are created to support\n  constraints) on table variables. Even if you have constraints, and\n  therefore indexes that will have statistics, the indexes will not be\n  used when the query is compiled because they won\xe2\x80\x99t exist at compile\n  time, nor will they cause recompilations.Schema Modifications Schema modifications are possible on temporary\n  tables but not on table variables. Although schema modifi cations are\n  possible on temporary tables, avoid using them because they cause\n  recompilations of statements that use the tables.TABLE VARIABLES ARE NOT CREATED IN MEMORYThere is a common misconception that table variables are in-memory structures\nand as such will perform quicker than temporary tables. Thanks to a DMV\ncalled  sys . dm _ db _ session _ space _ usage , which shows tempdb usage by\nsession, you can prove that\xe2\x80\x99s not the case. After restarting SQL Server to clear the\nDMV, run the following script to confi rm that your  session _ id returns  0 for\nuser _ objects _ alloc _ page _ count :Now you can check how much space a temporary table uses by running the following\n    script to create a temporary table with one column and populate it with one row:The results on my server  indicate that the table was allocated one page in tempdb.\nNow run the same script but use a table variable\nthis time:Which one to Use?Whether or not you use temporary tables or table variables should be\n  decided by thorough testing, but it\xe2\x80\x99s best to lean towards temporary\n  tables as the default because there are far fewer things that can go\n  wrong.  I\xe2\x80\x99ve seen customers develop code using table variables because  they\n  were dealing with a small amount of rows, and it was quicker than  a\n  temporary table, but a few years later there were hundreds of \n  thousands of rows in the table variable and performance was terrible, \n  so try and allow for some capacity planning when you make your \n  decision!Another difference:A table var can only be accessed from statements within the procedure that creates it, not from other procedures called by that procedure or nested dynamic SQL (via exec or sp_executesql).A temp table\'s scope, on the other hand, includes code in called procedures and nested dynamic SQL.If the table created by your procedure must be accessible from other called procedures or dynamic SQL, you must use a temp table.  This can be very handy in complex situations.Consider also that you can often replace both with derived tables which may be faster as well. As with all performance tuning, though, only actual tests against your actual data can tell you the best approach for your particular query.Temporary TableTemporary table behave like a real tables but created on run time. Its work similar to real table. We can do almost every operations which possible into real tables. We can use DDL Statements like ALTER, CREATE, DROP on Temporary Tables.Any changes in structure of Temporary table is possible after creation. Temporary Table stored into \xe2\x80\x9ctempdb\xe2\x80\x9d Database of system Databases.Temporary Table participate in transactions, logging or locking. Due to that reason it\xe2\x80\x99s slower than Table Variable.  Table VariableIt\xe2\x80\x99s Variable but work like a table.  It\xe2\x80\x99s also created into Tempdb Database not in the memory. Table Variable only available in the batch or stored Procedure scope. You no need to drop Table Variable , It\xe2\x80\x99s automatically dropped when batch and store Procedure execution process completeTable variable support primary Key, identity on creation time. But it not support non-clustered index.  After declaration primary key, identity you can\xe2\x80\x99t modify them.Table variables don\'t participate in transactions, logging or locking. Transactions, logging and locking not effect to Table Variables.Read this article for more - http://goo.gl/GXtXqz