What does a JIT compiler specifically do as opposed to a non-JIT compiler? Can someone give a succinct and easy to understand description?A JIT compiler runs after the program has started and compiles the code (usually bytecode or some kind of VM instructions) on the fly (or just-in-time, as it\'s called) into a form that\'s usually faster, typically the host CPU\'s native instruction set. A JIT has access to dynamic runtime information whereas a standard compiler doesn\'t and can make better optimizations like inlining functions that are used frequently.This is in contrast to a traditional compiler that compiles all the code to machine language before the program is first run.To paraphrase, conventional compilers build the whole program as an EXE file BEFORE the first time you run it. For newer style programs, an assembly is generated with pseudocode (p-code). Only AFTER you execute the program on the OS (e.g., by double-clicking on its icon) will the (JIT) compiler kick in and generate machine code (m-code) that the Intel-based processor or whatever will understand.In the beginning, a compiler was responsible for turning a high-level language (defined as higher level than assembler) into object code (machine instructions), which would then be linked (by a linker) into an executable.At one point in the evolution of languages, compilers would compile a high-level language into pseudo-code, which would then be interpreted (by an interpreter) to run your program.  This eliminated the object code and executables, and allowed these languages to be portable to multiple operating systems and hardware platforms.  Pascal (which compiled to P-Code) was one of the first; Java and C# are more recent examples.  Eventually the term P-Code was replaced with bytecode, since most of the pseudo-operations are a byte long.A Just-In-Time (JIT) compiler is a feature of the run-time interpreter, that instead of interpreting bytecode every time a method is invoked, will compile the bytecode into the machine code instructions of the running machine, and then invoke this object code instead.  Ideally the efficiency of running object code will overcome the inefficiency of recompiling the program every time it runs.JIT-Just in time\nthe word itself says when it\'s needed (on demand)The source code is completely converted into machine codeThe source code will be converted into assembly language like structure [for ex IL (intermediate language) for C#, ByteCode for java].The intermediate code is converted into machine language only when the application needs that is required codes are only converted to machine code.In JIT not all the code is converted into machine code first a part\nof the code that is necessary will be converted into machine code\nthen if a method or functionality called is not in machine then that\nwill be turned into machine code... it reduces burden on the CPU.As the machine code will be generated on run time....the JIT\ncompiler will produce machine code that is optimised for running\nmachine\'s CPU architecture.As other have mentionedJIT stands for Just-in-Time which means that code gets compiled when it is needed, not before runtime. Just to add a point to above discussion JVM maintains a count as of how many time a function is executed. If this count exceeds a predefined limit JIT compiles the code into machine language which can directly be executed by the processor (unlike the normal case in which javac compile the code into bytecode and then java - the interpreter interprets this bytecode line by line converts it into machine code and executes).Also next time this function is calculated same compiled code is executed again unlike normal interpretation in which the code is interpreted again line by line. This makes execution faster.JIT stands for Just-in-Time which means that code gets compiled when it is needed, not before runtime. This is beneficial because the compiler can generate code that is optimised for your particular machine. A static compiler, like your average C compiler, will compile all of the code on to executable code on the developer\'s machine. Hence the compiler will perform optimisations based on some assumptions. It can compile more slowly and do more optimisations because it is not slowing execution of the program for the user.After the byte code (which is architecture neutral) has been generated by the Java compiler, the execution will be handled by the JVM (in Java). The byte code will be loaded in to JVM by the loader and then each byte instruction is interpreted.When we need to call a method multiple times, we need to interpret the same code many times and this may take more time than is needed. So we have the JIT (just-in-time) compilers. When the byte has been is loaded in to JVM (its run time), the whole code will be compiled rather than interpreted, thus saving time.JIT compilers works only during run time, so we do not have any binary output.Just In Time Compiler (JIT) :\nIt compiles the java bytecodes into machine instructions of that specific CPU. For example, if we have a loop statement in our java code :The above loop code runs for 10 times if the value of i is 0.It is not necessary to compile the bytecode for 10 times again and again as the same instruction is going to execute for 10 times. In that case, it is necessary to compile that code only once and the value can be changed for the required number of times. So, Just In Time (JIT) Compiler keeps track of such statements and methods (as said above before) and compiles such pieces of byte code into machine code for better performance. Another similar example , is that a search for a pattern using "Regular Expression" in a list of strings/sentences.JIT Compiler doesn\'t compile all the code to machine code. It compiles code that have a similar pattern at run time.See this Oracle documentation on Understand JIT to read more.I know this is an old thread, but runtime optimization is another important part of JIT compilation that doesn\'t seemed to be discussed here.  Basically, the JIT compiler can monitor the program as it runs to determine ways to improve execution.  Then, it can make those changes on the fly - during runtime.  Google JIT optimization (javaworld has a pretty good article about it.)You have code that is compliled into some IL (intermediate language).  When you run your program, the computer doesn\'t understand this code.  It only understands native code.  So the JIT compiler compiles your IL into native code on the fly.  It does this at the method level.Jit stands for just in time compiler\njit is a program that turns java byte code into instruction that can be sent directly to the processor.Using the java just in time compiler (really a second compiler) at the particular system platform  complies the bytecode into particular system code,once the code has been re-compiled by the jit complier ,it will usually run more quickly in the computer.   The just-in-time compiler comes with the virtual machine and is used optionally. It compiles the bytecode into platform-specific executable code that is immediately executed.A non-JIT compiler takes source code and transforms it into machine specific byte code at compile time. A JIT compiler takes machine agnostic byte code that was generated at compile time and transforms it into machine specific byte code at run time. The JIT compiler that Java uses is what allows a single binary to run on a multitude of platforms without modification.The following code examples show how the JIT optimizes Java code.Code Before OptimizationCode After OptimizationOriginally, the code contained two calls to the b.get() method. After optimization, the two method calls are optimized into a single variable-copy operation; that is, the optimized code does not need to perform a method call to acquire the field value of class B.20% of the byte code is used 80% of the time. The JIT compiler gets these stats and optimizes this 20% of the byte code to run faster by adding inline methods, removal of unused locks etc and also creating the bytecode specific to that machine.  I am quoting from this article,  I found it was handy. http://java.dzone.com/articles/just-time-compiler-jit-hotspotJIT refers to execution engine in few of JVM implementations, one that is faster but requires more memory,is a just-in-time compiler. In this scheme, the bytecodes of a method are compiled to native machine code the first time the method is invoked. The native machine code for the method is then cached, so it can be re-used the next time that same method is invoked.JVM actually performs compilation steps during runtime for performance reasons. This means that Java doesn\'t have a clean compile-execution separation. It first does a so called static compilation from Java source code to bytecode. Then this bytecode is passed to the JVM for execution. But executing bytecode is slow so the JVM measures how often the bytecode is run and when it detects a "hotspot" of code that\'s run very frequently it performs dynamic compilation from bytecode to machinecode of the "hotspot" code (hotspot profiler). So effectively today Java programs are run by machinecode execution. 