Is there any way to get something like the following to work in JavaScript?In the current form, this code obviously throws a reference error since this doesn\'t refer to foo. But is there any way to have values in an object literal\'s properties depend on other properties declared earlier?Well, the only thing that I can tell you about are getters:This is a syntactic extension introduced by the ECMAScript 5th Edition Specification, the syntax is supported by most modern browsers (including IE9).You could do something like:This would be some kind of one time initialization of the object.Note that you are actually assigning the return value of init() to foo, therefore you have to return this.The obvious, simple answer is missing, so for completeness:But is there any way to have values in an object literal\'s properties depend on other properties declared earlier?No. All of the solutions here defer it until after the object is created (in various ways) and then assign the third property. The simplest way is to just do this:All others are just more indirect ways to do the same thing. (Felix\'s is particularly clever, but requires creating and destroying a temporary function, adding complexity; and either leaves an extra property on the object or [if you delete that property] impacts the performance of subsequent property accesses on that object.)If you need it to all be within one expression, you can do that without the temporary property:Or of course, if you need to do this more than once:then where you need to use it:Simply instantiate an anonymous function:Some closure should deal with this;All the variables declared within foo are private to foo, as you would expect with any function declaration and because they are all in scope, they all have access to each other without needing to refer to this, just as you would expect with a function.  The difference is that this function returns an object that exposes the private variables and assigns that object to foo.  In the end, you return just the interface you want to expose as an object with the return {} statement.The function is then executed at the end with the () which causes the entire foo object to be evaluated, all the variables within instantiated and the return object added as properties of foo().You could do it like thisThat method has proven useful to me when I had to refer to the object that a function was originally declared on. The following is a minimal example of how I used it:By defining self as the object that contains the print function you allow the function to refer to that object. This means you will not have to \'bind\' the print function to an object if you need to pass it somewhere else. If you would, instead, use this as illustrated belowThen the following code will log 0, 1, 2 and then give an errorBy using the self method you guarantee that print will always return the same object regardless of the context in which the function is ran. The code above will run just fine and log 0, 1, 2 and 3 when using the self version of createMyObject(). Now in ES6 you can create lazy cached properties. On first use the property evaluates once to become a normal static property. Result: The second time the math function overhead is skipped. The magic is in the getter.In the arrow getter this picks up the surrounding lexical scope. You can do it using the module pattern. Just like:With this pattern you can instantiate several foo objects according to your need.http://jsfiddle.net/jPNxY/1/There are several ways to accomplish this; this is what I would use:For completion, in ES6 we\'ve got classes (supported at the time of writing this only by latest browsers, but available in Babel, TypeScript and other transpilers)just for the sake of thought - place object\'s properties out of a timeline:there are better answers above too. This is how I modified example code you questioned with.UPDATE:Creating new function on your object literal and invoking a constructor seems a radical departure from the original problem, and it\'s unnecessary.  You cannot reference a sibling property during object literal initialization. The simplest solution for computed properties follows (no heap, no functions, no constructor): The other answers posted here are better but here\'s an alternative that:Self-executing anonymous functions and window storageThe order is guaranteed (bar before baz).It pollutes window of course, but I can\'t imagine someone writing a script that requires window.temp to be persistent. Maybe tempMyApp if you\'re paranoid.It\'s also ugly but occasionally useful. An example is when you are using an API with rigid initialization conditions and don\'t feel like refactoring so the scoping is correct.And it\'s dry, of course.if your object is written as a function which returns an object, AND you use ES6 object-attribute \'methods\', then it\'s possible:The key to all this is SCOPE.You need to encapsulate the "parent" (parent object) of the property you want to define as it\'s own instantiated object, and then you can make references to sibling properties using the key word thisIt\'s very, very important to remember that if you refer to this without first so doing, then this will refer to the outer scope... which will be the window object.How about this  solution this will work with nested objects with array as wellI use the following code as alternative, and it works. And the variable can be array too. (@ Fausto R.)