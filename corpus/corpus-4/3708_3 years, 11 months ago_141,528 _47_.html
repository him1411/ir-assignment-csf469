I want to look at the source code for a function to see how it works. I know I can print a function by typing its name at the prompt:In this case, what does UseMethod("t") mean?  How do I find the source code that\'s actually being used by, for example: t(1:10)?In other cases, I can see that R functions are being called, but I can\'t find the source code for those functions.How do I find functions like .cbindts and .makeNamesTs?In still other cases, there\'s a bit of R code, but most of work seems to be done somewhere else.How do I find out what the .Primitive function does?  Similarly, some functions call .C, .Call, .Fortran, .External, or .Internal.  How can I find the source code for those?UseMethod("t") is telling you that t() is a (S3) generic function that has methods for different object classes.For S3 classes, you can use the methods function to list the methods for a particular generic function or class."Non-visible functions are asterisked" means the function is not exported from its package\'s namespace.  You can still view its source code via the ::: function (i.e. stats:::t.ts), or by using getAnywhere().  getAnywhere() is useful because you don\'t have to know which package the function came from.The S4 system is a newer method dispatch system and is an alternative to the S3 system. Here is an example of an S4 function:The output already offers a lot of information. standardGeneric is an indicator of an S4 function. The method to see defined S4 methods is offered helpfully:getMethod can be used to see the source code of one of the methods:There are also methods with more complex signatures for each method, for exampleTo see the source code for one of these methods the entire signature must be supplied, e.g.It will not suffice to supply the partial signatureIn the case of ts.union, .cbindts and .makeNamesTs are unexported functions from the stats namespace. You can view the source code of unexported functions by using the ::: operator or getAnywhere.Note that "compiled" does not refer to byte-compiled R code as created by the compiler package. The <bytecode: 0x294e410> line in the above output indicates that the function is byte-compiled, and you can still view the source from the R command line.Functions that call .C, .Call, .Fortran, .External, .Internal, or .Primitive are calling entry points in compiled code, so you will have to look at sources of the compiled code if you want to fully understand the function. This GitHub mirror of the R source code is a decent place to start. The function pryr::show_c_source can be a useful tool as it will take you directly to a GitHub page for .Internal and .Primitive calls. Packages may use .C, .Call, .Fortran, and .External; but not .Internal or .Primitive, because these are used to call functions built into the R interpreter.Calls to some of the above functions may use an object instead of a character string to reference the compiled function. In those cases, the object is of class "NativeSymbolInfo", "RegisteredNativeSymbol", or "NativeSymbol"; and printing the object yields useful information.  For example, optim calls .External2(C_optimhess, res$par, fn1, gr1, con) (note that\'s C_optimhess, not "C_optimhess").  optim is in the stats package, so you can type stats:::C_optimhess to see information about the compiled function being called.If you want to view compiled code in a package, you will need to download/unpack the package source. The installed binaries are not sufficient. A package\'s source code is available from the same CRAN (or CRAN compatible) repository that the package was originally installed from. The download.packages() function can get the package source for you.This will download the source version of the Matrix package and save the corresponding .tar.gz file in the current directory. Source code for compiled functions can be found in the src directory of the uncompressed and untared file. The uncompressing and untaring step can be done outside of R, or from within R using the untar() function. It is possible to combine the download and expansion step into a single call (note that only one package at a time can be downloaded and unpacked in this way):Alternatively, if the package development is hosted publicly (e.g. via GitHub, R-Forge, or RForge.net), you can probably browse the source code online.Certain packages are considered "base" packages. These packages ship with R and their version is locked to the version of R. Examples include base, compiler, stats, and utils. As such, they are not available as separate downloadable packages on CRAN as described above. Rather, they are part of the R source tree in individual package directories under /src/library/. How to access the R source is described in the next section.If you want to view the code built-in to the R interpreter, you will need to download/unpack the R sources; or you can view the sources online via the R Subversion repository or Winston Chang\'s github mirror.Uwe Ligges\'s R news article (PDF) (p. 43) is a good general reference of how to view the source code for .Internal and .Primitive functions.  The basic steps are to first look for the function name in src/main/names.c and then search for the "C-entry" name in the files in src/main/*.In addition to the other answers on this question and its duplicates, here\'s a good way to get source code for a package function without needing to know which package it\'s in.\ne.g. if we want the source for randomForest::rfcv():To view/edit it in a pop-up window:To redirect to a separate file:It gets revealed when you debug using the debug() function. \nSuppose you want to see the underlying code in t() transpose function. Just typing \'t\', doesn\'t reveal much.But, Using the \'debug(functionName)\', it reveals the underlying code, sans the internals.EDIT:\ndebugonce() accomplishes the same without having to use undebug()Didn\'t see how this fit into the flow of the main answer but it stumped me for a while so I\'m adding it here:To see the source code of some base infix operators (e.g., %%, %*%, %in%), use getAnywhere, e.g.:The main answer covers how to then use mirrors to dig deeper.For non-primitive functions, R base includes a function called body() that returns the body of function.  For instance the source of the print.Date() function can be viewed:will produce this:If you are working in a script and want the function code as a character vector, you can get it.will get you:Why would I want to do such a thing?  I was creating a custom S3 object (x, where class(x) = "foo") based on a list.  One of the list members (named "fun") was a function and I wanted print.foo() to display the function source code, indented.  So I ended up with the following snippet in print.foo():which indents and displays the code associated with x[["fun"]].There is a very handy function in R editIt will open the source code of optim using the editor specified in R\'s options, and then you can edit it and assign the modified function to new_optim. I like this function very much to view code or to debug the code, e.g, print some messages or variables or even assign them to a global variables for further investigation (of course you can use debug).If you just want to view the source code and don\'t want the annoying long source code printed on your console, you can useClearly, this cannot be used to view C/C++ or Fortran source code.BTW, edit can open other objects like list, matrix, etc, which then shows the data structure with attributes as well.  Function de can be used to open an excel like editor (if GUI supports it) to modify matrix or data frame and return the new one. This is handy sometimes, but should be avoided in usual case, especially when you matrix is big.As long as the function is written in pure R not C/C++/Fortran, one may use the following. Otherwise the best way is debugging and using "jump into":View([function_name]) - eg. View(mean) Make sure to use uppercase [V]. The read-only code will open in the editor.