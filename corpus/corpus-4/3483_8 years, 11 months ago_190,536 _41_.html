What is the difference between using the Runnable and Callable interfaces when designing a concurrent thread in Java, why would you choose one over the other?See explanation here.The Callable interface is similar to\n  Runnable, in that both are designed\n  for classes whose instances are\n  potentially executed by another\n  thread. A Runnable, however, does not\n  return a result and cannot throw a\n  checked exception.What are the differences in the applications of Runnable and Callable. Is the difference only with the return parameter present in Callable?Basically, yes.  See the answers to this question.  And the javadoc for Callable.What is the need of having both if Callable can do all that Runnable does?Because the Runnable interface cannot do everything that Callable does!Runnable has been around since Java 1.0, but Callable was only introduced in Java 1.5 ... to handle use-cases that Runnable does not support.  In theory, the Java team could have changed the signature of the Runnable.run() method, but this would have broken binary compatiblity with pre-1.5 code, requiring recoding when migrating old Java code to newer JVMs.  That is a BIG NO-NO.  Java strives to be backwards compatible ... and that\'s been one of Java\'s biggest selling points for business computing.And, obviously, there are use-cases where a task doesn\'t need to return a result or throw a checked exception.  For those use-cases, using Runnable is more concise than using Callable<Void> and returning a dummy (null) value from the call() method.A Callable can be used with ExecutorService#invokeXXX(Collection<? extends Callable<T>> tasks) methods but a Runnable cannot be.I found this in another blog that can explain it a little bit more these differences: Though both the interfaces are implemented by the classes who wish to execute in a different thread of execution, but there are few differences between the two interface which are:The designers of Java felt a need of extending the capabilities of the Runnable interface, but they didn\'t want to affect the uses of the Runnable interface and probably that was the reason why they went for having a separate interface named Callable in Java 1.5 than changing the already existing Runnable.Let us look at where one would use Runnable and Callable.Runnable and Callable both run on a different thread than the calling thread. But Callable can return a value and Runnable cannot. So where does this really apply.Runnable : If you have a fire and forget task then use Runnable. Put your code inside a Runnable and when the run() method is called, you can perform your task. The calling thread really does not care when you perform your task.Callable : If you are trying to retrieve a value from a task, then use Callable. Now callable on its own will not do the job. You will need a Future that you wrap around your Callable and get your values on future.get (). Here the calling thread will be blocked till the Future comes back with results which in turn is waiting for Callable\'s call() method to execute.So think about an interface to a target class where you have both Runnable and Callable wrapped methods defined. The calling class will randomly call your interface methods not knowing which is Runnable and which is Callable. The Runnable methods will execute asynchronously, till a Callable method is called. Here the calling class\'s thread will block since you are retrieving values from your target class. NOTE : Inside your target class you can make the calls to Callable and Runnable on a single thread executor, making this mechanism similar to a serial dispatch queue. So as long as the caller calls your Runnable wrapped methods the calling thread will execute really fast without blocking. As soon as it calls a Callable wrapped in Future method it will have to block till all the other queued items are executed. Only then the method will return with values. This is a synchronization mechanism.Callable interface declares call() method and you need to provide generics as type of Object call() should return -Runnable on the other hand is interface that declares run() method that is called when you create a Thread with the runnable and call start() on it. You can also directly call run() but that just executes the run() method is same thread.To summarize few notable Difference areFew similarities includeMethods in ExecutorService interface areThe differences between Callable and Runnable & use cases to use each of them are clear from earlier answers.I will provide more info on exception handling part. I have a written a code to simulate Arithmetic exception : divide by zero. If you submit Runnable by using Executor.html#execute, it will return Exceptions during the processing of Runnable task. If you submit the Callable and did not check the status of Future task (by calling get() method on Future), you will be misled with result of future task.future.isDone() returns true even for divide by zero exception, which has been encountered in Callable task call() method. These types of Exceptions are caught by Framework internally and hidden. Have a look at example code ( Without inspecting get() method on Future).output:Now uncomment the code fromto output:The other ways of handling these type of exceptions are explained in :Handling exceptions from Java ExecutorService tasksWhy is UncaughtExceptionHandler not called by ExecutorService?As it was already mentioned here Callable is relatively new interface and it was introduced as a part of concurrency package. Both Callable and Runnable can be used with executors. Class Thread (that implements Runnable itself) supports Runnable only.You can still use Runnable with executors. The advantage of Callable that you can send it to executor and immediately get back Future result that will be updated when the execution is finished. The same may be implemented with Runnable, but in this case you have to manage the results yourself. For example you can create results queue that will hold all results. Other thread can wait on this queue and deal with results that arrive.