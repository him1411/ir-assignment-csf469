I am using the function below to match URLs inside a given text and replace them for HTML links. The regular expression is working great, but currently I am only replacing the first match.How I can replace all the URL? I guess I should be using the exec command, but I did not really figure how to do it.First off, rolling your own regexp to parse URLs is a terrible idea. You must imagine this is a common enough problem that someone has written, debugged and tested a library for it, according to the RFCs. URIs are complex - check out the code for URL parsing in Node.js and the Wikipedia page on URI schemes.There are a ton of edge cases when it comes to parsing URLs: international domain names, actual (.museum) vs. nonexistent (.etc) TLDs, weird punctuation including parentheses, punctuation at the end of the URL, IPV6 hostnames etc.I\'ve looked at a ton of libraries, and there are a few worth using despite some downsides:Libraries that I\'ve disqualified quickly for this task:If you insist on a regular expression, the most comprehensive is the URL regexp from Component, though it will falsely detect some non-existent two-letter TLDs by looking at it.The regular expression in the question misses a lot of edge cases. When detecting URLs, it\'s always better to use a specialized library that handles international domain names, new TLDs like .museum, parentheses and other punctuation within and at the end of the URL, and many other edge cases. See the Jeff Atwood\'s blog post The Problem With URLs for an explanation of some of the other issues. The best summary of URL matching libraries is in Dan Dascalescu\'s Answer \n  (as of Feb 2014)Add a "g" to the end of the regular expression to enable global matching:But that only fixes the problem in the question where the regular expression was only replacing the first match. Do not use that code.I\'ve made some small modifications to Travis\'s code (just to avoid any unnecessary redeclaration - but it\'s working great for my needs, so nice job!):Made some optimizations to Travis\' Linkify() code above. I also fixed a bug where email addresses with subdomain type formats would not be matched (i.e. example@domain.co.uk).In addition, I changed the implementation to prototype the String class so that items can be matched like so:Anyway, here\'s the script:Thanks, this was very helpful. I also wanted something that would link things that looked like a URL -- as a basic requirement, it\'d link something like www.yahoo.com, even if the http:// protocol prefix was not present. So basically, if "www." is present, it\'ll link it and assume it\'s http://. I also wanted emails to turn into mailto: links. EXAMPLE:  www.yahoo.com would be converted to www.yahoo.comHere\'s the code I ended up with (combination of code from this page and other stuff I found online, and other stuff I did on my own):In the 2nd replace, the (^|[^/]) part is only replacing www.whatever.com if it\'s not already prefixed by // -- to avoid double-linking if a URL was already linked in the first replace. Also, it\'s possible that www.whatever.com might be at the beginning of the string, which is the first "or" condition in that part of the regex.This could be integrated as a jQuery plugin as Jesse P illustrated above -- but I specifically wanted a regular function that wasn\'t acting on an existing DOM element, because I\'m taking text I have and then adding it to the DOM, and I want the text to be "linkified" before I add it, so I pass the text through this function. Works great.Identifying URLs is tricky because they are often surrounded by punctuation marks and because users frequently do not use the full form of the URL. Many JavaScript functions exist for replacing URLs with hyperlinks, but I was unable to find one that works as well as the urlize filter in the Python-based web framework Django. I therefore ported Django\'s urlize function to JavaScript:https://github.com/ljosa/urlize.jsAn example:The second argument, if true, causes rel="nofollow" to be inserted. The third argument, if true, escapes characters that have special meaning in HTML. See the README file.I made a change to Roshambo String.linkify() to the emailAddressPattern to recognize aaa.bbb.@ccc.ddd addressesThe best script to do this:\nhttp://benalman.com/projects/javascript-linkify-process-lin/This solution works like many of the others, and in fact uses the same regex as one of them, however in stead of returning a HTML String this will return a document fragment containing the A element and any applicable text nodes. There are some caveats, namely with older IE and textContent support. here is a demo.If you need to show shorter link (only domain), but with same long URL, you can try my modification of Sam Hasler\'s code version posted aboveKeep it simple! Say what you cannot have, rather than what you can have :)As mentioned above, URLs can be quite complex, especially after the \'?\', and not all of them start with a \'www.\' e.g. maps.bing.com/something?key=!"\xc2\xa3$%^*()&lat=65&lon&lon=20So, rather than have a complex regex that wont meet all edge cases, and will be hard to maintain, how about this much simpler one, which works well for me in practise.Matchhttp(s):// (anything but a space)+www. (anything but a space)+Where \'anything\' is [^\'"<>\\s]\n... basically a greedy match, carrying on to you meet a space, quote, angle bracket, or end of line Also:Remember to check that it is not already in URL format, e.g. the text contains href="..." or src="..."Add ref=nofollow (if appropriate)This solution isn\'t as "good" as the libraries mentioned above, but is much simpler, and works well in practise.I searched on google for anything newer and ran across this one:demo: http://jsfiddle.net/kachibito/hEgvc/1/Works really well for normal links.The warnings about URI complexity should be noted, but the simple answer to your question is:\nTo replace every match you need to add the /g flag to the end of the RegEx:\n/(\\b(https?|ftp|file):\\/\\/[-A-Z0-9+&@#\\/%?=~_|!:,.;]*[-A-Z0-9+&@#\\/%=~_|])/giReg Ex: \n/(\\b((https?|ftp|file):\\/\\/|(www))[-A-Z0-9+&@#\\/%?=~_|!:,.;]*[-A-Z0-9+&@#\\/%=~_|]*)/igBelow are some tested string: Note: If you don\'t want to pass www as valid one just use below reg ex: \n/(\\b((https?|ftp|file):\\/\\/|(www))[-A-Z0-9+&@#\\/%?=~_|!:,.;]*[-A-Z0-9+&@#\\/%=~_|])/igCorrect URL detection with international domains & astral characters support is not trivial thing. linkify-it library builds regex from many conditions, and final size is about 6 kilobytes :) . It\'s more accurate than all libs, currently referenced in accepted answer.See linkify-it demo to check live all edge cases and test your ones.If you need to linkify HTML source, you should parse it first, and iterate each text token separately.I had to do the opposite, and make html links into just the URL, but I modified your regex and it works like a charm, thanks :) The e-mail detection in Travitron\'s answer above did not work for me, so I extended/replaced it with the following (C# code).This allows for e-mail addresses like "firstname.secondname@one.two.three.co.uk".After input from several sources I\'ve now a solution that works well.  It had to do with writing your own replacement code.Answer.Fiddle.Replace URLs in text with HTML links, ignore the URLs within a href/pre tag. \nhttps://github.com/JimLiu/auto-linkI\'ve wrote yet another JavaScript library, it might be better for you since it\'s very sensitive with the least possible false positives, fast and small in size. I\'m currently actively maintaining it so please do test it in the demo page and see how it would work for you.link: https://github.com/alexcorvi/anchorme.js