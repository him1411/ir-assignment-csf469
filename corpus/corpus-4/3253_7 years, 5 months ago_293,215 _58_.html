I\'d read that when renaming files in git, you should commit any changes, perform your rename and then stage your renamed file. Git will recognise the file from the contents, rather than seeing it as a new untracked file, and keep the change history.However, doing just this tonight I ended up reverting to git mv.Rename my stylesheet in Finder from iphone.css to mobile.cssSo git now thinks I\'ve deleted one CSS file, and added a new one. Not what I want, lets undo the rename and let git do the work.Back to where I began.Lets use git mv instead.Looks like we\'re good. So why didn\'t git recognise the rename the first time around when I used Finder?For git mv the\nmanual page\nsaysThe index is updated after successful completion,\n  [....]So, at first you have to update the index on your own\n(by using git add mobile.css). However\ngit status\nwill still show two different filesYou can get a different output by running\ngit commit --dry-run -a which results in what you\nexpectI can\'t tell you exactly why we see these differences\nbetween git status and\ngit commit --dry-run -a, but\nhere is a hint from\nLinusgit really doesn\'t even care about the whole\n  "rename detection" internally, and any commits you have\n  done with renames are totally independent of the\n  heuristics we then use to show the renames.A dry-run uses the real renaming mechanisms, while a\ngit status probably doesn\'t.You have to add the two modified files to the index before git will recognize it as a move.The only difference between mv old new and git mv old new is that the git mv also adds the files to the index.mv old new then git add -A would have worked, too.Note that you can\'t just use git add . because that doesn\'t add removals to the index.See Difference between "git add -A" and "git add ."Best thing is to try it for yourself.Now git status and git commit --dry-run -a shows two different results where git status shows bbb.txt as a new file/ aaa.txt is deleted, and the --dry-run commands shows the actual rename.Now go ahead and do the check-in.Now you can see that the file is in fact renamed, and what\'s shown in git status is wrong. Moral of the story: If you\'re not sure whether your file got renamed, issue a "git commit --dry-run -a". If its showing that the file is renamed, you\'re good to go.you have to git add css/mobile.css the new file and git rm css/iphone.css, so git knows about it. then it will show the same output in git statusyou can see it clearly in the status output (the new name of the file):and (the old name):i think behind the scenes git mv is nothing more than a wrapper script which does exactly that: delete the file from the index and add it under a different nameStep1: rename the file from oldfile to newfileStep2: git commit and add commentsStep3: push this change to remote sever Let\'s think about your files from git perspective.Keep in mind git doesn\'t track any metadata about your filesYour repository has (among others)and it is under git control:Test this with:When you doFrom git perspective,So, git advises about files it already knows (iphone.css) and new files it detects (mobile.css) but only when files are in index or HEAD git starts to check their contents.At this moment, neither "iphone.css deletion" nor mobile.css are on index.Add iphone.css deletion to indexgit tells you exactly what has happened: (iphone.css is deleted. Nothing more happened)then add new file mobile.cssThis time both deletion and new file are on index. Now git detects context are the same and expose it as a rename. In fact if files are 50% similar it will detect that as a rename, that let you change mobile.css a bit while keeping the operation as a rename.See this is reproducible on git diff. Now that your files are on index you must use --cached. Edit mobile.css a bit, add that to index and see the difference between:and-M is the "detect renames" option for git diff. -M stands for -M50% (50% or more similarity will make git express it as a rename) but you can reduce this to -M20% (20%) if you edit mobile.css a lot.Git will recognise the file from the contents, rather than seeing it as a new untracked fileThat\'s where you went wrong.It\'s only after you add the file, that git will recognize it from content.For git 1.7.x the following commands worked for me:There was no need for git add, since the original file (i.e. css/mobile.css) was already in the committed files previously. You didn\'t stage the results of your finder move. I believe if you did the move via Finder and then did git add css/mobile.css ; git rm css/iphone.css, git would compute the hash of the new file and only then realize that the hashes of the files match (and thus it\'s a rename).In cases where you really have to rename the files manually, for eg. using a script to batch rename a bunch of files, then using git add -A . worked for me.For Xcode users: If your rename your file in Xcode you see the badge icon change to append. If you do a commit using XCode you will actually create a new file and lose the history.A workaround is easy but you have to do it before commiting using Xcode:renamed:    Project/OldName.h -> Project/NewName.h\nrenamed:    Project/OldName.m -> Project/NewName.mThen go back to XCode and you will see the badge changed from A to M and it is save to commit furtur changes in using xcode now.