I\'m trying to get an evaluated attribute from my custom directive, but I can\'t find the right way of doing it.I\'ve created this jsFiddle to elaborate.What am I missing?Notice: I do update this answer as I find better solutions. I also keep the old answers for future reference as long as they remain related. Latest and best answer comes first. Directives in angularjs are very powerful, but it takes time to comprehend which processes lie behind them.While creating directives, angularjs allows you to create an isolated scope with some bindings to the parent scope. These bindings are specified by the attribute you attach the element in DOM and how you define scope property in the directive definition object.There are 3 types of binding options which you can define in scope and you write those as prefixes related attribute.HTMLIn that case, in the scope of directive (whether it\'s in linking function or controller), we can access these properties like this:Since this answer got accepted, but has some issues, I\'m going to update it to a better one. Apparently, $parse is a service which does not lie in properties of the current scope, which means it only takes angular expressions and cannot reach scope. \n{{,}} expressions are compiled while angularjs initiating which means when we try to access them in our directives postlink method, they are already compiled. ({{1+1}} is 2 in directive already).This is how you would want to use:.One thing you should notice here is that, if you want set the value string, you should wrap it in quotes. (See 3rd input)Here is the fiddle to play with: http://jsfiddle.net/neuTA/6/I\'m not removing this for folks who can be misled like me, note that using $eval is perfectly fine the correct way to do it, but $parse has a different behavior, you probably won\'t need this to use in most of the cases.The way to do it is, once again, using scope.$eval. Not only it compiles the angular expression, it has also access to the current scope\'s properties.What you are missing was $eval.http://docs.angularjs.org/api/ng.$rootScope.Scope#$evalExecutes the expression on the current scope returning the result. Any exceptions in the expression are propagated (uncaught). This is useful when evaluating angular expressions.For an attribute value that needs to be interpolated in a directive that is not using an isolated scope, e.g., use Attributes\' method $observe:From the directive page, observing interpolated attributes: Use $observe to observe the value changes of attributes that contain interpolation (e.g. src="{{bar}}"). Not only is this very efficient but it\'s also the only way to easily get the actual value because during the linking phase the interpolation hasn\'t been evaluated yet and so the value is at this time set to undefined.If the attribute value is just a constant, e.g.,you can use $eval if the value is a number or boolean, and you want the correct type:If the attribute value is a string constant, or you want the value to be string type in your directive, you can access it directly:In your case, however, since you want to support interpolated values and constants, use $observe.The other answers here are very much correct, and valuable. But sometimes you just want simple: to get a plain old parsed value at directive instantiation, without needing updates, and without messing with isolate scope. For instance, it can be handy to provide a declarative payload into your directive as an array or hash-object in the form:In that case, you can cut to the chase and just use a nice basic angular.$eval(attr.attrName). Working Fiddle.For the same solution I was looking for Angularjs directive with ng-Model.\n Here is the code that resolve the problem.\n \nHTML DOM\nMy Result is:Use $timeout because directive call after dom load so your changes doesn`\'t applyLot of good answers here, but sometimes you just want\'s a plain, easy, old, jQuery-ish, solution. My solution does not handle changes to the DOM. If the attribute might change, do not use my method!In my case I had an element, and needed to retrieve the value of an attribute (rel).Template:In my directive:\n