Say I am monkey patching a method in a class, how could I call the overridden method from the overriding method? I.e. Something a bit like superE.g. EDIT: It has been 5 years since I originally wrote this answer, and it deserves some cosmetic surgery to keep it current.You can see the last version before the edit here.You can\xe2\x80\x99t call the overwritten method by name or keyword. That\xe2\x80\x99s one of the many reasons why monkey patching should be avoided and inheritance be preferred instead, since obviously you can call the overridden method.So, if at all possible, you should prefer something like this:This works, if you control creation of the Foo objects. Just change every place which creates a Foo to instead create an ExtendedFoo. This works even better if you use the Dependency Injection Design Pattern, the Factory Method Design Pattern, the  Abstract Factory Design Pattern or something along those lines, because in that case, there is only place you need to change.If you do not control creation of the Foo objects, for example because they are created by a framework that is outside of your control (like ruby-on-rails for example), then you could use the Wrapper Design Pattern:Basically, at the boundary of the system, where the Foo object comes into your code, you wrap it into another object, and then use that object instead of the original one everywhere else in your code.This uses the Object#DelegateClass helper method from the delegate library in the stdlib.The two methods above require changing the system to avoid monkey patching. This section shows the preferred and least invasive method of monkey patching, should changing the system not be an option.Module#prepend was added to support more or less exactly this use case. Module#prepend does the same thing as Module#include, except it mixes in the mixin directly below the class:Note: I also wrote a little bit about Module#prepend in this question: Ruby module prepend vs derivationI have seen some people try (and ask about why it doesn\xe2\x80\x99t work here on StackOverflow) something like this, i.e. includeing a mixin instead of prepending it:Unfortunately, that won\xe2\x80\x99t work. It\xe2\x80\x99s a good idea, because it uses inheritance, which means that you can use super. However, Module#include inserts the mixin above the class in the inheritance hierarchy, which means that FooExtensions#bar will never be called (and if it were called, the super would not actually refer to Foo#bar but rather to Object#bar which doesn\xe2\x80\x99t exist), since Foo#bar will always be found first.The big question is: how can we hold on to the bar method, without actually keeping around an actual method? The answer lies, as it does so often, in functional programming. We get a hold of the method as an actual object, and we use a closure (i.e. a block) to make sure that we and only we hold on to that object:This is very clean: since old_bar is just a local variable, it will go out of scope at the end of the class body, and it is impossible to access it from anywhere, even using reflection! And since Module#define_method takes a block, and blocks close over their surrounding lexical environment (which is why we are using define_method instead of def here), it (and only it) will still have access to old_bar, even after it has gone out of scope.Short explanation:Here we are wrapping the bar method into an UnboundMethod method object and assigning it to the local variable old_bar. This means, we now have a way to hold on to bar even after it has been overwritten.This is a bit tricky. Basically, in Ruby (and in pretty much all single-dispatch based OO languages), a method is bound to a specific receiver object, called self in Ruby. In other words: a method always knows what object it was called on, it knows what its self is. But, we grabbed the method directly from a class, how does it know what its self is?Well, it doesn\xe2\x80\x99t, which is why we need to bind our UnboundMethod to an object first, which will return a Method object that we can then call. (UnboundMethods cannot be called, because they don\xe2\x80\x99t know what to do without knowing their self.)And what do we bind it to? We simply bind it to ourselves, that way it will behave exactly like the original bar would have!Lastly, we need to call the Method that is returned from bind. In Ruby 1.9, there is some nifty new syntax for that (.()), but if you are on 1.8, you can simply use the call method; that\xe2\x80\x99s what .() gets translated to anyway.Here are a couple of other questions, where some of those concepts are explained:The problem we are having with our monkey patching is that when we overwrite the method, the method is gone, so we cannot call it anymore. So, let\xe2\x80\x99s just make a backup copy!The problem with this is that we have now polluted the namespace with a superfluous old_bar method. This method will show up in our documentation, it will show up in code completion in our IDEs, it will show up during reflection. Also, it still can be called, but presumably we monkey patched it, because we didn\xe2\x80\x99t like its behavior in the first place, so we might not want other people to call it.Despite the fact that this has some undesirable properties, it has unfortunately become popularized through AciveSupport\xe2\x80\x99s Module#alias_method_chain.In case you only need the different behavior in a few specific places and not throughout the whole system, you can use Refinements to restrict the monkey patch to a specific scope. I am going to demonstrate it here using the Module#prepend example from above:You can see a more sophisticated example of using Refinements in this question: How to enable monkey patch for specific method?Before the Ruby community settled on Module#prepend, there were multiple different ideas floating around that you may occasionally see referenced in older discussions. All of these are subsumed by Module#prepend.One idea was the idea of method combinators from CLOS. This is basically a very lightweight version of a subset of Aspect-Oriented Programming.Using syntax likeyou would be able to \xe2\x80\x9chook into\xe2\x80\x9d the execution of the bar method.It is however not quite clear if and how you get access to bar\xe2\x80\x99s return value within bar:after. Maybe we could (ab)use the super keyword?The before combinator is equivalent to prepending a mixin with an overriding method that calls super at the very end of the method. Likewise, the after combinator is equivalent to prepending a mixin with an overriding method that calls super at the very beginning of the method.You can also do stuff before and after calling super, you can call super multiple times, and both retrieve and manipulate super\xe2\x80\x99s return value, making prepend more powerful than method combinators.and This idea adds a new keyword similar to super, which allows you to call the overwritten method the same way super lets you call the overridden method:The main problem with this is that it is backwards incompatible: if you have method called old, you will no longer be able to call it!super in an overriding method in a prepended mixin is essentially the same as old in this proposal.Similar to above, but instead of adding a new keyword for calling the overwritten method and leaving def alone, we add a new keyword for redefining methods. This is backwards compatible, since the syntax currently is illegal anyway:Instead of adding two new keywords, we could also redefine the meaning of super inside redef:redefining a method is equivalent to overriding the method in a prepended mixin. super in the overriding method behaves like super or old in this proposal.Take a look at aliasing methods, this is kind of renaming the method to a new name.For more information and a starting point take a look at this replacing methods article (especially the first part).\nThe Ruby API docs, also provides (a less elaborate) example.The class that will make override must to be reloaded after class that contains the original method, so require it in the file that will make overrride.