I often run into the case where I want to eval a query right where I declare it. This is usually because I need to iterate over it multiple times and it is expensive to compute. For example:This works fine. But if I am not going to modify the result, then I might as well call ToArray() instead of ToList().I wonder however whether ToArray() is implemented by first calling ToList() and is therefore less memory efficient than just calling ToList().Am I crazy? Should I just call ToArray() - safe and secure in the knowledge that the memory won\'t be allocated twice?Unless you simply need an array to meet other constraints you should use ToList.  In the majority of scenarios ToArray will allocate more memory than ToList.  Both use arrays for storage, but ToList has a more flexible constraint.  It needs the array to be at least as large as the number of elements in the collection.  If the array is larger, that is not a problem.  However ToArray needs the array to be sized exactly to the number of elements.To meet this constraint ToArray often does one more allocation than ToList.  Once it has an array that is big enough it allocates an array which is exactly the correct size and copies the elements back into that array.  The only time it can avoid this is when the grow algorithm for the array just happens to coincide with the number of elements needing to be stored (definitely in the minority).  EDITA couple of people have asked me about the consequence of having the extra unused memory in the List<T> value.  This is a valid concern.  If the created collection is long lived, is never modified after being created and has a high chance of landing in the Gen2 heap then you may be better off taking the extra allocation of ToArray up front.  In general though I find this to be the rarer case.  It\'s much more common to see a lot of ToArray calls which are immediately passed to other short lived uses of memory in which case ToList is demonstrably better.  The key here is to profile, profile and then profile some more. The performance difference will be insignificant, since List<T> is implemented as a dynamically sized array.  Calling either ToArray() (which uses an internal Buffer<T> class to grow the array) or ToList() (which calls the List<T>(IEnumerable<T>) constructor) will end up being a matter of putting them into an array and growing the array until it fits them all.If you desire concrete confirmation of this fact, check out the implementation of the methods in question in Reflector -- you\'ll see they boil down to almost identical code.I agree with @mquander that the performance difference should be insignificant. However, I wanted to benchmark it to be sure, so I did - and it is, insignificant.Each source array/List had 1000 elements. So you can see that both time and memory differences are negligible.My conclusion: you might as well use ToList(), since a List<T> provides more functionality than an array, unless a few bytes of memory really matter to you.The memory will always be allocated twice - or something close to that. As you can not resize an array, both methods will use some sort of mechanism to gather the data in a growing collection. (Well, the List is a growing collection in itself.)The List uses an array as internal storage, and doubles the capacity when needed. This means that by average 2/3 of the items has been reallocated at least once, half of those reallocated at least twice, half of those at least thrice, and so on. That means that each item has by average been reallocated 1.3 times, which is not very much overhead.Remember also that if you are colleting strings, the collection itself only contains the references to the strings, the strings themselves aren\'t reallocated.ToList() is usually preferred if you use it on IEnumerable<T> (from ORM, for instance). If the length of sequence is not known at the beginning, ToArray() creates dynamic-length collection like List and then converts it to array, which takes extra time.Edit: The last part of this answer is not valid.  However, the rest is still useful information, so I\'ll leave it.I know this is an old post, but after having the same question and doing some research, I have found something interesting that might be worth sharing.First, I agree with @mquander and his answer.  He is correct in saying that performance-wise, the two are identical.However, I have been using Reflector to take a look at the methods in the System.Linq.Enumerable extensions namespace, and I have noticed a very common optimization.\nWhenever possible, the IEnumerable<T> source is cast to IList<T> or ICollection<T> to optimize the method.  For example, look at ElementAt(int).Interestingly, Microsoft chose to only optimize for IList<T>, but not IList.  It looks like Microsoft prefers to use the IList<T> interface.  System.Array only implements IList, so it will not benefit from any of these extension optimizations.\nTherefore, I submit that the best practice is to use the .ToList() method.\nIf you use any of the extension methods, or pass the list to another method, there is a chance that it might be optimized for an IList<T>.\nYou should base your decision to go for ToList or ToArray based on what ideally the design choice is. If you want a collection that can only be iterated and accessed by index, choose ToArray. If you want additional capabilities of adding and removing from the collection later on without much hassle, then do a ToList (not really that you cant add to an array, but that\'s not the right tool for it usually).If performance matters, you should also consider what would be faster to operate on. Realistically, you wont call ToList or ToArray a million times, but might work on the obtained collection a million times. In that respect [] is better, since List<> is [] with some overhead. See this thread for some efficiency comparison: Which one is more efficient : List<int> or int[]In my own tests a while ago, I had found ToArray faster. And I\'m not sure how skewed the tests were. The performance difference is so insignificant though, which can noticeable only if you are running these queries in a loop millions of times.A very late answer but I think it will be helpful for googlers.They both suck when they created using linq. They both implement same code to resize buffer if necessary. ToArray internally uses a class to convert IEnumerable<> to array, by allocating an array of 4 elements. If that is not enough than it doubles the size by creating a new array double the size of current and copying current array to it. At the end it allocates a new array of count of your items. If your query returns 129 elements then ToArray will make 6 allocations and memory copy operations to create a 256 element array and than am another array of 129 to return. so much for memory efficiency.ToList does the same thing, but it skips the last allocation since you can add items in the future. List does not care if it is created from a linq query or created manually.for creation List is better with memory but worse with cpu since list is a generic solution every action requires range checks additional to the .net\'s internal range checks for arrays.So if you will iterate through your result set too many times, then arrays are good since it means less range checks than lists, and compilers generally optimizes arrays for sequential access.List\'s initialization allocation can be better if you specify capacity parameter when you create it. In this case it will allocate array only once, assuming you know the result size. ToList of linq does not specify an overload to provide it, so we have to create our extension method that creates a list with given capacity and then uses List<>.AddRange.To finish this answer I have to write following sentences(seven years later...)A couple of other (good) answers have concentrated on microscopic performance differences that will occur.This post is just a supplement to mention the semantic difference that exists between the IEnumerator<T> produced by an array (T[]) as compared to that returned by a List<T>.Best illustrated with by example:The above code will run with no exception and produces the output:This shows that the IEnumarator<int> returned by an int[] does not keep track on whether the array has been modified since the creation of the enumerator.Note that I declared the local variable source as an IList<int>. In that way I make sure the C# compiler does not optimze the foreach statement into something which is equivalent to a for (var idx = 0; idx < source.Length; idx++) { /* ... */ } loop. This is something the C# compiler might do if I use var source = ...; instead. In my current version of the .NET framework the actual enumerator used here is a non-public reference-type System.SZArrayHelper+SZGenericArrayEnumerator`1[System.Int32] but of course this is an implementation detail.Now, if I change .ToArray() into .ToList(), I get only:followed by a System.InvalidOperationException blow-up saying:Collection was modified; enumeration operation may not execute.The underlying enumerator in this case is the public mutable value-type System.Collections.Generic.List`1+Enumerator[System.Int32] (boxed inside an IEnumerator<int> box in this case because I use IList<int>).In conclusion, the enumerator produced by a List<T> keeps track on whether the list changes during enumeration, while the enumerator produced by T[] does not. So consider this difference when choosing between .ToList() and .ToArray().People often add one extra .ToArray() or .ToList() to circumvent a collection that keeps track on whether it was modified during the life-time of an enumerator.(If anybody wants to know how the List<> keeps track on whether collection was modified, there is a private field _version in this class which is changed everytime the List<> is updated.)This is an old question - but for the benefit of users who stumble upon it, there is also and alternative of \'Memoizing\' the Enumerable - which has the effect of caching and stopping multiple enumeration of a Linq statement, which is what ToArray() and ToList() are used for a lot, even though the collection attributes of the list or array are never used.Memoize is available in the RX/System.Interactive lib, and is explained here:\nMore LINQ with System.Interactive(From Bart De\'Smet\'s blog which is a highly recommended read if you are working with Linq to Objects a lot)One option is to add your own extension method that returns a readonly ICollection<T>. This can be better than using ToList or ToArray when you do not want to use either the indexing properties of an array/list, or add/remove from a list.Unit tests:Old question but new questioners at all time.According to source of System.Linq.Enumerable, ToList just return a new List(source), while ToArray use a new Buffer<T>(source).ToArray() to return a T[].About memory allocation:While running on an IEnumerable<T> only object, ToArray do allocate memory one more time than ToList. But you do not have to care about it in most cases, because GC will do the garbage collection when needed.About the runtime efficient:Those who are questioning this question can run the following code on your own machine, and you\'ll get your answer.I got these results on my machine:Group1:Group2:Group3:Group4:Group5:Due to stackoverflow\'s limit to the characters amount of the answer, the sample lists of Group2 and Group3 are omitted.As you can see, it\'s really not important to use ToList or ToArry in most cases.While processing runtime-calculated IEnumerable<T> objects, if the load brought by calculation is heavy than memory allocation and copy operations of ToList and ToArray, the disparity is insignificant (C.ToList vs C.ToArray and S.ToList vs S.ToArray).The difference can be observed only on non-runtime-calculated IEnumerable<T> only objects (C1.ToList vs C1.ToArray and S1.ToList vs S1.ToArray). But the absolute difference (<60ms) is still acceptable on an one million small object IEnumerable<T>. In fact, the difference is decided by the implementation of Enumerator<T> of IEnumerable<T>. So, if your program is really really really sensitive on this, you do have to profile, profile, profile! At last you\'ll probably find that the bottleneck is not on ToList or ToArray, but the detail of enumerators.And, the result of C2.ToList vs C2.ToArray and S2.ToList vs S2.ToArray shows that, you really don\'t need to care ToList or ToArray on non-runtime-calculated ICollection<T> objects.Of course, this is just results on my machine, the actual time spend of these operations on different machine will not be the same, you can find out on your machine using code above.The only reason you need to make a choice is that, you have specific needs on List<T> or T[], as described by the answer of @Jeppe Stig Nielsen.For anyone interested in using this result in another Linq-to-sql such as then the SQL that is generated is the same whether you used a List or Array for the myListOrArray.\nNow I know some may ask why even enumerate before this statement, but there is a difference between the SQL generated from an IQueryable vs (List or Array).I found the other benchmarks people have done here lacking, so here\'s my crack at it. Let me know if you find something wrong with my methodology.You can download the LINQPad Script here.Results: \nTweaking the code above, you will discover that:This agrees with the conclusions of the top-voted answers:@JonHanna pointed out that depending on the implementation of Select it\'s possible for a ToList() or ToArray() implementation to predict the resulting collection\'s size ahead of time. Replacing .Select(i => i) in the code above with Where(i => true) yields very similar results at the moment, and is more likely to do so regardless of the .NET implementation.