I see that for using objects which are not thread safe we wrap the code with a lock like this:So what happens when multiple threads access the same code (let\'s assume that it is running in a ASP.NET web application). Are they queued? If so how long will they wait? What is the performance impact because of using locks?The lock statement is translated by C# 3.0 to the following:In C# 4.0 this has changed and it is now generated as follows:You can find more info about what Monitor.Enter does here. To quote MSDN:Use Enter to acquire the Monitor on\n  the object passed as the parameter. If\n  another thread has executed an Enter\n  on the object but has not yet executed\n  the corresponding Exit, the current\n  thread will block until the other\n  thread releases the object. It is\n  legal for the same thread to invoke\n  Enter more than once without it\n  blocking; however, an equal number of\n  Exit calls must be invoked before\n  other threads waiting on the object\n  will unblock.The Monitor.Enter method will wait infinitely; it will not time out.Its simpler than you think.According to Microsoft:\nThe lock keyword ensures that one thread does not enter a critical section of code while another thread is in the critical section. If another thread tries to enter a locked code, it will wait, block, until the object is released.The lock keyword calls Enter at the start of the block and Exit at the end of the block. lock keyword actually handles Monitor class at back end.For example:In above code first thread enters critical section then it will lock obj and when other thread tries to enter then it will also try to lock obj which is already locked by first thread, I will have to wait for first thread to release obj. and when first will leave then other thread will lock obj and will enter to critical section.No, they are not queued, they are sleepingA lock statement of the formwhere x is an expression of a reference-type, is precisely equivalent toYou just need to know that they are waiting to each other, and only one thread will enter to lock block, the others will wait...Monitor is written fully in .net so it is enough fast, also look at  class Monitor with reflector for more detailsLocks will block other threads from executing the code contained in the lock block.  The threads will have to wait until the thread inside the lock block has completed and the lock is released.  This does have a negative impact on performance in a multithreaded environment.  If you do need to do this you should make sure the code within the lock block can process very quickly.  You should try to avoid expensive activities like accessing a database etc.The part within the lock statement can only be executed by one thread, so all other threads will wait indefinitely for it the thread holding the lock to finish. This can result in a so-called deadlock.The performance impact depends on the way you lock. You can find a good list of optimizations here: http://www.thinkingparallel.com/2007/07/31/10-ways-to-reduce-lock-contention-in-threaded-programs/Basically you should try to lock as little as possible, since it puts your waiting code to sleep. If you have some heavy calculations or long lasting code (e.g. file upload) in a lock it results in a huge performance loss.The lock statement is translated to calls to the Enter and Exit methods of Monitor.The lock statement will wait indefinitely for the locking object to be released. lock is actualy hidden Monitor class.