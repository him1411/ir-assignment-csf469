I am a newbie to Java Persistence API and Hibernate. What is the difference between FetchType.LAZY and FetchType.EAGER in Java Persistence API? Sometimes you have two entities and there\'s a relationship between them. For example, you might have an entity called University and another entity called Student.The University entity might have some basic properties such as id, name, address, etc. as well as a property called students:Now when you load a University from the database, JPA loads its id, name, and address fields for you. But you have two options for students: to load it together with the rest of the fields (i.e. eagerly) or to load it on-demand (i.e. lazily) when you call the university\'s getStudents() method.When a university has many students it is not efficient to load all of its students with it when they are not needed. So in suchlike cases, you can declare that you want students to be loaded when they are actually needed. This is called lazy loading.Basically,EAGER loading of collections means that they are fetched fully at the time their parent is fetched. So if you have Course and it has  List<Student>, all the students are fetched from the database at the time the Course is fetched.LAZY on the other hand means that the contents of the List are fetched only when you try to access them. For example, by calling course.getStudents().iterator(). Calling any access method on the List will initiate a call to the database to retrieve the elements. This is implemented by creating a Proxy around the List (or Set). So for your lazy collections, the concrete types are not ArrayList and HashSet, but PersistentSet and PersistentList (or PersistentBag)I may consider performance and memory utilization. One big difference is that EAGER fetch strategy allows to use fetched data object without session. Why?\nAll data is fetched when eager marked data in the object when session is connected.  However, in case of lazy loading strategy, lazy loading marked object does not retrieve data if session is disconnected (after session.close() statement). All that can be made by hibernate proxy. Eager strategy lets data to be still available after closing session.By default, for all collection and map objects the fetching rule is FetchType.LAZY and for other instances it follows the FetchType.EAGER policy.\nIn brief, @OneToMany and @ManyToMany relations does not fetch the related objects (collection and map) implicictly but the retrieval operation is cascaded through the field in @OneToOne and @ManyToOne ones.(courtesy :- objectdbcom)As per my knowledge both type of fetch depends your requirement.FetchType.LAZY is on demand (i.e. when we required the data).FetchType.EAGER is immediate (i.e. before our requirement comes we are unnecessarily fetching the record)    Both FetchType.LAZY and FetchType.EAGER are used to define the default fetch plan. Unfortunately you can only override the default fetch plan for LAZY fetching. EAGER fetching is less flexible and can lead to many performance issues.My advice is to restrain the urge of making your associations EAGER, because fetching is a query-time responsibility. So all your queries should use the fetch directive to only retrieve what\'s necessary for the current business case.From the Javadoc:The EAGER strategy is a requirement on the persistence provider runtime that data must be eagerly fetched. The LAZY strategy is a hint to the persistence provider runtime that data should be fetched lazily when it is first accessed. E.g., eager is more proactive than lazy. Lazy only happens on first use (if the provider takes the hint), whereas with eager things (may) get pre-fetched.Book.javaSubject.javaHibernateUtil.javaMain.javaCheck the retrieve() method of Main.java. When we get Subject, then its collection listBooks, annotated with @OneToMany, will be loaded lazily. But, on the other hand, Books related association of collection subject, annotated with @ManyToOne, loads eargerly (by [default][1] for @ManyToOne, fetchType=EAGER). We can change the behaviour by placing fetchType.EAGER on @OneToMany Subject.java or fetchType.LAZY on @ManyToOne in Books.java.public enum FetchType\n  extends java.lang.Enum\n  Defines strategies for fetching data from the database. The EAGER strategy is a requirement on the persistence provider runtime that data must be eagerly fetched. The LAZY strategy is a hint to the persistence provider runtime that data should be fetched lazily when it is first accessed. The implementation is permitted to eagerly fetch data for which the LAZY strategy hint has been specified.\n     Example:\n     @Basic(fetch=LAZY)\n     protected String getName() { return name; }Source@drop-shadow if you\'re using Hibernate, you can call Hibernate.initialize() when you invoke the getStudents() method:LAZY: It fetches the child entities lazily i.e at the time of fetching parent entity it just fetches proxy(created by cglib or any other utility) of the child entities and when you access any property of child entity then it is actually fetched by hibernate.EAGER: it fetches the child entities along with parent.For better understanding go to Jboss documentation or you can use hibernate.show_sql=true for your app and check the queries issued by the hibernate.The Lazy Fetch type is by default selected by Hibernate unless you explicitly mark Eager Fetch type. To be more accurate and concise, difference can be stated as below.FetchType.LAZY = This does not load the relationships unless you invoke it via the getter method. FetchType.EAGER = This loads all the relationships.Pros and Cons of these two fetch types.Lazy initialization improves performance by avoiding unnecessary computation and reduce memory requirements.Eager initialization takes more memory consumption and processing speed is slow. Having said that, depends on the situation either one of these initialization can be used. 