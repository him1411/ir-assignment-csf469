I am new to AngularJS, and I am a little confused of how I can use angular-"ui-router" in the following scenario:I am building a web application which consists of two sections. The first section is the homepage with its login and signup views, and the second section is the dashboard (after successful login).I have created an index.html for the home section with its angular app and ui-router config to handle /login and /signup views,\nand there is another file dashboard.html for the dashboard section with its app and ui-router config to handle many sub views.Now I finished the dashboard section and don\'t know how to combine the two sections with their different angular apps. How could I tell the home app to redirect to the dashboard app?I\'m in the process of making a nicer demo as well as cleaning up some of these services into a usable module, but here\'s what I\'ve come up with. This is a complex process to work around some caveats, so hang in there. You\'ll need to break this down into several pieces.Take a look at this plunk.First, you need a service to store the user\'s identity. I call this principal. It can be checked to see if the user is logged in, and upon request, it can resolve an object that represents the essential information about the user\'s identity. This can be whatever you need, but the essentials would be a display name, a username, possibly an email, and the roles a user belongs to (if this applies to your app). Principal also has methods to do role checks.Second, you need a service that checks the state the user wants to go to, makes sure they\'re logged in (if necessary; not necessary for signin, password reset, etc.), and then does a role check (if your app needs this). If they are not authenticated, send them to the sign-in page. If they are authenticated, but fail a role check, send them to an access denied page. I call this service authorization.Now all you need to do is listen in on ui-router\'s $stateChangeStart. This gives you a chance to examine the current state, the state they want to go to, and insert your authorization check. If it fails, you can cancel the route transition, or change to a different route.The tricky part about tracking a user\'s identity is looking it up if you\'ve already authenticated (say, you\'re visiting the page after a previous session, and saved an auth token in a cookie, or maybe you hard refreshed a page, or dropped onto a URL from a link). Because of the way ui-router works, you need to do your identity resolve once, before your auth checks. You can do this using the resolve option in your state config. I have one parent state for the site that all states inherit from, which forces the principal to be resolved before anything else happens. There\'s another problem here... resolve only gets called once. Once your promise for identity lookup completes, it won\'t run the resolve delegate again. So we have to do your auth checks in two places: once pursuant to your identity promise resolving in resolve, which covers the first time your app loads, and once in $stateChangeStart if the resolution has been done, which covers any time you navigate around states.OK, so what have we done so far?Where do we go from here? Well, you can organize your states into regions that require sign in. You can require authenticated/authorized users by adding data with roles to these states (or a parent of them, if you want to use inheritance). Here, we restrict a resource to Admins:Now you can control state-by-state what users can access a route. Any other concerns? Maybe varying only part of a view based on whether or not they are logged in? No problem. Use the principal.isAuthenticated() or even principal.isInRole() with any of the numerous ways you can conditionally display a template or an element.First, inject principal into a controller or whatever, and stick it to the scope so you can use it easily in your view:Show or hide an element:Etc., so on, so forth. Anyways, in your example app, you would have a state for home page that would let unauthenticated users drop by. They could have links to the sign-in or sign-up states, or have those forms built into that page. Whatever suits you.The dashboard pages could all inherit from a state that requires the users to be logged in and, say, be a User role member. All the authorization stuff we\'ve discussed would flow from there.The solutions posted so far are needlessly complicated, in my opinion. There\'s a simpler way. The documentation of ui-router says listen to $locationChangeSuccess and use $urlRouter.sync() to check a state transition, halt it, or resume it. But even that actually doesn\'t work. However, here are two simple alternatives. Pick one:You can listen to $locationChangeSuccess and you can perform some logic, even asynchronous logic there. Based on that logic, you can let the function return undefined, which will cause the state transition to continue as normal, or you can do $state.go(\'logInPage\'), if the user needs to be authenticated. Here\'s an example:Keep in mind that this doesn\'t actually prevent the target state from loading, but it does redirect to the log-in page if the user is unauthorized. That\'s okay since real protection is on the server, anyway.In this solution, you use ui-router resolve feature. You basically reject the promise in resolve if the user is not authenticated and then redirect them to the log-in page.Here\'s how it goes:Unlike the first solution, this solution actually prevents the target state from loading.The easiest solution is to use $stateChangeStart and event.preventDefault() to cancel the state change when the user is not authenticated and redirect him to the auth state that is the login page.I think you need a service that handle the authentication process (and its storage).In this service you\'ll need some basic methods :This service should be injected in your controllers of each module :A good and robust example for this behavior is the project angular-app and specifically its security module which is based over the awesome HTTP Auth Interceptor ModuleHope this helpsI Created this module to help make this process piece of cakeYou can do things like:Or alsoIt\'s brand new but worth checking out!https://github.com/Narzerus/angular-permissionI wanted to share another solution working with the ui router 1.0.0.X As you may know, stateChangeStart and stateChangeSuccess are now deprecated. https://github.com/angular-ui/ui-router/issues/2655Instead you should use $transitions http://angular-ui.github.io/ui-router/1.0.0-alpha.1/interfaces/transition.ihookregistry.htmlThis is how I achieved it:First I have and AuthService with some useful functionsThen I have this configuration:You can see that I use to mark the state only accessible if is authenticated.then, on the .run I use the transitions to check the autheticated stateI build this example using some code found on the $transitions documentation. I\'m pretty new with the ui router but it works.Hope it can helps anyone.Here is how we got out of the infinite routing loop and still used $state.go instead of $location.pathI have another solution: that solution works perfectly when you have only content you want to show when you are logged in. Define a rule where you checking if you are logged in and its not path of whitelist routes. In my example i ask if i am not logged in and the current route i want to route is not part of `/login\', because my whitelist routes are the followingso i have instant access to this two routes and every other route will be checked if you are online.Here is my whole routing file for the login module() => { /* code */ } is ES6 syntax, use instead function() { /* code */ }First you\'ll need a service that you can inject into your controllers that has some idea of app authentication state. Persisting auth details with local storage is a decent way to approach it. Next, you\'ll need to check the state of auth right before state changes. Since your app has some pages that need to be authenticated and others that don\'t, create a parent route that checks auth, and make all other pages that require the same be a child of that parent. Finally, you\'ll need some way to tell if your currently logged in user can perform certain operations. This can be achieved by adding a \'can\' function to your auth service. Can takes two parameters: \n - action - required - (ie \'manage_dashboards\' or \'create_new_dashboard\')\n - object - optional - object being operated on. For example, if you had a dashboard object, you may want to check to see if dashboard.ownerId === loggedInUser.id. (Of course, information passed from the client should never be trusted and you should always verify this on the server before writing it to your database). ** DISCLAIMER: The above code is pseudo-code and comes with no guarantees **Use $http InterceptorBy using an $http interceptor you can send headers to Back-end or the other way around and do your checks that way. Great article on $http interceptorsExample: Put this in your .config or .run function. 