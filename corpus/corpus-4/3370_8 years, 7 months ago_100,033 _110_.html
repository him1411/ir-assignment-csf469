I\'m debating whether I should learn PowerShell, or just stick with Cygwin/Perl scripts/Unix shell scripts, etc.The benefit of PowerShell would be that the scripts could be more easily used by teammates that don\'t have Cygwin; however, I don\'t know if I\'d really be writing that many general purpose scripts, or if people would even use them.Unix scripting is so powerful, does PowerShell come close enough to warrant switching over?Here are some of the specific things (or equivalents) I would be looking for in PowerShell:Tools are just tools.\nThey help or they don\'t.\nYou need help or you don\'t.If you know Unix and those tools do what you need them to do on Windows - then you are a happy guy and there is no need to learn PowerShell (unless you want to explore).My original intent was to include a set of Unix tools in Windows and be done with it (a number of us on the team have deep Unix backgrounds and a healthy dose of respect for that community.)  What I found was that this didn\'t really help much.  The reason for that is that awk/grep/sed don\'t work against COM, WMI, ADSI, the Registry, the cert store, etc, etc.  In other words, UNIX is an entire ecosystem self-tuned around text files.  As such, text processing tools are effectively management tools.  Windows is a completely different ecosystem self-tuned around APIs and Objects.  That\'s why we invented PowerShell.What I think you\'ll find is that there will be lots of occasions when text-processing won\'t get you what you want on Windows.  At that point, you\'ll want to pick up PowerShell.  NOTE - it is not an all or nothing deal.  Within PowerShell, you can call out to your Unix tools (and use their text process or PowerShell\'s text processing).  Also you can call PowerShell from your Unix tools and get text.  Again - there is no religion here - our focus is on giving you the tools you need to succeed.  That is why we are so passionate about feedback.  Let us know where we are falling down on the job or where you don\'t have a tool you need and we\'ll put it on the list and get to it.  In all honesty, we are digging ourselves out of a 30 year hole so it is going to take a while.  That said, if you pick up the beta of Windows Server 2008 /R2 and/or the betas of our server products, I think you\'ll be shocked at how quickly that hole is getting filled.  With regard to usage - we\'ve had > 3.5 million downloads to date.  That does not include the people using it in Windows Server 2008 because it is included as an optional component and does not need a download.  V2 will ship in all versions of Windows.  It will be on-by-default for all editions except Server core where it is an optional component.  Shortly after Windows 7/Windows Server 2008 R2 ships, we\'ll make V2 available on all platforms XP and above.  In other words - your investment in learning will be applicable to a very large number of machines/environments.One last comment.  If/when you start to learn PowerShell, I think you\'ll be pretty happy.  Much of the design is heavily influenced by our Unix backgrounds so while we are quite different, you\'ll pick it up very quickly (after you get over cussing that it isn\'t Unix :-) ).  We know that people have a very limited budget for learning - that is why we are super hard-core about consistency.  You are going to learn something and then you\'ll use it over and over and over again.Experiment! Enjoy! Engage!grepSelect-String cmdlet and -match operator work with regexes. Also you can directly make use of .NET\'s regex support for more advanced functionality.sortSort-Object is more powerful (than I remember *nix\'s sort). Allowing multi-level sorting on arbitrary expressions. Here PSH\'s maintenance of underlying type helps; e.g. a DateTime property will be sorted as a DateTime without having to ensure formatting into a sortable format.uniqSelect-Object -UniquePerl (how close does PowerShell come to Perl capabilities?)In terms of Perl\'s breadth of domain specific support libraries: nowhere close (yet).For general programming, PSH is certainly more cohesive and consistent, and easier to extend. The one gap for text munging is something equivalent to perl\'s .. operator.awkIt has been long enough since using awk (must be >18 years, since later I just used perl), so can\'t really comment.sed[See above]file (the command that gives file info)PSH\'s strength here isn\'t so much of what it can do with filesystem objects (and it gets full information here, dir returns FileInfo or FolderInfo objects as appropriate) is that is the whole provider model.You can treat the registry, certificate store, SQL Server, IE\'s RSS cache etc. as an object space navigable by the same cmdlets as the filesystem.PSH is definitely the way forward on Windows. MS have made it part of their requirements for future non-home products. Hence rich support in Exchange, support in SQL Server, this is only going to expand.A recent example of this is the TFS PowerToys. Many TFS client operations are done without having to startup tf.exe each time (which requires a new TFS server connection etc.) and is notably easier to then further process the data. As well as allowing wide access to the whole TFS client API to a greater detail than exposed in either Team Explorer of TF.exe.As someone who\'s career focused on Windows enterprise development from 1997 - 2010 the obvious answer would be Powershell for all the good reasons given above (e.g. It is part of MS\' enterprise strategy; it integrates well with Windows/COM/.NET; and using objects instead of files provides for a "richer" coding model). For that reason I\'d been using and promoting Powershell for the last 2 years or so, with the express belief I was following  the "Word of Bill."However, as a pragmatist I\'m no longer sure Powershell is such a great answer. While it\'s an excellent Windows tool and provides a much needed step towards filling the historic hole that is the Window command line, as we all watch MS\' grip on consumer computing slip it seems increasingly likely that MS has a massive battle ahead to keep it\'s OS as important to the enterprise of the future.Indeed, given I find my work is increasingly in heterogeneous environments, I\'m finding it much more useful to use bash scripts at the moment, as they not only work on Linux, Solaris and Mac OS X, but they also work\xe2\x80\x94with the help of Cygwin\xe2\x80\x94on Windows. So if you buy into the belief that the future of the OS is commoditized rather than a monopolized, then it seems to make sense to opt for an agile development tool strategy that keeps away from proprietary tools where feasible. If however you see your future being dominated by all-that-is-Redmond then go for Powershell.I have used a bit of PowerShell for script automation. While it is very nice that the environment seems to have been thought out much more than Unix shells, in practice the use of objects instead of text streams is much more clunky, and a lot of the Unix facilities that have been developed in the last 30 years are still missing.Cygwin is still my scripting environment of choice for Windows hosts. It certainly beats the alternatives in terms of getting things done.I have only recently started dabbling in PS with any degree of seriousness. Although for the past seven years I\'ve worked in an almost exclusively Windows-based environment, I come from a Unix background and find myself constantly trying to "Unix-fy" my interaction experience on Windows.  It\'s frustrating to say the least.It\'s only fair to compare PS to something like Bash, tcsh or zsh since utilities like grep, sed, awk, find etc. are not, strictly speaking, part of the shell; they will always, however, be part of any Unix environment.  That said, a PS command like Select-String has a very similar function to grep and is bundled as a core module in PS ... so the lines can be a little blurred.I think the key thing is culture, and the fact that the respective tool-sets will embody their respective cultures:The Unix administrative (and, for many years, development) interface has traditionally been the command line and the virtual terminal.  Windows started off as a GUI and administrative functions have only recently started moving away from being exclusively GUI-based.  We can expect the Unix experience on the command line to be a richer, more mature one given the significant lead it has on PS, and my experience matches this.  On this, in my experience:The Unix administrative experience is geared towards making things easy to do in a minimal amount of key strokes; this is probably as a result of the historical situation of having to administer a server over a slow 9600 baud dial-up connection.  Now PS does have aliases which go a long way to getting around the rather verbose Verb-Noun standard, but getting to know those aliases is a bit of a pain (anyone know of something better than: alias | where {$_.ResolvedCommandName -eq "<command>"}?).An example of the rich way in which history can be manipulated:iptables commands are often long-winded and repeating them with slight differences would be a pain if it weren\'t for just one of many neat features of history manipulation built into Bash, so inserting an iptables rule like the following:iptables -I camera-1-internet -s 192.168.0.50 -m state --state NEW -j ACCEPTa second time for another camera ("camera-2"), is just a case of issuing:!!:s/-1-/-2-/:s/50/51which means "perform the previous command, but substitute -1- with -2- and 50 with 51.The Unix experience is optimised for touch-typists; one can pretty much do everything without leaving the "home" position.  For example, in Bash, using the Emacs key bindings (yes, Bash also supports vi bindings), cycling through the history is done using Ctrl-P and Ctrl-N whilst moving to the start and end of a line is done using Ctrl-A and Ctrl-E respectively ... and it definitely doesn\'t end there.  Try even the simplest of navigation in the PS console without moving from the home position and you\'re in trouble.In short, although the scripting capabilities of PS are arguably more powerful than Bash (especially when you consider the availability of the .NET BCL), the interactive experience is significantly weaker, particularly if you\'re coming at it from an entirely keyboard-driven, console-based perspective (as many Unix-heads are).Lots of great great answers, here is my take. PS is ready if you are... Examplegrep = "Select-String -Pattern"sort = "Sort-Object"uniq = "Get-Unique" file = "Get-Item"cat = "Get-Content"Perl/Awk/Sed are not command but utilities hence hard to compare, but you can do almost everything in Powershell.I am not a very experienced PowerShell user by any means, but the little bit of it that I was exposed to impressed me a great deal. You can chain the built-in cmdlets together to do just about anything that you could do at a Unix prompt, and there\'s some additional goodness for doing things like exporting to CSV, HTML tables, and for more in-depth sys-admin types of jobs. And if you really needed something like sed, there\'s always UnixUtils or GnuWin32, which you could integrate with Powershell fairly easily.As a longtime Unix user, I did however have a bit of trouble getting used to the command naming scheme, and I certainly would have benefitted more from it if I knew more .NET.So essentially, I say it\'s well worth learning it if the Windows-only-ness of it doesn\'t pose a problem.If you like shell scripting you will love PowerShell!Start at A guided tour of the Microsoft Command Shell (Ars Technica).When you compare PowerShell to the combination Cygwin/Perl/Shell, be aware that PowerShell only represents the "Shell" part of that combination.You can however invoke any command from PowerShell just as you do from cmd.exe or Cygwin. It does not re-implement the specified functions, and it is certainly not comparable to Perl. It\'s "just" a shell, but it makes programming easier providing a comfortable interface to the .Net universe.Also keep in mind that PowerShell requires WinXP, Srv2003 or higher, which may pose a problem depending on your IT infrastructure.Update:I had no idea what kind of philosophical debate my answer would spark.I posted my answer in the context of the question: Compare PowerShell to Cygwin and Perl and bash.PowerShell is a shell, as it makes no syntactic difference between built-in commands, commandlets, user functions, and external commands (.exe, .bat, .cmd). Only invoking .Net methods differ by adding a namespace or an object in the call.Its programmability derives from .Net framework, not from anything specific to the PowerShell "language".I\'d say I believe PowerShell is a "scripting language" as soon as Bugzilla or MediaWiki are implemented as PowerShell scripts running on a web server ;)Until then, enjoy the comparisons.As my recent experiments led me into depths of Powershell and .NET calls, I must say that Powershell can replace Cygwin and Unix shell. I\'m not sure about Perl, but since both Powershell and Perl are Turing complete as programming languages, I give this as a yes to replacing Perl too. One thing that Powershell has above Cygwin and ordinary bash under *nix, is its ability to perform sandboxed DLL calls, manipulating the operating system via direct API calls, WMI methods and even COM objects. How about launching IE via code, then doing whatever you want with its displayed document, effectively emulating a back-end for a Web server? How about gathering data from SQL servers and other data providers, parse them and export as CSV, mail messages, text and actually any kind of existing and non-existing file formats? (With proper skills of creating a valid file out of data received, of course, but CSV are readily available) And there is an extra security available via signed cmdlets and scripts, group policies and execution policies that help prevent malicious codes from running on your system even if you run them as administrator.About what commands are implemented - the answer by Richard lists them and Powershell\'s capability of emulating their functionality already. About whether Powershell is strong to warrant switching over - this is more a matter of personal preference, although as more and more Windows services are providing Powershell cmdlets to control them, not using Powershell with these services present is considered a hindrance. (Hyper-V server is the primary such service, it also provides the ability to do more with Powershell cmdlets than with GUI!)Probably this answer is five years late, but still, if someone performs administrative tasks or general scripting of various stuff on Windows, they should definitely try harnessing Powershell for their purposes.TL;DR -- I don\'t hate Windows or Powershell I just can\'t do anything in windows or on Powershell.I personally still find powershell underwhelming at best. NTFS is still a mess and seemingly always will be, good luck navigating.cmd-esque interface, The dinosaur cmd.exe is still visible in Powershell, edit->mark still being the only way to copy information, and copying only in the form of rectangular blocks of visible terminal space. and edit->paste still being the only way to paste strings into the terminal.Painting it blue doesn\'t make it any more attractive. I don\'t mind MS developers having a taste in color though.Windows always opens at top left corner of screen, For somebody who uses vertical task bars this is incredibly annoying, especially considering that the windows task bar will cover the only corner of the window that gives access to copy/paste functionality. I can\'t speak much on the grounds of the tools windows includes. Being that there is a whole set of open-source, freely licensed cli tools, and powershell ships with, to my knowledge, none of them is an utter disappointment.I dunno man, I gave it a shot, I really did; I still try to give it a shot in the hopes that the next time I open it it will be any less useless. I cannot do anything in powershell, and I can bearly do things with a real project to bring gnu tools to Windows. MySysGit gives me the dinosaur cmd.exe prompt with a couple gnu tools, still very underwhelming, but at last path completion works. and git command will run in gitBashMintty for MySysGit gives the Cygwin interface over mysysgit\'s environment, making copy and paste a thing. (select to copy (mouse), shift+ins to paste, how modern...) however, things like git push are broken in Mintty.I don\'t mean to rant, but I still see huge problems with command-line usability on windows even given tools like Cygwin. P.S. Just cause something can be done in powershell, doen\'t make it usable, usability is deeper than ability and is what I tend to focus on when trying to use a product as a consumer.The cmdlets in powershell are very nice and work reliably. Their object-orientedness appeals to me a lot since I\'m a java/C# developer, but it\'s not at all a complete set. Since it\'s object oriented, it\'s missed out on a lot of the text stream maturity of the POSIX tool set (awk and sed to name a few).The best answer I\'ve found to the dilemma of loving OO techniques and loving the maturity in the POSIX tools is to use both! One great aspect of Powershell is that it does an excellent job piping objects to standard streams. Powershell by default uses an object pipeline to transport its objects around. These aren\'t the standard streams (standard out, standard error, and standard in). When Powershell needs to pass output to a standard process that doesn\'t have an object pipeline, it first converts the objects to a text stream. Since it does this so well, Powershell makes an excellent place to host POSIX tools!The best POSIX tool set is GnuWin32. It does take more than 5 seconds to install, but it\'s worth the trouble, and as far as I can tell, it doesn\'t modify your system (registry, c:\\windows\\* folders, etc.) except copying files to the directories you specify. This is extra nice because if you put the tools in a shared directory, many people can access them concurrently.Download and execute the exe (it\'s from the SourceForge site) pointing it to a suitable directory (I\'ll be using c:\\bin). It will create a GetGnuWin32 directory there in which you will run download.bat, then install.bat (without parameters), after which, there will be a c:\\bin\\GetGnuWin32\\gnuwin32\\bin directory that is the most useful folder that has ever existed on a Windows machine. Add that directory to your path and you\'re ready to go.I haven\'t seen that the Powershell has really taken off, at least not yet. So it might not be worth the effort of learning it unless those others on your team already know it.For your predicament you might be better off with a scripting language that others could get behind, Perl like you mentioned, or others like Ruby or Python.I think a lot of it depends on what you need to do. Personally I\'ve been using Python for my own personal scripts, but I know when I start writing something that I\'ll never be able to pass it on - so I try not to do anything too revolutionary.Why not use both?  Call PowerShell scripts in Cygwin just like any other interpreted scripts like perl, etc.I do this enough that I wrote https://bitbucket.org/jbianchi/powershell for a bash wrapper to call powershell.exe in Cygwin.  Can be used as a Shebang as the first line of a powershell.exe .ps1 script (since powershell also uses "#" as a comment).  See https://bitbucket.org/jbianchi/powershell/wiki/Home for examplesPowerShell is very powerful, more powerful than the standard built-ins of the Unix shells (but only because it includes much of the functionality usually shelled out to subprograms).  Also, consider that you can write applets in any .NET language, including IronPython, IronRuby, PerlNet, etc.. or you can simply call your cygwin commands from PowerShell, ignoring all the extra functionality and it will work similarly to bash, korn, or whatever...In a couple of lines, Cygwin and Powershell are different tools however if you have Cygwin installed you can run the Cygwin executables within a Powershell session.  I\'ve gotten so used to Powershell that now I no longer use grep, sort, awk, etc.  There are pretty much built-in alternatives in Powershell, and if not you can find a cmdlet out there. The main tool I find myself using is ssh.exe but within a Powershell session.Works great.You can also try running Bash scripts on windows using BashWin at \nhttps://github.com/skanga/BashWinI found PowerShell programming to be not worth the effort.  I have several years of experience with shell scripting under Unix, but I found it enormously difficult to do much of anything with PowerShell.  It seems like many functions require you to interrogate the Windows Management Interface and issue SQL-like commands to get the information you need.  For example, I wanted to write a script to remove all files with a specific suffix from a directory tree.  Under Unix, this would be a simple ...After a couple of hours dicking around with Scripting.FileSystemObject and WScript.Shell and issuing "SELECT * FROM Win32_ShortcutFile WHERE Drive = \'" & drive & "\' AND Path = \'" & searchFolder & "\'", I finally gave up and settled for Windows Explorer\'s Search command and just do it manually.  There\'s probably some way to do what I wanted, but I didn\'t see anything obvious and all the examples on the MSDN site were so trivial as to be worthless.EDIT Heh, of course as soon as I wrote this I poked around some more and found what I had been missing: the -recurse option to the remove-item command is faulty (revealed if you use get-help remove-item -detailed).  I had been trying "remove-item -filter \'* .xyz\' -recurse" and it wasn\'t working, so I gave up on it.  Turns out you need to use get-childitem -filter \'*.xyz\' -recurse | remove-item