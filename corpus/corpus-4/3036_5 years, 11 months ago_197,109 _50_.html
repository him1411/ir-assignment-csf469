I am using Entity Framework 1 with .net 3.5.I am doing something simple like this:I am getting this error when I try to do:I get the error:Unable to update the EntitySet - because it has a DefiningQuery and no <UpdateFunction> element exists in the <ModificationFunctionMapping> element to support the current operation.I am doing lots of updates on the context and not having any issues, it\'s only when I try to update this particular entity.All my searching shows up the same thing, that there is no primary key declared on the entity that I\'m trying to update. But alas, I do have a Primary key declared...It usually happens because one of the following reasons:After doing so, you may still need to update in the Entity Framework designer (or alternatively delete the entity and then add it) before you stop getting the error.Just Add a primary key to the table. That\'s it. Problem solved.Just note that maybe your Entity have primary key but your table in database doesn\'t have primary key. This is the case for me. Simply removing  resulted in another error.  I followed the steps of this post except the last one. For your convenience, I copied the 4 steps from the post   that I followed to solve the problem as following:UPDATE: I\'ve gotten a few upvotes on this lately, so I figured I\'d let people know the advice I give below isn\'t the best. Since I originally started mucking about with doing Entity Framework on old keyless databases, I\'ve come to realize that the best thing you can do BY FAR is do it by reverse code-first. There are a few good articles out there on how to do this. Just follow them, and then when you want to add a key to it, use data annotations to "fake" the key. For instance, let\'s say I know my table Orders, while it doesn\'t have a primary key, is assured to only ever have one order number per customer. Since those are the first two columns on the table, I\'d set up the code first classes to look like this:By doing this, you\'re basically faked EF into believing that there\'s a clustered key composed of OrderNumber and Customer. This will allow you to do inserts, updates, etc on your keyless table.If you\'re not too familiar with doing reverse Code First, go and find a good tutorial on Entity Framework Code First. Then go find one on Reverse Code First (which is doing Code First with an existing database). Then just come back here and look at my key advice again. :)Original Answer:First: as others have said, the best option is to add a primary key to the table. Full stop. If you can do this, read no further.But if you can\'t, or just hate yourself, there\'s a way to do it without the primary key.In my case, I was working with a legacy system (originally flat files on a AS400 ported to Access and then ported to T-SQL). So I had to find a way. This is my solution. The following worked for me using Entity Framework 6.0 (the latest on NuGet as of this writing).Right-click on your .edmx file in the Solution Explorer. Choose "Open With..." and then select "XML (Text) Editor". We\'re going to be hand-editing the auto-generated code here.Look for a line like this: \n<EntitySet Name="table_name" EntityType="MyModel.Store.table_name" store:Type="Tables" store:Schema="dbo" store:Name="table_nane">Remove store:Name="table_name" from the end.Change store:Schema="whatever" to Schema="whatever"Look below that line and find the <DefiningQuery> tag. It will have a big ol\' select statement in it. Remove the tag and it\'s contents.Now your line should look something like this: \n<EntitySet Name="table_name" EntityType="MyModel.Store.table_name" store:Type="Tables" Schema="dbo" />We have something else to change. Go through your file and find this:\n<EntityType Name="table_name">Nearby you\'ll probably see some commented text warning you that it didn\'t have a primary key identified, so the key has been inferred and the definition is a read-only table/view. You can leave it or delete it. I deleted it.Below is the <Key> tag. This is what Entity Framework is going to use to do insert/update/deletes. SO MAKE SURE YOU DO THIS RIGHT. The property (or properties) in that tag need to indicate a uniquely identifiable row. For instance, let\'s say I know my table orders, while it doesn\'t have a primary key, is assured to only ever have one order number per customer. So mine looks like:Seriously, don\'t do this wrong. Let\'s say that even though there should never be duplicates, somehow two rows get into my system with the same order number and customer name. Whooops! That\'s what I get for not using a key! So I use Entity Framework to delete one. Because I know the duplicate is the only order put in today, I do this:Guess what? I just deleted both the duplicate AND the original! That\'s because I told Entity Framework that order_number/cutomer_name was my primary key.  So when I told it to remove duplicateOrder, what it did in the background was something like:And with that warning... you should now be good to go!This can also happen if data model is out of date.Hopefully this will save someone else frustration :)I was getting the same error message, but in my scenario I was trying to update entities derived from a many-to-many relationship using a PJT (Pure Join Table).From reading the other posts, I thought I could fix it by adding an additional PK field to the join table... However, if you add a PK column to a join table, it is no longer a PJT and you lose all of the entity framework advantages like the automatic relationship mapping between the entities.So the solution in my case was to alter the join table on the DB to make a PK that includes BOTH of the foreign ID columns.an error may be occurred , if your table doesn\'t have primary key, in this case the table is "read only", and db.SaveChanges () command  always will bring an errorso its true, just add a primary keyNote: be sure that when you\'re updating your EF diagram from the database that you\'re pointing to the right database,  in my case the connection string was pointing to a local DB instead of the up-to-date Dev DB, schoolboy error i know, but I wanted to post this because it can be very frustrating if you\'re convinced you\'ve added the primary key and you\'re still getting the same error I had the same issue. As this thread said, My table didn\'t have a PK, so I set the PK and ran the code. But unfortunately error came again. What I did next was, deleted the DB connection (delete .edmx file in Model folder of Solution Explorer) and recreated it. Error gone after that. Thanks everyone for sharing your experiences. It save lots of time.I was getting this issue because i was generating my EDMX from an existing database (designed by somebody else, and i use the term \'designed\' loosely here).Turns out the table had no keys whatsoever. EF was generating the model with many multiple keys. I had to go add a primary key to the db table in SQL and then updated my model in VS. That fixed it for me.Adding the primary key worked for me too !Once that is done, here\'s how to update the data model without deleting it -Right click on the edmx Entity designer page and \'Update Model from Database\'.I had the exact same problem, unfortunately, adding the primary key doesn\'t solve the issue. So here\'s how I solve mine:Problem solved.