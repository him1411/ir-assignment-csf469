I have a Java String that contains XML, with no line feeds or indentations. I would like to turn it into a String with nicely formatted XML. How do I do this?Note: My input is a String. My output is a String.Note: Results may vary depending on the Java version. Search for workarounds specific to your platform.Here\'s an answer to my own question. I combined the answers from the various results to write a class that pretty prints XML.No guarantees on how it responds with invalid XML or large documents.a simpler solution based on this answer: testcase:returns:Now it\'s 2012 and Java can do more than it used to with XML, I\'d like to add an alternative to my accepted answer. This has no dependencies outside of Java 6.Just to note that top rated answer requires the use of xerces.If you don\'t want to add this external dependency then you can simply use the standard jdk libraries (which actually are built using xerces internally).N.B. There was a bug with jdk version 1.5 see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6296446 but it is resolved now.,(Note if an error occurs this will return the original text)I\'ve pretty printed in the past using the org.dom4j.io.OutputFormat.createPrettyPrint() methodHere\'s a way of doing it using dom4j:Imports:Code: Since you are starting with a String, you need to covert to a DOM object (e.g. Node) before you can use the Transformer.   However, if you know your XML string is valid, and you don\'t want to incur the memory overhead of parsing a string into a DOM, then running a transform over the DOM to get a string back - you could just do some old fashioned character by character parsing.  Insert a newline and spaces after every </...> characters, keep and indent counter (to determine the number of spaces) that you increment for every <...> and decrement for every </...> you see.Disclaimer - I did a cut/paste/text edit of the functions below, so they may not compile as is.If using a 3rd party XML library is ok, you can get away with something significantly simpler than what the currently highest-voted answers suggest.  It was stated that both input and output should be Strings, so here\'s a utility method that does just that, implemented with the XOM library:I tested that it works, and the results do not depend on your JRE version or anything like that. To see how to customise the output format to your liking, take a look at the Serializer API.This actually came out longer than I thought - some extra lines were needed because Serializer wants an OutputStream to write to. But note that there\'s very little code for actual XML twiddling here.(This answer is part of my evaluation of XOM, which was suggested as one option in my question about the best Java XML library to replace dom4j. For the record, with dom4j you could achieve this with similar ease using XMLWriter and OutputFormat. Edit: ...as demonstrated in mlo55\'s answer.)Hmmm... faced something like this and it is a known bug ... \njust add this OutputProperty ..Hope this helps ...Using scala:You can do this in Java too, if you depend on the scala-library.jar. It looks like this:The PrettyPrinter object is constructed with two ints, the first being max line length and the second being the indentation step.Kevin Hakanson said:\n"However, if you know your XML string is valid, and you don\'t want to incur the memory overhead of parsing a string into a DOM, then running a transform over the DOM to get a string back - you could just do some old fashioned character by character parsing. Insert a newline and spaces after every  characters, keep and indent counter (to determine the number of spaces) that you increment for every <...> and decrement for every  you see."Agreed. Such an approach is much faster and has far fewer dependencies.Example solution:Just for future reference, here\'s a solution that worked for me (thanks to a comment that @George Hawkins posted in one of the answers):Regarding comment that "you must first build a DOM tree": No, you need not and should not do that.Instead, create a StreamSource (new StreamSource(new StringReader(str)), and feed that to the identity transformer mentioned. That\'ll use SAX parser, and result will be much faster.\nBuilding an intermediate tree is pure overhead for this case.\nOtherwise the top-ranked answer is good.slightly improved version from milosmns...If you\'re sure that you have a valid XML, this one is simple, and avoids XML DOM trees. Maybe has some bugs, do comment if you see anythingAll above solutions didn\'t work for me, then I found this http://myshittycode.com/2014/02/10/java-properly-indenting-xml-string/The clue is remove whitespaces with XPathJust another solution which works for usAs an alternative to the answers from max, codeskraps, David Easley and milosmns, have a look at my lightweight, high-performance pretty-printer library: xml-formatterSometimes, like when running mocked SOAP services directly from file, it is good to have a pretty-printer which also handles already pretty-printed XML:As some have commented, pretty-printing is just a way of presenting XML in a more human-readable form - whitespace strictly does not belong in your XML data. The library is intended for pretty-printing for logging purposes, and also includes functions for filtering (subtree removal / anonymization) and pretty-printing of XML in CDATA and Text nodes.This code below working perfectlyI had the same problem and I\'m having great success with JTidy (http://jtidy.sourceforge.net/index.html)Example:Using jdom2 : http://www.jdom.org/there is a very nice command line xml utility called xmlstarlet(http://xmlstar.sourceforge.net/) that can do a lot of things which a lot of people use.Your could execute this program programatically using Runtime.exec and then readin the formatted output file. It has more options and better error reporting than a few lines of Java code can provide.download xmlstarlet : http://sourceforge.net/project/showfiles.php?group_id=66612&package_id=64589I have found that in Java 1.6.0_32 the normal method to pretty print an XML string (using a Transformer with a null or identity xslt) does not behave as I would like if tags are merely separated by whitespace, as opposed to having no separating text. I tried using <xsl:strip-space elements="*"/> in my template to no avail. The simplest solution I found was to strip the space the way I wanted using a SAXSource and XML filter. Since my solution was for logging  I also extended this to work with incomplete XML fragments. Note the normal method seems to work fine if you use a DOMSource but I did not want to use this because of the incompleteness and memory overhead. The solutions I have found here for Java 1.6+ do not reformat the code if it is already formatted. The one that worked for me (and re-formatted already formatted code) was the following.It is a good tool to use in your unit tests for full-string xml comparison. For those searching for a quick and dirty solution - which doesn\'t need the XML to be 100% valid. e.g. in case of REST / SOAP logging (you never know what the others send ;-))I found and advanced a code snipped I found online which I think is still missing here as a valid possible approach: here is the output:I saw one answer using Scala, so here is another one in Groovy, just in case someone finds it interesting. The default indentation is 2 steps, XmlNodePrinter constructor can be passed another value as well.Usage from Java if groovy jar is in classpathIn case you do not need indentation that much but a few line breaks, it could be sufficient to simply regex...The code is nice, not the result because of missing indentation. (For solutions with indentation, see other answers.)Try this: