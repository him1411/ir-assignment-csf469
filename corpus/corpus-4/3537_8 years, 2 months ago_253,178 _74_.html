Is there a way to return the difference between two arrays in JavaScript?For example:Any advice greatly appreciated.I assume you are comparing a normal array. If not, you need to change the for loop to a for .. in loop.A better solution, if you don\'t care about backward compatibility, is using filter. But still, this solution works, so voting it down is unfair.Note indexOf and filter are not available in ie before ie9.This is by far the easiest way to get exactly the result you are looking for, using jQuery:diff now contains what was in old_array that is not in new_arrayThere is a better way using ES6:For [1,2,3] [2,3] it will yield [1]. On the other hand, for [1,2,3] [2,3,5] will return the same thing.For a symmetric difference, you can do:This way, you will get an array containing all the elements of arr1 that are not in arr2 and vice-versaThe difference method in Underscore (or its drop-in replacement, Lo-Dash) can do this too:As with any Underscore function, you could also use it in a more object-oriented style:There are two possible intepretations for "difference". I\'ll let you choose which one you want. Say you have:If you want to get [\'a\'], use this function:If you want to get [\'a\', \'c\'] (all elements contained in either a1 or a2, but not both -- the so-called symmetric difference), use this function:If you are using lodash, you can use _.difference(a1, a2) (case 1 above) or _.xor(a1, a2) (case 2).If you are using Underscore.js, you can use the _.difference(a1, a2) function for case 1.The code above works on all browsers. However, for large arrays of more than about 10,000 items, it becomes quite slow, because it has O(n\xc2\xb2) complexity. On many modern browsers, we can take advantage of the ES6 Set object to speed things up. Lodash automatically uses Set when it\'s available. If you are not using lodash, use the following implementation, inspired by Axel Rauschmayer\'s blog post:The behavior for all examples may be surprising or non-obvious if you care about -0, +0, NaN or sparse arrays. (For most uses, this doesn\'t matter.)You could use a Set in this case. It is optimized for this kind of operation (union, intersection, difference).Make sure it applies to your case, once it allows no duplicates.to subtract one array from another, simply use the snippet below:It will returns [\'1,\'2\',\'6\'] that are items of first array which don\'t exist in the second.Therefore, according to your problem sample, following code is the exact solution:Merge both the arrays, unique values will appear only once so indexOf() will be the same as lastIndexOf().A solution using indexOf() will be ok for small arrays but as they grow in length the performance of the algorithm approaches O(n^2).  Here\'s a solution that will perform better for very large arrays by using objects as associative arrays to store the array entries as keys; it also eliminates duplicate entries automatically but only works with string values (or values which can be safely stored as strings):The above answer by Joshaven Potter is great. But it returns elements in array B that are not in array C, but not the other way around. For example, if var a=[1,2,3,4,5,6].diff( [3,4,5,7]); then it will output: ==> [1,2,6], but not [1,2,6,7], which is the actual difference between the two. You can still use Potter\'s code above but simply redo the comparison once backwards too:This should output: [ 1, 2, 6, 7 ]With the arrival of ES6 with sets and splat operator (at the time of being works only in Firefox, check compatibility table), you can write the following one liner:which will result in [ "c", "d" ].Computing the difference between two arrays is one of the Set operations. The term already indicates that the native Set type should be used, in order to increase the lookup speed. Anyway, there are three permutations when you compute the difference between two sets:Here is a functional solution that reflects these permutations.differencer is trivial. It is just differencel with flipped arguments. You can write a function for convenience: const differencer = flip(differencel). That\'s all!Now that we have the left and right one, implementing the symmetric difference gets trivial as well:I guess this example is a good starting point to obtain an impression what functional programming means:Programming with building blocks that can be plugged together in many different ways.Another way to solve the problem   Very Simple Solution with the filter function of JavaScript:Using http://phrogz.net/JS/ArraySetMath.js you can:This is working: basically merge the two arrays, look for the duplicates and push what is not duplicated into a new array which is the difference.this is works for meJust thinking... for the sake of a challenge ;-) would this work... (for basic arrays of strings, numbers, etc.) no nested arraysNote the sorting will likely not be as noted above... but if desired, call .sort() on the array to sort it.How about this:So this way you can do array1.diff(array2) to get their difference (Horrible time complexity for the algorithm though - O(array1.length x array2.length) I believe)littlebit fix for the best answerthis will take current type of element in consideration. b/c when we make a[a1[i]] it converts a value to string from its oroginal value, so we lost actual value.I wanted a similar function which took in an old array and a new array and gave me an array of added items and an array of removed items, and I wanted it to be efficient (so no .contains!).You can play with my proposed solution here: http://jsbin.com/osewu3/12.Can anyone see any problems/improvements to that algorithm? Thanks!Code listing:I was looking for a simple answer that didn\'t involve using different libraries, and I came up with my own that I don\'t think has been mentioned here.\nI don\'t know how efficient it is or anything but it works;For my code I need duplicates taken out as well, but I guess that isn\'t always preferred.I guess the main downside is it\'s potentially comparing many options that have already been rejected.In response to the person who wanted to subtract one array from another...If no more than say 1000 elements try this...Setup a new variable to duplicate Array01 and call it Array03.Now, use the bubble sort algorithm to compare the elements of Array01 with Array02 and whenever you find a match\ndo the following to Array03...NB: We are modifying Array03 instead of Array01 so as not to screw up the nested loops of the bubble sort!Finally, copy the contents of Array03 to Array01 with a simple assignment, and you\'re done.You can use underscore.js : http://underscorejs.org/#intersectionYou have needed methods for array : If not use hasOwnProperty then we have incorrect elements. For example: My version:Contributing with a jQuery solution that I\'m currently using: