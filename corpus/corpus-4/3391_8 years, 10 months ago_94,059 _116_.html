Is it possible to write a template that changes behavior depending on if a certain member function is defined on a class?Here\'s a simple example of what I would want to write:So, if class T has toString() defined, then it uses it; otherwise, it doesn\'t. The magical part that I don\'t know how to do is the "FUNCTION_EXISTS" part.Yes, with SFINAE you can check if a given class does provide a certain method. Here\'s the working code:I\'ve just tested it with Linux and gcc 4.1/4.3. I don\'t know if it\'s portable to other platforms running different compilers. This question is old, but with C++11 we got a new way to check for a functions existence (or existence of any non-type member, really), relying on SFINAE again:Live example.Now onto some explanations. First thing, I use expression SFINAE to exclude the serialize(_imp) functions from overload resolution, if the first expression inside decltype isn\'t valid (aka, the function doesn\'t exist).The void() is used to make the return type of all those functions void.The 0 argument is used to prefer the os << obj overload if both are available (literal 0 is of type int and as such the first overload is a better match).Now, you probably want a trait to check if a function exists. Luckily, it\'s easy to write that. Note, though, that you need to write a trait yourself for every different function name you might want.Live example.And on to explanations. First, sfinae_true is a helper type, and it basically amounts to the same as writing decltype(void(std::declval<T>().stream(a0)), std::true_type{}). The advantage is simply that it\'s shorter.\nNext, the struct has_stream : decltype(...) inherits from either std::true_type or std::false_type in the end, depending on whether the decltype check in test_stream fails or not.\nLast, std::declval gives you a "value" of whatever type you pass, without you needing to know how you can construct it. Note that this is only possible inside an unevaluated context, such as decltype, sizeof and others.Note that decltype is not necessarily needed, as sizeof (and all unevaluated contexts) got that enhancement. It\'s just that decltype already delivers a type and as such is just cleaner. Here\'s a sizeof version of one of the overloads:Live example.The int and long parameters are still there for the same reason. The array pointer is used to provide a context where sizeof can be used.C++ allows SFINAE to be used for this (notice that with C++11 features this is simplier because it supports extended SFINAE on nearly arbitrary expressions - the below was crafted to work with common C++03 compilers):the above template and macro tries to instantiate a template, giving it a member function pointer type, and the actual member function pointer. If the types to not fit, SFINAE causes the template to be ignored. Usage like this:But note that you cannot just call that toString function in that if branch. since the compiler will check for validity in both branches, that would fail for cases the function doesnt exist. One way is to use SFINAE once again (enable_if can be gotten from boost too):Have fun using it. The advantage of it is that it also works for overloaded member functions, and also for const member functions (remember using  std::string(T::*)() const as the member function pointer type then!). Though this question is two years old, I\'ll dare to add my answer. Hopefully it will clarify the previous, indisputably excellent, solution. I took the very helpful answers of Nicola Bonelli and Johannes Schaub and merged them into a solution that is, IMHO, more readable, clear and does not require the typeof extension:I checked it with gcc 4.1.2.\nThe credit goes mainly to Nicola Bonelli and Johannes Schaub, so give them a vote up if my answer helps you :)N4502 proposes a detection tookit for inclusion into the C++17 standard library which can solve the problem in a somewhat elegant manner. Moreover, it just got accepted into the library fundamentals TS v2. It introduces some metafunctions, including std::is_detected which can be used to easily write type or function detection metafunctions on the top of it. Here is how you could use it:Note that the example above is untested. The detection toolkit is not available in standard libraries yet but the proposal contains a full implementation that you can easily copy if you really need it. It plays nice with the C++17 feature if constexpr:Another somewhat idiomatic toolkit to perform such a check - even though less elegant - is Boost.TTI, introduced in Boost 1.54.0. For your example, you would have to use the macro BOOST_TTI_HAS_MEMBER_FUNCTION. Here is how you could use it:Then, you could use the bool to create a SFINAE check.ExplanationThe macro BOOST_TTI_HAS_MEMBER_FUNCTION generates the metafunction has_member_function_toString which takes the checked type as its first template parameter. The second template parameter corresponds to the return type of the member function, and the following parameters correspond to the types of the function\'s parameters. The member value contains true if the class T has a member function std::string toString().Alternatively, has_member_function_toString can take a member function pointer as a template parameter. Therefore, it is possible to replace has_member_function_toString<T, std::string>::value by has_member_function_toString<std::string T::* ()>::value.This is what type traits are there for. Unfortunately, they have to be defined manually. In your case, imagine the following:A simple solution for C++11:Well, this question has a long list of answers already, but I would like to emphasize the comment from Morwenn: there is a proposal for C++17 that makes it really much simpler.  See N4502 for details, but as a self-contained example consider the following.This part is the constant part, put it in a header.then there is the variable part, where you specify what you are looking for (a type, a member type, a function, a member function etc.).  In the case of the OP:The following example, taken from N4502, shows a more elaborate probe:Compared to the other implementations described above, this one is fairly simple: a reduced set of tools (void_t and detect) suffices, no need for hairy macros.  Besides, it was reported (see N4502) that it is measurably more efficient (compile-time and compiler memory consumption) than previous approaches.Here is a live example.  It works fine with Clang, but unfortunately, GCC versions before 5.1 followed a different interpretation of the C++11 standard which caused void_t to not work as expected.  Yakk already provided the work-around: use the following definition of void_t (void_t in parameter list works but not as return type):Here are some usage snippets:\n*The guts for all this are farther downCheck for member x in a given class.  Could be var, func, class, union, or enum:Check for member function void x():Check for member variable x:Check for member class x:Check for member union x:Check for member enum x:Check for any member function x regardless of signature:ORDetails and core:Macros (El Diablo!):CREATE_MEMBER_CHECK:CREATE_MEMBER_VAR_CHECK:CREATE_MEMBER_FUNC_SIG_CHECK:CREATE_MEMBER_CLASS_CHECK:CREATE_MEMBER_UNION_CHECK:CREATE_MEMBER_ENUM_CHECK:CREATE_MEMBER_FUNC_CHECK:CREATE_MEMBER_CHECKS:The standard C++ solution presented here by litb will not work as expected if the method happens to be defined in a base class. For a solution that handles this situation refer to :In Russian :\nhttp://www.rsdn.ru/forum/message/2759773.1.aspx English Translation by Roman.Perepelitsa : \nhttp://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/4f7c7a96f9afbe44/c95a7b4c645e449f?pli=1 It is insanely clever. However one issue with this solutiion is that gives compiler errors if the type being tested is one that cannot be used as a base class (e.g. primitive types)In Visual Studio, I noticed that if working with method having no arguments, an extra pair of redundant ( )  needs to be inserted around the argments to deduce( )  in the sizeof expression.I wrote an answer to this in another thread that (unlike the solutions above) also checks inherited member functions:SFINAE to check for inherited member functionsHere are some example from that solution:We are checking for a member with the following signature: \nT::const_iterator begin() constPlease notice that it even checks the constness of the method, and works with primitive types, as well. (I mean has_const_begin<int>::value is false and doesn\'t cause a compile-time error.) Now we are looking for the signature: void foo(MyClass&, unsigned)Please notice that MyClass doesn\'t has to be default constructible or to satisfy any special concept. The technique works with template members, as well.I am eagerly waiting opinions regarding this.Now this was a nice little puzzle - great question!Here\'s an alternative to Nicola Bonelli\'s solution that does not rely on the non-standard typeof operator.Unfortunately, it does not work on GCC (MinGW) 3.4.5 or Digital Mars 8.42n, but it does work on all versions of MSVC (including VC6) and on Comeau C++.The longer comment block has the details on how it works (or is supposed to work).  As it says, I\'m not sure which behavior is standards compliant - I\'d welcome commentary on that.update - 7 Nov 2008:It looks like while this code is syntactically correct, the behavior that MSVC and Comeau C++ show does not follow the standard (thanks to Leon Timmermans and litb for pointing me in the right direction).  The C++03 standard says the following:14.6.2 Dependent names [temp.dep]Paragraph 3In the definition of a class template\n  or a member of a class template, if a\n  base class of the class template\n  depends on a template-parameter, the\n  base class scope is not examined\n  during unqualified name lookup either\n  at the point of definition of the\n  class template or member or during an\n  instantiation of the class template or\n  member.So, it looks like that when MSVC or Comeau consider the toString() member function of T performing name lookup at the call site in doToString() when the template is instantiated, that is incorrect (even though it\'s actually the behavior I was looking for in this case).The behavior of GCC and Digital Mars looks to be correct - in both cases the non-member toString() function is bound to the call.Rats - I thought I might have found a clever solution, instead I uncovered a couple compiler bugs...This is a C++11 solution for the general problem if "If I did X, would it compile?"Trait has_to_string such that has_to_string<T>::value is true if and only if T has a method .toString that can be invoked with 0 arguments in this context.Next, I\'d use tag dispatching:which tends to be more maintainable than complex SFINAE expressions.You can write these traits with a macro if you find yourself doing it alot, but they are relatively simple (a few lines each) so maybe not worth it:what the above does is create a macro MAKE_CODE_TRAIT.  You pass it the name of the trait you want, and some code that can test the type T.  Thus:creates the above traits class.As an aside, the above technique is part of what MS calls "expression SFINAE", and their 2013 compiler fails pretty hard.Note that in C++1y the following syntax is possible:which is an inline compilation conditional branch that abuses lots of C++ features.  Doing so is probably not worth it, as the benefit (of code being inline) is not worth the cost (of next to nobody understanding how it works), but the existence of that above solution may be of interest.MSVC has the __if_exists and __if_not_exists keywords (Doc). Together with the typeof-SFINAE approach of Nicola I could create a check for GCC and MSVC like the OP looked for.Update: Source can be found HereI modified the solution provided in https://stackoverflow.com/a/264088/2712152 to make it a bit more general. Also since it doesn\'t use any of the new C++11 features we can use it with old compilers and should also work with msvc. But the compilers should enable C99 to use this since it uses variadic macros.The following macro can be used to check if a particular class has a particular typedef or not.The following macro can be used to check if a particular class has a particular member function or not with any given number of arguments.We can use the above 2 macros to perform the checks for has_typedef and has_mem_func as:Strange nobody suggested the following nice trick I saw once on this very site :You have to make sure T is a class. It seems that ambiguity in the lookup of foo is a substitution failure. I made it work on gcc, not sure if it is standard though.The generic template that can be used for checking if some "feature" is supported by the type:The template that checks whether there is a method foo that is compatible with signature double(const char*)Exampleshttp://coliru.stacked-crooked.com/a/83c6a631ed42cea4There are a lot of answers here, but I failed, to find a version, that performs real method resolution ordering, while not using any of the newer c++ features (only using c++98 features).\nNote: This version is tested and working with vc++2013, g++ 5.2.0 and the onlline compiler.So I came up with a version, that only uses sizeof():Live demo (with extended return type checking and vc++2010 workaround): http://cpp.sh/5b2vsNo source, as I came up with it myself.When running the Live demo on the g++ compiler, please note that array sizes of 0 are allowed, meaning that the static_assert used will not trigger a compiler error, even when it fails.\nA commonly used work-around is to replace the \'typedef\' in the macro with \'extern\'.How about this solution?Here is my version that handles all possible member function overloads with arbitrary arity, including template member functions, possibly with default arguments. It distinguishes 3 mutually exclusive scenarios when making a member function call to some class type, with given arg types: (1) valid, or (2) ambiguous, or (3) non-viable. Example usage:Now you can use it like this:Here is the code, written in c++11, however, you can easily port it (with minor tweaks) to non-c++11 that has typeof extensions (e.g. gcc). You can replace the HAS_MEM macro with your own.You can skip all the metaprogramming in C++14, and just write this using fit::conditional from the Fit library:You can also create the function directly from the lambdas as well:However, if you are using a compiler that doesn\'t support generic lambdas, you will have to write separate function objects: