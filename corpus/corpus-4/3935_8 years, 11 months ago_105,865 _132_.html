I collect a few corner cases and brain teasers and would always like to hear more. The page only really covers C# language bits and bobs, but I also find core .NET things interesting too. For example, here\'s one which isn\'t on the page, but which I find incredible:I\'d expect that to print False - after all, "new" (with a reference type) always creates a new object, doesn\'t it? The specs for both C# and the CLI indicate that it should.  Well, not in this particular case. It prints True, and has done on every version of the framework I\'ve tested it with. (I haven\'t tried it on Mono, admittedly...)Just to be clear, this is only an example of the kind of thing I\'m looking for - I wasn\'t particularly looking for discussion/explanation of this oddity. (It\'s not the same as normal string interning; in particular, string interning doesn\'t normally happen when a constructor is called.) I was really asking for similar odd behaviour.Any other gems lurking out there?I think I showed you this one before, but I like the fun here - this took some debugging to track down! (the original code was obviously more complex and subtle...)So what was T...Answer: any Nullable<T> - such as int?. All the methods are overridden, except GetType() which can\'t be; so it is cast (boxed) to object (and hence to null) to call object.GetType()... which calls on null ;-pUpdate: the plot thickens... Ayende Rahien threw down a similar challenge on his blog, but with a where T : class, new():But it can be defeated! Using the same indirection used by things like remoting; warning - the following is pure evil:With this in place, the new() call is redirected to the proxy (MyFunnyProxyAttribute), which returns null. Now go and wash your eyes!Bankers\' Rounding.This one is not so much a compiler bug or malfunction, but certainly a strange corner case...The .Net Framework employs a scheme or rounding known as Banker\'s Rounding.In Bankers\' Rounding the 0.5 numbers are rounded to the nearest even number, soThis can lead to some unexpected bugs in financial calculations based on the more well known Round-Half-Up rounding.This is also true of Visual Basic.What will this function do if called as Rec(0) (not under the debugger)?Answer:This is because the 64-bit JIT compiler applies tail call optimisation, whereas the 32-bit JIT does not. Unfortunately I haven\'t got a 64-bit machine to hand to verify this, but the method does meet all the conditions for tail-call optimisation. If anybody does have one I\'d be interested to see if it\'s true.This is one that I like to ask at parties (which is probably why I don\'t get invited anymore):Can you make the following piece of code compile?An easy cheat could be:But the real solution is this:So it\'s a little know fact that value types (structs) can reassign their this variable.Few years ago, when working on loyality program, we had an issue with the amount of points given to customers. The issue was related to casting/converting double to int.In code below:does i1 == i2 ?It turns out that i1 != i2.\nBecause of different rounding policies in Convert and cast operator the actual values are:It\'s always better to call Math.Ceiling() or Math.Floor() (or Math.Round with MidpointRounding that meets our requirements)They should have made 0 an integer even when there\'s an enum function overload.I knew C# core team rationale for mapping 0 to enum, but still, it is not as orthogonal as it should be.  Example from Npgsql.Test example:This is one of the most unusual i\'ve seen so far (aside from the ones here of course!):It lets you declare it but has no real use, since it will always ask you to wrap whatever class you stuff in the center with another Turtle.[joke] I guess it\'s turtles all the way down... [/joke]Here\'s one I only found out about recently...The above looks crazy at first glance, but is actually legal.No, really (although I\'ve missed out a key part, but it isn\'t anything hacky like "add a class called IFoo" or "add a using alias to point IFoo at a class"). See if you can figure out why, then: Who says you can\xe2\x80\x99t instantiate an interface?When is a Boolean neither True nor False?Bill discovered that you can hack a boolean so that if A is True and B is True, (A and B) is False.Hacked BooleansI\'m arriving a bit late to the party, but I\'ve got three four five:If you poll InvokeRequired on a control that hasn\'t been loaded/shown, it will say false - and blow up in your face if you try to change it from another thread (the solution is to reference this.Handle in the creator of the control).Another one which tripped me up is that given an assembly with:if you calculate MyEnum.Red.ToString() in another assembly, and in between times someone has recompiled your enum to:at runtime, you will get "Black".I had a shared assembly with some handy constants in. My predecessor had left a load of ugly-looking get-only properties, I thought I\'d get rid of the clutter and just use public const. I was more than a little surprised when VS compiled them to their values, and not references.If you implement a new method of an interface from another assembly, but you rebuild referencing the old version of that assembly, you get a TypeLoadException (no implementation of \'NewMethod\'), even though you have implemented it (see here).Dictionary<,>: "The order in which the items are returned is undefined". This is horrible, because it can bite you sometimes, but work others, and if you\'ve just blindly assumed that Dictionary is going to play nice ("why shouldn\'t it? I thought, List does"), you really have to have your nose in it before you finally start to question your assumption.VB.NET, nullables and the ternary operator:This took me some time to debug, since I expected i to contain Nothing.What does i really contain? 0.This is surprising but actually "correct" behavior: Nothing in VB.NET is not exactly the same as null in CLR: Nothing can either mean null or default(T) for a value type T, depending on the context. In the above case, If infers Integer as the common type of Nothing and 5, so, in this case, Nothing means 0.I found a second really strange corner case that beats my first one by a long shot.String.Equals Method (String, String, StringComparison) is not actually side effect free.I was working on a block of code that had this on a line by itself at the top of some function:Removing that line lead to a stack overflow somewhere else in the program.The code turned out to be installing a handler for what was in essence a BeforeAssemblyLoad event and trying to doBy now I shouldn\'t have to tell you. Using a culture that hasn\'t been used before in a string comparison causes an assembly load. InvariantCulture is not an exception to this.Here is an example of how you can create a struct that causes the error message "Attempted to read or write protected memory. This is often an indication that other memory is corrupt".\nThe difference between success and failure is very subtle.The following unit test demonstrates the problem.See if you can work out what went wrong.C# supports conversions between arrays and lists as long as the arrays are not multidimensional and there is an inheritance relation between the types and the types are reference typesNote that this does not work:This is the strangest I\'ve encountered by accident:Used as follows:Will throw a NullReferenceException. Turns out the multiple additions are compiled by the C# compiler to a call to String.Concat(object[]). Prior to .NET 4, there is a bug in just that overload of Concat where the object is checked for null, but not the result of ToString():This is a bug by ECMA-334 \xc2\xa714.7.4:The binary + operator performs string concatenation when one or both operands are of type string. If an operand of string concatenation is null, an empty string is substituted. Otherwise, any non-string operand is converted to its string representation by invoking the virtual ToString method inherited from type object. If ToString returns null, an empty string is substituted.Interesting - when I first looked at that I assumed it was something the C# compiler was checking for, but even if you emit the IL directly to remove any chance of interference it still happens, which means it really is the newobj op-code that\'s doing the checking.It also equates to true if you check against string.Empty which means this op-code must have special behaviour to intern empty strings.The output is "Attempted to read protected memory. This is an indication that other memory is corrupt."PropertyInfo.SetValue() can assign ints to enums, ints to nullable ints, enums to nullable enums, but not ints to nullable enums.Full description hereWhat if you have a generic class that has methods that could be made ambiguous depending on the type arguments? I ran into this situation recently writing a two-way dictionary. I wanted to write symmetric Get() methods that would return the opposite of whatever argument was passed. Something like this:All is well good if you make an instance where T1 and T2 are different types:But if T1 and T2 are the same (and probably if one was a subclass of another), it\'s a compiler error:Interestingly, all other methods in the second case are still usable; it\'s only calls to the now-ambiguous method that causes a compiler error. Interesting case, if a little unlikely and obscure.The following derived class is accessing a private field from its base class, and the compiler silently looks to the other side:The field is indeed private:Care to guess how we can make such code compile?.......The trick is to declare Derived as an inner class of Base:Inner classes are given full access to the outer class members. In this case the inner class also happens to derive from the outer class. This allows us to "break" the encapsulation of  private members.Just found a nice little thing today:This throws compile error.  The call to method \'Initialize\' needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.If I write base.Initialize(stuff as object); it works perfectly, however this seems to be a "magic word" here, since it does exactly the same, everything is still recieved as dynamic...In an API we\'re using, methods that return a domain object might return a special "null object". In the implementation of this, the comparison operator and the Equals() method are overridden to return true if it is compared with null.So a user of this API might have some code like this:or perhaps a bit more verbose, like this:where GetDefault() is a method returning some default value that we want to use instead of null. The surprise hit me when I was using ReSharper and following it\'s recommendation to rewrite either of this to the following:If the test object is a null object returned from the API instead of a proper null, the behavior of the code has now changed, as the null coalescing operator actually checks for null, not running operator= or Equals().Consider this weird case:If Base and Derived are declared in the same assembly, the compiler will make Base::Method virtual and sealed (in the CIL), even though Base doesn\'t implement the interface. If Base and Derived are in different assemblies, when compiling the Derived assembly, the compiler won\'t change the other assembly, so it will introduce a member in Derived that will be an explicit implementation for MyInterface::Method that will just delegate the call to Base::Method.The compiler has to do this in order to support polymorphic dispatch with regards to the interface, i.e. it has to make that method virtual.The following might be general knowledge I was just simply lacking, but eh. Some time ago, we had a bug case which included virtual properties. Abstracting the context a bit, consider the following code, and apply breakpoint to specified area :While in the Derived object context, you can get the same behavior when adding base.Property as a watch, or typing base.Property into the quickwatch. Took me some time to realize what was going on. In the end I was enlightened by the Quickwatch. When going into the Quickwatch and exploring the Derived object d (or from the object\'s context, this) and selecting the field base, the edit field on top of the Quickwatch displays the following cast:Which means that if base is replaced as such, the call would befor the Watches, Quickwatch and the debugging mouse-over tooltips, and it would then make sense for it to display "AWESOME" instead of "BASE_AWESOME" when considering polymorphism. I\'m still unsure why it would transform it into a cast, one hypothesis is that call might not be available from those modules\' context, and only callvirt.Anyhow, that obviously doesn\'t alter anything in terms of functionality, Derived.BaseProperty will still really return "BASE_AWESOME", and thus this was not the root of our bug at work, simply a confusing component. I did however find it interesting how it could mislead developpers which would be unaware of that fact during their debug sessions, specially if Base is not exposed in your project but rather referenced as a 3rd party DLL, resulting in Devs just saying :"Oi, wait..what ? omg that DLL is\n  like, ..doing something funny"This one\'s pretty hard to top.  I ran into it while I was trying to build a RealProxy implementation that truly supports Begin/EndInvoke (thanks MS for making this impossible to do without horrible hacks).  This example is basically a bug in the CLR, the unmanaged code path for BeginInvoke doesn\'t validate that the return message from RealProxy.PrivateInvoke (and my Invoke override) is returning an instance of an IAsyncResult.  Once it\'s returned, the CLR gets incredibly confused and loses any idea of whats going on, as demonstrated by the tests at the bottom.Output:I\'m not sure if you\'d say this is a Windows Vista/7 oddity or a .Net oddity but it had me scratching my head for a while.In Windows Vista/7 the file will actually be written to C:\\Users\\<username>\\Virtual Store\\Program Files\\my folder\\test.txtHave you ever thought the C# compiler could generate invalid CIL? Run this and you\'ll get a TypeLoadException:I don\'t know how it fares in the C# 4.0 compiler though.EDIT: this is the output from my system:There is something really exciting about C#, the way it handles closures.Instead of copying the stack variable values to the closure free variable, it does that preprocessor magic wrapping all occurences of the variable into an object and thus moves it out of stack - straight to the heap! :)I guess, that makes C# even more functionally-complete (or lambda-complete huh)) language than ML itself (which uses stack value copying AFAIK). F# has that feature too, as C# does. That does bring much delight to me, thank you MS guys!It\'s not an oddity or corner case though... but something really unexpected from a stack-based VM language :)From a question I asked not long ago:Conditional operator cannot cast implicitly?Given:Where aBoolValue is assigned either True or False;The following will not compile:But this would:The answer provided is pretty good too.The scoping in c# is truly bizarre at times. Lets me give you one example:This fails to compile, because command is redeclared? There are some interested guesswork as to why it works that way in this thread on stackoverflow and in my blog.