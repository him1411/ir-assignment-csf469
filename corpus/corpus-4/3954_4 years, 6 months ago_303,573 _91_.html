In Java we use final keyword with variables to specify its values are not to be changed.\nBut I see that you can change the value in the constructor / methods of the class. Again, if the variable is static then it is a compilation error.Here is the code: Above code works fine and no errors.Now change the variable as static:Now it is a compilation error. How does this final really work?You are always allowed to initialize a final variable.  The compiler makes sure that you can do it only once. Note that calling methods on an object stored in a final variable has nothing to do with the semantics of final. In other words: final is only about the reference itself, and not about the contents of the referenced object.Java has no concept of object immutability; this is achieved by carefully designing the object, and is a far-from-trivial endeavor.This is a favorite interview question. With this questions, the interviewer tries to find out how well you understand the behavior of objects with respect to constructors, methods, class variables (static variables) and instance variables.In the above case, we have defined a constructor for \'Test\' and gave it a \'setFoo\' method. About constructor:  Constructor can be invoked only one time per object creation by using the new keyword. You cannot invoke constructor multiple times, because constructor are not designed to do so. About method: A method can be invoked as many times as you want (Even never) and the compiler knows it. Scenario 1foo is an instance variable. When we create Test class object then the instance variable foo, will be copied inside the object of Test class. If we assign foo inside the constructor, then the compiler knows that the constructor will be invoked only once, so there is no problem assigning it inside the constructor.\n\nIf we assign foo inside a method, the compiler knows that a method can be called multiple times, which means the value will have to be changed multiple times, which is not allowed for a final variable. So the compiler decides constructor is good choice! You can assign a value to a final variable only one time.Scenario 2foo is now a static variable. When we create an instance of Test class, foo will not be copied to the object because foo is static. Now foo is not an independent property of each object. This is a property of Test class. But foo can be seen by multiple objects and if every object which is created by using the new keyword which will ultimately invoke the Test constructor which changes the value at the time of multiple object creation (Remember static foo is not copied in every object, but is shared between multiple objects.) Scenario 3 Above Modification-2 is from your question. In the above case, you are not changing the first referenced object, but you are adding content inside foo which is allowed. Compiler complains if you try to assign a new ArrayList() to the foo reference variable.\nRule If you have initialized a final variable, then you cannot change it to refer to a different object. (In this case ArrayList)final classes cannot be subclassed\nfinal methods cannot be overridden. (This method is in superclass)\nfinal methods can override. (Read this in grammatical way. This method is in a subclass)Final keyword has a numerous way to use:Other usage:A static class variable will exist from the start of the JVM, and should be initialized in the class. The  error message won\'t appear if you do this.The final keyword can be interpreted in two different ways depending on what it\'s used on:Value types: For ints, doubles etc, it will ensure that the value cannot change,Reference types: For references to objects, final ensures that the reference will never change, meaning that it will always refer to the same object. It makes no guarantees whatsoever about the values inside the object being referred to staying the same.As such, final List<Whatever> foo; ensures that foo always refers to the same list, but the contents of said list may change over time.If you make foo static, you must initialize it in the class constructor (or inline where you define it) like the following examples.Class constructor (not instance):Inline:The problem here is not how the final modifier works, but rather how the static modifier works. The final modifier enforces an initialization of your reference by the time the call to your constructor completes (i.e. you must initialize it in the constructor).When you initialize an attribute in-line, it gets initialized before the code you have defined for the constructor is run, so you get the following outcomes:When you do not initilize an attribute in-line, the final modifier enforces that you initialize it and that you must do so in the constructor. If you also have a static modifier, the constructor you will have to initialize the attribute in is the class\' initialization block : static{}.The error you get in your code is from the fact that static{} is run when the class is loaded, before the time you instantiate an object of that class. Thus, you will have not initialized foo when the class is created. Think of the static{} block as a constructor for an object of type Class. This is where you must do the initialization of your static final class attributes (if not done inline).Side note:The final modifier assures const-ness only for primitive types and references. When you declare a final object, what you get is a final reference to that object, but the object itself is not constant. What you are really achieving when declaring a final attribute is that, once you declare an object for your specific purpose (like the final List that you have declared), that and only that object will be used for that purpose: you will not be able to change List foo to another List, but you can still alter your List by adding/removing items (the List you are using will be the same, only with its contents altered).This is a very good interview question. Sometimes they might even ask you what is the difference between a final object and immutable object.1) When someone mentions a final object, it means that the reference cannot be changed, but its state(instance variables) can be changed.  2) An immutable object is one whose state can not be changed, but its reference can be changed. \nEx:ref variable x can be changed to point a different string, but value of "abc" cannot be changed. 3) Instance variables(non static fields) are initialized when a constructor is called. So you can initialize values to you variables inside a constructor.4) "But i see that you can change the value in the constructor/methods of the class". -- You cannot change it inside a method.5) A static variable is initialized during class loading. So you cannot initialize inside a constructor, it has to be done even before it. So you need to assign values to a static variable during declaration itself.Suppose you have two moneyboxes, red and white. You assign these moneyboxes only two children and they are not allowed interchange their boxes. So You have red or white moneyboxes(final) you cannot modify the box but you can put money on your box.Nobody cares (Modification-2).final is a reserved keyword in Java to restrict the user and it can be applied to member variables, methods, class and local variables. Final variables are often declared with the static keyword in Java and are treated as constants. For example:When we use the final keyword with a variable declaration, the value stored inside that variable cannot be changed latter. For example:Note: A class declared as final cannot be extended or inherited (i.e, there cannot be a subclass of the super class). It is also good to note that methods declared as final cannot be overridden by subclasses. Benefits of using the final keyword are addressed in this thread.It is worth to mention some straightforward definitions:Classes/MethodsYou can declare some or all of a class\'s methods final. You use the final keyword in a method declaration to indicate that the method cannot be overridden by subclasses.VariablesOnce a final variable has been assigned, it always contains the same value. FINAL basically avoid overwrite/superscribe by anything (subclasses, variable "reasign"), depending on the case.When you make it static final it should be initialized in a static initialization blockThe final keyword indicates that a variable may only be initialized once.  In your code you are only performing one initialization of final so the terms are satisfied.  This statement performs the lone initialization of foo.  Note that final != immutable, it only means that the reference cannot change.When you declare foo as static final the variable must be initialized when the class is loaded and cannot rely on instantiation (aka call to constructor) to initialize foo since static fields must be available without an instance of a class.  There is no guarantee that the constructor will have been called prior to using the static field.When you execute your method under the static final scenario the Test class is loaded prior to instantiating t at this time there is no instantiation of foo meaning it has not been initialized so foo is set to the default for all objects which is null.  At this point I assume your code throws a NullPointerException when you attempt to add an item to the list.Following are different contexts where final is used.Final variables A final variable can only be assigned once. If the variable is a reference, this means that the variable cannot be re-bound to reference another object.final variable can be assigned value later (not compulsory to assigned a value when declared), but only once.Final classes A final class cannot be extended (inherited)Final methods A final method cannot be overridden by subclasses.Above all are correct. Further if you do not want others to create sub classes from your class, then declare your class as final. Then it becomes the leaf level of your class tree hierarchy that no one can extend it further. It is a good practice to avoid huge hierarchy of classes.First of all, the place in your code where you are initializing (i.e. assigning for the first time) foo is here:foo is an object (with type List) so it is a reference type, not a value type (like int). As such, it holds a reference to a memory location (e.g. 0xA7D2A834) where your List elements are stored. Lines like thisdo not change the value of foo (which, again, is just a reference to a memory location). Instead, they just add elements into that referenced memory location. To violate the final keyword, you would have to try to re-assign foo as follows again:That would give you a compilation error.Now, with that out of the way, think about what happens when you add the static keyword. When you do NOT have the static keyword, each object that instantiates the class has its own copy of foo. Therefore, the constructor assigns a value to a blank, fresh copy of the foo variable, which is perfectly fine.However, when you DO have the static keyword, only one foo exists in memory that is associated with the class. If you were to create two or more objects, the constructor would be attempting to re-assign that one foo each time, violating the final keyword.The final keyword in java is used to restrict the user. The java final keyword can be used in many context. Final can be:variable,\nmethod,\nclass,.\nThe final keyword can be applied with the variables, a final variable that have no value it is called blank final variable or uninitialized final variable. It can be initialized in the constructor only. The blank final variable can be static also which will be initialized in the static block only. Java final variableIf you make any variable as final, you cannot change the value of final variable(It will be constant).Example of final variableThere is a final variable speedlimit, we are going to change the value of this variable, but It can\'t be changed because final variable once assigned a value can never be changed.Java final class:If you make any class as final, you cannot extend it.Example of final classJava final method:If you make any method as final, you cannot override it.Example of final method\n(run() in Honda cannot override run() in Bike)shared from:\nhttp://www.javatpoint.com/final-keywordRead all the answers. There is another user case where final keyword can be used i.e. in a method argument:Can be used for variable which should not be changed.