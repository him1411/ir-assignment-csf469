I\'m trying to get an if statement to work in Bash (using Ubuntu):I\'ve tried various forms of the if statement, using [["$s1" == "$s2"]], with and without quotes, using =, == and -eq, but I still get the following error:[hi: command not foundI\'ve looked at various sites and tutorials and copied those, but it doesn\'t work - what am I doing wrong?Eventually, I want to say if $s1 contains $s2, so how can I do that?I did just work out the spaces bit.. :/ How do I say contains?I triedbut it didn\'t work.For string comparison, use:For the a contains b, use:(and make sure to add spaces between the symbols):bad:good:You need spaces:You should be careful to leave a space between the sign of \'[\' and double quotes where the variable contains this:The ^s show the blank spaces you need to leave.I suggest this one:Notice the white space between the openning/closing brackets and the variables and also the white spaces wrapping the \'=\' sign.Also, be careful of your script header. It\'s not the same thing whether you useorHere\'s the source.I would suggest:Without the double quotes and with only one equals.I don\'t have access to a linux box right now, but [ is actually a program (and a bash builtin), so I think you have to put a space between [ and the first parameter.Also note that string equality operator seems to be a single =This question has already great answers but here it appears that there is a slight confusion between using single equal and double equals inThe main difference lies in which scripting language are you using. If you are using bash then include #!/bin/bash in the starting of the script and save your script as filename.bash. To execute use bash filename.bash - then you have to use ==.If you are using sh then use #!/bin/sh and save your script as filename.sh. To execute use sh filename.sh - then you have to use single =. Avoid intermixing them.Adding additional string inside makes it more safe.You could also use other notation for single line commands:For a version with pure Bash and without test, but really ugly, try:Explanation: In ( )an extra subshell is opened. It exits with 0 if there was a match, and it tries to exit with $s1 if there was no match which raises an error (ugly). This error is directed to /dev/null.This is more clarification than answer !\nYes , the clue is in the error message:[hi: command not foundwhich shows you that your "hi" has been concatenated to the "[".Unlike in more traditional programming languages, in Bash, "[" is a command just like the more obvious "ls" etc. - it\'s not treated specially just because it\'s a symbol, hence the "[" and the (substituted) "$s1" which are immediately next to each other in your question, are joined (as is correct for Bash) and it then tries to find a command in that position: [hi - which is unknown to Bash.In C and some other languages, the "[" would be seen as a different "character class" and would be disjoint from the following "hi".Hence you require a space after the opening "[".