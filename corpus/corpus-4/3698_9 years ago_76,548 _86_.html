A y-combinator is a comp-sci concept from the "functional" side of things.  Most programmers don\'t know much at all about them, if they\'ve even heard about them.What is a y-combinator?\nHow do they work?\nWhat are they good for?\nAre they useful in procedural languages?If you\'re ready for a long read, Mike Vanier has a great explanation. Long story short, it allows you to implement recursion in a language that doesn\'t necessarily support it natively.A Y-combinator is a "functional" (a function that operates on other functions) that enables recursion, when you can\'t refer to the function from within itself.  In computer-science theory, it generalizes recursion, abstracting its implementation, and thereby separating it from the actual work of the function in question.  The benefit of not needing a compile-time name for the recursive function is sort of a bonus. =)This is applicable in languages that support lambda functions.  The expression-based nature of lambdas usually means that they cannot refer to themselves by name.  And working around this by way of declaring the variable, refering to it, then assigning the lambda to it, to complete the self-reference loop, is brittle.  The lambda variable can be copied, and the original variable re-assigned, which breaks the self-reference.Y-combinators are cumbersome to implement, and often to use, in static-typed languages (which procedural languages often are), because usually typing restrictions require the number of arguments for the function in question to be known at compile time.  This means that a y-combinator must be written for any argument count that one needs to use.Below is an example of how the usage and working of a Y-Combinator, in C#.Using a Y-combinator involves an "unusual" way of constructing a recursive function.  First you must write your function as a piece of code that calls a pre-existing function, rather than itself:Then you turn that into a function that takes a function to call, and returns a function that does so.  This is called a functional, because it takes one function, and performs an operation with it that results in another function.Now you have a function that takes a function, and returns another function that sort of looks like a factorial, but instead of calling itself, it calls the argument passed into the outer function.  How do you make this the factorial?  Pass the inner function to itself.  The Y-Combinator does that, by being a function with a permanent name, which can introduce the recursion.Rather than the factorial calling itself, what happens is that the factorial calls the factorial generator (returned by the recursive call to Y-Combinator).  And depending on the current value of t the function returned from the generator will either call the generator again, with t - 1, or just return 1, terminating the recursion.It\'s complicated and cryptic, but it all shakes out at run-time, and the key to its working is "deferred execution", and the breaking up of the recursion to span two functions.  The inner F is passed as an argument, to be called in the next iteration, only if necessary.I\'ve lifted this from http://www.mail-archive.com/boston-pm@mail.pm.org/msg02716.html which is an explanation I wrote several years ago.I\'ll use JavaScript in this example, but many other languages will work as well.Our goal is to be able to write a recursive function of 1\nvariable using only functions of 1 variables and no\nassignments, defining things by name, etc.  (Why this is our\ngoal is another question, let\'s just take this as the\nchallenge that we\'re given.)  Seems impossible, huh?  As\nan example, let\'s implement factorial.Well step 1 is to say that we could do this easily if we\ncheated a little.  Using functions of 2 variables and\nassignment we can at least avoid having to use\nassignment to set up the recursion.Now let\'s see if we can cheat less.  Well firstly we\'re using\nassignment, but we don\'t need to.  We can just write X and\nY inline.But we\'re using functions of 2 variables to get a function of 1\nvariable.  Can we fix that?  Well a smart guy by the name of\nHaskell Curry has a neat trick, if you have good higher order\nfunctions then you only need functions of 1 variable.  The\nproof is that you can get from functions of 2 (or more in the\ngeneral case) variables to 1 variable with a purely\nmechanical text transformation like this:where ... remains exactly the same.  (This trick is called\n"currying" after its inventor.  The language Haskell is also\nnamed for Haskell Curry.  File that under useless trivia.)\nNow just apply this transformation everywhere and we get\nour final version.Feel free to try it.  alert() that return, tie it to a button, whatever.\nThat code calculates factorials, recursively, without using\nassignment, declarations, or functions of 2 variables.  (But\ntrying to trace how it works is likely to make your head spin.\nAnd handing it, without the derivation, just slightly reformatted\nwill result in code that is sure to baffle and confuse.)You can replace the 4 lines that recursively define factorial with\nany other recursive function that you want.I wonder if there\'s any use in attempting to build this from the ground up. Let\'s see. Here\'s a basic, recursive factorial function:Let\'s refactor and create a new function called fact that returns an anonymous factorial-computing function instead of performing the calculation itself:That\'s a little weird, but there\'s nothing wrong with it. We\'re just generating a new factorial function at each step. The recursion at this stage is still fairly explicit. The fact function needs to be aware of its own name. Let\'s parameterize the recursive call:That\'s great, but recurser still needs to know its own name. Let\'s parameterize that, too:Now, instead of calling recurser(recurser) directly, let\'s create a wrapper function that returns its result: We can now get rid of the recurser name altogether; it\'s just an argument to Y\'s inner function, which can be replaced with the function itself:The only external name still referenced is fact, but it should be clear by now that that\'s easily parameterized, too, creating the complete, generic, solution:Most of the answers above describe what the Y-combinator is but not what it is for.Fixed point combinators are used to show that lambda calculus is turing complete. This is a very important result in the theory of computation and provides a theoretical foundation for functional programming.Studying fixed point combinators has also helped me really understand functional programming. I have never found any use for them in actual programming though.y-combinator in JavaScript:Edit:\nI learn a lot from looking at code, but this one is a bit tough to swallow without some background - sorry about that. With some general knowledge presented by other answers, you can begin to pick apart what is happening.The Y function is the "y-combinator". Now take a look at the var factorial line where Y is used. Notice you pass a function to it that has a parameter (in this example, recurse) that is also used later on in the inner function. The parameter name basically becomes the name of the inner function allowing it to perform a recursive call (since it uses recurse() in it\'s definition.) The y-combinator performs the magic of associating the otherwise anonymous inner function with the parameter name of the function passed to Y.For the full explanation of how Y does the magic, checked out the linked article (not by me btw.)For programmers who haven\'t encountered functional programming in depth, and don\'t care to start now, but are mildly curious:The Y combinator is a formula which lets you implement recursion in a situation where functions can\'t have names but can be passed around as arguments, used as return values, and defined within other functions.It works by passing the function to itself as an argument, so it can call itself.It\'s part of the lambda calculus, which is really maths but is effectively a programming language, and is pretty fundamental to computer science and especially to functional programming.The day to day practical value of the Y combinator is limited, since programming languages tend to let you name functions.In case you need to identify it in a police lineup, it looks like this:Y = \xce\xbbf.(\xce\xbbx.f (x x)) (\xce\xbbx.f (x x))You can usually spot it because of the repeated (\xce\xbbx.f (x x)).The \xce\xbb symbols are the Greek letter lambda, which gives the lambda calculus its name, and there\'s a lot of (\xce\xbbx.t) style terms because that\'s what the lambda calculus looks like.Other answers provide pretty concise answer to this, without one important fact: You don\'t need to implement fixed point combinator in any practical language in this convoluted way and doing so serves no practical purpose (except "look, I know what Y-combinator is"). It\'s important theoretical concept, but of little practical value.A Y-Combinator is another name for a flux capacitor.Here is a JavaScript implementation of the Y-Combinator and the Factorial function (from Douglas Crockford\'s article, available at: http://javascript.crockford.com/little.html).I have written a sort of "idiots guide" to the Y-Combinator in both Clojure and Scheme in order to help myself come to grips with it. They are influenced by material in "The Little Schemer"In Scheme:\nhttps://gist.github.com/z5h/238891or Clojure:\nhttps://gist.github.com/z5h/5102747Both tutorials are code interspersed with comments and should be cut & pastable into your favourite editor.The y-combinator implements anonymous recursion. So instead ofyou can doof course, the y-combinator only works in call-by-name languages. If you want to use this in any normal call-by-value language, then you will need the related z-combinator (y-combinator will diverge/infinite-loop).A fixed point combinator (or fixed-point operator) is a higher-order function that computes a fixed point of other functions. This operation is relevant in programming language theory because it allows the implementation of recursion in the form of a rewrite rule, without explicit support from the language\'s runtime engine. (src Wikipedia)The this-operator can simplify your life:Then you avoid the extra function:Finally, you call fac(5).As a newbie to combinators, I found Mike Vanier\'s article (thanks Nicholas Mancuso) to be really helpful. I would like to write a summary, besides documenting my understanding, if it could be of help to some others I would be very glad.Using factorial as an example, we use the following almost-factorial function to calculate factorial of number x:In the pseudo-code above, almost-factorial takes in function f and number x (almost-factorial is curried, so it can be seen as taking in function f and returning a 1-arity function).When almost-factorial calculates factorial for x, it delegates the calculation of factorial for x - 1 to function f and accumulates that result with x (in this case, it multiplies the result of (x - 1) with x).It can be seen as almost-factorial takes in a crappy version of factorial function (which can only calculate till number x - 1) and returns a less-crappy version of factorial (which calculates till number x). As in this form:If we repeatedly pass the less-crappy version of factorial to almost-factorial, we will eventually get our desired factorial function f. Where it can be considered as:The fact that almost-factorial f = f means f is the fix-point of function almost-factorial.This was a really interesting way of seeing the relationships of the functions above and it was an aha moment for me. (please read Mike\'s post on fix-point if you haven\'t)To generalize, we have a non-recursive function fn (like our almost-factorial), we have its fix-point function fr (like our f), then what Y does is when you give Y fn, Y returns the fix-point function of fn.So in summary (simplified by assuming fr takes only one parameter; x degenerates to x - 1, x - 2... in recursion):I will skip the derivation of Y and go to understanding Y. Mike Vainer\'s post has a lot of details.Y is defined as (in lambda calculus format):If we replace the variable s in the left of the functions, we getSo indeed, the result of (Y f) is the fix-point of f.Depending the signature of f, (Y f) can be a function of any arity, to simplify, let\'s assume (Y f) only takes one parameter, like our factorial function.since fn fr = fr, we continuethe recursive calculation terminates when the inner-most (fn fr 1) is the base case and fn doesn\'t use fr in the calculation.Looking at Y again:SoTo me, the magical parts of this setup are:It helped me understanding Y this way at the moment, hope it helps.BTW, I also found the book An Introduction to Functional Programming Through Lambda Calculus very good, I\'m only part through it and the fact that I couldn\'t get my head around Y in the book led me to this post.I think the best way to answer this is to pick a language, like JavaScript:Now rewrite it so that it doesn\'t use the name of the function inside the function, but still calls it recursively.The only place the function name factorial should be seen is at the call site.Hint: you can\'t use names of functions, but you can use names of parameters.Work the problem.  Don\'t look it up.   Once you solve it, you will understand what problem the y-combinator solves.