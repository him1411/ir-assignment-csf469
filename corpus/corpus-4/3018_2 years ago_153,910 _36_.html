I\'m trying to find the proper way to define some components which could be used in a generic way:There is a logic going on for rendering between parent and children components of course, you can imagine <select> and <option> as an example of this logic.This is a dummy implementation for the purpose of the question:The question is whenever you use {this.props.children} to define a wrapper component, how do you pass down some property to all its children?You can use React.Children to iterate over the children, and then clone each element with new props (shallow merged) using React.cloneElement e.g:Fiddle: https://jsfiddle.net/wqvmf7or/16/For a slightly cleaner way to do it, try:Try thisIt worked for me using react-15.1.See all other answersKeep reading.React\'s context makes data available / enables dependency injection to all children and subchildren components, here is an exampleDisclaimer: React\'s documentation mentions that context is an experimental API, but it hasn\'t changed for years now. Also, it really is needed in some cases, this is why (one of) the most famous React libraries makes use of it internally - React Router. If you want to go on the super safe side though, you might want to abstract context in some way that fits your needs.I needed to fix accepted answer above to make it work using that instead of this pointer. This within the scope of map function didn\'t have doSomething function defined.Update: this fix is for ECMAScript 5, in ES6 there is no need in var that=thisYou can use React.cloneElement, it\'s better to know how it works before you start using it in your application. It\'s introduced in React v0.13, read on for more information, so something along with this work for you:So bring the lines from React documentiotaion for you to understand how it\'s all working and how you can make use of them:In React v0.13 RC2 we will introduce a new API, similar to\n  React.addons.cloneWithProps, with this signature:Unlike cloneWithProps, this new function does not have any magic\n  built-in behavior for merging style and className for the same reason\n  we don\'t have that feature from transferPropsTo. Nobody is sure what\n  exactly the complete list of magic things are, which makes it\n  difficult to reason about the code and difficult to reuse when style\n  has a different signature (e.g. in the upcoming React Native).React.cloneElement is almost equivalent to:However, unlike JSX and cloneWithProps, it also preserves refs. This\n  means that if you get a child with a ref on it, you won\'t accidentally\n  steal it from your ancestor. You will get the same ref attached to\n  your new element.One common pattern is to map over your children and add a new prop.\n  There were many issues reported about cloneWithProps losing the ref,\n  making it harder to reason about your code. Now following the same\n  pattern with cloneElement will work as expected. For example:Note: React.cloneElement(child, { ref: \'newRef\' }) DOES override the\n  ref so it is still not possible for two parents to have a ref to the\n  same child, unless you use callback-refs.This was a critical feature to get into React 0.13 since props are now\n  immutable. The upgrade path is often to clone the element, but by\n  doing so you might lose the ref. Therefore, we needed a nicer upgrade\n  path here. As we were upgrading callsites at Facebook we realized that\n  we needed this method. We got the same feedback from the community.\n  Therefore we decided to make another RC before the final release to\n  make sure we get this in.We plan to eventually deprecate React.addons.cloneWithProps. We\'re not\n  doing it yet, but this is a good opportunity to start thinking about\n  your own uses and consider using React.cloneElement instead. We\'ll be\n  sure to ship a release with deprecation notices before we actually\n  remove it so no immediate action is necessary.more here...React-router versions 0.x - 3.x were a mess. Version 4 is the complete rewrite the proper way. You no longer need {this.props.children}. Now you can wrap your child component using component or render in Match and pass your props as usual:Cleaner way considering one or more childrenFurther to @and_rest answer, this is how I clone the children and add a class.Is this what you required?  The slickest way to do this:Parent.jsx:Child.jsx:and main.jsx:see example here: https://plnkr.co/edit/jJHQECrKRrtKlKYRpIWl?p=preview