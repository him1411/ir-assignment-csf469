I\'ve heard in a few places that one of the main reasons why distributed version control systems shine, is much better merging than in traditional tools like SVN.\nIs this actually due to inherent differences in how the two systems work, or do specific DVCS implementations like Git/Mercurial just have cleverer merging algorithms than SVN?The claim of why merging is better in a DVCS than in Subversion was largely based on how branching and merge worked in Subversion a while ago. Subversion prior to 1.5.0 didn\'t store any information about when branches were merged, thus when you wanted to merge you had to specify which range of revisions that had to be merged.Ponder this example:When we want to merge b1\'s changes into the trunk we\'d issue the following command, while standing on a folder that has trunk checked out:\xe2\x80\xa6 which will attempt to merge the changes from b1 into your local working directory. And then you commit the changes after you resolve any conflicts and tested the result. When you commit the revision tree would look like this:However this way of specifying ranges of revisions gets quickly out of hand when the version tree grows as subversion didn\'t have any meta data on when and what revisions got merged together. Ponder on what happens later:This is largely an issue by the repository design that Subversion has, in order to create a branch you need to create a new virtual directory in the repository which will house a copy of the trunk but it doesn\'t store any information regarding when and what things got merged back in. That will lead to nasty merge conflicts at times. What was even worse is that Subversion used two-way merging by default, which has some crippling limitations in automatic merging when two branch heads are not compared with their common ancestor.To mitigate this Subversion now stores meta data for branch and merge. That would solve all problems right?On a centralized system, like subversion, virtual directories suck. Why? Because everyone has access to view them\xe2\x80\xa6 even the garbage experimental ones. Branching is good if you want to experiment but you don\'t want to see everyones\' and their aunts experimentation. This is serious cognitive noise. The more branches you add, the more crap you\'ll get to see.The more public branches you have in a repository the harder it will be to keep track of all the different branches. So the question you\'ll have is if the branch is still in development or if it is really dead which is hard to tell in any centralized version control system.Most of the time, from what I\'ve seen, an organization will default to use one big branch anyway. Which is a shame because that in turn will be difficult to keep track of testing and release versions, and whatever else good comes from branching.There is a very simple reason why: branching is a first-class concept. There are no virtual directories by design and branches are hard objects in DVCS which it needs to be such in order to work simply with synchronization of repositories (i.e. push and pull).The first thing you do when you work with a DVCS is to clone repositories (git\'s clone, hg\'s clone and bzr\'s branch). Cloning is conceptually the same thing as creating a branch in version control. Some call this forking or branching (although the latter is often also used to refer to co-located branches), but it\'s just the same thing. Every user runs their own repository which means you have a per-user branching going on.The version structure is not a tree, but rather a graph instead. More specifically a directed acyclic graph (DAG, meaning a graph that doesn\'t have any cycles). You really don\'t need to dwell into the specifics of a DAG other than each commit has one or more parent references (which what the commit was based on). So the following graphs will show the arrows between revisions in reverse because of this.A very simple example of merging would be this; imagine a central repository called origin and a user, Alice, cloning the repository to her machine.What happens during a clone is that every revision is copied to Alice exactly as they were (which is validated by the uniquely identifiable hash-id\'s), and marks where the origin\'s branches are at.Alice then works on her repo, committing in her own repository and decides to push her changes:The solution is rather simple, the only thing that the origin repository needs to do is to take in all the new revisions and move it\'s branch to the newest revision (which git calls "fast-forward"):The use case, which I illustrated above, doesn\'t even need to merge anything. So the issue really isn\'t with merging algorithms since three-way merge algorithm is pretty much the same between all version control systems. The issue is more about structure than anything.Admittedly the above example is a very simple use case, so lets do a much more twisted one albeit a more common one. Remember that origin started out with three revisions? Well, the guy who did them, lets call him Bob, has been working on his own and made a commit on his own repository:Now Bob can\'t push his changes directly to the origin repository. How the system detects this is by checking if Bob\'s revisions directly descents from origin\'s, which in this case doesn\'t. Any attempt to push will result into the system saying something akin to "Uh... I\'m afraid can\'t let you do that Bob."So Bob has to pull-in and then merge the changes (with git\'s pull; or hg\'s pull and merge; or bzr\'s merge). This is a two-step process. First Bob has to fetch the new revisions, which will copy them as they are from the origin repository. We can now see that the graph diverges:The second step of the pull process is to merge the diverging tips and make a commit of the result:Hopefully the merge won\'t run into conflicts (if you anticipate them you can do the two steps manually in git with fetch and merge). What later needs to be done is to push in those changes again to origin, which will result into a fast-forward merge since the merge commit is a direct descendant of the latest in the origin repository:There is another option to merge in git and hg, called rebase, which\'ll move Bob\'s changes to after the newest changes. Since I don\'t want this answer to be any more verbose I\'ll let you read the git, mercurial or bazaar docs about that instead.As an exercise for the reader, try drawing out how it\'ll work out with another user involved. It is similarly done as the example above with Bob. Merging between repositories is easier than what you\'d think because all the revisions/commits are uniquely identifiable.There is also the issue of sending patches between each developer, that was a huge problem in Subversion which is mitigated in git, hg and bzr by uniquely identifiable revisions. Once someone has merged his changes (i.e. made a merge commit) and sends it for everyone else in the team to consume by either pushing to a central repository or sending patches then they don\'t have to worry about the merge, because it already happened. Martin Fowler calls this way of working promiscuous integration.Because the structure is different from Subversion, by instead employing a DAG, it enables branching and merging to be done in an easier manner not only for the system but for the user as well.Historically, Subversion has only been able to perform a straight two-way merge because it\'s didn\'t store any merge information.  This involves taking a set of changes and applying them to a tree.  Even with merge information, this is still the most commonly-used merge strategy.Git uses a 3-way merge algorithm by default, which involves finding a common ancestor to the heads being merged and making use of the knowledge that exists on both sides of the merge.  This allows Git to be more intelligent in avoiding conflicts.Git also has some sophisticated rename finding code, which also helps.  It doesn\'t store changesets or store any tracking information -- it just stores the state of the files at each commit and uses heuristics to locate renames and code movements as required (the on-disk storage is more complicated than this, but the interface it presents to the logic layer exposes no tracking).Put simply, the merge implementation is done better in Git than in SVN. Before 1.5 SVN did not record a merge action, so it was incapable to do future merges without help by the user which needed to provide information that SVN did not record. With 1.5 it got better, and indeed the SVN storage model is slightly more capable that Git\'s DAG. But SVN stored the merge information in a rather convoluted form that lets merges take massively more time than in Git - I\'ve observed factors of 300 in execution time.Also, SVN claims to track renames to aid merges of moved files. But actually it still stores them as a copy and a separate delete action, and the merge algorithm still stumbles over them in modify/rename situations, that is, where a file is modified on one branch and rename on the other, and those branches are to be merged. Such situations will still produce spurious merge conflicts, and in the case of directory renames it even leads to silent loss of modifications. (The SVN people then tend to point out that the modifications are still in the history, but that doesn\'t help much when they aren\'t in a merge result where they should appear.Git, on the other hand, does not even track renames but figures them out after the fact (at merge time), and does so pretty magically.The SVN merge representation also has issues; in 1.5/1.6 you could merge from trunk to branch as often as just liked, automatically, but a merge in the other direction needed to be announced (--reintegrate), and left the branch in an unusable state. Much later they found out that this actually isn\'t the case, and that a) the --reintegrate can be figured out automatically, and b) repeated merges in both directions are possible.But after all this (which IMHO shows a lack of understanding of what they are doing), I\'d be (OK, I am) very cautions to use SVN in any nontrivial branching scenario, and would ideally try to see what Git thinks of the merge result.Other points made in the answers, as the forced global visibility of branches in SVN, aren\'t relevant to merge capabilities (but for usability). Also, the \'Git stores changes while SVN stores (something different)\' are mostly off the point. Git conceptually stores each commit as a separate tree (like a tar file), and then uses quite some heuristics to store that efficiently. Computing the changes between two commits is separate from the storage implementation. What is true is that Git stores the history DAG in a much more straightforward form that SVN does its mergeinfo. Anyone trying to understand the latter will know what I mean.In a nutshell: Git uses a much simpler data model to store revisions than SVN, and thus it could put a lot of energy into the actual merge algorithms rather than trying to cope with the representation => practically better merging.I read the accepted answer. It\'s just plain wrong.SVN merging can be a pain, and it can also be cumbersome. But, ignore how it actually works for a minute. There is no information that Git keeps or can derive that SVN doesn\'t also keep or can derive. More importantly, there is no reason why keeping separate (sometimes partial) copies of the version control system will provide you with more actual information. The two structures are completely equivalent. Assume you want to do "some clever thing" Git is "better at". And you\'re thing is checked into SVN.Convert your SVN into the equivalent Git form, do it in Git, and then check the result in, perhaps using multiple commits, some extra branches. If you can imagine an automated way to turn an SVN problem into a Git problem, then Git has no fundamental advantage.At the end of the day, any version control system will let meAdditionally, for merging it\'s also useful (or critical) to knowMercurial, Git and Subversion (now natively, previously using svnmerge.py) can all provide all three pieces of information. In order to demonstrate something fundamentally better with DVC, please point out some fourth piece of information which is available in Git/Mercurial/DVC not available in SVN / centralized VC.That\'s not to say they\'re not better tools!One thing that hasn\'t been mentioned in the other answers, and that really is a big advantage of a DVCS, is that you can commit locally before you push your changes. In SVN, when I had some change I wanted to check in, and someone had already done a commit on the same branch in the meantime, this meant that I had to do an svn update before I could commit. This means that my changes, and the changes from the other person are now mixed together, and there is no way to abort the merge (like with git reset or hg update -C), because there is no commit to go back to. If the merge is non-trivial,this means that you can\'t continue to work on your feature before you have cleaned up the merge result.But then, maybe that is only an advantage for people who are too dumb to use separate branches (if I remember correctly, we had only one branch that was used for development back in the company where I used SVN).SVN tracks files while Git tracks content changes. It is clever enough to track a block of code that was refactored from one class/file to another. They use two complete different approaches to tracking your source.I still use SVN heavily, but I am very pleased with the few times I\'ve used Git.A nice read if you have the time: Why I chose GitJust read an article on Joel\'s blog(sadly his last one). This one is about Mercurial, but it actually talks about advantages of Distributed VC systems such as Git.With distributed version control, the\n  distributed part is actually not the\n  most interesting part. The interesting part is that these systems think in terms of changes, not in terms of versions.Read the article here.