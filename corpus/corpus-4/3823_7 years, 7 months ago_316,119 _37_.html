I receive following error when I save the object using Hibernate object references an unsaved transient\n  instance - save the transient instance\n  before flushingYou should include cascade="all" (if using xml) or cascade=CascadeType.ALL (if using annotations) on your collection mapping.This happens because you have a collection in your entity, and that collection has one or more items which are not present in the database. By specifying the above options you tell hibernate to save them to the database when saving their parent.I believe this might be just repeat answer, but just to clarify, I got this on a @OneToOne mapping as well as a @OneToMany.  In both cases, it was the fact that the Child object I was adding to the Parent wasn\'t saved in the database yet.  So when I added the Child to the Parent, then saved the Parent, Hibernate would toss the "object references an unsaved transient instance - save the transient instance before flushing" message when saving the Parent.Adding in the cascade = {CascadeType.ALL} on the Parent\'s reference to the Child solved the problem in both cases.  This saved the Child and the Parent.Sorry for any repeat answers, just wanted to further clarify for folks.This happens when saving an object when Hibernate thinks it needs to save an object that is associated with the one you are saving. I had this problem and did not want to save changes to the referenced object so I wanted the cascade type to be NONE. The trick is to ensure that the ID and VERSION in the referenced object is set so that Hibernate does not think that the referenced object is a new object that needs saving. This worked for me.Look through all of the relationships in the class you are saving to work out the associated objects (and the associated objects of the associated objects) and ensure that the ID and VERSION is set in all objects of the object tree.Or, if you want to use minimal "powers" (e.g. if you don\'t want a cascade delete) to achieve what you want, use This occurred for me when persisting an entity in which the existing record in the database had a NULL value for the field annotated with @Version (for optimistic locking). Updating the NULL value to 0 in the database corrected this.This isn\'t the only reason for the error. I encountered it just now for a typo error in my coding, which I believe, set a value of an entity which was already saved.I spotted the error by finding exactly which variable caused the error (in this case String xid). I used a catch around the whole block of code that saved the entity and printed the traces.In my case it was caused by not having CascadeType on the @ManyToOne side of the bidirectional relationship. To be more precise, I had CascadeType.ALL on @OneToMany side and did not have it on @ManyToOne. Adding CascadeType.ALL to @ManyToOne resolved the issue.\nOne-to-many side:Many-to-one side (caused the problem)Many-to-one (fixed by adding CascadeType.PERSIST)If your collection is nullable just try: object.SetYouColection(null);To add my 2 cents, I got this same issue when I m accidentally sending null as the ID. Below code depicts my scenario (and OP didn\'t mention any specific scenario).Here I m setting the existing department id to a new employee instance without actually getting the department entity first, as I don\'t want to another select query to fire.In some scenarios, deptId PKID is coming as null from calling method and I m getting the same error. So, watch for null values for PK IDi get this error when i use but it works with no problem when I use beside all other good answers, this could happen if you use merge to persist an object and accidentally forget to use merged reference of the object in the parent class. consider the following exampleIn this case, you merge A but forget to use merged object of A. to solve the problem you must rewrite the code like this.One other possible reason: in my case, I was attempting to save the child before saving the parent, on a brand new entity.The code was something like this in a User.java model:The setNewPassword() method creates a PasswordHistory record and adds it to the history collection in User. Since the create() statement hadn\'t been executed yet for the parent, it was trying to save to a collection of an entity that hadn\'t yet been created. All I had to do to fix it was to move the setNewPassword() call after the call to create().Simple way of solving this issue is save the both entity.\nfirst save the child entity and then save the parent  entity.\nBecause parent entity is depend on child entity for the foreign key value.Below simple exam of one to one relationshipThere is another possibility that can cause this error in hibernate. You may set an unsaved reference of your object A to an attached entity B and want to persist object C. Even in this case, you will get the aforementioned error.Don\'t use Cascade.All until you really have to. Role and Permission have bidirectional manyToMany relation. Then the following code would work fine  while if the object is just a "new" one, then it would throw the same error.One possible cause of the error is the inexistence of the setting of the value of the parent entity ; for example for a department-employees relationship you have to write this in order to fix the error :There are so many possibilities of this error some other possibilities are   also on add page or edit page. In my case I was trying to save a object AdvanceSalary. The problem is that in edit the AdvanceSalary employee.employee_id is null Because on edit I was not set the employee.employee_id. I have make a hidden field and set it. my code working absolutely fine.