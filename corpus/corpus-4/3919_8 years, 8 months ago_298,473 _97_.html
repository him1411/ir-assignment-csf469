I wish to have long and short forms of command line options invoked using my shell script.I know that getopts can be used, but like in Perl, I have not been able to do the same with shell.Any ideas on how this can be done, so that I can use options like:In the above, both the commands mean the same thing to my shell, but using getopts, I have not been able to implement these?The bash getopts builtin does not support long option names with the double-dash prefix.  It only supports single-character options.There is a shell tool getopt which is another program, not a bash builtin.  The GNU implementation of getopt(3) (used by the command-line getopt(1) on Linux) supports parsing long options.  But the BSD implementation of getopt (e.g. on Mac OS X) does not.getopt and getopts are different beasts, and people seem to have a bit of misunderstanding of what they do.  getopts is a built-in command to bash to process command-line options in a loop and assign each found option and value in turn to built-in variables, so you can further process them.  getopt, however, is an external utility program, and it doesn\'t actually process your options for you the way that e.g. bash getopts, the Perl Getopt module or the Python optparse/argparse modules do.  All that getopt does is canonicalize the options that are passed in \xe2\x80\x94 i.e. convert them to a more standard form, so that it\'s easier for a shell script to process them.  For example, an application of getopt might convert the following:into this:You have to do the actual processing yourself.  You don\'t have to use getopt at all if you make various restrictions on the way you can specify options: Why use getopt instead of getopts?  The basic reason is that only GNU getopt gives you support for long-named command-line options.1 (GNU getopt is the default on Linux. Mac OS X and FreeBSD come with a basic and not-very-useful getopt, but the GNU version can be installed; see below.)For example, here\'s an example of using GNU getopt, from a script of mine called javawrap:This lets you specify options like --verbose -dm4096 --minh=20 --maxhe 40 --debugfi="/Users/John Johnson/debug.txt" or similar.  The effect of the call to getopt is to canonicalize the options to --verbose -d -m 4096 --minheap 20 --maxheap 40 --debugfile "/Users/John Johnson/debug.txt" so that you can more easily process them.  The quoting around "$1" and "$2" is important as it ensures that arguments with spaces in them get handled properly.If you delete the first 9 lines (everything up through the eval set line), the code will still work!  However, your code will be much pickier in what sorts of options it accepts: In particular, you\'ll have to specify all options in the "canonical" form described above.  With the use of getopt, however, you can group single-letter options, use shorter non-ambiguous forms of long-options, use either the --file foo.txt or --file=foo.txt style, use either the -m 4096 or -m4096 style, mix options and non-options in any order, etc.  getopt also outputs an error message if unrecognized or ambiguous options are found.NOTE: There are actually two totally different versions of getopt, basic getopt and GNU getopt, with different features and different calling conventions.2 Basic getopt is quite broken: Not only does it not handle long options, it also can\'t even handle embedded spaces inside of arguments or empty arguments, whereas getopts does do this right. The above code will not work in basic getopt. GNU getopt is installed by default on Linux, but on Mac OS X and FreeBSD it needs to be installed separately. On Mac OS X, install MacPorts (http://www.macports.org) and then do sudo port install getopt to install GNU getopt (usually into /opt/local/bin), and make sure that /opt/local/bin is in your shell path ahead of /usr/bin. On FreeBSD, install misc/getopt.A quick guide to modifying the example code for your own program: Of the first few lines, all is "boilerplate" that should stay the same, except the line that calls getopt.  You should change the program name after -n, specify short options after -o, and long options after --long.  Put a colon after options that take a value.Finally, if you see code that has just set instead of eval set, it was written for BSD getopt. You should change it to use the eval set style, which works fine with both versions of getopt, while the plain set doesn\'t work right with GNU getopt.1Actually, getopts in ksh93 supports long-named options, but this shell isn\'t used as often as bash. In zsh, use zparseopts to get this functionality.2Technically, "GNU getopt" is a misnomer; this version was actually written for Linux rather than the GNU project. However, it follows all the GNU conventions, and the term "GNU getopt" is commonly used (e.g. on FreeBSD).The built-in getopts command is still, AFAIK, limited to single-character options only.There is (or used to be) an external program getopt that would reorganize a set of options such that it was easier to parse.  You could adapt that design to handle long options too.  Example usage:You could use a similar scheme with a getoptlong command.Note that the fundamental weakness with the external getopt program is the difficulty of handling arguments with spaces in them, and in preserving those spaces accurately.  This is why the built-in getopts is superior, albeit limited by the fact it only handles single-letter options.The Bash builtin getopts function can be used to parse long options by putting a dash character followed by a colon into the optspec:After copying to executable file name=getopts_test.sh in the current working directory, one can produce output likeObviously getopts neither performs OPTERR checking nor option-argument parsing for the long options. The script fragment above shows how this may be done manually. The basic principle also works in the Debian Almquist shell ("dash"). Note the special case:Note that, as GreyCat from over at http://mywiki.wooledge.org/BashFAQ points out, this trick exploits a non-standard behaviour of the shell which permits the option-argument (i.e. the filename in "-f filename") to be concatenated to the option (as in "-ffilename"). The POSIX standard says there must be a space between them, which in the case of "-- longoption" would terminate the option-parsing and turn all longoptions into non-option arguments.Here\'s an example that actually uses getopt with long options:Take a look at shFlags which is a portable shell library (meaning: sh, bash, dash, ksh, zsh on Linux, Solaris, etc.).It makes adding new flags as simple as adding one line to your script, and it provides an auto generated usage function.Here is a simple Hello, world! using shFlag:For OSes that have the enhanced getopt that supports long options (e.g. Linux), you can do:For the rest, you must use the short option:Adding a new flag is as simple as adding a new DEFINE_ call.Long options can be parsed by the standard getopts builtin as \xe2\x80\x9carguments\xe2\x80\x9d to the - \xe2\x80\x9coption\xe2\x80\x9dThis is portable and native POSIX shell \xe2\x80\x93 no external programs or bashisms are needed.This guide implements long options as arguments to the - option, so --alpha is seen by getopts as - with argument alpha and --bravo=foo is seen as - with argument bravo=foo.  The true argument can be harvested with a simple replacement: ${OPTARG#*=}.In this example, -b (and its long form, --bravo) has a mandatory option (note the manual reconstruction of enforcing that for the long form).  Non-boolean options to long arguments come after equals signs, e.g. --bravo=foo (space delimiters for long options would be hard to implement).Because this uses getopts, this solution supports usage like cmd -ac --bravo=foo -d FILE (which has combined options -a and -c and interleaves long options with standard options) while most other answers here either struggle or fail to do that.When the argument is a dash (-), it has two more components:  the flag name and (optionally) its argument.  I delimit these the standard way any command would, with the first equals sign (=).  $LONG_OPTARG is therefore merely the content of $OPTARG without the flag name or equals sign.The inner case implements long options manually, so it needs some housekeeping:You don\'t necessarily need all of those housekeeping items.  For example, perhaps you want --bravo to have an optional argument (which -b can\'t support due to a limitation in getopts).  Merely remove the =? and the related failure case and then call ${ARG_B:=$DEFAULT_ARG_B} the first time you use $ARG_B.I kind of solved this way:Am I being dumb or something? getopt and getopts are so confusing.Another way...In case you don\'t want the getopt dependency, you can do this:Of course, then you can\'t use long style options with one dash. And if you want to add shortened versions (e.g. --verbos instead of --verbose), then you need to add those manually.But if you are looking to get getopts functionality along with long options, this is a simple way to do it.I also put this snippet in a gist. The built-in getopts can\'t do this.  There is an external getopt(1) program that can do this, but you only get it on Linux from the util-linux package. It comes with an example script getopt-parse.bash.There is also a getopts_long written as a shell function. .In ksh93, getopts does support long names...Or so the tutorials I have found have said.  Try it and see.Inventing yet another version of the wheel...This function is a (hopefully) POSIX-compatible plain bourne shell replacement for GNU getopt. It supports short/long options which can accept mandatory/optional/no arguments, and the way in which options are specified is almost identical to GNU getopt, so conversion is trivial.Of course this is still a sizeable chunk of code to drop into a script, but it\'s about half the lines of the well-known getopt_long shell function, and might be preferable in cases where you just want to replace existing GNU getopt uses.This is pretty new code, so YMMV (and definitely please let me know if this isn\'t actually POSIX-compatible for any reason -- portability was the intention from the outset, but I don\'t have a useful POSIX test environment).Code and example usage follows:Example usage:Here you can find a few different approaches for complex option parsing in bash:\nhttp://mywiki.wooledge.org/ComplexOptionParsingI did create the following one, and I think it\'s a good one, because it\'s minimal code\nand both long and short options work. A long option can also have multiple arguments with this approach.I have been working on that subject for quite a long time... and made my own library which you will need to source in your main script.\nSee libopt4shell and cd2mpc for an example.\nHope it helps !An improved solution:Maybe it\'s simpler to use ksh, just for the getopts part, if need long command line options, as it can be easier done there.I wanted something without external dependencies, with strict bash support (-u), and I needed it to work on even the older bash versions. This handles various types of params:Just insert the following at the top of your script:And use it like so:I don\'t have enough rep yet to comment or vote his solution up, but sme\'s answer worked extremely well for me. The only issue I ran into was that the arguments end up wrapped in single-quotes (so I have an strip them out).I also added some example usages and HELP text.  I\'ll included my slightly extended version here:In order to stay cross-platform compatible, and avoid the reliance on external executables, I ported some code from another language.I find it very easy to use, here is an example:The required BASH is a little longer than it could be, but I wanted to avoid reliance on BASH 4\'s associative arrays.  You can also download this directly from http://nt4.com/bash/argparser.inc.shIf all your long options have unique, and matching, first characters as the short options, so for exampleIs the same asYou can use this before getopts to rewrite $args:Thanks for mtvee for the inspiration ;-)Builtin getopts only parse short options (except in ksh93),\nbut you can still add few lines of scripting to make getopts handles long options.Here is a part of code found in http://www.uxora.com/unix/shell-script/22-handle-long-options-with-getoptsHere is a test:Otherwise in recent Korn Shell ksh93, getopts can naturally parse long options and even display a man page alike. (See http://www.uxora.com/unix/shell-script/20-getopts-with-man-page-and-long-options)Th built-in OS X (BSD) getopt does not support long options, but the GNU version does: brew install gnu-getopt.  Then, something similar to: cp /usr/local/Cellar/gnu-getopt/1.1.6/bin/getopt /usr/local/bin/gnu-getopt.EasyOptions handles short and long options:getopts "could be used" for parsing long options as long as you don\'t expect them to have arguments...Here\'s how to:If you try to use OPTIND for getting a parameter for the long option, getopts will treat it as the first no optional positional parameter and will stop parsing any other parameters. \nIn such a case you\'ll be better off handling it manually with a simple case statement.This will "always" work:Albeit is not as flexible as getopts and you have to do much of the error checking code yourself within the case instances...But it is an option.hm.not really satisfied with the pure bash options. why not use perl to get what you want. Directly parse the $* array, and auto-name your options.simple helper script:then you can use in your script as a one liner, for example:/tmp/script.sh hello --reuse me --long_opt whatever_you_want_except_spaces --hello 1 2 3HELLO: 1\nLONG_OPT: whatever_you_want_except spaces\nREUSE: me1 2 3Only caveat here is spaces don\'t work. But it avoids bash\'s rather complicated looping syntax, works with long args, auto-names them as variables and automatically resizes $*, so will work 99% of the time.