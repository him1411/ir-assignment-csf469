I want to kill a whole process tree.  What is the best way to do this using any common scripting languages? I am looking for a simple solution.You don\'t say if the tree you want to kill is a single process group.  (This is often the case if the tree is the result of forking from a server start or a shell command line.)  You can discover process groups using GNU ps as follows:If it is a process group you want to kill, just use the kill(1) command but instead of giving it a process number, give it the negation of the group number.  For example to kill every process in group 5112, use kill -TERM -- -5112.Kill all the processes belonging to the same process tree using the Process Group ID (PGID)You can retrieve the PGID from any Process-ID (PID) of the same process treeSpecial thanks to tanager and Speakus for contributions on $PID remaining spaces and OSX compatibility.Run the process tree in background using \'&\'The command pkill -P $PID does not kill the grandchild:The command kill -- -$PGID kills all processes including the grandchild.I notice in this example PID and PGID are equal (28957). \nThis is why I originally thought kill -- -$PID was enough. But in the case the process is spawn within a Makefile the Process ID is different from the Group ID. I think kill -- -$(ps -o pgid= $PID | grep -o [0-9]*) is the best simple trick to kill a whole process tree when called from a different Group ID (another process tree).This will kill all processes that have the parent process ID 27888.Or more robust:which schedule killing 33 second later and politely ask processes to terminate.See this answer for terminating all descendants.To kill a process tree recursively, use killtree():brad\'s answer is what I\'d recommend too, except that you can do away with awk altogether if you use the --ppid option to ps.if you know pass the pid of the parent process, here\'s a shell script that should work:I use a little bit modified version of a method described here:\nhttps://stackoverflow.com/a/5311362/563175So it looks like that:where 24901 is parent\'s PID.It looks pretty ugly but does it\'s job perfectly.Modified version of zhigang\'s answer:To add to Norman Ramsey\'s answer, it may be worth looking at at setsid if you want to create a process group.\nhttp://pubs.opengroup.org/onlinepubs/009695399/functions/setsid.htmlThe setsid() function shall create a\n  new session, if the calling process is\n  not a process group leader. Upon\n  return the calling process shall be\n  the session leader of this new\n  session, shall be the process group\n  leader of a new process group, and\n  shall have no controlling terminal.\n  The process group ID of the calling\n  process shall be set equal to the\n  process ID of the calling process. The\n  calling process shall be the only\n  process in the new process group and\n  the only process in the new session.Which I take to mean that you can create a group from the starting process.  I used this in php in order to be able to kill a whole process tree after starting it.  This may be a bad idea.  I\'d be interested in comments.  I can\'t comment (not enough reputation), so I am forced to add a new answer, even though this is not really an answer.There is a slight problem with the otherwise very nice and thorough answer given by @olibre on Feb 28.  The output of ps opgid= $PID will contain leading spaces for a PID shorter than five digits because ps is justifying the column (rigth align the numbers).  Within the entire command line, this results in a negative sign, followed by space(s), followed by the group PID.  Simple solution is to pipe ps to tr to remove spaces:Inspired by ysth\xe2\x80\x99s commentinstead of giving it a process number, give it the negation of the group\n  number. As usual with almost any command, if you want a normal argument that\n  starts with a - to not be interpreted as a switch, precede it with --rkill command from pslist package sends given signal (or SIGTERM by default) to specified process and all its descendants:The following shell function is similar to many of the other answers, but it works both on Linux and BSD (OS X, etc) without external dependencies like pgrep:It\'s super easy to do this with python using psutil. Just install psutil with pip and then you have a full suite of process manipulation tools:Based on zhigang\'s answer, this avoids self-killing:This is my version of killing all the child processes using bash script.\nIt does not use recursion and depends on pgrep command.Use Contents of killtrees.shIf you want to kill a process by name:orHere is a variation of @zhigang\'s answer which does without AWK, relying only on Bash\'s native parsing possibilities:It seems to work fine on both Macs and Linux. In situations where you can\'t rely on being able  to manage process groups -- like when writing scripts for testing a piece of software which must be built in multiple environments -- this tree-walking technique is definitely helpful.It is probably better to kill the parent before the children; otherwise the parent may likely spawn new children again before he is killed himself. These will survive the killing.My version of ps is different from that above; maybe too old, therefore the strange grepping...To use a shell script instead of a shell function has many advantages...However, it is basically zhigangs ideaThe following has been tested on FreeBSD, Linux and MacOS X and only depends on pgrep and kill (the ps -o versions don\'t work under BSD). First argument is parent pid of which children have to be terminated. second argument is a boolean to determine whether the parent pid has to be terminated too.This will send SIGTERM to any child / grandchild process within a shell script and if SIGTERM doesn\'t succeed, it will wait 10 seconds and then send kill.Earlier answer:The following also works but will kill the shell itself on BSD.I develop the solution of zhigang, xyuri and solidsneck further:This version will avoid killing its ancestry - which causes a flood of child processes in the previous solutions.Processes are properly stopped before the child list is determined, so that no new children are created or disappear.After being killed, the stopped jobs have to be continued to disappear from the system. Thanks for your wisdom, folks. My script was leaving some child processes on exit and the negation tip made things easier. I wrote this function to be used in other scripts if necessary:Cheers.if you have pstree and perl on your system, you can try this:If you know the pid of the thing you want to kill, you can usually go from the session id, and everything in the same session. I\'d double check, but I used this for scripts starting rsyncs in loops that I want to die, and not start another (because of the loop) as it would if I\'d just killall\'d rsync.If you don\'t know the pid you can still nest moreKilling child process in shell script:Many time we need to kill child process which are hanged or block for some reason. eg. FTP connection issue.There are two approaches,1) To create separate new parent for each child which will monitor and kill child process once timeout reached.Create test.sh as follows,and watch processes which are having name as \'test\' in other terminal using following command.Above script will create 4 new child processes and their parents. Each child process will run for 10sec. But once timeout of 5sec reach, thier respective parent processes will kill those childs.\nSo child won\'t be able to complete execution(10sec). \nPlay around those timings(switch 10 and 5) to see another behaviour. In that case child will finish execution in 5sec before it reaches timeout of 10sec.2) Let the current parent monitor and kill child process once timeout reached. This won\'t create separate parent to monitor each child. Also you can manage all child processes properly within same parent.Create test.sh as follows,and watch processes which are having name as \'test\' in other terminal using following command.Above script will create 4 new child processes. We are storing pids of all child process and looping over them to check if they are finished their execution or still running.\nChild process will execution till CMD_TIME time. But if CNT_TIME_OUT timeout reach , All children will get killed by parent process.\nYou can switch timing and play around with script to see behavior.\nOne drawback of this approach is , it is using group id for killing all child tree. But parent process itself belong to same group so it will also get killed.You may need to assign other group id to parent process if you don\xe2\x80\x99t want parent to be killed.More details can be found here,Killing child process in shell scriptThis script also work:#/bin/sh\nwhile true\ndo\n  echo "Enter parent process id  [type quit for exit]"\n  read ppid\n  if [ $ppid -eq "quit" -o $ppid -eq "QUIT" ];then\n     exit 0\n  fi\n  for i in `ps -ef| awk \'$3 == \'$ppid\' { print $2 }\'`\n     do\n       echo killing $i\n       kill $i\n     done\ndone\nIn sh the jobs command will list the background processes. In some cases it might be better to kill the newest process first, e.g. the older one created a shared socket. In those cases sort the PIDs in reverse order. Sometimes you want to wait moment for the jobs to write something on disk or stuff like that before they stop.And don\'t kill if you don\'t have to!type ps -ef check the process id.\nKill the process by typing kill -9 <pid>