What are the differences between #import and #include in Objective-C and are there times where you should use one over the other? Is one deprecated?I was reading the following tutorial: http://www.otierney.net/objective-c.html#preamble and its paragraph about #import and #include seems to contradict itself or at least is unclear.The #import directive was added to Objective-C as an improved version of #include. Whether or not it\'s improved, however, is still a matter of debate. #import ensures that a file is only ever included once so that you never have a problem with recursive includes. However, most decent header files protect themselves against this anyway, so it\'s not really that much of a benefit.Basically, it\'s up to you to decide which you want to use. I tend to #import headers for Objective-C things (like class definitions and such) and #include standard C stuff that I need. For example, one of my source files might look like this:There seems to be a lot of confusion regarding the preprocessor.What the compiler does when it sees a #include that it replaces that line with the contents of the included files, no questions asked.So if you have a file a.h with this contents:and a file b.c with this content:the file b.c will be translated by the preprocessor before compilation towhich will result in a compiler error, since the type my_number is defined twice. Even though the definition is the same this is not allowed by the C language.Since a header often is used in more than one place include guards usually are used in C. This looks like this:The file b.c still would have the whole contents of the header in it twice after being preprocessed. But the second instance would be ignored since the macro _a_h_included_ would already have been defined.This works really well, but has two drawbacks. First of all the include guards have to be written, and the macro name has to be different in every header. And secondly the compiler has still to look for the header file and read it as often as it is included.Objective-C has the #import preprocessor instruction (it also can be used for C and C++ code with some compilers and options). This does almost the same as #include, but it also notes internally which file has already been included. The #import line is only replaced by the contents of the named file for the first time it is encountered. Every time after that it is just ignored. I agree with Jason.I got caught out doing this:For GNU gcc, it kept complaining that time() function was\nnot defined.So then I changed #import to #include and all went ok.Reason: You #import <sys/time.h>:\n    <sys/time.h> includes only a part of <time.h> by using #definesYou #import <time.h>:\n    No go. Even though only part of <time.h> was already included, as\n    far as #import is concerned, that file is now already completely included.Bottom line:C/C++ headers traditionally includes parts of other include files.\nSo for C/C++ headers, use #include.\nFor objc/objc++ headers, use #import.#include works just like the C #include.#import keeps track of which headers have already been included and is ignored if a header is imported more than once in a compilation unit. This makes it unnecessary to use header guards.The bottom line is just use #import in Objective-C and don\'t worry if your headers wind up importing something more than once.I know this thread is old... but in "modern times".. there is a far superior "include strategy" via clang\'s @import modules - that is oft-overlooked..Modules improve access to the API of software libraries by replacing the textual preprocessor inclusion model with a more robust, more efficient semantic model. From the user\xe2\x80\x99s perspective, the code looks only slightly different, because one uses an import declaration rather than a #include preprocessor directive:or However, this module import behaves quite differently from the corresponding #include: when the compiler sees the module import above, it loads a binary representation of the module and makes its API available to the application directly. Preprocessor definitions that precede the import declaration have no impact on the API provided... because the module itself was compiled as a separate, standalone module. Additionally, any linker flags required to use the module will automatically be provided when the module is imported. This semantic import model addresses many of the problems of the preprocessor inclusion model.To enable modules, pass the command-line flag -fmodules aka CLANG_ENABLE_MODULES in Xcode- at compile time.  As mentioned above.. this strategy obviates ANY and ALL LDFLAGS.  As in, you can REMOVE any "OTHER_LDFLAGS" settings, as well as any "Linking" phases..I find compile / launch times to "feel" much snappier (or possibly, there\'s just less of a lag while "linking"?).. and also, provides a great opportunity to purge the now extraneous Project-Prefix.pch file, and corresponding build settings, GCC_INCREASE_PRECOMPILED_HEADER_SHARING, GCC_PRECOMPILE_PREFIX_HEADER, and GCC_PREFIX_HEADER, etc.Also, while not well-documented\xe2\x80\xa6 You can create module.maps for your own frameworks and include them in the same convenient fashion.  You can take a look at my ObjC-Clang-Modules github repo for some examples of how to implement such miracles.If you are familiar with C++ and macros, thenis similar towhich means that your Class will be loaded only once when your app runs.IF you #include a file two times in .h files  than compiler will give error.\nBut if you #import a file more than once compiler will ignore it.In may case I had a global variable in one of my .h files that was causing the problem, and I solved it by adding extern in front of it.#include it used to get "things" from another file to the one the #include is used in.\nEx:in file: main.cppHeader guard is used on the top of each header file (*.h) to prevent including the same file more then once (if it happens you will get compile errors).in file: otherfile.heven if you put #include "otherfile.h" n time in your code, this inside it will not be redeclared.