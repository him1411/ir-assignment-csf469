Occasionally I have a need to retry an operation several times before giving up.  My code is like:I would like to rewrite this in a general retry function like:Is it possible in C#?  What would be the code for the TryThreeTimes() method?Blanket catch statements that simply retry the same call can be dangerous if used as a general exception handling mechanism. Having said that, here\'s a lambda-based retry wrapper that you can use with any method. I chose to factor the number of retries and the retry timeout out as parameters for a bit more flexibility:You can now use this utility method to perform retry logic:or:or:Or you could even make an async overload.You should try Polly. It\'s a .NET library written by me that allows developers to express transient exception handling policies such as Retry, Retry Forever, Wait and Retry or Circuit Breaker in a fluent manner.This is possibly a bad idea. First, it is emblematic of the maxim "the definition of insanity is doing the same thing twice and expecting different results each time". Second, this coding pattern does not compose well with itself. For example:Suppose your network hardware layer resends a packet three times on failure, waiting, say, a second between failures. Now suppose the software layer resends an notification about a failure three times on packet failure.Now suppose the notification layer reactivates the notification three times on an notification delivery failure.Now suppose the error reporting layer reactivates the notification layer three times on a notification failure.And now suppose the web server reactivates the error reporting three times on error failure.And now suppose the web client resends the request three times upon getting an error from the server.Now suppose the line on the network switch that is supposed to route the notification to the administrator is unplugged. When does the user of the web client finally get their error message?  I make it at about twelve minutes later. Lest you think this is just a silly example: we have seen this bug in customer code, though far, far worse than I\'ve described here. In the particular customer code, the gap between the error condition happening and it finally being reported to the user was several weeks because so many layers were automatically retrying with waits. Just imagine what would happen if there were ten retries instead of three.Usually the right thing to do with an error condition is report it immediately and let the user decide what to do.  If the user wants to create a policy of automatic retries, let them create that policy at the appropriate level in the software abstraction.The Transient Fault Handling Application Block provides an extensible collection of retry strategies including:It also includes a collection of error detection strategies for cloud-based services.For more information see this chapter of the Developer\'s Guide.Available via NuGet (search for \'topaz\').Then you would call:...or alternatively...A more flexible option:To be used as:Allowing for functions and retry messagesYou might also consider adding the exception type you want to retry for.  For instance is this a timeout exception you want to retry?  A database exception?You might also note that all of the other examples have a similar issue with testing for retries == 0 and either retry infinity or fail to raise exceptions when given a negative value.  Also Sleep(-1000) will fail in the catch blocks above.  Depends on how \'silly\' you expect people to be but defensive programming never hurts.I\'m a fan of recursion and extension methods, so here are my two cents:Building on the previous work, I thought about enhancing the retry logic in three ways:Making it an Action extension methodThe method can then be invoked like so (anonymous methods can be used as well, of course):I\'d implement this:I wouldn\'t use exceptions the way they\'re used in the other examples.  It seems to me that if we\'re expecting the possibility that a method won\'t succeed, its failure isn\'t an exception.  So the method I\'m calling should return true if it succeeded, and false if it failed.Why is it a Func<bool, bool> and not just a Func<bool>?  So that if I want a method to be able to throw an exception on failure, I have a way of informing it that this is the last try.  So I might use it with code like:orIf passing a parameter that the method doesn\'t use proves to be awkward, it\'s trivial to implement an overload of Retry that just takes a Func<bool> as well.Use Pollyhttps://github.com/App-vNext/Polly-SamplesHere is a retry-generic I use with PollyUse it like thisKeep it simple with C# 6.0For those who want to have both the option to retry on any exception or explicitly set the exception type, use this: I needed a method that supported cancellation, while I was at it, I added support for returning intermediate failures.You can use the Retry function like this, retry 3 times with a 10 second delay but without cancellation.or, retry eternally every five seconds, unless cancelled.As you guess, In my source code I\'ve overloaded the Retry function to support the differing delgate types I desire to use.My async implementation of the retry method:Key points: I used .ConfigureAwait(false); and Func<dynamic> instead Func<T>Or how about doing it a bit neater....I believe throwing exceptions should generally be avoided as a mechanism unless your a passing them between boundaries (such as building a library other people can use).  Why not just have the DoSomething() command return true if it was successful and false otherwise?EDIT: And this can be encapsulated inside a function like others have suggested as well.  Only problem is if you are not writing the DoSomething() function yourselfI had the need to pass some parameter to my method to retry, and have a result value; so i need an expression..\nI build up this class that does the work (it is inspired to the the LBushkin\'s one)\nyou can use it like this: ps.\nthe LBushkin\'s solution does one more retry =DI would add the following code to the accepted answerBasically the above code is making the Retry class generic so you can pass the type of the exception you want to catch for retry.Now use it almost in the same way but specifying the exception typeI know this answer is very old but I just wanted to comment on this because I have run into issues using these while, do, whatever statement with counters. Over the years I have settled on a better approach I think. That is to use some sort of event aggregation like a reactive extensions "Subject" or the like. When a try fails, you simply publish an event saying the try failed, and have the aggregator function re-schedule the event. This allows you much more control over the retry without polluting the call itself with a bunch of retry loops and what not. Nor are you tying up a single thread with a bunch of thread sleeps.Do it simple in C#, Java or other languages:and use it in your code very simple:or you can use it in recursive methods:Exponential backoff is a good retry strategy than simply trying\xc2\xa0x number of times.\xc2\xa0You can use a library like Polly to implement it.I\'ve written a small class based on answers posted here. Hopefully it will help someone: https://github.com/natenho/resiliency