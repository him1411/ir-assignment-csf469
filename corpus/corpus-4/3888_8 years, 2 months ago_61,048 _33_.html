It\'s a sad fact of life on Scala that if you instantiate a List[Int], you can verify that your instance is a List, and you can verify that any individual element of it is an Int, but not that it is a List[Int], as can be easily verified:The -unchecked option puts the blame squarely on type erasure:Why is that, and how do I get around it?Scala was defined with Type Erasure because the Java Virtual Machine (JVM), unlike Java, did not get generics. This means that, at run time, only the class exists, not its type parameters. In the example, JVM knows it is handling a scala.collection.immutable.List, but not that this list is parameterized with Int.Fortunately, there\'s a feature in Scala that lets you get around that. It\xe2\x80\x99s the Manifest. A Manifest is class whose instances are objects representing types. Since these instances are objects, you can pass them around, store them, and generally call methods on them. With the support of implicit parameters, it becomes a very powerful tool. Take the following example, for instance:When storing an element, we store a "Manifest" of it too. A Manifest is a class whose instances represent Scala types. These objects have more information than JVM does, which enable us to test for the full, parameterized type.Note, however, that a Manifest is still an evolving feature. As an example of its limitations, it presently doesn\'t know anything about variance, and assumes everything is co-variant. I expect it will get more stable and solid once the Scala reflection library, presently under development, gets finished.You can do this using TypeTags (as Daniel already mentions, but I\'ll just spell it out explicitly):You can also do this using ClassTags (which saves you from having to depend on scala-reflect):ClassTags can be used so long as you don\'t expect the type parameter A to itself be a generic type.Unfortunately it\'s a little verbose and you need the @unchecked annotation to suppress a compiler warning.  The TypeTag may be incorporated into the pattern match automatically by the compiler in the future:  https://issues.scala-lang.org/browse/SI-6517You can use the Typeable type class from shapeless to get the result you\'re after,Sample REPL session,The cast operation will be as precise wrt erasure as possible given the in-scope Typeable instances available.I came up with a relatively simple solution that would suffice in limited-use situations, essentially wrapping parameterized types that would suffer from the type erasure problem in wrapper classes that can be used in a match statement.This has the expected output and limits the contents of our case class to the desired type, String Lists.More details here: http://www.scalafied.com/?p=60There is a way to overcome the type erasure issue in Scala. In Overcoming Type Erasure in matching 1 and Overcoming Type Erasure in Matching 2 (Variance) are some explanation of how to code some helpers to wrap the types, including Variance, for matching. I found a slightly better workaround for this limitation of the otherwise awesome language. In Scala, the issue of type erasure does not occur with arrays. I think it is easier to demonstrate this with an example. Let us say we have a list of (Int, String), then the following gives a type erasure warningTo work around this, first create a case class:then in the pattern matching do something like:which seems to work perfectly. This will require minor changes in your code to work with arrays instead of lists, but should not be a major problem.Note that using case a:Array[(Int, String)] will still give a type erasure warning, so it is necessary to use a new container class (in this example, IntString).I\'m wondering if this is a suited workaround:It does not match the "empty list" case, but it gives a compile error, not a warning!This on the other hand seems to work....Isn\'t it kinda even better or am I missing the point here?Since Java does not know the actual element type, I found it most useful to just use List[_]. Then the warning goes away and the code describes reality - it is a list of something unknown.Not a solution but a way to live with it without sweeping it under the rug altogether:\nAdding the @unchecked annotation. See here - http://www.scala-lang.org/api/current/index.html#scala.uncheckedUsing pattern match guard