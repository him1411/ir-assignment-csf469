I was benchmarking some code, and I could not get it to run as fast as with java.math.BigInteger, even when using the exact same algorithm.\nSo I copied java.math.BigInteger source into my own package and tried this:When I run this (jdk 1.8.0_144-b01 on MacOS) it outputs:When I run it with the import line uncommented:It\'s almost three times as fast when using the JDK version of BigInteger versus my version, even if it\'s using the exact same code.I\'ve examined the bytecode with javap, and compared compiler output when running with options:and both versions seem to generate the same code.\nSo is hotspot using some precomputed optimisations that I can\'t use in my code? I always understood that they don\'t.\nWhat explains this difference?Yes, HotSpot JVM is kind of "cheating", because it has a special version of some BigInteger methods that you won\'t find in Java code. These methods are called JVM intrinsics.In particular, BigInteger.multiplyToLen is instrinsic method in HotSpot. There is a special hand-coded assembly implementation in JVM source base, but only for x86-64 architecture.You may disable this instrinsic with -XX:-UseMultiplyToLenIntrinsic option to force JVM to use pure Java implementation. In this case the performance will be similar to the performance of your copied code.P.S. Here is a list of other HotSpot intrinsic methods.In Java 8 this is indeed an intrinsic, a slightly modified version of the method:Running this with:This will print lots of lines and one of them will be:In Java 9 on the other hand that method seems to not be an intrinsic anymore, but in turn it calls a method that is an intrinsic:So running the same code under Java 9 (with the same parameters) will reveal:Underneath it\'s the same code for the method - just a slightly different naming. 