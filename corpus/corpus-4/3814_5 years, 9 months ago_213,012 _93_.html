What is the life cycle of an Android activity? Why are so many similar sounding methods (onCreate(), onStart(), onResume()) called during initialization, and so many others (onPause(), onStop(), onDestroy()) called at the end?When are these methods called, and how should they be used properly?See it in Activity Lifecycle (at Android Developers).onCreate():Called when the activity is first created. This is where you should do\n  all of your normal static set up: create views, bind data to lists,\n  etc. This method also provides you with a Bundle containing the\n  activity\'s previously frozen state, if there was one. Always followed\n  by onStart().onRestart():Called after your activity has been stopped, prior to it being started\n  again. Always followed by onStart()onStart():Called when the activity is becoming visible to the user. Followed by\n  onResume() if the activity comes to the foreground, or onStop()  if it\n  becomes hidden.onResume():Called when the activity will start interacting with the user. At this\n  point your activity is at the top of the activity stack, with user\n  input going to it. Always followed by onPause().onPause ():Called as part of the activity lifecycle when an activity is going\n  into the background,\n  but has not (yet) been killed. The counterpart to onResume().\n  When activity B is launched in front of activity A, this callback will be invoked on A.\n  B will not be created until A\'s onPause() returns, so be sure to not\n  do anything lengthy here.onStop():Called when you are no longer visible to the user. You will next\n  receive either onRestart(),  onDestroy(), or nothing, depending on\n  later user activity.Note that this method may never be called, in low memory situations\n  where the system does not  have enough memory to keep your activity\'s\n  process running after its onPause() method is called.onDestroy():The final call you receive before your activity is destroyed. This\n  can happen either   because the activity is finishing (someone called\n  finish() on it, or because the system   is temporarily destroying this\n  instance of the activity to save space. You can distinguish   between\n  these two scenarios with the isFinishing() method.When the Activity first time loads the events are called as below:When you click on Phone button the Activity goes to the background and the below events are called:Exit the phone dialer and the below events will be called:When you click the back button OR try to finish() the activity the events are called as below:Activity StatesThe Android OS uses a priority queue to assist in managing activities running on the device. Based on the state a particular Android activity is in, it will be assigned a certain priority within the OS. This priority system helps Android identify activities that are no longer in use, allowing the OS to reclaim memory and resources. The following diagram illustrates the states an activity can go through, during its lifetime:These states can be broken into three main groups as follows:Active or Running - Activities are considered active or running if they are in the foreground, also known as the top of the activity stack. This is considered the highest priority activity in the Android Activity stack, and as such will only be killed by the OS in extreme situations, such as if the activity tries to use more memory than is available on the device as this could cause the UI to become unresponsive.Paused - When the device goes to sleep, or an activity is still visible but partially hidden by a new, non-full-sized or transparent activity, the activity is considered paused. Paused activities are still alive, that is, they maintain all state and member information, and remain attached to the window manager. This is considered to be the second highest priority activity in the Android Activity stack and, as such, will only be killed by the OS if killing this activity will satisfy the resource requirements needed to keep the Active/Running Activity stable and responsive.Stopped - Activities that are completely obscured by another activity are considered stopped or in the background. Stopped activities still try to retain their state and member information for as long as possible, but stopped activities are considered to be the lowest priority of the three states and, as such, the OS will kill activities in this state first to satisfy the resource requirements of higher priority activities.*Sample activity to understand the life cycle**The entire confusion is caused since Google chose non-intuivitive names instead of something as follows:The Activity Diagram can be interpreted as:Activity has six statesActivity lifecycle has seven methods Situations When open the appWhen back button pressed and exit the appWhen home button pressed After pressed home button when again open app from recent task list or clicked on iconWhen open app another app from notification bar or open settingsBack button pressed from another app or settings then used can see our appWhen any dialog open on screenAfter dismiss the dialog or back button from dialog Any phone is ringing and user in the appWhen user pressed phone\'s answer buttonAfter call end When phone screen offWhen screen is turned back onANDROID LIFE-CYCLEThere are seven methods that manage the life cycle of an Android application:Let us take a simple scenario where knowing in what order these methods are called will help us give a clarity why they are used.onCreate() - - - > onStart() - - - > onResume()onPause() - - - > onStop()onRestart() - - - > onStart() - - - > onResume()onStop() - - - > onDestroy()Starting state involves:Creating a new Linux process, allocating new memory for the new UI objects, and setting up the whole screen. So most of the work is involved here.Running state involves:It is the activity (state) that is currently on the screen. This state alone handles things such as typing on the screen, and touching & clicking buttons.Paused state involves:When an activity is not in the foreground and instead it is in the background, then the activity is said to be in paused state.Stopped state involves:A stopped activity can only be bought into foreground by restarting it and also it can be destroyed at any point in time.The activity manager handles all these states in such a way that the user experience and performance is always at its best even in scenarios where the new activity is added to the existing activitiesFrom the Android Developers page,onPause():Called when the system is about to start resuming a previous activity.\n  This is typically used to commit unsaved changes to persistent data,\n  stop animations and other things that may be consuming CPU, etc.\n  Implementations of this method must be very quick because the next\n  activity will not be resumed until this method returns. Followed by\n  either onResume() if the activity returns back to the front, or\n  onStop() if it becomes invisible to the user.onStop():Called when the activity is no longer visible to the user, because\n  another activity has been resumed and is covering this one. This may\n  happen either because a new activity is being started, an existing one\n  is being brought in front of this one, or this one is being destroyed.\n  Followed by either onRestart() if this activity is coming back to\n  interact with the user, or onDestroy() if this activity is going away.Now suppose there are three Activities and you go from A to B, then onPause of A will be called now from B to C, then onPause of B and onStop of A will be called.The paused Activity gets a Resume and Stopped gets Restarted.When you call this.finish(), onPause-onStop-onDestroy will be called. The main thing to remember is: paused Activities get Stopped and a Stopped activity gets Destroyed whenever Android requires memory for other operations.I hope it\'s clear enough.I like this question and the answers to it, but so far there isn\'t coverage of less frequently used callbacks like onPostCreate() or onPostResume().  Steve Pomeroy has attempted a diagram including these and how they relate to Android\'s Fragment life cycle, at https://github.com/xxv/android-lifecycle.  I revised Steve\'s large diagram to include only the Activity portion and formatted it for letter size one-page printout.  I\'ve posted it as a text PDF at https://github.com/code-read/android-lifecycle/blob/master/AndroidActivityLifecycle1.pdf and below is its image:Adding some more info on top of highly rated answer (Added additional section of KILLABLE and next set of methods, which are going to be called in the life cycle):Source: developer.android.comNote the "Killable" column in the above table -- for those methods that are marked as being killable, after that method returns the process hosting the activity may be killed by the system at any time without another line of its code being executed.Because of this, you should use the onPause() method to write any persistent data (such as user edits) to storage. In addition, the method onSaveInstanceState(Bundle) is called before placing the activity in such a background state, allowing you to save away any dynamic instance state in your activity into the given Bundle, to be later received in onCreate(Bundle) if the activity needs to be re-created. Note that it is important to save persistent data in onPause() instead of onSaveInstanceState(Bundle) because the latter is not part of the lifecycle callbacks, so will not be called in every situation as described in its documentation.I would like to add few more methods. These are not listed as life cycle methods but they will be called during life cycle depending on some conditions. Depending on your requirement, you may have to implement these methods in your application for proper handling of state. Called when activity start-up is complete (after onStart() and onRestoreInstanceState(Bundle) have been called).Called when activity resume is complete (after onResume() has been called).Called to retrieve per-instance state from an activity before being killed so that the state can be restored in onCreate(Bundle) or onRestoreInstanceState(Bundle) (the Bundle populated by this method will be passed to both).This method is called after onStart() when the activity is being re-initialized from a previously saved state, given here in savedInstanceState.My application code using all these methods:Login Activity:output: ( Before pause)output: ( After resume from pause)Note that onPostResume() is invoked even though it\'s not quoted as life cycle method. 