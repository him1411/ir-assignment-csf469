POCO = Plain Old CLR (or better: Class) ObjectDTO = Data Transfer ObjectIn this post there is a difference, but frankly most of the blogs I read describe POCO in the way DTO is defined: DTOs are simple data containers used for moving data between the layers of an application.Are POCO and DTO the same thing?(ps: look at this great article about POCO as a lifestyle)A POCO follows the rules of OOP.  It should (but doesn\'t have to) have state and behavior.  POCO comes from POJO, coined by Martin Fowler [anecdote here].  He used the term POJO as a way to make it more sexy to reject the framework heavy EJB implementations.  POCO should be used in the same context in .Net.  Don\'t let frameworks dictate your object\'s design.A DTO\'s only purpose is to transfer state, and should have no behavior.  See Martin Fowler\'s explanation of a DTO for an example of the use of this pattern.Here\'s the difference: POCO describes an approach to programming (good old fashioned object oriented programming), where DTO is a pattern that is used to "transfer data" using objects.While you can treat POCOs like DTOs, you run the risk of creating an anemic domain model if you do so.  Additionally, there\'s a mismatch in structure, since DTOs should be designed to transfer data, not to represent the true structure of the business domain.  The result of this is that DTOs tend to be more flat than your actual domain.In a domain of any reasonable complexity, you\'re almost always better off creating separate domain POCOs and translating them to DTOs.  DDD (domain driven design) defines the anti-corruption layer (another link here, but best thing to do is buy the book), which is a good structure that makes the segregation clear.It\'s probably redundant for me to contribute since I already stated my position in my blog article, but the final paragraph of that article kind of sums things up:  So, in conclusion, learn to love the POCO, and make sure you don\xe2\x80\x99t spread any misinformation about it being the same thing as a DTO.  DTOs are simple data containers used for moving data between the layers of an application.  POCOs are full fledged business objects with the one requirement that they are Persistence Ignorant (no get or save methods).  Lastly, if you haven\xe2\x80\x99t checked out Jimmy Nilsson\xe2\x80\x99s book yet, pick it up from your local university stacks.  It has examples in C# and it\xe2\x80\x99s a great read.BTW, Patrick I read the POCO as a Lifestyle article, and I completely agree, that is a fantastic article.  It\'s actually a section from the Jimmy Nilsson book that I recommended. I had no idea that it was available online. His book really is the best source of information I\'ve found on POCO / DTO / Repository / and other DDD development practices.   POCO is simply an object that does not take a dependency on an external framework. It is PLAIN.Whether a POCO has behaviour or not is immaterial.A DTO maybe POCO as may a domain object (which would typically be rich in behaviour)Typically DTOs are more likely to take dependencies on external frameworks (eg attributes) for serialisation purposes as typically they exit at the boundary of a system.In typical Onion style architectures (often used within a broadly DDD approach) the domain layer is placed at the centre and so it\'s objects should not at this point have dependencies outside of that layer.I think a DTO can be a POCO. DTO is more about the usage of the object while POCO is more of the style of the object (decoupled from architectural concepts).One example where a POCO is something different than DTO is when you\'re talking about POCO\'s inside your domain model/business logic model, which is a nice OO representation of your problem domain. You could use the POCO\'s throughout the whole application, but this could have some undesirable side effect such a knowledge leaks. DTO\'s are for instance used from the Service Layer which the UI communicates with, the DTO\'s are flat representation of the data, and are only used for providing the UI with data, and communicating changes back to the service layer. The service layer is in charge of mapping the DTO\'s both ways to the POCO domain objects. Update Martin Fowler said that this approach is a heavy road to take, and should only be taken if there is a significant mismatch between the domain layer and the user interface.I wrote an article for that topic: DTO vs Value Object vs POCO.In short:here is the general rule: DTO==evil and indicator of over-engineered software. POCO==good. \'enterprise\' patterns have destroyed the brains of a lot of people in the Java EE world. please don\'t repeat the mistake in .NET land.A primary use case for a DTO is in returning data from a web service. In this instance, POCO and DTO are equivalent. Any behavior in the POCO would be removed when it is returned from a web service, so it doesn\'t really matter whether or not it has behavior.Don\'t even call them DTOs.  They\'re called Models....Period.  Models never have behavior.  I don\'t know who came up with this dumb term DTO but it must be a .NET thing is all I can figure.  Think of view models in MVC, same dam** thing, models are used to transfer state between layers server side or over the wire period, they are all models.  Properties with data.  These are models you pass ove the wire.  Models, Models Models.  That\'s it. I wish the stupid term DTO would go away from our vocabulary.