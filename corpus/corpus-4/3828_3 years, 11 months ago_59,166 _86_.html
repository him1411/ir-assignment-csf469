I first noticed in 2009 that gcc (at least on my projects and on my machines) have the tendency to generate noticeably faster code if I optimize for size (-Os) instead of speed (-O2 or -O3), and I have been wondering ever since why.I have managed to create (rather silly) code that shows this surprising behavior and is sufficiently small to be posted here.If I compile it with -Os, it takes 0.38 s to execute this program, and 0.44 s if it is compiled with -O2 or -O3. These times are obtained consistently and with practically no noise (gcc 4.7.2, x86_64 GNU/Linux, Intel Core i5-3320M).(Update: I have moved all assembly code to GitHub: They made the post bloated and apparently add very little value to the questions as the fno-align-* flags have the same effect.)The generated assembly with -Os and -O2.\nUnfortunately, my understanding of assembly is very limited, so I have no idea whether what I did next was correct: I grabbed the assembly for -O2 and merged all its differences into the assembly for -Os except the .p2align lines, result here. This code still runs in 0.38s and the only difference is the .p2align stuff.If I guess correctly, these are paddings for stack alignment. According to Why does GCC pad functions with NOPs? it is done in the hope that the code will run faster, but apparently this optimization backfired in my case.Is it the padding that is the culprit in this case? Why and how?The noise it makes pretty much makes timing micro-optimizations impossible.How can I make sure that such accidental lucky / unlucky alignments are not interfering when I do micro-optimizations (unrelated to stack alignment) on C or C++ source code?UPDATE:Following Pascal Cuoq\'s answer I tinkered a little bit with the alignments. By passing -O2 -fno-align-functions -fno-align-loops to gcc, all .p2align are gone from the assembly and the generated executable runs in 0.38s. According to the gcc documentation:-Os enables all -O2 optimizations [but] -Os disables the following optimization flags:So, it pretty much seems like a (mis)alignment issue.I am still skeptical about -march=native as suggested in Marat Dukhan\'s answer. I am not convinced that it isn\'t just interfering with this (mis)alignment issue; it has absolutely no effect on my machine. (Nevertheless, I upvoted his answer.)UPDATE 2:We can take -Os out of the picture. The following times are obtained by compiling with-O2 -fno-omit-frame-pointer 0.37s-O2 -fno-align-functions -fno-align-loops 0.37s-S -O2 then manually moving the assembly of add() after work() 0.37s-O2 0.44sIt looks like to me the distance of add() from the call site matters a lot. I have tried perf, but the output of perf stat and perf report makes very little sense to me. However, I could only get one consistent result out of it:-O2:For fno-align-*:For -fno-omit-frame-pointer:It looks like we are stalling on the call to add() in the slow case.I have examined everything that perf -e can spit out on my machine; not just the stats that are given above.For the same executable, the stalled-cycles-frontend shows linear correlation with the execution time; I did not notice anything else that would correlate so clearly. (Comparing stalled-cycles-frontend for different executables doesn\'t make sense to me.)I included the cache misses as it came up as the first comment. I examined all the cache misses that can be measured on my machine by perf, not just the ones given above. The cache misses are very very noisy and show little to no correlation with the execution times.By default compilers optimize for "average" processor. Since different processors favor different instruction sequences, compiler optimizations enabled by -O2 might benefit average processor, but decrease performance on your particular processor (and the same applies to -Os). If you try the same example on different processors, you will find that on some of them benefit from -O2 while other are more favorable to -Os optimizations.Here are the results for time ./test 0 0 on several processors (user time reported):In some cases you can alleviate the effect of disadvantageous optimizations by asking gcc to optimize for your particular processor (using options -mtune=native or -march=native):Update: on Ivy Bridge-based Core i3 three versions of gcc (4.6.4, 4.7.3, and 4.8.1) produce binaries with significantly different performance, but the assembly code has only subtle variations. So far, I have no explanation of this fact.Assembly from gcc-4.6.4 -Os (executes in 0.709 secs):Assembly from gcc-4.7.3 -Os (executes in 0.822 secs):Assembly from gcc-4.8.1 -Os (executes in 0.994 secs):My colleague helped me find a plausible answer to my question. He noticed the importance of the 256 byte boundary. He is not registered here and encouraged me to post the answer myself (and take all the fame).Short answer:Is it the padding that is the culprit in this case? Why and how?It all boils down to alignment. Alignments can have a significant impact on the performance, that is why we have the -falign-* flags in the first place.I have submitted a (bogus?) bug report to the gcc developers. It turns out that the default behavior is "we align loops to 8 byte by default but try to align it to 16 byte if we don\'t need to fill in over 10 bytes." Apparently, this default is not the best choice in this particular case and on my machine. Clang 3.4 (trunk) with -O3 does the appropriate alignment and the generated code does not show this weird behavior.Of course, if an inappropriate alignment is done, it makes things worse. An unnecessary / bad alignment just eats up bytes for no reason and potentially increases cache misses, etc.The noise it makes pretty much makes timing micro-optimizations\n  impossible.How can I make sure that such accidental lucky / unlucky alignments\n  are not interfering when I do micro-optimizations (unrelated to stack\n  alignment) on C or C++ source codes?Simply by telling gcc to do the right alignment:g++ -O2 -falign-functions=16 -falign-loops=16Long answer:The code will run slower if:an XX byte boundary cuts add() in the middle (XX being machine dependent).if the call to add() has to jump over an XX byte boundary and the target is not aligned.if  add() is not aligned.if the loop is not aligned.The first 2 are beautifully visible on the codes and results that Marat Dukhan kindly posted. In this case, gcc-4.8.1 -Os (executes in 0.994 secs):a 256 byte boundary cuts add() right in the middle and neither add() nor the loop is aligned. Surprise, surprise, this is the slowest case!In case gcc-4.7.3 -Os (executes in 0.822 secs), the 256 byte boundary only cuts into a cold section (but neither the loop, nor add() is cut):Nothing is aligned, and the call to add() has to jump over the 256 byte boundary. This code is the second slowest.In case gcc-4.6.4 -Os (executes in 0.709 secs), although nothing is aligned, the call to add() doesn\'t have to jump over the 256 byte boundary and the target is exactly 32 byte away:This is the fastest of all three. Why the 256 byte boundary is speacial on his machine, I will leave it up to him to figure it out. I don\'t have such a processor.Now, on my machine I don\'t get this 256 byte boundary effect. Only the function and the loop alignment kicks in on my machine. If I pass g++ -O2 -falign-functions=16 -falign-loops=16 then everything is back to normal: I always get the fastest case and the time isn\'t sensitive to the -fno-omit-frame-pointer flag anymore. I can pass g++ -O2 -falign-functions=32 -falign-loops=32 or any multiples of 16, the code is not sensitive to that either.I first noticed in 2009 that gcc (at least on my projects and on my\n  machines) have the tendency to generate noticeably faster code if I\n  optimize for size (-Os) instead of speed (-O2 or -O3) and I have been\n  wondering ever since why.A likely explanation is that I had hotspots which were sensitive to the alignment, just like the one in this example. By messing with the flags (passing -Os instead of -O2), those hotspots were aligned in a lucky way by accident and the code became faster. It had nothing to do with optimizing for size: These were by sheer accident that the hotspots got aligned better. From now on, I will check the effects of alignment on my projects.Oh, and one more thing. How can such hotspots arise, like the one shown in the example? How can the inlining of such a tiny function like add() fail?Consider this:and in a separate file:and compiled as: g++ -O2 add.cpp main.cpp.       gcc won\'t inline add()!That\'s all, it\'s that easy to  unintendedly create hotspots like the one in the OP. Of course it is partly my fault: gcc is an excellent compiler. If compile the above as: g++ -O2 -flto add.cpp main.cpp, that is, if I perform link time optimization, the code runs in 0.19s! (Inlining is artificially disabled in the OP, hence, the code in the OP was 2x slower).I\'m adding this post-accept to point out that the effects of alignment on overall performance of programs - including big ones - has been studied.  For example, this article (and I believe a version of this also appeared in CACM) shows how link order and OS environment size changes alone were sufficient to shift performance significantly.  They attribute this to alignment of "hot loops".This paper, titled "Producing wrong data without doing anything obviously wrong!" says that inadvertent experimental bias due to nearly uncontrollable differences in program running environments probably renders many benchmark results meaningless. I think you\'re encountering a different angle on the same observation.  For performance-critical code, this is a pretty good argument for systems that assess the environment at installation or run time and choose the local best among differently optimized versions of key routines. I think that you can obtain the same result as what you did:I grabbed the assembly for -O2 and merged all its differences into the assembly for -Os except the .p2align lines:\xe2\x80\xa6 by using -O2 -falign-functions=1 -falign-jumps=1 -falign-loops=1 -falign-labels=1. I have been compiling everything with these options, that were faster than plain -O2 everytime I bothered to measure, for 15 years.Also, for a completely different context (including a different compiler), I noticed that the situation is similar: the option that is supposed to \xe2\x80\x9coptimize code size rather than speed\xe2\x80\x9d optimizes for code size and speed.If I guess correctly, these are paddings for stack alignment.No, this has nothing to do with the stack, the NOPs that are generated by default and that options -falign-*=1 prevent are for code alignment.According to Why does GCC pad functions with NOPs? it is done in the hope that the code will run faster but apparently this optimization backfired in my case.Is it the padding that is the culprit in this case? Why and how?It is very likely that the padding is the culprit. The reason padding is felt to be necessary and is useful in some cases is that code is typically fetched in lines of 16 bytes (see Agner Fog\'s optimization resources for the details, which vary by model of processor). Aligning a function, loop, or label on a 16-bytes boundary means that the chances are statistically increased that one fewer lines will be necessary to contain the function or loop. Obviously, it backfires because these NOPs reduce code density and therefore cache efficiency. In the case of loops and label, the NOPs may even need to be executed once (when execution arrives to the loop/label normally, as opposed to from a jump).If your program is bounded by the CODE L1 cache, then optimizing for size suddenly starts to pay out.When last I checked, the compiler is not smart enough to figure this out in all cases.In your case, -O3 probably generates code enough for two cache lines, but -Os fits in one cache line.I\'m by no means an expert in this area, but I seem to remember that modern processors are quite sensitive when it comes to branch prediction. The algorithms used to predict the branches are (or at least were back in the days I wrote assembler code) based on several properties of the code, including the distance of a target and on the direction.The scenario which comes to mind is small loops. When the branch was going backwards and the distance was not too far, the branch predicition was optimizing for this case as all the small loops are done this way. The same rules might come into play when you swap the location of add and work in the generated code or when the position of both slightly changes.That said, I have no idea how to verify that and I just wanted to let you know that this might be something you want to look into.