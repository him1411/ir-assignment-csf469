In Objective-C the code to check for a substring in an NSString is: But how do I do this in Swift?You can do exactly the same call with Swift:I hope this is a helpful solution since some people, including me, encountered some strange problems by calling containsString().PS. Don\'t forget to import FoundationYou can write extension contains: and containsIgnoringCase for StringExample:From the docs, it seems that calling containsString() on a String should work:Swift\xe2\x80\x99s String type is bridged seamlessly to Foundation\xe2\x80\x99s NSString\n  class. If you are working with the Foundation framework in Cocoa or\n  Cocoa Touch, the entire NSString API is available to call on any\n  String value you create, in addition to the String features described\n  in this chapter. You can also use a String value with any API that\n  requires an NSString instance.However, it doesn\'t seem to work that way.If you try to use someString.containsString(anotherString), you will get a compile time error that states \'String\' does not contain a member named \'containsString\'.So, you\'re left with a few options, one of which is to explicitly bridge your String to Objective-C by using bridgeToObjectiveC() other two involve explicitly using an NSString and the final one involves casting the String to an NSStringBy bridging, you\'d get:By explicitly typing the string as an NSString, you\'d get:If you have an existing String, you can initialize an NSString from it by using NSString(string:):And finally, you can cast an existing String to an NSString as belowAnother one. Supports case and diacritic options.Swift 3.0Case and diacritic insensitive function available since iOS 9.As of Xcode 7.1 and Swift 2.1 containsString() is working fine for me.You can do this very easily in Swift using the code:> IN SWIFT 3.0OutputOf all of the answers here, I think they either don\'t work, or they\'re a bit of a hack (casting back to NSString).  It\'s very likely that the correct answer to this has changed with the different beta releases.Here is what I use:The "!= nil" became required with Beta 5.Just an addendum to the answers here.You can also do a local case insensitive test using: Example:UPDATEThis is part of the Foundation Framework for iOS & Mac OS X 10.10.x\n and was part of 10.10 at Time of my original Posting.Document Generated: 2014-06-05 12:26:27 -0700 OS X Release Notes\n  Copyright \xc2\xa9 2014 Apple Inc. All Rights Reserved.OS X 10.10 Release Notes Cocoa Foundation FrameworkNSString now has the following two convenience methods:- (BOOL)containsString:(NSString *)str;- (BOOL)localizedCaseInsensitiveContainsString:(NSString *)str; Here is my first stab at this in the swift playground.\nI extend String by providing two new functions (contains and containsIgnoreCase)Use it like thisI\'d welcome any feedback :)Here you are:You don\'t need to write any custom code for this. Starting from the 1.2 version Swift has already had all the methods you need:In Swift 3Here you go! Ready for Xcode 8 and Swift 3.Usestring.containsString is only available in 10.10 Yosemite (and probably iOS8).\nAlso bridging it to ObjectiveC crashes in 10.9. You\'re trying to pass a NSString to NSCFString. I don\'t know the difference, but I can say 10.9 barfs when it executes this code in a OS X 10.9 app.  Here are the differences in Swift with 10.9 and 10.10:\nhttps://developer.apple.com/library/prerelease/mac/documentation/General/Reference/APIDiffsMacOSX10_10SeedDiff/index.html containsString is only available in 10.10Range of String above works great on 10.9.  I am finding developing on 10.9 is super stable with Xcode beta2.  I don\'t use playgrounds through or the command line version of playgrounds. I\'m finding if the proper frameworks are imported the autocomplete is very helpful.Xcode 8/Swift 3 version:You can also use contains:Check if it contains \'Hello\'In iOS 8 and newer, you can use these two NSString methods:I\'ve found a couple of interesting use cases. These variants make use of the rangeOfString method and I include the equality example to show how one might best use the search and comparison features of Strings in Swift 2.0Later after I\'ve made changes to self.myObject, I can refer to the\n  following string comparison routines (setup as lazy variables that\n  return a Bool). This allows one to check the state at any time.A variant of this happens when sometimes I need to analyze a missing\n  property on that object. A string search allows me to find a\n  particular substring being set to nil (the default when an object is created).Swift 3: Here you can see my smart search extension fro string that let you make a search on string for seeing if it contains, or maybe to filter a collection based on a search text.https://github.com/magonicolas/Swift-Smart-String-SearchYou can just do what you have mentioned:From the docs:Swift\xe2\x80\x99s String type is bridged seamlessly to Foundation\xe2\x80\x99s NSString\n  class. If you are working with the Foundation framework in Cocoa or\n  Cocoa Touch, the entire NSString API is available to call on any\n  String value you create, in addition to the String features described\n  in this chapter. You can also use a String value with any API that\n  requires an NSString instance.You need to import Foundation to bridge the NSString methods and make them available to Swift\'s String class.