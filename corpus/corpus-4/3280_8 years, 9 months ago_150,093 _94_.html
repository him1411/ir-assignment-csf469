How can I set default value in ActiveRecord?I see a post from Pratik that describes an ugly, complicated chunk of code: http://m.onkey.org/2007/7/24/how-to-set-default-values-in-your-modelI have seen the following examples googling around:andI\'ve also seen people put it in their migration, but I\'d rather see it defined in the model code.Is there a canonical way to set default value for fields in ActiveRecord model?There are several issues with each of the available methods, but I believe that defining an after_initialize callback is the way to go for the following reasons:DEPRECATION WARNING: Base#after_initialize has been deprecated, please use Base.after_initialize :method instead. (called from /Users/me/myapp/app/models/my_model:15)Therefore I\'d say write an after_initialize callback, which lets you default attributes in addition to letting you set defaults on associations like so:Now you have just one place to look for initialization of your models. I\'m using this method until someone comes up with a better one.Caveats:For boolean fields do:self.bool_field = true if self.bool_field.nil?See Paul Russell\'s comment on this answer for more detailsIf you\'re only selecting a subset of columns for a model (ie; using select in a query like Person.select(:firstname, :lastname).all) you will get a MissingAttributeError if your init method accesses a column that hasn\'t been included in the select clause. You can guard against this case like so:self.number ||= 0.0 if self.has_attribute? :numberand for a boolean column...self.bool_field = true if (self.has_attribute? :bool_value) && self.bool_field.nil?Also note that the syntax is different prior to Rails 3.2 (see Cliff Darling\'s comment below)We put the default values in the database through migrations (by specifying the :default option on each column definition) and let Active Record use these values to set the default for each attribute.IMHO, this approach is aligned with the principles of AR : convention over configuration, DRY, the table definition drives the model, not the other way around.Note that the defaults are still in the application (Ruby) code, though not in the model but in the migration(s).Some simple cases can be handled by defining a default in the database schema but that doesn\'t handle a number of trickier cases including calculated values and keys of other models. For these cases I do this:I\'ve decided to use the after_initialize but I don\'t want it to be applied to objects that are found only those new or created.  I think it is almost shocking that an after_new callback isn\'t provided for this obvious use case but I\'ve made do by confirming whether the object is already persisted indicating that it isn\'t new.Having seen Brad Murray\'s answer this is even cleaner if the condition is moved to callback request:The Phusion guys have some nice plugin for this.The after_initialize callback pattern can be improved by simply doing the followingThis has a non-trivial benefit if your init code needs to deal with associations, as the following code triggers a subtle n+1 if you read the initial record without including the associated.I use the attribute-defaults gemFrom the documentation:\nrun sudo gem install attribute-defaults and add require \'attribute_defaults\' to your app.In Rails 5+, you can use the attribute method within your models, eg.:This is what constructors are for! Override the model\'s initialize method.Use the after_initialize method.Sup guys, I ended up doing the following:Works like a charm!An even better/cleaner potential way than the answers proposed is to overwrite the accessor, like this:See "Overwriting default accessors" in the ActiveRecord::Base documentation and more from StackOverflow on using self.First things first: I do not disagree with Jeff\'s answer. It makes sense when your app is small and your logic simple. I am here trying to give an insight into how it can be a problem when building and maintaining a larger application. I do not recommend to use this approach first when building something small, but to keep it in mind as an alternative approach:A question here is whether this default on records is business logic. If it is, I would be cautious to put it in the ORM model. Since the field ryw mentions is active, this does sound like business logic. E.g. the user is active.Why would I be wary to put business concerns in an ORM model?It breaks SRP. Any class inheriting from ActiveRecord::Base is already doing a lot of different things, chief among them being data consistency (validations) and persistence (save). Putting business logic, however small it is, in with AR::Base breaks SRP.It is slower to test. If I want to test any form of logic happening in my ORM model, my tests have to initialise Rails in order to run. This wont be too much of a problem in thee beginning of your application, but will accumulate until your unit tests take a long time to run.It will break SRP even more down the line, and in concrete ways. Say our business now requires us to email users when there Item\'s become active? Now we are adding email logic to the Item ORM model, whose primary responsibility is modelling an Item. It should not care about email logic. This is a case of business side effects. These do not belong in the ORM model.It is hard to diversify. I have seen mature Rails apps with things like a database backed init_type: string field, whose only purpose is to control the initialisation logic. This is polluting the database to fix a structural problem. There are better ways, I believe.The PORO way: While this is a bit more code, it allows you to keep your ORM Models and Business Logic separate. The code here is simplified, but should show the idea:Then with this in place, the way to create a new Item would beAnd my tests could now simply verify that ItemFactory sets active on Item if it does not have a value. No Rails initialisation needed, no SRP breaking. When Item initialisation becomes more advanced (e.g. set a status field, a default type, etc.) the ItemFactory can have this added. If we end up with two types of defaults, we can create a new BusinesCaseItemFactory to do this.NOTE: It could also be beneficial to use dependency injection here to allow the factory to build many active things, but I left it out for simplicity. Here it is: self.new(klass = Item, attributes = {})Similar questions, but all have slightly different context:\n- How do I create a default value for attributes in Rails activerecord's model?Best Answer: Depends on What You Want!If you want every object to start with a value: use after_initialize :initYou want the new.html form to have a default value upon opening the page? use https://stackoverflow.com/a/5127684/1536309If you want every object to have a value calculated from user input: use before_save :default_values\nYou want user to enter X and then Y = X+\'foo\'? use:The problem with the after_initialize solutions is that you have to add an after_initialize to every single object you look up out of the DB, regardless of whether you access this attribute or not. I suggest a lazy-loaded approach. The attribute methods (getters) are of course methods themselves, so you can override them and provide a default. Something like:Unless, like someone pointed out, you need to do Foo.find_by_status(\'ACTIVE\'). In that case I think you\'d really need to set the default in your database constraints, if the DB supports it.This has been answered for a long time, but I need default values frequently and prefer not to put them in the database. I create a DefaultValues concern:And then use it in my models like so:Although doing that for setting default values is confusing and awkward in most cases, you can use :default_scope as well. Check out squil\'s comment here.after_initialize method is deprecated, use the callback instead.however, using :default in your migrations is still the cleanest way.I\'ve found that using a validation method provides a lot of control over setting defaults. You can even set defaults (or fail validation) for updates. You even set a different default value for inserts vs updates if you really wanted to.\nNote that the default won\'t be set until #valid? is called.Regarding defining an after_initialize method, there could be performance issues because after_initialize is also called by each object returned by :find :\nhttp://guides.rubyonrails.org/active_record_validations_callbacks.html#after_initialize-and-after_findI ran into problems with after_initialize giving ActiveModel::MissingAttributeError errors when doing complex finds:eg:"search" in the .where is hash of conditionsSo I ended up doing it by overriding initialize in this way:The super call is necessary to make sure the object initializing correctly from ActiveRecord::Base before doing my customize code, ie: default_valuesIf the column happens to be a \'status\' type column, and your model lends itself to the use of state machines, consider using the aasm gem, after which you can simply do It still doesn\'t initialize the value for unsaved records, but it\'s a bit cleaner than rolling your own with init or whatever, and you reap the other benefits of aasm such as scopes for all your statuses.https://github.com/keithrowell/rails_default_valueI strongly suggest using the "default_value_for" gem: https://github.com/FooBarWidget/default_value_forThere are some tricky scenarios that pretty much require overriding the initialize method, which that gem does.Examples:Your db default is NULL, your model/ruby-defined default is "some string", but you actually want to set the value to nil for whatever reason: MyModel.new(my_attr: nil)Most solutions here will fail to set the value to nil, and will instead set it to the default.OK, so instead of taking the ||= approach, you switch to my_attr_changed?...BUT now imagine your db default is "some string", your model/ruby-defined default is "some other string", but under a certain scenario, you want to set the value to "some string" (the db default): MyModel.new(my_attr: \'some_string\')This will result in my_attr_changed? being false because the value matches the db default, which in turn will fire your ruby-defined default code and set the value to "some other string" -- again, not what you desired.For those reasons I don\'t think this can properly be accomplished with just an after_initialize hook.Again, I think the "default_value_for" gem is taking the right approach: https://github.com/FooBarWidget/default_value_forI\'ve also seen people put it in their migration, but I\'d rather see it\n  defined in the model code.Is there a canonical way to set default value for fields in\n  ActiveRecord model?The canonical Rails way, before Rails 5, was actually to set it in the migration, and just look in the db/schema.rb for whenever wanting to see what default values are being set by the DB for any model. Contrary to what @Jeff Perrin answer states (which is a bit old), the migration approach will even apply the default when using Model.new, due to some Rails magic. Verified working in Rails 4.1.16.The simplest thing is often the best. Less knowledge debt and potential points of confusion in the codebase. And it \'just works\'.The null: false disallows NULL values in the DB, and, as an added benefit, it also updates all pre-existing DB records is set with the default value for this field as well. You may exclude this parameter in the migration if you wish, but I found it very handy!The canonical way in Rails 5+ is, as @Lucas Caton said:use default_scope in rails 3api docActiveRecord obscures the difference between defaulting defined in the database (schema) and defaulting done in the application (model). During initialization, it parses the database schema and notes any default values specified there. Later, when creating objects, it assigns those schema-specified default values without touching the database.discussionFrom the api docs http://api.rubyonrails.org/classes/ActiveRecord/Callbacks.html\nUse the before_validation method in your model, it gives you the options of creating specific initialisation for create and update calls\ne.g. in this example (again code taken from the api docs example) the number field is initialised for a credit card. You can easily adapt this to set whatever values you wantSurprised that his has not been suggested here