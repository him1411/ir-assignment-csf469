Bearing in mind that I\'ll be performing calculations on lat / long pairs, what datatype is best suited for use with a MySQL database?Use MySQL\'s spatial extensions with GIS.Google provides a start to finish PHP/MySQL solution for an example "Store Locator" application with Google Maps. In this example, they store the lat/lng values as "Float" with a length of "10,6"http://code.google.com/apis/maps/articles/phpsqlsearch.htmlBasically it depends on the precision you need for your locations. Using DOUBLE you\'ll have a 3.5nm precision. DECIMAL(8,6)/(9,6) goes down to 16cm. FLOAT is 1.7m...This very interesting table has a more complete list: http://mysql.rjweb.org/doc.php/latlng :Hope this helps.MySQL\'s Spatial Extensions are the best option because you have the full list of spatial operators and indices at your disposal. A spatial index will allow you to perform distance-based calculations very quickly. Please keep in mind that as of 6.0, the Spatial Extension is still incomplete. I am not putting down MySQL Spatial, only letting you know of the pitfalls before you get too far along on this.If you are dealing strictly with points and only the DISTANCE function, this is fine. If you need to do any calculations with Polygons, Lines, or Buffered-Points, the spatial operators do not provide exact results unless you use the "relate" operator. See the warning at the top of 21.5.6. Relationships such as contains, within, or intersects are using the MBR, not the exact geometry shape (i.e. an Ellipse is treated like a Rectangle).Also, the distances in MySQL Spatial are in the same units as your first geometry. This means if you\'re using Decimal Degrees, then your distance measurements are in Decimal Degrees. This will make it very difficult to get exact results as you get furthur from the equator. When I did this for a navigation database built from ARINC424 I did a fair amount of testing and looking back at the code, I used a DECIMAL(18,12) (Actually a NUMERIC(18,12) because it was firebird).Floats and doubles aren\'t as precise and may result in rounding errors which may be a very bad thing. I can\'t remember if I found any real data that had problems - but I\'m fairly certain that the inability to store accurately in a float or a double could cause problemsThe point is that when using degrees or radians we know the range of the values - and the fractional part needs the most digits.The MySQL Spatial Extensions are a good alternative because they follow The OpenGIS Geometry Model. I didn\'t use them because I needed to keep my database portable.Based on this wiki article\nhttp://en.wikipedia.org/wiki/Decimal_degrees#Accuracy\nthe appropriate data type in MySQL is Decimal(9,6) for storing the longitude and latitude in\nseparate fields.Depends on the precision that you require.From: http://mysql.rjweb.org/doc.php/latlngTo summarise:As of MySQL 5.7, consider using Spatial Data Types (SDT), specifically POINT for storing a single coordinate. Prior to 5.7, SDT does not support indexes (with exception of 5.6 when table type is MyISAM).Note:Use DECIMAL(8,6) for latitude (90 to -90 degrees) and DECIMAL(9,6) for longitude (180 to -180 degrees). 6 decimal places is fine for most applications. Both should be "signed" to allow for negative values.We store latitude/longitude X 1,000,000 in our oracle database as NUMBERS to avoid round off errors with doubles.Given that latitude/longitude to the 6th decimal place was 10 cm accuracy that was all we needed.  Many other databases also store lat/long to the 6th decimal place.No need to go far, according to Google Maps, the best is FLOAT(10,6) for lat and lng.In a completely different and simpler perspective:This way you don\'t need to worry about indexing numbers and all the other problems associated with data types that may screw up your coordinates.depending on you application, i suggest using FLOAT(9,6)spatial keys will give you more features, but in by production benchmarks the floats are much faster than the spatial keys. (0,01 VS 0,001 in AVG)While it isn\'t optimal for all operations, if you are making map tiles or working with large numbers of markers (dots) with only one projection (e.g. Mercator, like Google Maps and many other slippy maps frameworks expect), I have found what I call "Vast Coordinate System" to be really, really handy.  Basically, you store x and y pixel coordinates at some way-zoomed-in -- I use zoom level 23.  This has several benefits:I talked about all this in a recent blog post:\n   http://blog.webfoot.com/2013/03/12/optimizing-map-tile-generation/The spatial functions in PostGIS are much more functional (i.e. not constrained to BBOX operations) than those in the MySQL spatial functions. Check it out: link textI am highly surprised by some answers/comments.Why on earth would anyone be willing to voluntarely "pre-decrease" the precision, and then later on perform calculations on the worse numbers? Sounds ultimately stupid.If the source has 64-bit precision, certainly it would be dumb to voluntarely fix the scale to eg. 6 decimals, and limit the precision to a maximum of 9 significant digts (which happens with the commonly proposed decimal 9.6 format).Naturally, one stores the data with the precision that the source material has. The only reason to decrease precision would be limited storage space.The decimal 9.6-format causes a snap-to-grid phenomen. That should be the very last step, if it is at all to happen.I wouldn\'t invite accumulated errors to my nest.MySQL uses double for all floats ... \nSo use type double. Using float will lead to unpredictable rounded values in most situationsA FLOAT should give you all of the precision you need, and be better for comparison functions than storing each co-ordinate as a string or the like.If your MySQL version is earlier than 5.0.3, you may need to take heed of certain floating point comparison errors however.Prior to MySQL 5.0.3, DECIMAL columns store values with exact precision because they are represented as strings, but calculations on DECIMAL values are done using floating-point operations. As of 5.0.3, MySQL performs DECIMAL operations with a precision of 64 decimal digits, which should solve most common inaccuracy problems when it comes to DECIMAL columnsLat Long calculations require precision, so use some type of decimal type and make the precision at least 2 higher than the number you will store in order to perform math calculations. I don\'t know about the my sql datatypes but in SQL server people often use float or real instead of decimal and get into trouble because these are are estimated numbers not real ones. So just make sure the data type you use is a true decimal type and not a floating decimal type and you should be fine.