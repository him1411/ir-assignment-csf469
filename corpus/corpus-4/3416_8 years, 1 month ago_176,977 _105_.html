What is the most efficient way to create an arbitrary length zero filled array in JavaScript?Although this is an old thread, I wanted to add my 2 cents to it. Not sure how slow/fast this is, but it\'s a quick one liner. Here is what I do:If I want to pre-fill with a number:If I want to pre-fill with a string:Other answers have suggested:but if you want 0 (the number) and not "0" (zero inside a string), you can do:ES6 introduces Array.prototype.fill. It can be used like this:Not sure if it\'s fast, but I like it because it\'s short and self-describing.Note added August 2013, updated February 2015: The answer below from 2009 relates to JavaScript\'s generic Array type. It doesn\'t relate to the newer typed arrays defined in ES2015 [and available now in many browsers], like Int32Array and such. Also note that ES2015 adds a fill method to both Arrays and typed arrays, which is likely to be the most efficient way to fill them...Also, it can make a big difference to some implementations how you create the array. Chrome\'s V8 engine, in particular, tries to use a highly-efficient, contiguous-memory array if it thinks it can, shifting to the object-based array only when necessary.With most languages, it would be pre-allocate, then zero-fill, like this:But, JavaScript arrays aren\'t really arrays, they\'re key/value maps just like all other JavaScript objects, so there\'s no "pre-allocate" to do (setting the length doesn\'t allocate that many slots to fill), nor is there any reason to believe that the benefit of counting down to zero (which is just to make the comparison in the loop fast) isn\'t outweighed by adding the keys in reverse order when the implementation may well have optimized their handling of the keys related to arrays on the theory you\'ll generally do them in order.In fact, Matthew Crumley pointed out that counting down is markedly slower on Firefox than counting up, a result I can confirm — it\'s the array part of it (looping down to zero is still faster than looping up to a limit in a var). Apparently adding the elements to the array in reverse order is a slow op on Firefox. In fact, the results vary quite a bit by JavaScript implementation (which isn\'t all that surprising). Here\'s a quick and dirty test page (below) for browser implementations (very dirty, doesn\'t yield during tests, so provides minimal feedback and will run afoul of script time limits). I recommend refreshing between tests; FF (at least) slows down on repeated tests if you don\'t.The fairly complicated version that uses Array#concat is faster than a straight init on FF as of somewhere between 1,000 and 2,000 element arrays.  On Chrome\'s V8 engine, though, straight init wins out every time...Here\'s the test page (live copy):The already mentioned ES 6 fill method takes care of this nicely. Most modern desktop browsers already support the required Array prototype methods as of today (Chromium, FF, Edge and Safari) [1]. You can look up details on MDN. A simple usage example isGiven the current browser support you should be cautious to use this unless you are sure your audience uses modern Desktop browsers.By default Uint8Array, Uint16Array and Uint32Array classes keep zeros as its values, so you don\'t need any complex filling techniques, just do:all elements of array ary will be zeros by default.Note that while is usually more efficient than for-in, forEach, etc.I\'ve tested all combinations of pre-allocating/not pre-allocating, counting up/down, and for/while loops in IE 6/7/8, Firefox 3.5, Chrome, and Opera.The functions below was consistently the fastest or extremely close in Firefox, Chrome, and IE8, and not much slower than the fastest in Opera and IE 6. It\'s also the simplest and clearest in my opinion. I\'ve found several browsers where the while loop version is slightly faster, so I\'m including it too for reference.orHere is another way to do it using ES6 that nobody has mentioned so far:It works by passing a map function as the second parameter of Array.from.I really like Array(len).fill(0) better, but you can\'t use it if you need to fill it with computed values instead (I know the question didn\'t ask for it, but a lot of people end up here looking for this).For instance, if you need an array of random numbers:It\'s more concise than the equivalent:This method can also be used to generate sequences of numbers by taking advantage of the index parameter provided in the callback:using object notationzero filled? like...filled with \'undefined\'...obj notation with zerosAs a side note, if you modify Array\'s prototype, bothandwill have those prototype modificationsAt any rate, I wouldn\'t be overly concerned with the efficiency or speed of this operation, there are plenty of other things that you will likely be doing that are far more wasteful and expensive than instanciating an array of arbitrary length containing zeros.If you need to create many zero filled arrays of different lengths during the execution of your code, the fastest way I\'ve found to achieve this is to create a zero array once, using one of the methods mentioned on this topic, of a length which you know will never be exceeded, and then slice that array as necessary.For example (using the function from the chosen answer above to initialize the array), create a zero filled array of length maxLength, as a variable visible to the code that needs zero arrays:Now slice this array everytime you need a zero filled array of length requiredLength < maxLength:I was creating zero filled arrays thousands of times during execution of my code, this speeded up the process tremendously.If you use ES6, you can use Array.from() like this:The way I usually do it (and is amazing fast) is using Uint8Array. For example, creating a zero filled vector of 1M elements:I\'m a Linux user and always have worked for me, but once a friend using a Mac had some non-zero elements. I thought his machine was malfunctioning, but still here\'s the safest way we found to fix it:EditedChrome 25.0.1364.160Firefox 20.0Missing the most important test (at least for me): the Node.js one. I suspect it close to Chrome benchmark.Using lodash or underscoreOr if you have an array existing and you want an array of the same lengthI have nothing against:suggested by Zertosh, but in a new ES6 array extensions allow you to do this natively with fill method. Now IE edge, Chrome and FF supports it, but check the compatibility tablenew Array(3).fill(0) will give you [0, 0, 0]. You can fill the array with any value like new Array(5).fill(\'abc\') (even objects and other arrays).On top of that you can modify previous arrays with fill:which gives you: [1, 2, 3, 9, 9, 6]What about new Array(51).join(\'0\').split(\'\')?My fastest function would be:Using the native push and shift to add items to the array is much faster (about 10 times) than declaring the array scope and referencing each item to set it\'s value.fyi: I consistently get faster times with the first loop, which is counting down, when running this in firebug (firefox extension).I\'m interested to know what T.J. Crowder makes of that ? :-)I was testing out the great answer by T.J. Crowder, and came up with a recursive merge based on the concat solution that outperforms any in his tests in Chrome (i didn\'t test other browsers).call the method with makeRec(29).Didn\'t see this method in answers, so here it is:In result you will get zero-valued array of length 200:I\'m not sure about the performance of this code, but it shouldn\'t be an issue if you use it for relatively small arrays.As of ECMAScript2016, there is one clear choice for large arrays. Since this answer still shows up near the top on google searches, here\'s an answer for 2017.Here\'s a current jsbench with a few dozen popular methods, including many proposed up to now on this question. If you find a better method please add, fork and share.I want to note that there is no true most efficient way to create an arbitrary length zero filled array. You can optimize for speed, or for clarity and maintainability - either can be considered the more efficient choice depending on the needs of the project.When optimizing for speed, you want to: create the array using literal syntax; set the length, initialize iterating variable, and iterate through the array using a while loop. Here\'s an example.Another possible implementation would be:But I strongly discourage using this second implantation in practice as it\'s less clear and doesn\'t allow you to maintain block scoping on your array variable.These are significantly faster than filling with a for loop, and about 90% faster than the standard method of But this fill method is still the most efficient choice for smaller arrays due to it\'s clarity, conciseness and maintainability. The performance difference likely won\'t kill you unless you\'re making a lot of arrays with lengths on the order of thousands or more.A few other important notes. Most style guides recommend you no longer use varwithout a very special reason when using ES6 or later. Use const for variables that won\'t be redefined and let for variables that will. The MDN and Airbnb\'s Style Guide are great places to go for more information on best practices. The questions wasn\'t about syntax, but it\'s important that people new to JS know about these new standards when searching through these reams of old and new answers.This concat version is much faster in my tests on Chrome (2013-03-21). About 200ms for 10,000,000 elements vs 675 for straight init.Bonus: if you want to fill your array with Strings, this is a concise way to do it (not quite as fast as concat though):It might be worth pointing out, that Array.prototype.fill had been added as part of the ECMAScript 6 (Harmony) proposal. I would rather go with the polyfill written below, before considering other options mentioned on the thread.I knew I had this proto\'d somewhere :)Edit: testsIn response to Joshua and others methods I ran my own benchmarking, and I\'m seeing completely different results to those reported.Here\'s what I tested:Results:So by my reckoning push is indeed slower generally but performs better with longer arrays in FF but worse in IE which just sucks in general (quel surprise).usage in expressions: arr[i]*1;EDIT: if arr supposed to be used in integer expressions, then please don\'t mind the char value of \'0\'. You just use it as follows:   a = a * arr[i] (assuming a has integer value). Shortest for loop codeSafe var versionThe fastest way to do that is with forEach =)(we keep backward compatibility for IE < 9)There\'s always the phpjs solution, which you can find here:http://phpjs.org/functions/array_fill/I can\'t speak for the project (creating a library of javascript functions that mirrors the greater functionality of php) as a whole, but the few functions that I\'ve personally pulled from there have worked like a champ.I just use :Anonymous function:A bit shorter with for-loop:Works with any Object, just change what\'s inside this.push(). You can even save the function:Call it using:Adding elements to an already existing array:Performance: http://jsperf.com/zero-filled-array-creation/25What everyone else seems to be missing is setting the length of the array beforehand so that the interpreter isn\'t constantly changing the size of the array.My simple one-liner would be Array.prototype.slice.apply(new Uint8Array(length))But if I were to create a function to do it fast without some hacky workaround, I would probably write a function like this: