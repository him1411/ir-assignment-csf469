Note: This question was asked at a time when C# did not yet support optional parameters (i.e. before C# 4).We\'re building a web API that\'s programmatically generated from a C# class. The class has method GetFooBar(int a, int b) and the API has a method GetFooBar taking query params like &a=foo &b=bar. The classes needs to support optional parameters, which isn\'t supported in C# the language. What\'s the best approach?Surprised no one mentioned C# 4.0 optional parameters that work like this:Edit: I know that at the time the question was asked, C# 4.0 didn\'t exist. But this question still ranks #1 in Google for "C# optional arguments" so I thought - this answer worth being here. Sorry.Another option is to use the params keywordCalled like...In C#, I would normally use multiple forms of the method:UPDATE:  This mentioned above WAS the way that I did default values with C# 2.0.  The projects I\'m working on now are using C# 4.0 which now directly supports optional parameters.  Here is an example I just used in my own code:From this site:http://www.tek-tips.com/viewthread.cfm?qid=1500861&page=1C# does allow the use of the [Optional] attribute (from VB, though not functional in C#). So you can have a method like this:In our API wrapper, we detect optional parameters (ParameterInfo p.IsOptional) and set a default value. The goal is to mark parameters as optional without resorting to kludges like having "optional" in the parameter name.You could use method overloading...It depends on the method signatures, the example I gave is missing the "int b" only method because it would have the same signature as the "int a" method.You could use Nullable types...You could then check, using a.HasValue, to see if a parameter has been set.Another option would be to use a \'params\' parameter.If you wanted to go with named parameters would would need to create a type to handle them, although I think there is already something like this for web apps (not really my area of knowledge).Keith.If you want the runtime to supply a default parameter value, you have to use reflection to make the call. Not as nice as the other suggestions for this question, but compatible with VB.NET.You can use optional parameters in C# 4.0 without any worries.\nIf we have a method like:when you call the method, you can skip parameters like this:C# 4.0 implements a feature called "named parameters", you can actually pass parameters by their names, and of course you can pass parameters in whatever order you want :) I agree with stephenbayer. But since it is a webservice, it is easier for end-user to use just one form of the webmethod, than using multiple versions of the same method. I think in this situation Nullable Types are perfect for optional parameters.optional parameters are for methods. if you need optional arguments for a class and you are:using c# 4.0: use optional arguments in the constructor of the class, a solution i prefer, since it\'s closer to what is done with methods, so easier to remember. here\'s an example:using c# versions previous to c#4.0: you should use constructor chaining (using the :this keyword), where simpler constructors lead to a "master constructor".\nexample:An elegant and easy way which allows you to omit any parameters in any position, by taking advantage of nullable types is as follows:Strings are already nullable types so they don\'t need the ?.Once you have this method, the following calls are all valid:When you define a method that way you have the freedom to set just the parameters you want by naming them. See the following link for more information on named and optional parameters:Named and Optional Arguments (C# Programming Guide) @ MSDNThe typical way this is handled in C# as stephen mentioned is to overload the method.  By creating multiple versions of the method with different parameters you effectively create optional parameters.  In the forms with fewer parameters you would typically call the form of the method with all of the parameters setting your default values in the call to that method.You can overload your method. One method contains one parameter GetFooBar(int a) and the other contain both parameters, GetFooBar(int a, int b)Instead of default parameters, why not just construct a dictionary class from the querystring passed .. an implementation that is almost identical to the way asp.net forms work with querystrings. i.e. Request.QueryString["a"] This will decouple the leaf class from the factory / boilerplate code.You also might want to check out Web Services with ASP.NET. Web services are a web api generated automatically via attributes on C# classes.I have a web service to write that takes 7 parameters. Each is an optional query attribute to a sql statement wrapped by this web service. So two workarounds to non-optional params come to mind... both pretty poor:method1(param1, param2, param 3, param 4, param 5, param 6, param7)\nmethod1(param1, param2, param3, param 4, param5, param 6)\nmethod 1(param1, param2, param3, param4, param5, param7)... start to see the picture. This way lies madness. Way too many combinations.Now for a simpler way that looks awkward but should work:\nmethod1(param1, bool useParam1, param2, bool useParam2, etc...)That\'s one method call, values for all parameters are required, and it will handle each case inside it. It\'s also clear how to use it from the interface.It\'s a hack, but it will work.I had to do this in a VB.Net 2.0 Web Service. I ended up specifying the parameters as strings, then converting them to whatever I needed. An optional parameter was specified with an empty string. Not the cleanest solution, but it worked. Just be careful that you catch all the exceptions that can occur.For just in case if someone wants to pass a callback (or delegate) as an optional parameter, can do it this way.Optional Callback parameter:A little late to the party, but I was looking for the answer to this question and ultimately figured out yet another way to do this.  Declare the data types for the optional args of your web method to be type XmlNode.  If the optional arg is omitted this will be set to null, and if it\'s present you can get is string value by calling arg.Value, i.e.,What\'s also decent about this approach is the .NET generated home page for the ws still shows the argument list (though you do lose the handy text entry boxes for testing).