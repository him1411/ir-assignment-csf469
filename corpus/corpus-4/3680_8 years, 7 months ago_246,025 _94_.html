Can any one tell me the advantage of synchronized method over synchronized block with an example?Can any one tell me the advantage of synchronized method over synchronized block with an example?Thanks.There is not a clear advantage of using synchronized method over block. Perhaps the only one ( but I wouldn\'t call it advantage ) is you don\'t need to include the object reference this.Method:Block:See? No advantage at all. Blocks do have advantages over methods though, mostly in flexibility because you can use another object as lock whereas syncing the method would lock the entire object.Compare: vs. Also if the method grows you can still keep the synchronized section separated:The only real difference is that a synchronized block can choose which object it synchronizes on.  A synchronized method can only use \'this\' (or the corresponding Class instance for a synchronized class method).  For example, these are semantically equivalent:The latter is more flexible since it can compete for the associated lock of any object, often a member variable.  It\'s also more granular because you could have concurrent code executing before and after the block but still within the method.  Of course, you could just as easily use a synchronized method by refactoring the concurrent code into separate non-synchronized methods.  Use whichever makes the code more comprehensible.Pros:Cons:Pros:Cons:Personally I prefer using synchronized methods with classes focused only to the thing needing synchronization. Such class should be as small as possible and so it should be easy to review the synchronization. Others shouldn\'t need to care about synchronization.The main difference is that if you use a synchronized block you may lock on an object other than this which allows to be much more flexible.Assume you have a message queue and multiple message producers and consumers. We don\'t want producers to interfere with each other, but the consumers should be able to retrieve messages without having to wait for the producers.\nSo we just create an objectAnd from now on every time a producers wants to add a new message we just lock on that:So consumers may still read, and producers will be locked.Synchronized methodSynchronized methods have two effects.\nFirst, when one thread is executing a synchronized method for an object, all other threads that invoke synchronized methods for the same object block (suspend execution) until the first thread is done with the object. Second, when a synchronized method exits, it automatically establishes a happens-before relationship with any subsequent invocation of a synchronized method for the same object. This guarantees that changes to the state of the object are visible to all threads. Note that constructors cannot be synchronized \xe2\x80\x94 using the synchronized keyword with a constructor is a syntax error. Synchronizing constructors doesn\'t make sense, because only the thread that creates an object should have access to it while it is being constructed. Synchronized StatementUnlike synchronized methods, synchronized statements must specify the object that provides the intrinsic lock: Most often I use this to synchronize access to a list or map but I don\'t want to block access to all methods of the object. Q: Intrinsic Locks and Synchronization\nSynchronization is built around an internal entity known as the intrinsic lock or monitor lock. (The API specification often refers to this entity simply as a "monitor.") Intrinsic locks play a role in both aspects of synchronization: enforcing exclusive access to an object\'s state and establishing happens-before relationships that are essential to visibility. Every object has an intrinsic lock associated with it. By convention, a thread that needs exclusive and consistent access to an object\'s fields has to acquire the object\'s intrinsic lock before accessing them, and then release the intrinsic lock when it\'s done with them. A thread is said to own the intrinsic lock between the time it has acquired the lock and released the lock. As long as a thread owns an intrinsic lock, no other thread can acquire the same lock. The other thread will block when it attempts to acquire the lock. Cross check different outputs with synchronized method, block and without synchronization.Note: static synchronized methods and blocks work on the Class object.When java compiler converts your source code to byte code, it handles synchronized methods and synchronized blocks very differently.When the JVM executes a synchronized method, the executing thread identifies that the method\'s method_info structure has the ACC_SYNCHRONIZED flag set, then it automatically acquires the object\'s lock, calls the method, and releases the lock. If an exception occurs, the thread automatically releases the lock.Synchronizing a method block, on the other hand, bypasses the JVM\'s built-in support for acquiring an object\'s lock and exception handling and requires that the functionality be explicitly written in byte code. If you read the byte code for a method with a synchronized block, you will see more than a dozen additional operations to manage this functionality. This shows calls to generate both a synchronized method and a synchronized block:The synchronizedMethodGet() method generates the following byte code:And here\'s the byte code from the synchronizedBlockGet() method:One significant difference between synchronized method and block is that, Synchronized block generally reduce scope of lock. As scope of lock is inversely proportional to performance, its always better to lock only critical section of code. One of the best example of using synchronized block is double checked locking in Singleton pattern where instead of locking whole getInstance() method we only lock critical section of code which is used to create Singleton instance. This improves performance drastically because locking is only required one or two times.While using synchronized methods, you will need to take extra care if you mix both static synchronized and non-static synchronized methods.Most often I use this to synchronize access to a list or map but I don\'t want to block access to all methods of the object.In the following code one thread modifying the list will not block waiting for a thread that is modifying the map.  If the methods were synchronized on the object then each method would have to wait even though the modifications they are making would not conflict.With synchronized blocks, you can have multiple synchronizers, so that multiple simultaneous but non-conflicting things can go on at the same time.Synchronized methods can be checked using reflection API. This can be useful for testing some contracts, such as all methods in model are synchronized.The following snippet prints all the synchronized methods of Hashtable:Important note on using the synchronized block: careful what you use as lock object!The code snippet from user2277816 above illustrates this point in that a reference to a string literal is used as locking object.\nRealize that string literals are automatically interned in Java and you should begin to see the problem: every piece of code that synchronizes on the literal "lock", shares the same lock! This can easily lead to deadlocks with completely unrelated pieces of code.It is not just String objects that you need to be careful with. Boxed primitives are also a danger, since autoboxing and the valueOf methods can reuse the same objects, depending on the value.For more information see:\nhttps://www.securecoding.cert.org/confluence/display/java/LCK01-J.+Do+not+synchronize+on+objects+that+may+be+reusedOften using a lock on a method level is too rude. Why lock up a piece of code that does not access any shared resources by locking up an entire method. Since each object has a lock, you can create dummy objects to implement block level synchronization.\nThe block level is more efficient because it does not lock the whole method.Here some exampleMethod LevelBlock Level[Edit]For Collection like Vector and Hashtable they are synchronized when ArrayList or HashMap are not and you need set synchronized keyword or invoke Collections synchronized method:Synchronized method is used for lock all the objects\nSynchronized block is used to lock specific objectIn general these are mostly the same other than being explicit about the object\'s monitor that\'s being used vs the implicit this object.  One downside of synchronized methods that I think is sometimes overlooked is that in using the "this" reference to synchronize on you are leaving open the possibility of external objects locking on the same object.  That can be a very subtle bug if you run into it.  Synchronizing on an internal explicit Object or other existing field can avoid this issue, completely encapsulating the synchronization.As already said here synchronized block can use user-defined variable as lock object, when synchronized function uses only "this". And of course you can manipulate with areas of your function which should be synchronized.\nBut everyone says that no difference between synchronized function and block which covers whole function using "this" as lock object. That is not true, difference is in byte code which will be generated in both situations. In case of synchronized block usage should be allocated local variable which holds reference to "this". And as result we will have a little bit larger size for function (not relevant if you have only few number of functions).More detailed explanation of the difference you can find here:\nhttp://www.artima.com/insidejvm/ed2/threadsynchP.htmlI know this is an old question, but with my quick read of the responses here, I didn\'t really see anyone mention that at times a synchronized method may be the wrong lock.\nFrom Java Concurrency In Practice (pg. 72):The above code has the appearance of being thread-safe.  However, in reality it is not.  In this case the lock is obtained on the instance of the class.  However, it is possible for the list to be modified by another thread not using that method. The correct approach would be to use The above code would block all threads trying to modify list from modifying the list until the synchronized block has completed.The only difference : synchronized blocks allows granular locking unlike synchronized methodBasically synchronized block or methods have been used to write thread safe code by avoiding memory inconsistency errors. This question is very old and many things have been changed during last 7 years. \nNew programming constructs have been introduced for thread safety.You can achieve thread safety by using advanced concurrency API instead of synchronied blocks. This documentation page provides good programming constructs to achieve thread safety.Lock Objects support locking idioms that simplify many concurrent applications.Executors define a high-level API for launching and managing threads. Executor implementations provided by java.util.concurrent provide thread pool management suitable for large-scale applications.Concurrent Collections make it easier to manage large collections of data, and can greatly reduce the need for synchronization.Atomic Variables have features that minimize synchronization and help avoid memory consistency errors.ThreadLocalRandom (in JDK 7) provides efficient generation of pseudorandom numbers from multiple threads.Better replacement for synchronized is ReentrantLock, which uses Lock APIA reentrant mutual exclusion Lock with the same basic behavior and semantics as the implicit monitor lock accessed using synchronized methods and statements, but with extended capabilities.Example with locks:Refer to java.util.concurrent and java.util.concurrent.atomic packages too for other programming constructs. Refer to this related question too:Synchronization vs LockFrom a Java specification summary:\nhttp://www.cs.cornell.edu/andru/javaspec/17.doc.htmlThe synchronized statement (\xc2\xa714.17) computes a reference to an object;\n  it then attempts to perform a lock action on that object and does not\n  proceed further until the lock action has successfully completed. ...A synchronized method (\xc2\xa78.4.3.5) automatically performs a lock action\n  when it is invoked; its body is not executed until the lock action has\n  successfully completed. If the method is an instance method, it\n  locks the lock associated with the instance for which it was invoked\n  (that is, the object that will be known as this during execution of\n  the body of the method). If the method is static, it locks the\n  lock associated with the Class object that represents the class in\n  which the method is defined. ...Based on these descriptions, I would say most previous answers are correct, and a synchronized method might be particularly useful for static methods, where you would otherwise have to figure out how to get the "Class object that represents the class in which the method was defined."Edit: I originally thought these were quotes of the actual Java spec.  Clarified that this page is just a summary/explanation of the specAs a practical matter, the advantage of synchronized methods over synchronized blocks is that they are more idiot-resistant; because you can\'t choose an arbitrary object to lock on, you can\'t misuse the synchronized method syntax to do stupid things like locking on a string literal or locking on the contents of a mutable field that gets changed out from under the threads.On the other hand, with synchronized methods you can\'t protect the lock from getting acquired by any thread that can get a reference to the object. So using synchronized as a modifier on methods is better at protecting your cow-orkers from hurting themselves, while using synchronized blocks in conjunction with private final lock objects is better at protecting your own code from the cow-orkers.In case of synchronized methods, lock will be acquired on an Object. But if you go with synchronized block you have an option to specify an object on which the lock will be acquired.Example :TLDR; Neither use the synchronized modifier nor the synchronized(this){...} expression but synchronized(myLock){...} where myLock is a final instance field holding a private object.The difference between using the synchronized modifier on the method declaration  and the synchronized(..){ } expression in the method body are this:However, using the synchronized modifier or synchronized(...) {...} with this as the lock object (as in synchronized(this) {...}), have the same disadvantage. Both use it\'s own instance as the lock object to synchronize on. This is dangerous because not only the object itself but any other external object/code that holds a reference to that object can also use it as a synchronization lock with potentially severe side effects (performance degradation and deadlocks).Therefore best practice is to neither use the synchronized modifier nor the synchronized(...) expression in conjunction with this as lock object but a lock object private to this object. For example:You can also use multiple lock objects but special care needs to be taken to ensure this does not result in deadlocks when used nested.Synchronizing with threads. \n1) NEVER use synchronized(this) in a thread it doesn\'t work. Synchronizing with (this) uses the current thread as the locking thread object. Since each thread is independent of other threads, there is NO coordination of synchronization.\n2) Tests of code show that in Java 1.6 on a Mac the method synchronization does not work.\n3) synchronized(lockObj) where lockObj is a common shared object of all threads synchronizing on it will work.\n4) ReenterantLock.lock() and .unlock() work. See Java tutorials for this.The following code shows these points. It also contains the thread-safe Vector which would be substituted for the ArrayList, to show that many threads adding to a Vector do not lose any information, while the same with an ArrayList can lose information. \n0) Current code shows loss of information due to race conditions\nA) Comment the current labeled A line, and uncomment the A line above it, then run, method loses data but it shouldn\'t.\nB) Reverse step A, uncomment B and // end block }. Then run to see results no loss of data\nC) Comment out B, uncomment C. Run, see synchronizing on (this) loses data, as expected.\nDon\'t have time to complete all the variations, hope this helps.\nIf synchronizing on (this), or the method synchronization works, please state what version of Java and OS you tested.  Thank you.