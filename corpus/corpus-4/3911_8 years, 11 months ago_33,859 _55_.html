I quite often see on the Internet various complaints that other peoples examples of currying are not currying, but are actually just partial application.I\'ve not found a decent explanation of what partial application is, or how it differs from currying. There seems to be a general confusion, with equivalent examples being described as currying in some places, and partial application in others.Could someone provide me with a definition of both terms, and details of how they differ?Currying is converting a single function of n arguments into n functions with a single argument each. Given the following function:When curried, becomes:In order to get the full application of f(x,y,z), you need to do this:Many functional languages let you write f x y z. If you only call f x y or f(x)(y) then you get a partially-applied function\xe2\x80\x94the return value is a closure of lambda(z){z(x(y))} with passed-in the values of x and y to f(x,y). One way to use partial application is to define functions as partial applications of generalized functions, like fold:The easiest way to see how they differ is to consider a real example. Let\'s assume that we have a function Add which takes 2 numbers as input and returns a number as output, e.g. Add(7, 5) returns 12. In this case:Partial applying the function Add with a value 7 will give us a new function as output. That function itself takes 1 number as input and outputs a number. As such:So we can do this:Currying the function Add will give us a new function as output. That function itself takes 1 number as input and outputs yet another new function. That third function then takes 1 number as input and returns a number as output. As such:So we can do this:In other words, "currying" and "partial application" are two totally different functions. Currying takes exactly 1 input, whereas partial application takes 2 (or more) inputs.Even though they both return a function as output, the returned functions are of totally different forms as demonstrated above.Note: this was taken from F# Basics an excellent introductory article for .NET developers getting into functional programming.Currying means breaking a function with many arguments into a series\n  of functions that each take one argument and ultimately produce the\n  same result as the original function. Currying is probably the most\n  challenging topic for developers new to functional programming, particularly because it\n  is often confused with partial application. You can see both at work\n  in this example:Right away, you should see behavior that is different from most\n  imperative languages. The second statement creates a new function\n  called double by passing one argument to a function that takes two.\n  The result is a function that accepts one int argument and yields the\n  same output as if you had called multiply with x equal to 2 and y\n  equal to that argument. In terms of behavior, it\xe2\x80\x99s the same as this\n  code:Often, people mistakenly say that multiply is curried to form double.\n  But this is only somewhat true. The multiply function is curried, but\n  that happens when it is defined because functions in F# are curried by\n  default. When the double function is created, it\xe2\x80\x99s more accurate to\n  say that the multiply function is partially applied.The multiply function is really a series of two functions. The first\n  function takes one int argument and returns another function,\n  effectively binding x to a specific value. This function also accepts\n  an int argument that you can think of as the value to bind to y. After\n  calling this second function, x and y are both bound, so the result is\n  the product of x and y as defined in the body of double.To create double, the first function in the chain of multiply\n  functions is evaluated to partially apply multiply. The resulting\n  function is given the name double. When double is evaluated, it uses\n  its argument along with the partially applied value to create the\n  result.Interesting question. After a bit of searching, "Partial Function Application is not currying" gave the best explanation I found. I can\'t say that the practical difference is particularly obvious to me, but then I\'m not an FP expert...Another useful-looking page (which I confess I haven\'t fully read yet) is "Currying and Partial Application with Java Closures".It does look like this is widely-confused pair of terms, mind you.I have answered this in another thread https://stackoverflow.com/a/12846865/1685865 .  In short, partial function application is about fixing some arguments of a given multivariable function to yield another function with fewer arguments, while Currying is about turning a function of N arguments into a unary function which returns a unary function...[An example of Currying is shown at the end of this post.] Currying is mostly of theoretical interest: one can express computations using only unary functions (i.e. every function is unary). In practice and as a byproduct, it is a technique which can make many useful (but not all) partial functional applications trivial, if the language has curried functions. Again, it is not the only means to implement partial applications. So you could encounter scenarios where partial application is done in other way, but people are mistaking it as Currying.(Example of Currying) In practice one would not just writeor the equivalent javascriptinstead offor the sake of Currying.The difference between curry and partial application can be best illustrated through this following JavaScript example:Partial application results in a function of smaller arity; in the example above, f has an arity of 3 while partial only has an arity of 2. More importantly, a partially applied function would return the result right away upon being invoke, not another function down the currying chain. So if you are seeing something like partial(2)(3), it\'s not partial application in actuality.Further reading:For me partial application must create a new function where the used arguments are completely integrated into the resulting function. Most functional languages implement currying by returning a closure: do not evaluate under lambda when partially applied. So, for partial application to be interesting, we need to make a difference between currying and partial application and consider partial application as currying plus evaluation under lambda.I could be very wrong here, as I don\'t have a strong background in theoretical mathematics or functional programming, but from my brief foray into FP, it seems that currying tends to turn a function of N arguments into N functions of one argument, whereas partial application [in practice] works better with variadic functions with an indeterminate number of arguments. I know some of the examples in previous answers defy this explanation, but it has helped me the most to separate the concepts. Consider this example (written in CoffeeScript for succinctness, my apologies if it confuses further, but please ask for clarification, if needed):This is obviously a contrived example, but notice that partially applying a function that accepts any number of arguments allows us to execute a function but with some preliminary data. Currying a function is similar but allows us to execute an N-parameter function in pieces until, but only until, all N parameters are accounted for.Again, this is my take from things I\'ve read. If anyone disagrees, I would appreciate a comment as to why rather than an immediate downvote. Also, if the CoffeeScript is difficult to read, please visit coffeescript.org, click "try coffeescript" and paste in my code to see the compiled version, which may (hopefully) make more sense. Thanks!There are other great answers here but I believe this example (as per my understanding) in Java might be of benefit to some people:So currying gives you a one-argument function to create functions, where partial-application creates a wrapper function that hard codes one or more arguments.If you want to copy&paste, the following is noisier but friendlier to work with since the types are more lenient:In writing this, I confused currying and uncurrying.  They are inverse transformations on functions.  It really doesn\'t matter what you call which, as long as you get what the transformation and its inverse represent.Uncurrying isn\'t defined very clearly (or rather, there are "conflicting" definitions that all capture the spirit of the idea).  Basically, it means turning a function that takes multiple arguments into a function that takes a single argument.  For example,Now, how do you turn this into a function that takes a single argument?  You cheat, of course!Notice that plus now takes a single argument (that is composed of two things).  Super!What\'s the point of this?  Well, if you have a function that takes two arguments, and you have a pair of arguments, it is nice to know that you can apply the function to the arguments, and still get what you expect.  And, in fact, the plumbing to do it already exists, so that you don\'t have to do things like explicit pattern matching.  All you have to do is:So what is partial function application?  It is a different way to turn a function in two arguments into a function with one argument.  It works differently though.  Again, let\'s take (+) as an example.  How might we turn it into a function that takes a single Int as an argument?  We cheat!That\'s the function that adds zero to any Int.adds 1 to any Int.  Etc.  In each of these cases, (+) is "partially applied".Currying is a function of one argument which takes a function f and returns a new function h:Partial application is a function of two(or more) arguments which takes a function f and one or more additional arguments to f and returns a new function g:The confusion arises because in the case of a two argument function f the following equality is true(Not true for higher arity functions):Both sides will yield the same one argument function.The difference is also in the behavior, whereas currying transforms the whole original function recursively(once for each argument), partial application is just a one step replacement, see wikipedia.