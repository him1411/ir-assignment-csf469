Assuming String a and b:Under the hood, are they the same thing?Here is concat decompiled as reference. I\'d like to be able to decompile the + operator as well to see what that does.No, not quite.Firstly, there\'s a slight difference in semantics. If a is null, then a.concat(b) throws a NullPointerException but a+=b will treat the original value of a as if it were null. Furthermore, the concat() method only accepts String values while the + operator will silently convert the argument to a String (using the toString() method for objects). So the concat() method is more strict in what it accepts.To look under the hood, write a simple class with a += b;Now disassemble with javap -c (included in the Sun JDK). You should see a listing including:So, a += b is the equivalent ofThe concat method should be faster. However, with more strings the StringBuilder method wins, at least in terms of performance.The source code of String and StringBuilder (and its package-private base class) is available in src.zip of the Sun JDK. You can see that you are building up a char array (resizing as necessary) and then throwing it away when you create the final String. In practice memory allocation is surprisingly fast.Niyaz is correct, but it\'s also worth noting that the special + operator can be converted into something more efficient by the Java compiler.  Java has a StringBuilder class which represents a non-thread-safe, mutable String.  When performing a bunch of String concatenations, the Java compiler silently convertsintowhich for large strings is significantly more efficient.  As far as I know, this does not happen when you use the concat method.However, the concat method is more efficient when concatenating an empty String onto an existing String.  In this case, the JVM does not need to create a new String object and can simply return the existing one.  See the concat documentation to confirm this.So if you\'re super-concerned about efficiency then you should use the concat method when concatenating possibly-empty Strings, and use + otherwise.  However, the performance difference should be negligible and you probably shouldn\'t ever worry about this.I ran a similar test as @marcio but with the following loop instead:Just for good measure, I threw in StringBuilder.append() as well.  Each test was run 10 times, with 100k reps for each run.  Here are the results:I haven\'t decompiled the class to see the internals or run it through profiler yet, but I suspect a += b spends much of the time creating new objects of StringBuilder and then converting them back to String.Tom is correct in describing exactly what the + operator does.  It creates a temporary StringBuilder, appends the parts, and finishes with toString().However, all of the answers so far are ignoring the effects of HotSpot runtime optimizations.  Specifically, these temporary operations are recognized as a common pattern and are replaced with more efficient machine code at run-time.@marcio: You\'ve created a micro-benchmark; with modern JVM\'s this is not a valid way to profile code.The reason run-time optimization matters is that many of these differences in code -- even including object-creation -- are completely different once HotSpot gets going.  The only way to know for sure is profiling your code in situ.Finally, all of these methods are in fact incredibly fast.  This might be a case of premature optimization.  If you have code that concatenates strings a lot, the way to get maximum speed probably has nothing to do with which operators you choose and instead the algorithm you\'re using!How about some simple testing? Used the code below:Tested several times. The concat() version execution took half of the time on average.This result surprised me because the concat() method always creates a new string (it returns a "new String(result)". It\'s well known that:Why wasn\'t the compiler capable of optimize the string creation in "a + b" code, knowing the it always resulted in the same string? It could avoid a new string creation.\nIf you don\'t believe the statement above, test for your self. I don\'t think so. a.concat(b) is implemented in String and I think the implementation didn\'t change much since early java machines. The + operation implementation depends on java version and compiler. Currently + is implemented using StringBuffer to make the operation as fast as possible. Maybe in future this will change. In earlier versions of java + operation on Strings was much slower as it produced intermediate results. I guess that += is implemented using + and similarly optimized.Basically, there are two important differences between + and the concat method.If you are using the concat method then you would only be able to concatenate strings while in case of the + operator, you can also concatenate the string with any data type.For Example:In this case, the output should be 10Hello.In the above case you have to provide two strings mandatory.The second and main difference between + and concat is that:Case 1:\nSuppose I concat the same strings with concat operator in this wayIn this case total number of objects created in the pool are 7 like this:Case 2:Now I am going to concatinate the same strings via + operatorIn the above case total number of objects created are only 5.Actually when we concatinate the strings via + operator then it maintains a StringBuffer class to perform the same task as follows:-In this way it will create only five objects.So guys these are the basic differences between + and the concat method.\nEnjoy :)The + operator can work between a string and a string, char, integer, double or float data type value. It just converts the value to its string representation before concatenation.The concat operator can only be done on and with strings. It checks for data type compatibility and throws an error, if they don\'t match.Except this, the code you provided does the same stuff.For the sake of completeness, I wanted to add that the definition of the \'+\' operator can be found in the JLS SE8 15.18.1:If only one operand expression is of type String, then string\n  conversion (\xc2\xa75.1.11) is performed on the other operand to produce a\n  string at run time.The result of string concatenation is a reference to a String object\n  that is the concatenation of the two operand strings. The characters\n  of the left-hand operand precede the characters of the right-hand\n  operand in the newly created string.The String object is newly created (\xc2\xa712.5) unless the expression is a\n  constant expression (\xc2\xa715.28).About the implementation the JLS says the following:An implementation may choose to perform conversion and concatenation\n  in one step to avoid creating and then discarding an intermediate\n  String object. To increase the performance of repeated string\n  concatenation, a Java compiler may use the StringBuffer class or a\n  similar technique to reduce the number of intermediate String objects\n  that are created by evaluation of an expression.For primitive types, an implementation may also optimize away the\n  creation of a wrapper object by converting directly from a primitive\n  type to a string.So judging from the \'a Java compiler may use the StringBuffer class or a similar technique to reduce\', different compilers could produce different byte-code. When using +, the speed decreases as the string\'s length increases, but when using concat, the speed is more stable, and the best option is using the StringBuilder class which has stable speed in order to do that.I guess you can understand why. But the totally best way for creating long strings is using StringBuilder() and append(), either speed will be unacceptable.