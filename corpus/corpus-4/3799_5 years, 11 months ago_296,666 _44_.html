I need to convert strings to some form of hash.  Is this possible in Javascript/jQuery?I\'m not utilizing a server-side language so I can\'t do it that way.Source:\nhttp://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/EDITbased on my jsperf tests, the accepted answer is actually faster: http://jsperf.com/hashcodelordvladORIGINALif anyone is interested, here is an improved ( faster ) version, which will fail on older browsers who lack the reduce array function.Note: Even with the best 32-bit hash, you will have to deal with the fact \nthat collisions will occur sooner or later. I.e. two different input strings\nwill return the same hash value with a probability of at least 1 : 2^32.In an answer to this question\nWhich hashing algorithm is best for uniqueness and speed?,\nIan Boyd posted a good in depth analysis.\nIn short (as I interpret it), he comes to the conclusion that Murmur is best, followed by FNV-1a.\nJava\xe2\x80\x99s String.hashCode() algorithm that esmiralha proposed seems to be a variant of DJB2.Some benchmarks with large input strings here: http://jsperf.com/32-bit-hash\nWhen short input strings are hashed, murmur\'s performance drops, relative to DJ2B and FNV-1a: http://jsperf.com/32-bit-hash/3So in general I would recommend murmur3.\nSee here for a JavaScript implementation:\nhttps://github.com/garycourt/murmurhash-jsIf input strings are short and performance is more important than distribution quality, use DJB2 (as proposed by the accepted answer by esmiralha).If quality and small code size are more important than speed, I use this implementation of FNV-1a (based on this code).If it helps anyone, I combined the top two answers into an older-browser-tolerant version, which uses the fast version if reduce is available and falls back to esmiralha\'s solution if it\'s not.Usage is like:Based on accepted answer in ES6. Smaller, maintainable and works in modern browsers.This is a refined and better performing variant: This matches Java\'s implementation of the standard object.hashCode()Here is also one that returns only positive hashcodes: And here is a matching one for Java that only returns positive hashcodes: Enjoy!I needed a similar function (but different) to generate a unique-ish ID based on the username and current time. So: Produces: edit Jun 2015: For new code I use shortid: https://www.npmjs.com/package/shortidThanks to the example by mar10, I found a way to get the same results in C# AND Javascript for an FNV-1a. If unicode chars are present, the upper portion is discarded for the sake of performance. Don\'t know why it would be helpful to maintain those when hashing, as am only hashing url paths for now.C# VersionJavaScript VersionSlightly simplified version of @esmiralha\'s answer.I don\'t override String in this version, since that could result in some undesired behaviour.I\'m a bit surprised nobody has talked about the new SubtleCrypto API yet.To get an hash from a string, you can use the subtle.digest method : A fast and concise one which was adapted from here:I have combined the two solutions (users esmiralha and lordvlad) to get a function that should be faster for browsers that support the js function reduce() and still compatible with old browsers:Example: I went for a simple concatenation of char codes converted to hex strings. This serves a relatively narrow purpose, namely just needing a hash representation of a SHORT string (e.g. titles, tags) to be exchanged with a server side that for not relevant reasons can\'t easily implement the accepted hashCode Java port. Obviously no security application here.This can be made more terse and browser-tolerant with Underscore. Example:I suppose if you wanted to hash larger strings in similar fashion you could just reduce the char codes and hexify the resulting sum rather than concatenate the individual characters together:Naturally more risk of collision with this method, though you could fiddle with the arithmetic in the reduce however you wanted to diversify and lengthen the hash.If you want to avoid collisions you may want to use a secure hash like SHA-256.\nThere are several JavaScript SHA-256 implementations.I wrote tests to compare several hash implementations, see https://github.com/brillout/test-javascript-hash-implementations.Or go to http://brillout.github.io/test-javascript-hash-implementations/, to run the tests.With this solution we can specify the character set to avoid some issues when the values are stored or sent between applications layers, for instance: When the result string (hash) produces percent encoding and that string is sent to controller using GET method from the view layer.