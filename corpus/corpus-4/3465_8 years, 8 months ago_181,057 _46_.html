Given a dictionary like so:How can one invert this map to get:EDITOR NOTE: map changed to my_map to avoid conflicts with the built-in function, map. Some comments may be affected below.For Python 2.7.xFor Python 3+:Assuming that the values in the dict are unique:If the values in my_map aren\'t unique:Try this:(Note that the Python docs on dictionary views explicitly guarantee that .keys() and .values() have their elements in the same order, which allows the approach above to work.)Alternatively:or using python 3.0\'s dict comprehensionsAnother, more functional, way:This expands upon the answer Python reverse / invert a mapping, applying to when the values in the dict aren\'t unique.The implementation is limited in that you cannot use reversed twice and get the original back. It is not symmetric as such. It is tested with Python 2.6. Here is a use case of how I am using to print the resultant dict.If you\'d rather use a set than a list, and there are applications for which this makes sense, instead of setdefault(v, []).append(k), use setdefault(v, set()).add(k).If the values aren\'t unique, and you\'re a little hardcore:Especially for a large dict, note that this solution is far less efficient than the answer Python reverse / invert a mapping because it loops over items() multiple times.In addition to the other functions suggested above, if you like lambdas:Or, you could do it this way too:I think the best way to do this is to define a class. Here is an implementation of a "symmetric dictionary":Deletion and iteration methods are easy enough to implement if they\'re needed.This implementation is way more efficient than inverting an entire dictionary (which seems to be the most popular solution on this page). Not to mention, you can add or remove values from your SymDict as much as you want, and your inverse-dictionary will always stay valid -- this isn\'t true if you simply reverse the entire dictionary once.We may also reverse a dictionary with duplicate keys using defaultdict:See here:This technique is simpler and faster than an equivalent technique using dict.setdefault().Adding my 2 cents of pythonic way:Example:Try this for python 2.7/3.xUsing zipThis handles non-unique values and retains much of the look of the unique case. For Python 3.x, replace itervalues with values. \nI can\'t take credit for this... it was suggested by Icon Jack. Function is symmetric for values of type list; Tuples are coverted to lists when performing reverse_dict(reverse_dict(dictionary))Since dictionaries require one unique key within the dictionary unlike values, we have to append the reversed values into a list of sort to be included within the new specific keys. Fast functional solution for non-bijective maps (values not unique):In theory this should be faster than adding to the set (or appending to the list) one by one like in the imperative solution.Unfortunately the values have to be sortable, the sorting is required by groupby.Not something completely different, just a bit rewritten recipe from Cookbook. It\'s futhermore optimized by retaining setdefault method, instead of each time getting it through the instance:Designed to be run under CPython 3.x, for 2.x replace mapping.items() with mapping.iteritems()On my machine runs a bit faster, than other examples hereI wrote this with the help of cycle \'for\' and method \'.get()\' and I changed the name \'map\' of the dictionary to \'map1\' because \'map\' is a function.If values aren\'t unique AND may be a hash (one dimension):And with a recursion if you need to dig deeper then just one dimension:I would do it that way in python 2.This will provide output as : {1: [\'a\', \'d\'], 2: [\'b\'], 3: [\'c\']}For all kinds of dictionary, no matter if they don\'t have unique values to use as keys, you can create a list of keys for each valueif the items are not unique try this: