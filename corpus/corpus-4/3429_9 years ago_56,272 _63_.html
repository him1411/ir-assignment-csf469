If you\'re writing a library, or an app, where do the unit test files go?  It\'s nice to separate the test files from the main app code, but it\'s awkward to put them into a "tests" subdirectory inside of the app root directory, because it makes it harder to import the modules that you\'ll be testing.  Is there a best practice here?For a file module.py, the unit test should normally be called test_module.py, following Pythonic naming conventions.There are several commonly accepted places to put test_module.py:I prefer #1 for its simplicity of finding the tests and importing them. Whatever build system you\'re using can easily be configured to run files starting with test_. Actually, the default unittest pattern used for test discovery is test*.py.A common practice is to put the tests directory in the same parent directory as your module/package. So if your module was called foo.py your directory layout would look like:Of course there is no one way of doing it. You could also make a tests subdirectory and import the module using absolute import.Wherever you put your tests, I would recommend you use nose to run them. Nose searches through your directories for tests. This way, you can put tests wherever they make the most sense organizationally.If doesn\'t have many test file, put in top-level directory is nice (I think this is python recommended way):If has many test file, put in a tests folder:but if put the tests in tests folder, test can\'t import ..lib in CLI because __main__  can\'t import relative module, we can use nose, or we can add parent directory to python import path, for that I will create ainand import env before test import moduleWe had the very same question when writing Pythoscope (http://pythoscope.org), which generates unit tests for Python programs.  We polled people on the testing in python list before we chose a directory, there were many different opinions.  In the end we chose to put a "tests" directory in the same directory as the source code. In that directory we generate a test file for each module in the parent directory.  I also tend to put my unit tests in the file itself, as Jeremy Cantrell above notes, although I tend to not put the test function in the main body, but rather put everything in anblock.  This ends up adding documentation to the file as \'example code\' for how to use the python file you are testing.I should add, I tend to write very tight modules/classes.  If your modules require very large numbers of tests, you can put them in another, but even then, I\'d still add:This lets anybody reading your source code know where to look for the test code.I use a tests/ directory, and then import the main application modules using relative imports. So in MyApp/tests/foo.py, there might be:to import the MyApp.foo module.I don\'t believe there is an established "best practice".I put my tests in another directory outside of the app code. I then add the main app directory to sys.path (allowing you to import the modules from anywhere) in my test runner script (which does some other stuff as well) before running all the tests. This way I never have to remove the tests directory from the main code when I release it, saving me time and effort, if an ever so tiny amount.From my experience in developing Testing frameworks in Python, I would suggest to put python unit tests in a separate directory. Maintain a symmetric directory structure. This would be helpful in packaging just the core libraries and not package the unit tests. Below is implemented through a schematic diagram. In this way when you package these libraries using an rpm, you can just package the main library modules (only). This helps maintainability particularly in agile environment. How I do it...Folder structure:Setup.py points to src/ as the location containing my projects modules, then i run:Which adds my project into site-packages, pointing to my working copy. To run my tests i use:Using whichever test runner I\'ve configured.I recommend you check some main Python projects on GitHub and get some ideas.When your code gets larger and you add more libraries it\'s better to create a test folder in the same directory you have setup.py and mirror your project directory structure for each test type (unittest, integration, ...)For example if you have a directory structure like:After adding test folder you will have a directory structure like:Many properly written Python packages uses the same structure. A very good example is the Boto package.\nCheck https://github.com/boto/botoI prefer toplevel tests directory. This does mean imports become a little more difficult. For that I have two solutions:Here\'s how that stuff is supported by code in M2Crypto:If you prefer to run tests with nosetests you might need do something a little different.Every once in a while I find myself checking out the topic of test placement, and every time the majority recommends a separate folder structure beside the library code, but I find that every time the arguments are the same and are not that convincing. I end up putting my test modules somewhere beside the core modules. The main reason for doing this is: refactoring.When I move things around I do want test modules to move with the code; it\'s easy to lose tests if they are in a separate tree. Let\'s be honest, sooner or later you end up with a totally different folder structure, like django, flask and many others. Which is fine if you don\'t care.The main question you should ask yourself is this:  Am I writing:  If a: A separate folder and the extra effort to maintain its structure may be better suited. No one will complain about your tests getting deployed to production. But it\'s also just as easy to exclude tests from being distributed when they are mixed with the core folders; put this in the setup.py:If b: You may wish \xe2\x80\x94 as every one of us do \xe2\x80\x94 that you are writing reusable libraries, but most of the time their life is tied to the life of the project. Ability to easily maintain your project should be a priority. Then if you did a good job and your module is a good fit for another project, it will probably get copied \xe2\x80\x94 not forked or made into a separate library \xe2\x80\x94 into this new project, and moving tests that lay beside it in the same folder structure is easy in comparison to fishing up tests in a mess that a separate test folder had become. (You may argue that it shouldn\'t be a mess in the first place but let\'s be realistic here).So the choice is still yours, but I would argue that with mixed up tests you achieve all the same things as with a separate folder, but with less effort on keeping things tidy.    We use app/src/code.pyapp/testing/code_test.py app/docs/..In each test file we insert "../src/" in sys.path. It\'s not the nicest solution but works. I think it would be great if someone came up w/ something like maven in java that gives you standard conventions that just work, no matter what project you work on.In C#, I\'ve generally separated the tests into a separate assembly.In Python -- so far -- I\'ve tended to either write doctests, where the test is in the docstring of a function, or put them in the if __name__ == "__main__" block at the bottom of the module.When writing a package called "foo", I will put unit tests into a separate package "foo_test". Modules and subpackages will then have the same name as the SUT package module. E.g. tests for a module foo.x.y are found in foo_test.x.y. The __init__.py files of each testing package then contain an AllTests suite that includes all test suites of the package. setuptools provides a convenient way to specify the main testing package, so that after "python setup.py develop" you can just use "python setup.py test" or "python setup.py test -s foo_test.x.SomeTestSuite" to the just a specific suite.If the tests are simple, simply put them in the docstring -- most of the test frameworks for Python will be able to use that:For other more involved tests, I\'d put them either in ../tests/test_module.py or in tests/test_module.py.I\'ve recently started to program in Python, so I\'ve not really had chance to find out best practice yet.\nBut, I\'ve written a module that goes and finds all the tests and runs them.So, I have:I\'ll have to see how it goes as I progress to larger projects.