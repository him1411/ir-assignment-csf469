I had some experience lately with function pointers in C.So going on with the tradition of answering your own questions, I decided to make a small summary of the very basics, for those who need a quick dive-in to the subject.Let\'s start with a basic function which we will be pointing to:First thing, let\'s define a pointer to a function which receives 2 ints and returns an int:Now we can safely point to our function:Now that we have a pointer to the function, let\'s use it:Passing the pointer to another function is basically the same:We can use function pointers in return values as well (try to keep up, it gets messy):But it\'s much nicer to use a typedef:Function pointers in C can be used to perform object-oriented programming in C.For example, the following lines is written in C:Yes, the -> and the lack of a new operator is a dead give away, but it sure seems to imply that we\'re setting the text of some String class to be "hello".By using function pointers, it is possible to emulate methods in C.How is this accomplished?The String class is actually a struct with a bunch of function pointers which act as a way to simulate methods. The following is a partial declaration of the String class:As can be seen, the methods of the String class are actually function pointers to the declared function. In preparing the instance of the String, the newString function is called in order to set up the function pointers to their respective functions:For example, the getString function that is called by invoking the get method is defined as the following:One thing that can be noticed is that there is no concept of an instance of an object and having methods that are actually a part of an object, so a "self object" must be passed in on each invocation. (And the internal is just a hidden struct which was omitted from the code listing earlier -- it is a way of performing information hiding, but that is not relevant to function pointers.)So, rather than being able to do s1->set("hello");, one must pass in the object to perform the action on s1->set(s1, "hello"). With that minor explanation having to pass in a reference to yourself out of the way, we\'ll move to the next part, which is inheritance in C.Let\'s say we want to make a subclass of String, say an ImmutableString. In order to make the string immutable, the set method will not be accessible, while maintaining access to get and length, and force the "constructor" to accept a char*:Basically, for all subclasses, the available methods are once again function pointers. This time, the declaration for the set method is not present, therefore, it cannot be called in a ImmutableString.As for the implementation of the ImmutableString, the only relevant code is the "constructor" function, the newImmutableString:In instantiating the ImmutableString, the function pointers to the get and length methods actually refer to the String.get and String.length method, by going through the base variable which is an internally stored String object.The use of a function pointer can achieve inheritance of a method from a superclass.We can further continue to polymorphism in C.If for example we wanted to change the behavior of the length method to return 0 all the time in the ImmutableString class for some reason, all that would have to be done is to:Adding an overriding length method in ImmutableString may be performed by adding an lengthOverrideMethod:Then, the function pointer for the length method in the constructor is hooked up to the lengthOverrideMethod:Now, rather than having an identical behavior for the length method in ImmutableString class as the String class, now the length method will refer to the behavior defined in the lengthOverrideMethod function.I must add a disclaimer that I am still learning how to write with an object-oriented programming style in C, so there probably are points that I didn\'t explain well, or may just be off mark in terms of how best to implement OOP in C. But my purpose was to try to illustrate one of many uses of function pointers.For more information on how to perform object-oriented programming in C, please refer to the following questions:The guide to getting fired: How to abuse function pointers in GCC on x86 machines by compiling your code by hand:Returns the current value on the EAX registerWrite a swap functionWrite a for-loop counter to 1000, calling some function each timeYou can even write a recursive function that counts to 100One of my favorite uses for function pointers is as cheap and easy iterators - Function pointers become easy to declare once you have the basic declarators:While D is another declarator built using those same rules. In the end, somewhere, it ends with ID (see below for an example), which is the name of the declared entity. Let\'s try to build a function taking a pointer to a function taking nothing and returning int, and returning a pointer to a function taking a char and returning int. With type-defs it\'s like thisAs you see, it\'s pretty easy to build it up using typedefs. Without typedefs, it\'s not hard either with the above declarator rules, applied consistently. As you see i missed out the part the pointer points to, and the thing the function returns. That\'s what appears at the very left of the declaration, and is not of interest: It\'s added at the end if one built up the declarator already. Let\'s do that. Building it up consistently, first wordy - showing the structure using [ and ]:As you see, one can describe a type completely by appending declarators one after each other. Construction can be done in two ways. One is bottom-up, starting with the very right thing (leaves) and working the way through up to the identifier. The other way is top-down, starting at the identifier, working the way down to the leaves. I\'ll show both ways.Construction starts with the thing at the right: The thing returned, which is the function taking char. To keep the declarators distinct, i\'m going to number them:Inserted the char parameter directly, since it\'s trivial. Adding a pointer to declarator by replacing D1 by *D2. Note that we have to wrap parentheses around *D2. That can be known by looking up the precedence of the *-operator and the function-call operator (). Without our parentheses, the compiler would read it as *(D2(char p)). But that would not be a plain replace of D1 by *D2 anymore, of course. Parentheses are always allowed around declarators. So you don\'t make anything wrong if you add too much of them, actually.Return type is complete! Now, let\'s replace D2 by the function declarator function taking <parameters> returning, which is D3(<parameters>) which we are at now. Note that no parentheses are needed, since we want D3 to be a function-declarator and not a pointer declarator this time. Great, only thing left is the parameters for it. The parameter is done exactly the same as we\'ve done the return type, just with char replaced by void. So i\'ll copy it:I\'ve replaced D2 by ID1, since we are finished with that parameter (it\'s already a pointer to a function - no need for another declarator). ID1 will be the name of the parameter. Now, i told above at the end one adds the type which all those declarator modify - the one appearing at the very left of every declaration. For functions, that becomes the return type. For pointers the pointed to type etc... It\'s interesting when written down the type, it will appear in the opposite order, at the very right :) Anyway, substituting it yields the complete declaration. Both times int of course. I\'ve called the identifier of the function ID0 in that example. This starts at the identifier at the very left in the description of the type, wrapping that declarator as we walk our way through the right. Start with function taking <parameters> returningThe next thing in the description (after "returning") was pointer to. Let\'s incorporate it:Then the next thing was functon taking <parameters> returning. The parameter is a simple char, so we put it in right away again, since it\'s really trivial.Note the parentheses we added, since we again want that the * binds first, and then the (char). Otherwise it would read function taking <parameters> returning function .... Noes, functions returning functions aren\'t even allowed. Now we just need to put <parameters>. I will show a short version of the deriveration, since i think you already by now have the idea how to do it.Just put int before the declarators like we did with bottom-up, and we are finishedIs bottom-up or top-down better? I\'m used to bottom-up, but some people may be more comfortable with top-down. It\'s a matter of taste i think. Incidentally, if you apply all the operators in that declaration, you will end up getting an int:That is a nice property of declarations in C: The declaration asserts that if those operators are used in an expression using the identifier, then it yields the type on the very left. It\'s like that for arrays too. Hope you liked this little tutorial! Now we can link to this when people wonder about the strange declaration syntax of functions. I tried to put as little C internals as possible. Feel free to edit/fix things in it. They\'re very handy to use for when you want different functions at different times, or different phases of development. For instance, I\'m developing an application on a host computer that has a console, but the final release of the software will be put on an Avnet ZedBoard (which has ports for displays and consoles, but they are not needed/wanted for the final release). So during development, I will use printf to view status and error messages, but when I\'m done, I don\'t want anything printed. Here\'s what I\'ve done:In version.c I will define the 2 function prototypes present in version.hNotice how the function pointer is prototyped in version.h as void (* zprintf)(const char *, ...);When it is referenced in the application, it will start executing wherever it is pointing, which has yet to be defined.In version.c, notice in the board_init()function where zprintf is assigned a unique function (whose function signature matches) depending on the version that is defined in version.hzprintf = &printf; zprintf calls printf for debugging purposesorzprintf = &noprint; zprintf just returns and will not run unnecessary codeRunning the code will look like this:The above code will use printf if in debug mode, or do nothing if in release mode. This is much easier than going through the entire project and commenting out or deleting code. All that I need to do is change the version in version.h and the code will do the rest!Function pointer is usually defined by typedef, and used as param & return value,Above answers already explained a lot, I just give a full example:One of the big uses for function pointers in C is to call a function selected at run-time. For example, the C run-time library has two routines, qsort and bsearch, which take a pointer to a function that is called to compare two items being sorted; this allows you to sort or search, respectively, anything, based on any criteria you wish to use. A very basic example, if there is one function called print(int x, int y) which in turn may require to call add() function or sub() which are of similar types then what we will do, we will add one function pointer argument to the print() function as shown below:- Starting from scratch function has Some Memory Address From Where They start executing. In Assembly Language They Are called as (call "function\'s memory address").Now come back to C If function has a memory address then they can be manipulated by Pointers in C.So By the rules of C 1.First you need to declare a pointer to function \n2.Pass the Address of the  Desired function ****Note->the functions should be of same type**** This Simple Programme will Illustrate Every Thing.After That lets See How machine Understands Them.Glimpse of machine instruction of the above programme in 32 bit architecture.The red mark area is showing how the address is being exchanged and storing in eax.Then their is a call instruction on eax. eax contains the desired address of the functionSince function pointers are often typed callbacks, you might want to have a look at type safe callbacks. The same applies to entry points, etc of functions that are not callbacks.C is quite fickle and forgiving at the same time :)function pointers are useful in many situations, eg: