Consider:Suppose I have the code above, what is the correct way to write the statement if ($a contains \'are\')?You can use the strpos() function which is used to find the occurrence of one string inside another one:Note that the use of !== false is deliberate; strpos() returns either the offset at which the needle string begins in the haystack string, or the boolean false if the needle isn\'t found. Since 0 is a valid offset and 0 is "falsey", we can\'t use simpler constructs like !strpos($a, \'are\').You could use regular expressions. It would look something like this:Don\'t tell me it\'s bad just because you\'ve heard it\'s bad before. You might if you have any facts to back it up though ;)On the performance side, strpos is about three times faster and have in mind, when I did one million compares at once, it took preg match 1.5 seconds to finish and for strpos it took 0.5 seconds. What I\'m trying to say is that it runs really fast either way. If you don\'t have 100,000 visitors every second, you shouldn\'t concern yourself with this kind of stuff and take what\'s most comfortable, IMO.Use strpos function:Here is a little utility function that is useful in situations like thisWhile most of these answers will tell you if a substring appears in your string, that\'s usually not what you want if you\'re looking for a particular word, and not a substring.What\'s the difference?  Substrings can appear within other words:One way to mitigate this would be to use a regular expression coupled with word boundaries (\\b):This method doesn\'t have the same false positives noted above, but it does have some edge cases of its own.  Word boundaries match on non-word characters (\\W), which are going to be anything that isn\'t a-z, A-Z, 0-9, or _.  That means digits and underscores are going to be counted as word characters and scenarios like this will fail:If you want anything more accurate than this, you\'ll have to start doing English language syntax parsing, and that\'s a pretty big can of worms (and assumes proper use of syntax, anyway, which isn\'t always a given).To determine whether a string contains another string you can use the PHP function strpos().int strpos ( string $haystack , mixed $needle [, int $offset = 0 ] )CAUTION:If the needle you are searching for is at the beginning of the haystack it will return position 0, if you do a == compare that will not work, you will need to do a ===A == sign is a comparison and tests whether the variable / expression / constant to the left has the same value as the variable / expression / constant to the right. A === sign is a comparison to see whether two variables / expresions / constants are equal AND have the same type - i.e. both are strings or both are integers.Look at strpos():Using strstr() or stristr() if your search should be case insensitive would be another option.If you want to avoid the "falsey" and "truthy" problem, you can use substr_count:It\'s a bit slower than strpos but it avoids the comparison problems.Make use of case-insensitve matching using stripos():Another option is to use the strstr() function. Something like:Point to note: The strstr() function is case-sensitive. For a case-insensitive search, use the stristr() function.Peer to SamGoody and Lego Stormtroopr comments.If you are looking for a php algorithm to rank search results based on proximity/relevance of multiple words\nhere comes a quick and easy way of generating search results with PHP only:Issues with the other boolean search methods sush as strpos(), preg_match(), strstr() or stristr() PHP method based on Vector Space Model and tf-idf (term frequency\xe2\x80\x93inverse document frequency):It sounds difficult but is surprisingly easy.If we want to search for multiple words in a string the core problem is how we assign a weight to each one of them?If we could weight the terms in a string based on how representative they are of the string as a whole, \nwe could order our results by the ones that best match the query. This is the idea of the vector space model, not far from how SQL fulltext search works:CASE 1RESULTCASE 2RESULTSCASE 3RESULTSThere are plenty of improvements to be made\nbut the model provides a way of getting good results from natural queries, \nwhich don\'t have boolean operators sush as strpos(), preg_match(), strstr() or stristr().NOTA BENEOptionally eliminating redundancy prior to search the wordsthereby reducing index size and resulting in less storage requirementless disk I/Ofaster indexing and a consequently faster search.1. Normalisation2. Stop word elimination3. Dictionary substitutionReplace words with others which have an identical or similar meaning. \n(ex:replace instances of \'hungrily\' and \'hungry\' with \'hunger\')Further algorithmic measures (snowball) may be performed to further reduce words to their essential meaning. The replacement of colour names with their hexadecimal equivalents The reduction of numeric values by reducing precision are other ways of normalising the text.RESOURCES I\'m a bit impressed that none of the answers here that used strpos, strstr and similar functions mentioned Multibyte String Functions yet (2015-05-08).Basically, if you\'re having trouble finding words with characters specific to some languages, such as German, French, Portuguese, Spanish, etc. (e.g.: \xc3\xa4, \xc3\xa9, \xc3\xb4, \xc3\xa7, \xc2\xba, \xc3\xb1), you may want to precede the functions with mb_. Therefore, the accepted answer would use mb_strpos or mb_stripos (for case-insensitive matching) instead:If you cannot guarantee that all your data is 100% in UTF-8, you may want to use the mb_ functions.A good article to understand why is The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!) by Joel Spolsky.The function below also works and does not depend on any other function; it uses only native PHP string manipulation. Personally, I do not recommend this, but you can see how it works:Test:I had some trouble with this, and finally I chose to create my own solution. Without using regular expression engine:You may notice that the previous solutions are not an answer for the word being used as a prefix for another. In order to use your example:With the samples above, both $a and $b contains $c, but you may want your function to tell you that only $a contains $c.You should use case Insensitive format,so if the entered value is in small or caps it wont matter.Here stripos finds needle in heystack without considering case (small/caps).PHPCode Sample with outputThe short-hand versionIn order to find a \'word\', rather than the occurrence of a series of letters that could in fact be a part of another word, the following would be a good solution.Another option to finding the occurrence of a word from a string using strstr() and stristr() is like the following:You can use the strstr function:Without using an inbuilt function:It can be done in three different ways:1- stristr()2- strpos()3- preg_match()Maybe you could use something like this:Do not use preg_match() if you only want to check if one string is contained in another string. Use strpos() or strstr() instead as they will be faster. (http://in2.php.net/preg_match)In PHP, the best way to verify if a string contains a certain substring, is to use a simple helper function like this:You need to use identical/not identical operators because strpos can return 0 as it\'s index value. If you like ternary operators, consider using the following (seems a little backwards I\'ll admit):If you want to check if the string contains several specifics words, you can do:This is useful to avoid spam when sending emails for example.The strpos function works fine, but if you want to do case-insensitive checking for a word in a paragraph then you can make use of the stripos function of PHP.For example,Find the position of the first occurrence of a case-insensitive substring in a string.If the word doesn\'t exist in the string then it will return false else it will return the position of the word.Check if string contains specific words?This means the string has to be resolved into words (see note below).One way to do this and to specify the separators is using preg_split (doc):A run givesNote: Here we do not mean word for every sequence of symbols.A practical definition of word is in the sense the PCRE regular expression engine, where words are substrings consisting of word characters only, being separated by non-word characters.A "word" character is any letter or digit or the underscore character,\n  that is, any character which can be part of a Perl " word ". The\n  definition of letters and digits is controlled by PCRE\'s character\n  tables, and may vary if locale-specific matching is taking place (..)