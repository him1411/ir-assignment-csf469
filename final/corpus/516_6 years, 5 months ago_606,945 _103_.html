I\'m new at the branching complexities of Git. I always work on a single branch and commit changes and then periodically push to my remote origin.Somewhere recently, I did a reset of some files to get them out of commit staging, and later did a rebase -i to get rid of a couple recent local commits. Now I\'m in a state I don\'t quite understand.In my working area, git log shows exactly what I\'d expect-- I\'m on the right train with the commits I didn\'t want gone, and new ones there, etc.But I just pushed to the remote repository, and what\'s there is different-- a couple of the commits I\'d killed in the rebase got pushed, and the new ones committed locally aren\'t there. I think "master/origin" is detached from HEAD, but I\'m not 100% clear on what that means, how to visualize it with the command line tools, and how to fix it.First, let\xe2\x80\x99s clarify what HEAD is and what it means when it is detached.  HEAD is the symbolic name for the currently checked out commit. When HEAD is not detached (the \xe2\x80\x9cnormal\xe2\x80\x9d1 situation: you have a branch checked out), HEAD actually points to a branch\xe2\x80\x99s \xe2\x80\x9cref\xe2\x80\x9d and the branch points to the commit. HEAD is thus \xe2\x80\x9cattached\xe2\x80\x9d to a branch. When you make a new commit, the branch that HEAD points to is updated to point to the new commit. HEAD follows automatically since it just points to the branch.We have HEAD \xe2\x86\x92 refs/heads/master \xe2\x86\x92 17a02998078923f2d62811326d130de991d1a95aWhen HEAD is detached, it points directly to a commit\xe2\x80\x94instead of indirectly pointing to one through a branch. You can think of a detached HEAD as being on an unnamed branch. We have HEAD \xe2\x86\x92 17a02998078923f2d62811326d130de991d1a95aThe important thing to remember with a detached HEAD is that if the commit it points to is otherwise unreferenced (no other ref can reach it), then it will become \xe2\x80\x9cdangling\xe2\x80\x9d when you checkout some other commit. Eventually, such dangling commits will be pruned through the garbage collection process (by default, they are kept for at least 2 weeks and may be kept longer by being referenced by HEAD\xe2\x80\x99s reflog).1\nIt is perfectly fine to do \xe2\x80\x9cnormal\xe2\x80\x9d work with a detached HEAD, you just have to keep track of what you are doing to avoid having to fish dropped history out of the reflog.The intermediate steps of an interactive rebase are done with a detached HEAD (partially to avoid polluting the active branch\xe2\x80\x99s reflog). If you finish the full rebase operation, it will update your original branch with the cumulative result of the rebase operation and reattach HEAD to the original branch. My guess is that you never fully completed the rebase process; this will leave you with a detached HEAD pointing to the commit that was most recently processed by the rebase operation.To recover from your situation, you should create a branch that points to the commit currently pointed to by your detached HEAD:(these two commands can be abbreviated as git checkout -b temp)This will reattach your HEAD to the new temp branch.Next, you should compare the current commit (and its history) with the normal branch on which you expected to be working:(You will probably want to experiment with the log options: add -p, leave off --pretty=\xe2\x80\xa6 to see the whole log message, etc.)If your new temp branch looks good, you may want to update (e.g.) master to point to it:(these two commands can be abbreviated as git checkout -B master temp)You can then delete the temporary branch:Finally, you will probably want to push the reestablished history:You may need to add --force to the end of this command to push if the remote branch can not be \xe2\x80\x9cfast-forwarded\xe2\x80\x9d to the new commit (i.e. you dropped, or rewrote some existing commit, or otherwise rewrote some bit of history).If you were in the middle of a rebase operation you should probably clean it up. You can check whether a rebase was in process by looking for the directory .git/rebase-merge/. You can manually clean up the in-progress rebase by just deleting that directory (e.g. if you no longer remember the purpose and context of the active rebase operation). Usually you would use git rebase --abort, but that does some extra resetting that you probably want to avoid (it moves HEAD back to the original branch and resets it back to the original commit, which will undo some of the work we did above).Just do this:Or, if you have changes that you want to keep, do this:I just ran into this issue and as soon as I read in the top voted answer:HEAD is the symbolic name for the currently checked out commit.I thought: ah-ha! I\'ll just rebase!This command:The end result is that all commits that were in HEAD but not master are then also in master.Regarding the remote:a couple of the commits I\'d killed in the rebase got pushed, and the new ones committed locally aren\'t there.The remote history can no longer be fast-forwarded using your local history. You\'ll need to force-push (git push -f) to overwrite the remote history. If you have any collaborators, it usually makes sense to coordinate this with them so everyone is on the same page.After you push master to remote origin, your remote tracking branch origin/master will be updated to point to the same commit as master.Look here for basic explanation of detached head:http://git-scm.com/docs/git-checkoutCommand line to visualize it:oryou will get output like below:The * (no branch) shows you are in detached head.You could have come to this state by doing a git checkout somecommit etc. and it would have warned you with the following:You are in \'detached HEAD\' state. You\n  can look around, make experimental\n  changes and commit them, and you can\n  discard any commits you make in this\n  state without impacting any branches\n  by performing another checkout.If you want to create a new branch to\n  retain commits you create, you may do\n  so (now or later) by using -b with the\n  checkout command again. Example:git checkout -b new_branch_nameNow, to get them onto master:Do a git reflog or even just git log and note your commits. Now git checkout master and git merge the commits.Edit:To add, use git rebase -i not only for deleting / killing commits that you don\'t need, but also for editing them. Just mention "edit" in the commit list and you will be able to amend your commit and then issue a git rebase --continue to go ahead. This would have ensured that you never came in to a detached HEAD.Simply run git checkout -b mynewbranch.Then run git log, and you\'ll see that commit is now HEAD on this new branch.if you have just master branch and wanna back to "develop" or a feature just do this :Note: checking out origin/develop.You are in detached HEAD state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout...thenIt works :) If you want to push your current detached HEAD (check git log before), try:to send your detached HEAD into master branch at origin. If your push gets rejected, try git pull origin master first to get the changes from origin. If you don\'t care about the changes from origin and it\'s rejected, because you did some intentional rebase and you want to replace origin/master with your currently detached branch - then you may force it (-f). In case you lost some access to previous commits, you can always run git reflog to see the history from all branches.To get back on a master branch, while keeping the changes, try the following commands:See: Git: "Not currently on any branch." Is there an easy way to get back on a branch, while keeping the changes?If you are completely sure HEAD is the good state:You probably can\'t push to origin, since your master has diverged from origin. If you are sure no one else is using the repo, you can force-push:Most useful if you are on a feature branch no one else is using.All you have to do is \'git checkout [branch-name]\' where [branch-name] is the name of the original branch from which you got into a detached head state.  The (detached from asdfasdf) will disappear.So for example, in branch \'dev\' you checkout the commit asdfasd14314 ->you are now in a detached head state\'git branch\' will list something like ->but to get out of the detached head state and back to dev ->and then \'git branch\' will list ->but that is of course if you do not intend on keeping any changes from the detached head state but I find myself doing this a lot not intending to make any changes but just to look at a previous commitI just ran into this issue today. Pretty sure I solved it by doing:I was on my work computer when I figured out how to do this, and now I\'m running into the same problem on my personal comp. So will have to wait till monday when I\'m back at work comp to see exactly how I did it.Instead of doing git checkout origin/masterjust do git checkout masterthen git branch will confirm your branch.for me it was as easy as deleting the local branch again, since I didn\'t have any local commits that I wanted to push:so I did: git branch -d branchnameand then checking the branch out againgit checkout branchnameIn simple words, Detached HEAD state means you are not checked out to HEAD (or tip) of any branch.A branch in most of the cases is sequence of multiple commits like:-commit 1:\nmaster-->branch_HEAD(123be6a76168aca712aea16076e971c23835f8ca)commit 2:\nmaster-->123be6a76168aca712aea16076e971c23835f8ca-->branch_HEAD(100644a76168aca712aea16076e971c23835f8ca)As you can see above in case of sequence of commits your branch points to your latest commit. So in that case if you checkout to commit 123be6a76168aca712aea16076e971c23835f8ca then you would be in detached head state since HEAD of your branch points to 100644a76168aca712aea16076e971c23835f8ca and technically you are checked out at HEAD of no branch.Hence, you are in detached HEAD stateIn this Blog its clearly stating \nGit repository is a tree-of-commits, with each commit pointing to its ancestor with each commit pointer is updated and these pointers to each branch are stored in the .git/refs sub-directories. Tags are stored in .git/refs/tags and branches are stored in .git/refs/heads. If you look at any of the files, you\'ll find each tag corresponds to a single file, with a 40-character commit hash and as explained above by @Chris Johnsen and @Yaroslav Nikitenko you can check out these referencesIf you did some commits on top of master and just want to "backwards merge" master there (i.e. you want master to point to HEAD), the one-liner would be:I found this especially useful in the case of sub-repositories, which also happen to be in a detached state rather often.I got into a really silly state, I doubt anyone else will find this useful.... but just in casewhich I eventually fixed withIn my case, I run git status and I saw that I had a few untracked files on my working directory.To make the rebase work, I just had to clean them (since I didn\'t need them).As pointed by Chris, I had following situationgit symbolic-ref HEAD fails with fatal: ref HEAD is not a symbolic refHowever git rev-parse refs/heads/master was pointing to a good commit from where I could recover (In my case last commit and you can see that commit by using git show SHAI did a lot messy things after that, but what seems to have fixed is just,git symbolic-ref HEAD refs/heads/masterAnd head is re attached!if you are using egit in eclipse:\nassume your master is your main development branch after this you should be able to reattach to the origin-masterThis worked for me perfectly:1.git stash to save your local modifications If you want to discard changes \ngit clean -df \ngit checkout -- . \ngit clean removes all untracked files (warning: while it won\'t delete ignored files mentioned directly in .gitignore, it may delete ignored files residing in folders) and git checkout clears all unstaged changes.2.git checkout master to switch to the main branch (Assuming you want to use master) \n3.git pull to pull last commit from master branch \n4.git status in order to check everything looks great