How can I convert a String to an int in Java?My String contains only numbers and I want to return the number it represents.For example, given the string "1234" the result should be the number 1234.See the Java Documentation for more information.(If you have it in a StringBuilder (or the ancient StringBuffer), you\'ll need to do Integer.parseInt(myBuilderOrBuffer.toString()); instead).For example, here are two ways:There is a slight difference between these methods: The same is for all cases: Short.valueOf/parseShort, Long.valueOf/parseLong, etc.Well, a very important point to consider is that the Integer parser throws NumberFormatException as stated in Javadoc. It is important to handle this exception when trying to get integer values from split arguments or dynamically parsing something.Do it manually:Currently I\'m doing an assignment for college, where I can\'t use certain expressions, such as the ones above, and by looking at the ASCII table, I managed to do it. It\'s a far more complex code, but it could help others that are restricted like I was.The first thing to do is to receive the input, in this case, a string of digits; I\'ll call it String number, and in this case, I\'ll exemplify it using the number 12, therefore String number = "12";Another limitation was the fact that I couldn\'t use repetitive cycles, therefore, a for cycle (which would have been perfect) can\'t be used either. This limits us a bit, but then again, that\'s the goal. Since I only needed two digits (taking the last two digits), a simple charAtsolved it:Having the codes, we just need to look up at the table, and make the necessary adjustments:Now, why double? Well, because of a really "weird" step. Currently we have two doubles, 1 and 2, but we need to turn it into 12, there isn\'t any mathematic operation that we can do.We\'re dividing the latter (lastdigit) by 10 in the fashion 2/10 = 0.2 (hence why double) like this:This is merely playing with numbers. We were turning the last digit into a decimal. But now, look at what happens:Without getting too into the math, we\'re simply isolating units the digits of a number. You see, since we only consider 0-9, dividing by a multiple of 10 is like creating a "box" where you store it (think back at when your first grade teacher explained you what a unit and a hundred were). So:And there you go. You turned a String of digits (in this case, two digits), into an integer composed of those two digits, considering the following limitations:An alternate solution is to use Apache Commons\' NumberUtils:The Apache utility is nice because if the string is an invalid number format then 0 is always returned. Hence saving you the try catch block.Apache NumberUtils API Version 3.4You can also use public static Integer decode(String nm) throws NumberFormatException.It also works for base 8 and 16:If you want to get int instead of Integer you can use:Unboxing:intValue():Converting a string to an int is more complicated than just convertig a number. You have think about the following issues:We can use the parseInt(String str) method of the Integer wrapper class for converting a String value to an integer value.For example:The Integer class also provides the valueOf(String str) method:We can also use toInt(String strValue) of NumberUtils Utility Class for the conversion:I\'m have a solution, but I do not know how effective it is. But it works well, and I think you could improve it. On the other hand, I did a couple of tests with JUnit which step correctly. I attached the function and testing:Testing with JUnit:Whenever there is the slightest possibility that the given String does not contain an Integer, you have to handle this special case. Sadly, the standard Java methods Integer::parseInt and Integer::valueOf throw a NumberFormatException to signal this special case. Thus, you have to use exceptions for flow control, which is generally considered bad coding style.In my opinion, this special case should be handled by returning an Optional<Integer>. Since Java does not offer such a method, I use the following wrapper:Usage:While this is still using exceptions for flow control internally, the usage code becomes very clean.Just for fun: You can use Java 8\'s Optional for converting a String into an Integer:Here we just combine Integer.valueOf and Optinal. Probably there might be situations when this is useful - for example when you want to avoid null checks. Pre Java 8 code will look like this:Guava has tryParse(String), which returns null if the string couldn\'t be parsed, for example:Apart from these above answers, I would like to add several functions: And here are results while you running them: You can use new Scanner("1244").nextInt(). Or ask if even an int exists: new Scanner("1244").hasNextInt()You can also begin by removing all non-numerical characters and then parsing the int:But be warned that this only works for non-negative numbers. You can use this code also, with some precautions.Option #1: Handle the exception explicitly, for example, showing a message dialog and then stop the execution of the current workflow. For example:Option #2: Reset the affected variable if the execution flow can continue in case of an exception. For example, with some modifications in the catch blockUsing a string constant for comparison or any sort of computing is always a good idea, because a constant never returns a null value.As mentioned Apache Commons NumberUtils can do it. Which return 0 if it cannot convert string to int.You can also define your own default value.example:In programming competitions, where you\'re assured that number will always be a valid integer, then you can write your own method to parse input. This will skip all validation related code (since you don\'t need any of that) and will be a bit more efficient.For valid positive integer:For both positive and negative integers:\xc2\xa0  If you are expecting a whitespace before or after these numbers,\nthen make sure to do a str = str.trim() before processing further.Here we goMake sure there is no non-numeric data in the string.This is Complete program with all conditions positive, negative without using library For normal string you can use:For String builder and String buffer you can use:One method is parseInt(String) returns a primitive intSecond method is valueOf(String) returns a new Integer() object.use this line to parse string value to int Alternatively, you can use Integer.valueOf(). It will return an Integer object.10